character:
 graphic_character
 | format_effector
 | other_control_function 
 ;

graphic_character:
 identifier_letter
 | digit
 | space_character
 | special_character 
 ;

identifier:
   identifier_letter  (  underline? letter_or_digit )* 
 ;

letter_or_digit:
 identifier_letter
 | digit 
 ;

numeric_literal:
 decimal_literal
 | based_literal 
 ;

decimal_literal:
 numeral  (  "." numeral )?  ( exponent )? 
 ;

numeral:
 digit  (  underline? digit )* 
 ;

exponent:
 E  ( "+" )? numeral
 | E "-" numeral 
 ;

based_literal:
   base  "#"  based_numeral  (  "." based_numeral )?  "#"   ( exponent )? 
 ;

base:
 numeral 
 ;

based_numeral:
   extended_digit  (  underline? extended_digit )* 
 ;

extended_digit:
 digit
 | "A"
 | "B"
 | "C"
 | "D"
 | "E"
 | "F" 
 ;

character_literal:
 "'" graphic_character "'" 
 ;

string_literal:
 QUOTE  ( string_element )* QUOTE
 ;

string_element:
 QUOTE QUOTE
 | non_quotation_mark_graphic_character 
 ;

comment:
 "--"  ( non_end_of_line_character )* 
 ;

pragma:
   pragma identifier  (  "(" pragma_argument_association  pragmaINLINE ")"  )? ";" 
 ;

pragmaINLINE:
   ( "," pragma_argument_association )*
 ;

pragma_argument_association:
      ( pragma_argument_identifier  DOUBLEARROW  )? name
   |  ( pragma_argument_identifier  DOUBLEARROW  )? expression 
 ;

basic_declaration:
     type_declaration              
   | subtype_declaration
   | object_declaration           
   | number_declaration
   | subprogram_declaration        
   | abstract_subprogram_declaration
   | package_declaration           
   | renaming_declaration
   | exception_declaration        
   | generic_declaration
   | generic_instantiation 
 ;

defining_identifier:
 identifier 
 ;

type_declaration:
  full_type_declaration
   | incomplete_type_declaration
   | private_type_declaration
   | private_extension_declaration 
 ;

full_type_declaration:
     type defining_identifier  ( known_discriminant_part )? is type_definition ";"
   | task_type_declaration
   | protected_type_declaration 
 ;

type_definition:
     enumeration_type_definition
   | integer_type_definition
   | real_type_definition      
   | array_type_definition
   | record_type_definition  
   | access_type_definition
   | derived_type_definition 
 ;

subtype_declaration:
   subtype defining_identifier is subtype_indication ";" 
 ;

subtype_indication:
  subtype_mark  ( constraint )? 
 ;

subtype_mark:
 subtype_name 
 ;

constraint:
 scalar_constraint
 | composite_constraint 
 ;

scalar_constraint:
     range_constraint
 | digits_constraint
 | delta_constraint 
 ;

composite_constraint:
     index_constraint
 | discriminant_constraint 
 ;

object_declaration:
    defining_identifier_list ":"  ( aliased )?  ( constant )? subtype_indication  (  ASSUMES expression )? ";"
  | defining_identifier_list ":"  ( aliased )?  ( constant )? array_type_definition  (  ASSUMES expression )? ";"
  | single_task_declaration
  | single_protected_declaration 
 ;

defining_identifier_list:
  defining_identifier  ( "," defining_identifier )* 
 ;

number_declaration:
 defining_identifier_list ":" constant ASSUMES static_expression ";" 
 ;

derived_type_definition:
  ( abstract )? new parent_subtype_indication  ( record_extension_part )? 
 ;

range_constraint:
  range range 
 ;

range:
  range_attribute_reference
   | simple_expression  ".."  simple_expression 
 ;

enumeration_type_definition:
   "(" enumeration_literal_specification  ( "," enumeration_literal_specification )* ")" 
 ;

enumeration_literal_specification:
  defining_identifier
 | defining_character_literal 
 ;

defining_character_literal:
 character_literal 
 ;

integer_type_definition:
 signed_integer_type_definition
 | modular_type_definition 
 ;

signed_integer_type_definition:
 range static_simple_expression  ".."  static_simple_expression 
 ;

modular_type_definition:
 mod static_expression 
 ;

real_type_definition:
   floating_point_definition
 | fixed_point_definition 
 ;

floating_point_definition:
  digits static_expression  ( real_range_specification )? 
 ;

real_range_specification:
  range static_simple_expression  ".."  static_simple_expression 
 ;

fixed_point_definition:
 ordinary_fixed_point_definition
 | decimal_fixed_point_definition 
 ;

ordinary_fixed_point_definition:
   delta static_expression  real_range_specification 
 ;

decimal_fixed_point_definition:
   delta static_expression digits static_expression  ( real_range_specification )? 
 ;

digits_constraint:
   digits static_expression  ( range_constraint )? 
 ;

array_type_definition:
   unconstrained_array_definition
 | constrained_array_definition 
 ;

unconstrained_array_definition:
   array "(" index_subtype_definition  ( "," index_subtype_definition )* ")" "of" component_definition 
 ;

index_subtype_definition:
 subtype_mark range "<>" 
 ;

constrained_array_definition:
   array "(" discrete_subtype_definition  (  "," discrete_subtype_definition )* ")" of component_definition 
 ;

discrete_subtype_definition:
 discrete_subtype_indication
 | range 
 ;

component_definition:
  ( aliased )? subtype_indication 
 ;

index_constraint:
  "(" discrete_range  (  "," discrete_range )* ")" 
 ;

discrete_range:
 discrete_subtype_indication
 | range 
 ;

discriminant_part:
 unknown_discriminant_part
 | known_discriminant_part 
 ;

unknown_discriminant_part:
 UNKNOWNDP 
 ;

known_discriminant_part:
   "(" discriminant_specification  (  ";" discriminant_specification )* ")" 
 ;

discriminant_specification:
  defining_identifier_list ":" subtype_mark  ( ASSUMES default_expression )?
| defining_identifier_list ":" access_definition  ( ASSUMES default_expression )?

 ;

default_expression:
 expression 
 ;

discriminant_constraint:
   "(" discriminant_association  ( "," discriminant_association )* ")" 
 ;

discriminant_association:
    ( discriminant_selector_name  discriminant_associationINLINE  DOUBLEARROW  )? expression 
 ;

discriminant_associationINLINE:
    (  "|" discriminant_selector_name )*
 ;

record_type_definition:
  (  abstract? tagged )?  ( limited )? record_definition 
 ;

record_definition:
    record       component_list    end record
  | null record 
 ;

component_list:
      component_item  ( component_item )*
   |  ( component_item )* variant_part
   |  "null" ";" 
 ;

component_item:
 component_declaration
 | representation_clause 
 ;

component_declaration:
 defining_identifier_list ":" component_definition  ( ASSUMES default_expression )? ";" 
 ;

variant_part:
   case discriminant_direct_name is
       variant
       ( variant )*
   end case ";" 
 ;

variant:
   when discrete_choice_list  DOUBLEARROW 
      component_list 
 ;

discrete_choice_list:
 discrete_choice  (  "|" discrete_choice )* 
 ;

discrete_choice:
 expression
 | discrete_range
 | others 
 ;

record_extension_part:
 with record_definition 
 ;

access_type_definition:
    access_to_object_definition
  | access_to_subprogram_definition 
 ;

access_to_object_definition:
    access  ( general_access_modifier )? subtype_indication 
 ;

general_access_modifier:
 all
 | constant 
 ;

access_to_subprogram_definition:
    access  ( protected )? procedure parameter_profile
  | access  ( protected )? function  parameter_and_result_profile 
 ;

access_definition:
 access subtype_mark 
 ;

incomplete_type_declaration:
 type defining_identifier  ( discriminant_part )? ";" 
 ;

declarative_part:
  ( declarative_item )* 
 ;

declarative_item:
    basic_declarative_item
 | body 
 ;

basic_declarative_item:
    basic_declaration
 | representation_clause
 | use_clause 
 ;

body:
 proper_body
 | body_stub 
 ;

proper_body:
    subprogram_body
 | package_body
 | task_body
 | protected_body 
 ;

name:
     direct_name             
   | explicit_dereference
   | indexed_component       
   | slice
   | selected_component      
   | attribute_reference
   | type_conversion         
   | function_call
   | character_literal 
 ;

direct_name:
 identifier
 | operator_symbol 
 ;

prefix:
 name
 | implicit_dereference 
 ;

explicit_dereference:
 name "." all 
 ;

implicit_dereference:
 name 
 ;

indexed_component:
 prefix "(" expression  ( "," expression )* ")" 
 ;

slice:
 prefix "(" discrete_range ")" 
 ;

selected_component:
 prefix  "."  selector_name 
 ;

selector_name:
 identifier
 | character_literal
 | operator_symbol 
 ;

attribute_reference:
 prefix "'" attribute_designator 
 ;

attribute_designator:
    identifier ( "(" static_expression ")" )?
  | Access
 | Delta
 | Digits 
 ;

range_attribute_reference:
 prefix "'" range_attribute_designator 
 ;

range_attribute_designator:
 Range ( "(" static_expression ")" )? 
 ;

aggregate:
 record_aggregate
 | extension_aggregate
 | array_aggregate 
 ;

record_aggregate:
 "(" record_component_association_list ")" 
 ;

record_component_association_list:
    record_component_association  ( "," record_component_association )*
  | null record 
 ;

record_component_association:
    (  component_choice_list  DOUBLEARROW   )? expression 
 ;

component_choice_list:
     component_selector_name  (  "|" component_selector_name )*
   | others 
 ;

extension_aggregate:
    "(" ancestor_part with record_component_association_list ")"
 ;

ancestor_part:
 expression
 | subtype_mark 
 ;

array_aggregate:
  positional_array_aggregate
 | named_array_aggregate 
 ;

positional_array_aggregate:
    "(" expression "," expression  ( "," expression )* ")"
  | "(" expression  ( "," expression )* "," others  DOUBLEARROW  expression ")" 
 ;

named_array_aggregate:
    "(" array_component_association  ( "," array_component_association )* ")" 
 ;

array_component_association:
    discrete_choice_list  DOUBLEARROW  expression 
 ;

expression:
     relation  ( and relation )*
   | relation  ( and then relation )*
   | relation  ( or relation )*
   | relation  ( or else relation )*
   | relation  ( xor relation )* 
 ;

relation:
     simple_expression  ( relational_operator simple_expression )?
   | simple_expression  ( not )? in range
   | simple_expression  ( not )? in subtype_mark 
 ;

simple_expression:
  ( unary_adding_operator )? term  ( binary_adding_operator term )* 
 ;

term:
 factor  ( multiplying_operator factor )* 
 ;

factor:
 primary  ( "**" primary )?
 | abs primary
 | not primary 
 ;

primary:
   numeric_literal
 | null
 | string_literal
 | aggregate
 | name
 | qualified_expression
 | allocator
 | "(" expression ")" 
 ;

logical_operator                                     :
  and
 | or
  | xor 
 ;

relational_operator         :
  "="  
 | "/="
  | "<"
   | "<="
 | ">"
 | ">="
 ;

binary_adding_operator      :
  "+"
   | "-"
   | "&" 
 ;

unary_adding_operator       :
  "+"
   | "--" 
 ;

multiplying_operator        :
  "*"
   | "/"
   | mod
 | rem 
 ;

highest_precedence_operator    :
  "**"
  | abs
 | not 
 ;

type_conversion:
    subtype_mark "(" expression ")"
  | subtype_mark "(" name ")" 
 ;

qualified_expression:
   subtype_mark "'" "(" expression ")"
 | subtype_mark "'" aggregate 
 ;

allocator:
   new subtype_indication
 | new qualified_expression 
 ;

sequence_of_statements:
 statement  ( statement )* 
 ;

statement:
    ( label )* simple_statement
 |  ( label )* compound_statement 
 ;

simple_statement:
 null_statement
   | assignment_statement           
   | exit_statement
   | goto_statement       
   | procedure_call_statement
   | return_statement     
   | entry_call_statement
   | requeue_statement    
   | delay_statement
   | abort_statement      
   | raise_statement
   | code_statement 
 ;

compound_statement:
     if_statement         
   | case_statement
   | loop_statement       
   | block_statement
   | accept_statement    
    | select_statement 
 ;

null_statement:
 null ";" 
 ;

label:
 "<<" label_statement_identifier ">>" 
 ;

statement_identifier:
 direct_name 
 ;

assignment_statement:
 variable_name ASSUMES expression ";"
 ;

if_statement:
    if condition then
      sequence_of_statements
    ( elsif condition then
      sequence_of_statements )*
    ( else
      sequence_of_statements )?
    end if ";" 
 ;

condition:
 boolean_expression 
 ;

case_statement:
   case expression is
       case_statement_alternative
       ( case_statement_alternative )*
   end case ";" 
 ;

case_statement_alternative:
   when discrete_choice_list  DOUBLEARROW 
      sequence_of_statements 
 ;

loop_statement:
    (loop_statement_identifier ":")?
       ( iteration_scheme )? loop
         sequence_of_statements
       end loop  ( loop_identifier )? ";" 
 ;

iteration_scheme:
 while condition
   | for loop_parameter_specification 
 ;

loop_parameter_specification:
   defining_identifier in  ( reverse )? discrete_subtype_definition 
 ;

block_statement:
   (block_statement_identifier ":")?
        ( declare
            declarative_part )?
        begin
            handled_sequence_of_statements
        end  ( block_identifier )? ";" 
 ;

exit_statement:
   exit  ( loop_name )?  ( when condition )? ";" 
 ;

goto_statement:
 goto label_name ";" 
 ;

subprogram_declaration:
 subprogram_specification ";" 
 ;

abstract_subprogram_declaration:
 subprogram_specification is abstract ";" 
 ;

subprogram_specification:
     procedure defining_program_unit_name  parameter_profile
   | function defining_designator  parameter_and_result_profile 
 ;

designator:
  ( parent_unit_name  "."   )? identifier
 | operator_symbol 
 ;

defining_designator:
 defining_program_unit_name
 | defining_operator_symbol 
 ;

defining_program_unit_name:
  ( parent_unit_name  "."   )? defining_identifier 
 ;

operator_symbol:
 string_literal 
 ;

defining_operator_symbol:
 operator_symbol 
 ;

parameter_profile:
  ( formal_part )? 
 ;

parameter_and_result_profile:
  ( formal_part )? return subtype_mark 
 ;

formal_part:
   "(" parameter_specification  ( ";" parameter_specification )* ")" 
 ;

parameter_specification:
   defining_identifier_list ":" mode  subtype_mark ( ASSUMES default_expression )?
 | defining_identifier_list ":" access_definition ( ASSUMES default_expression )?
 ;

mode:
  ( in )?
 | in out
 | out 
 ;

subprogram_body:
    subprogram_specification is
       declarative_part
    begin
        handled_sequence_of_statements
    end  ( designator )? ";" 
 ;

procedure_call_statement:
    procedure_name ";"
  | procedure_prefix actual_parameter_part ";" 
 ;

function_call:
    function_name
  | function_prefix actual_parameter_part 
 ;

actual_parameter_part:
    "(" parameter_association  ( "," parameter_association )* ")" 
 ;

parameter_association:
    ( formal_parameter_selector_name  DOUBLEARROW  )? explicit_actual_parameter 
 ;

explicit_actual_parameter:
 expression
 | variable_name 
 ;

return_statement:
 return  ( expression )? ";" 
 ;

package_declaration:
 package_specification ";" 
 ;

package_specification:
    package defining_program_unit_name is
       ( basic_declarative_item )*
    ( private
       basic_declarative_item* )?
    end  (  package_specificationINLINE  identifier )? 
 ;

package_specificationINLINE:
  ( parent_unit_name "."  )?
 ;

package_body:
    package body defining_program_unit_name is
       declarative_part
    ( begin
        handled_sequence_of_statements )?
    end  (  package_bodyINLINE identifier )? ";" 
 ;

package_bodyINLINE:
  ( parent_unit_name "."  )?
 ;

private_type_declaration:
   type defining_identifier  ( discriminant_part )? is  (  abstract? tagged )?  ( limited )? private ";" 
 ;

private_extension_declaration:
   type defining_identifier  ( discriminant_part )? is
      ( abstract )? new ancestor_subtype_indication with private ";" 
 ;

use_clause:
 use_package_clause
 | use_type_clause 
 ;

use_package_clause:
 use package_name  ( "," package_name )*";" 
 ;

use_type_clause:
 use type subtype_mark  ( "," subtype_mark )*";" 
 ;

renaming_declaration:
      object_renaming_declaration
    | exception_renaming_declaration
    | package_renaming_declaration
    | subprogram_renaming_declaration
    | generic_renaming_declaration 
 ;

object_renaming_declaration:
 defining_identifier ":" subtype_mark renames object_name ";" 
 ;

exception_renaming_declaration:
 defining_identifier ":" exception renames exception_name ";" 
 ;

package_renaming_declaration:
 package defining_program_unit_name renamespackage_name ";" 
 ;

subprogram_renaming_declaration:
 subprogram_specification renames callable_entity_name ";" 
 ;

generic_renaming_declaration:
    generic package       defining_program_unit_name renames generic_package_name ";"
  | generic procedure     defining_program_unit_name renames generic_procedure_name ";"
  | generic function      defining_program_unit_name renames generic_function_name ";" 
 ;

task_type_declaration:
   task type defining_identifier  ( known_discriminant_part )?  ( is task_definition )? ";" 
 ;

single_task_declaration:
   task defining_identifier  ( is task_definition )? ";" 
 ;

task_definition:
      ( task_item )*
   (  private
      task_item* )?
  end  ( task_identifier )? 
 ;

task_item:
 entry_declaration
 | representation_clause 
 ;

task_body:
   task body defining_identifier is
     declarative_part
   begin
     handled_sequence_of_statements
   end  ( task_identifier )? ";" 
 ;

protected_type_declaration:
  protected type defining_identifier  ( known_discriminant_part )? is protected_definition ";" 
 ;

single_protected_declaration:
  protected defining_identifier is protected_definition ";" 
 ;

protected_definition:
     (  protected_operation_declaration  )*
 (  private
     protected_element_declaration*  )?
  end  ( protected_identifier )? 
 ;

protected_operation_declaration:
 subprogram_declaration
     | entry_declaration
     | representation_clause 
 ;

protected_element_declaration:
 protected_operation_declaration
     | component_declaration 
 ;

protected_body:
  protected body defining_identifier is
    (  protected_operation_item  )*
  end  ( protected_identifier )? ";" 
 ;

protected_operation_item:
 subprogram_declaration
     | subprogram_body
     | entry_body
     | representation_clause 
 ;

entry_declaration:
   entry defining_identifier  ( "(" discrete_subtype_definition ")" )? parameter_profile ";" 
 ;

accept_statement:
   accept entry_direct_name  ( "(" entry_index ")" )? parameter_profile  ( do
     handled_sequence_of_statements
   end  entry_identifier? )? ";" 
 ;

entry_index:
 expression 
 ;

entry_body:
  entry defining_identifier  entry_body_formal_part  entry_barrier is
    declarative_part
  begin
    handled_sequence_of_statements
  end  ( entry_identifier )? ";" 
 ;

entry_body_formal_part:
  ( "(" entry_index_specification ")" )? parameter_profile 
 ;

entry_barrier:
 when condition 
 ;

entry_index_specification:
 for defining_identifier in discrete_subtype_definition 
 ;

entry_call_statement:
 entry_name  ( actual_parameter_part )? ";" 
 ;

requeue_statement:
 requeue entry_name  ( with abort )? ";" 
 ;

delay_statement:
 delay_until_statement
 | delay_relative_statement 
 ;

delay_until_statement:
 delay until delay_expression ";" 
 ;

delay_relative_statement:
 delay delay_expression ";" 
 ;

select_statement:
   selective_accept
  | timed_entry_call
  | conditional_entry_call
  | asynchronous_select 
 ;

selective_accept:
  select
    ( guard )?
     select_alternative
 (  or
    guard?
     select_alternative  )*
 (  else
   sequence_of_statements  )?
  end select ";" 
 ;

guard:
 when condition  DOUBLEARROW  
 ;

select_alternative:
   accept_alternative
  | delay_alternative
  | terminate_alternative 
 ;

accept_alternative:
  accept_statement  ( sequence_of_statements )? 
 ;

delay_alternative:
  delay_statement  ( sequence_of_statements )? 
 ;

terminate_alternative:
 terminate ";" 
 ;

timed_entry_call:
  select
   entry_call_alternative
  or
   delay_alternative
  end select ";" 
 ;

entry_call_alternative:
  entry_call_statement  ( sequence_of_statements )? 
 ;

conditional_entry_call:
  select
   entry_call_alternative
  else
   sequence_of_statements
  end select ";" 
 ;

asynchronous_select:
  select
   triggering_alternative
  then abort
   abortable_part
  end select ";" 
 ;

triggering_alternative:
 triggering_statement  ( sequence_of_statements )? 
 ;

triggering_statement:
 entry_call_statement
 | delay_statement 
 ;

abortable_part:
 sequence_of_statements 
 ;

abort_statement:
 abort task_name  ( "," task_name )* ";" 
 ;

compilation:
  ( compilation_unit )* 
 ;

compilation_unit:
    context_clause library_item
  | context_clause subunit 
 ;

library_item:
  ( private )? library_unit_declaration
  | library_unit_body
  |  ( private )? library_unit_renaming_declaration 
 ;

library_unit_declaration:
     subprogram_declaration
 | package_declaration
   | generic_declaration
  | generic_instantiation 
 ;

library_unit_renaming_declaration:
   package_renaming_declaration
 | generic_renaming_declaration
 | subprogram_renaming_declaration 
 ;

library_unit_body:
 subprogram_body
 | package_body 
 ;

parent_unit_name:
 name 
 ;

context_clause:
  ( context_item )* 
 ;

context_item:
 with_clause
 | use_clause 
 ;

with_clause:
 with library_unit_name  ( "," library_unit_name )* ";" 
 ;

body_stub:
 subprogram_body_stub
 | package_body_stub
 | task_body_stub
 | protected_body_stub 
 ;

subprogram_body_stub:
 subprogram_specification is separate ";" 
 ;

package_body_stub:
 package body defining_identifier is separate ";" 
 ;

task_body_stub:
 task body defining_identifier is separate ";" 
 ;

protected_body_stub:
 protected body defining_identifier is separate ";" 
 ;

subunit:
 separate "(" parent_unit_name ")" proper_body 
 ;

exception_declaration:
 defining_identifier_list ":" exception ";" 
 ;

handled_sequence_of_statements:
     sequence_of_statements
   ( exception
     exception_handler
     exception_handler* )? 
 ;

exception_handler:
  when (choice_parameter_specification ":")? exception_choice ("|" exception_choice)* "=>"
     sequence_of_statements 
 ;

choice_parameter_specification:
 defining_identifier 
 ;

exception_choice:
 exception_name
 | others 
 ;

raise_statement:
 raise  ( exception_name )? ";" 
 ;

generic_declaration:
 generic_subprogram_declaration
 | generic_package_declaration 
 ;

generic_subprogram_declaration:
     generic_formal_part  subprogram_specification ";" 
 ;

generic_package_declaration:
     generic_formal_part  package_specification ";" 
 ;

generic_formal_part:
 generic  ( generic_formal_parameter_declaration | use_clause )* 
 ;

generic_formal_parameter_declaration:
      formal_object_declaration
    | formal_type_declaration
    | formal_subprogram_declaration
    | formal_package_declaration 
 ;

generic_instantiation:
     package defining_program_unit_name is
         new generic_package_name  ( generic_actual_part )? ";"
   | procedure defining_program_unit_name is
         new generic_procedure_name  ( generic_actual_part )? ";"
   | function defining_designator is
         new generic_function_name  ( generic_actual_part )? ";" 
 ;

generic_actual_part:
   "(" generic_association  ( "," generic_association )* ")" 
 ;

generic_association:
    ( generic_formal_parameter_selector_name  DOUBLEARROW  )? explicit_generic_actual_parameter 
 ;

explicit_generic_actual_parameter:
 expression
 | variable_name
   | subprogram_name
 | entry_name
 | subtype_mark
   | package_instance_name 
 ;

formal_object_declaration:
  defining_identifier_list ":" mode subtype_mark ( ASSUMES default_expression )? ";"
 ;

formal_type_declaration:
    type defining_identifier ( discriminant_part )? is formal_type_definition ";" 
 ;

formal_type_definition:
      formal_private_type_definition
    | formal_derived_type_definition
    | formal_discrete_type_definition
    | formal_signed_integer_type_definition
    | formal_modular_type_definition
    | formal_floating_point_definition
    | formal_ordinary_fixed_point_definition
    | formal_decimal_fixed_point_definition
    | formal_array_type_definition
    | formal_access_type_definition 
 ;

formal_private_type_definition:
  (  abstract? tagged )?  ( limited )? private 
 ;

formal_derived_type_definition:
  ( abstract )? new subtype_mark  ( with private )? 
 ;

formal_discrete_type_definition:
 UNKNOWNDP
 ;

formal_signed_integer_type_definition:
 range "<>" 
 ;

formal_modular_type_definition:
 mod "<>" 
 ;

formal_floating_point_definition:
 digits "<>" 
 ;

formal_ordinary_fixed_point_definition:
 delta "<>" 
 ;

formal_decimal_fixed_point_definition:
 delta "<>" digits "<>" 
 ;

formal_array_type_definition:
 array_type_definition 
 ;

formal_access_type_definition:
 access_type_definition 
 ;

formal_subprogram_declaration:
 with subprogram_specification  ( is subprogram_default )? ";" 
 ;

subprogram_default:
 default_name
 | "<>" 
 ;

default_name:
 name 
 ;

formal_package_declaration:
    with package defining_identifier is new generic_package_name  formal_package_actual_part ";" 
 ;

formal_package_actual_part:
    UNKNOWNDP
 |  ( generic_actual_part )? 
 ;

representation_clause:
 attribute_definition_clause
      | enumeration_representation_clause
      | record_representation_clause
      | at_clause 
 ;

local_name:
 direct_name
      | direct_name "'" attribute_designator
      | library_unit_name 
 ;

attribute_definition_clause:
      for local_name "'" attribute_designator use expression ";"
    | for local_name "'" attribute_designator use name ";" 
 ;

enumeration_representation_clause:
    for first_subtype_local_name use enumeration_aggregate ";" 
 ;

enumeration_aggregate:
 array_aggregate 
 ;

record_representation_clause:
    for first_subtype_local_name use
      record  ( mod_clause )?
         ( component_clause )*
      end record ";" 
 ;

component_clause:
    component_local_name at position range first_bit  ".."  last_bit ";" 
 ;

position:
 static_expression 
 ;

first_bit:
 static_simple_expression 
 ;

last_bit:
 static_simple_expression 
 ;

code_statement:
 qualified_expression ";" 
 ;

restriction:
 restriction_identifier
    | restriction_parameter_identifier  DOUBLEARROW  expression 
 ;

delta_constraint:
 delta static_expression  ( range_constraint )? 
 ;

at_clause:
 for direct_name use at expression ";" 
 ;

mod_clause:
 at mod static_expression ";"
 ;
