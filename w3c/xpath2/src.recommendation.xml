<spec xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax" id="spec-top" w3c-doctype="rec">
<header id="id-spec-header">
<title role="spec-conditional" id="x">XML Path Language (XPath)</title>
<version role="spec-conditional">2.0</version>
<w3c-designation>REC-xpath-20070123</w3c-designation>
<w3c-doctype>W3C Recommendation</w3c-doctype>
<pubdate><day>23</day><month>January</month><year>2007</year></pubdate>

<publoc>

<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2007/REC-xpath20-20070123/" role="xpath" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/2007/REC-xpath20-20070123/</loc>
</publoc>

<altlocs>
  
  
  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2007/REC-xpath20-20070123/xpath20.xml" role="xpath" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML</loc>

</altlocs>

<latestloc>

<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/xpath20/" role="xpath" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xpath20/</loc></latestloc>

<prevlocs>
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/2006/PR-xpath20-20061121/" role="xpath" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
http://www.w3.org/TR/2006/PR-xpath20-20061121/</loc>

<!--*
<loc href="http://www.w3.org/TR/2006/CR-xpath20-20060608/" role="xpath">
http://www.w3.org/TR/2006/CR-xpath20-20060608/</loc>
<loc href="http://www.w3.org/TR/2006/CR-xquery-20060608/" role="xquery">
http://www.w3.org/TR/2006/CR-xquery-20060608/</loc>

<loc href="http://www.w3.org/TR/2005/CR-xpath20-20051103/" role="xpath">
http://www.w3.org/TR/2005/CR-xpath20-20051103/</loc>
<loc href="http://www.w3.org/TR/2005/CR-xquery-20051103/" role="xquery">
http://www.w3.org/TR/2005/CR-xquery-20051103/</loc>
*-->
</prevlocs>

<authlist>
<author role="xpath">
<name>Anders Berglund (XSL WG)</name>

<affiliation>IBM  Research</affiliation><email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:alrb@us.ibm.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">alrb@us.ibm.com</email></author>

<author>
<name>Scott Boag (XSL WG)</name>
<affiliation>IBM  Research</affiliation><email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:scott_boag@us.ibm.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">scott_boag@us.ibm.com</email>

</author><author> <name>Don Chamberlin (XML Query
WG)</name>
<affiliation>IBM Almaden Research Center</affiliation>
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.almaden.ibm.com/cs/people/chamberlin/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.almaden.ibm.com/cs/people/chamberlin/</loc>
</author>

<author><name>Mary F. Fernández (XML Query
WG)</name><affiliation>AT&amp;T Labs</affiliation><email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:mff@research.att.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">mff@research.att.com</email>
</author>



<author role="xpath">
<name>Michael Kay (XSL WG)</name>
<affiliation>Saxonica</affiliation>
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.saxonica.com/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.saxonica.com/</loc>
</author>

<author>
<name>Jonathan Robie (XML Query WG)</name>
<affiliation><phrase><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.xquery.com" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">DataDirect Technologies</loc></phrase></affiliation>
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.ibiblio.org/jwrobie/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ibiblio.org/jwrobie/</loc>
</author>

<author><name>Jérôme Siméon (XML Query
WG)</name><affiliation>IBM T.J. Watson Research Center
</affiliation><email xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:simeon@us.ibm.com" xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">simeon@us.ibm.com</email></author>

</authlist>

<!--* N.B. the value of the errataloc href attribute is set in 
    * ../style/assemble-spec.xsl
    * when the XQuery or XPath spec is assembled.  If it changes,
    * change it THERE.
    *-->
<errataloc xmlns:xlink="http://www.w3.org/1999/xlink" role="spec-conditional" href="http://www.w3.org/XML/2007/qt-errata/xpath20-errata.html" xlink:type="simple"/>

<!--* (This old hack is kept around in case we need it again.
    * If it's seen after 1 Feb 2007 it may be deleted without compunction.
    <preverrataloc id="hack_errataloc_xpath" 
     href="http://www.w3.org/XML/2007/qt-errata/xpath20-errata.html" 
     role="xpath" 
     xlink:type="simple"/>
*-->

<translationloc xmlns:xlink="http://www.w3.org/1999/xlink" role="spec-conditional" href="http://www.w3.org/2003/03/Translations/byTechnology?technology=xpath20" xlink:type="simple"/>

<!--* <translationloc href="http://www.w3.org/2003/03/Translations/byTechnology?technology=xpath20"/> *-->

<!--* Common status section for QT specs.
    * Use is currently not required, but it simplifies things.
    * 
    * Revisions:
    * 2007-01-15 : CMSMcQ : made file, to simplify publication of Rec.
    *-->

    <status id="id-status">

      <p><emph>This section describes the status of this
         document at the time of its publication.
         Other documents may supersede this document.
         A list of current W3C publications and the latest
         revision of this technical report can be found in the
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">W3C technical reports index</loc>
         at http://www.w3.org/TR/.</emph></p>

      <p>This is one document in a set of eight documents that have progressed to
         Recommendation together (XQuery 1.0, XQueryX 1.0, XSLT 2.0,
         Data Model, Functions and Operators, Formal Semantics,
         Serialization, XPath 2.0). </p>

      <p>This is a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsW3C" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Recommendation</loc>
         of the W3C.  It 
<phrase role="xpath">has been jointly developed by the W3C 
<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Style/XSL" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XSL Working Group</loc> and the W3C <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Query" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML Query Working Group</loc>, each of which is part of the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/Activity" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">XML Activity</loc>.</phrase></p>
 
      <p>This document has been reviewed by W3C Members, by
         software developers, and by other W3C groups and interested parties,
         and is endorsed by the Director as a W3C Recommendation. It is a
         stable document and may be used as reference material or cited from
         another document. W3C's role in making the Recommendation is to draw
         attention to the specification and to promote its widespread
         deployment. This enhances the functionality and interoperability of
         the Web.</p>

         <p>

<phrase role="xpath">No substantive changes have
been made to this specification since its publication as a
Proposed Recommendation.</phrase>
</p>

         <!--* &implementation-para; *-->

         <p>Please report errors in this document using W3C's
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Bugs/Public/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public Bugzilla system</loc>
         (instructions can be found at
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/XML/2005/04/qt-bugzilla" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/XML/2005/04/qt-bugzilla</loc>).
         If access to that system is not feasible, you may send your comments
         to the W3C XSLT/XPath/XQuery public comments mailing list,
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="mailto:public-qt-comments@w3.org" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public-qt-comments@w3.org</loc>.
         It will be very helpful if you include the string 
         “[<phrase role="xpath">XPath</phrase>]”
         in the subject line of your report, whether made in Bugzilla or in email.
         Each Bugzilla entry and email message should contain only one error report.
         Archives of the comments and responses are available at
         <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://lists.w3.org/Archives/Public/public-qt-comments/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://lists.w3.org/Archives/Public/public-qt-comments/</loc>. </p>

         
<p>This document was produced by <phrase role="xpath">groups</phrase> operating under the
  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">5 February 2004
  W3C Patent Policy</loc>.
  W3C maintains a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2004/01/pp-impl/18797/status#disclosures" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public list of any 
  patent disclosures</loc> made in connection with the deliverables of the 
  <phrase role="xpath">XML Query Working Group</phrase> <phrase role="xpath"> and also maintains a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/2004/01/pp-impl/19552/status#disclosures" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">public list of any patent 
  disclosures</loc> made in connection with the deliverables of the XSL 
  Working Group; those pages also include</phrase> instructions for
  disclosing a patent.
  An individual who has actual knowledge of a patent which the individual believes
  contains
  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">Essential Claim(s)</loc>
  must disclose the information in accordance with
  <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">section 6 of the W3C Patent Policy</loc>. </p>


    </status>
 

<!--* 
<status id="id-status">
<p><emph>This section describes the status of this document at the
time of its publication. Other documents may supersede this document.
A list of current W3C publications and the latest revision of this
technical report can be found in the <loc href="http://www.w3.org/TR/">W3C technical reports index</loc> at
http://www.w3.org/TR/.</emph></p>

<p>This is one document in a set of eight documents that have
progressed to Recommendation together (XQuery 1.0, XQueryX 1.0, XSLT
2.0, Data Model, Functions and Operators, Formal Semantics,
Serialization, XPath 2.0).</p><p>This is a <loc
href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsREC">Recommendation</loc>
of the W3C.

<phrase role="xquery">This document was produced by the 
<loc href="http://www.w3.org/XML/Query">XML Query Working Group</loc>, which is part of the 
<loc href="http://www.w3.org/XML/Activity">XML Activity</loc>.</phrase>
<phrase role="xpath">This document was jointly produced by the 
<loc href="http://www.w3.org/XML/Query">XML Query Working Group</loc> 
and the <loc href="http://www.w3.org/Style/XSL">XSL Working Group</loc>, 
both of which are part of the 
<loc href="http://www.w3.org/XML/Activity">XML Activity</loc>.</phrase>
It has been reviewed by W3C Members and other interested parties and
has been endorsed by the Director.  It is a stable document and may be
used as reference material or cited as a normative reference from
another document.  W3C's role in making the Recommendation is to draw
attention to the specification and to promote its widespread
deployment.
This enhances the functionality and interoperability of the Web.</p>

<p role="xquery">This document incorporates minor changes made against
the <loc
href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsPR">Proposed 
Recommendation</loc> of 21 November 2006; please see the public
disposition of comments for details. Changes to this document since
the <loc
href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsPR">Proposed 
Recommendation</loc> are detailed in the
<specref ref="id-revisions-log"/>. </p>

<p role="xquery">An implementation report is available at <loc
href="http://www.w3.org/XML/Query/test-suite/XQTSReport.html">http://www.w3.org/XML/Query/test-suite/XQTSReport.html</loc>.</p>

<p><phrase role="xpath">
This specification is designed to be referred to normatively from
other specifications defining a host language for it; it is not
intended to be implemented outside a host language.  The
implementability of this specification has been tested in the context
of its normative inclusion in host languages defined by the <loc href="http://www.w3.org/TR/xslt20">XSLT 2.0</loc> and <loc href="http://www.w3.org/TR/xquery">XQuery 1.0</loc> specifications;
see those specifications for implementation reports.</phrase></p>

<p>Please report errors in this document using W3C's
          <loc href="http://www.w3.org/Bugs/Public/">public Bugzilla 
system</loc>
          (instructions can be found at
          <loc href="http://www.w3.org/XML/2005/04/qt-bugzilla">http://www.w3.org/XML/2005/04/qt-bugzilla</loc>).
          If access to that system is not feasible, you may send your comments
          to the W3C XSLT/XPath/XQuery public comments mailing list,
          <loc href="mailto:public-qt-comments@w3.org">public-qt-comments@w3.org</loc>.
          It will be very helpful if you include the string

<phrase role="xquery">[XQuery]</phrase><phrase role="xpath">[XPath]</phrase> in the subject line of your report, whether made in 
Bugzilla or in email.
          Each Bugzilla entry and email message should contain only 
one error report.
          Archives of the comments and responses are available at
          <loc href="http://lists.w3.org/Archives/Public/public-qt-comments/">http://lists.w3.org/Archives/Public/public-qt-comments/</loc>.</p>


<p>This document was produced by <phrase role="xquery">a group</phrase> 
<phrase role="xpath">groups</phrase> operating under the <loc href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 
2004 W3C Patent Policy</loc>. W3C maintains a <loc 
href="http://www.w3.org/2004/01/pp-impl/18797/status#disclosures">public list of any 
patent disclosures</loc> made in connection with the deliverables of the 
<phrase role="xpath">XML Query Working Group</phrase><phrase role="xquery">group; that page also 
includes</phrase> <phrase role="xpath"> and also maintains a <loc 
href="http://www.w3.org/2004/01/pp-impl/19552/status#disclosures">public list of any patent 
disclosures</loc> made in connection with the deliverables of the XSL 
Working Group; those pages also include</phrase> instructions for 
disclosing a patent. An individual who has actual knowledge of a patent 
which the individual believes contains <loc href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential 
Claim(s)</loc> with respect to this specification should disclose the 
information in accordance with  <loc href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section 
6 of the W3C Patent Policy</loc>.</p>


<p>This document was produced by a group operating under the <loc href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 
2004 W3C Patent Policy</loc>. <phrase role="xquery">The Working Group maintains</phrase><phrase role="xpath">The Working Groups maintain</phrase>  a public list of patent disclosures relevant to this document;
          that page also includes instructions for disclosing (and excluding)
          a patent.
          An individual who has actual knowledge of a patent which 
the individual believes
          to contain
 <loc href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential 
Claim(s)</loc> must disclose the 
information in accordance with  <loc href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section 
6 of the W3C Patent Policy</loc>.</p>
</status>
*-->

<abstract id="id-abstract"><p role="xpath">XPath 2.0 is an expression
language that allows the processing of values conforming to the data
model defined in <bibref ref="datamodel"/>. The data model provides a
tree representation of XML documents as well as atomic values such as
integers, strings, and booleans, and sequences that may contain both
references to nodes in an XML document and atomic values. The result
of an XPath expression may be a selection of nodes from the input
documents, or an atomic value, or more generally, any sequence allowed
by the data model. The name of the language derives from its most
distinctive feature, the path expression, which provides a means of
hierarchic addressing of the nodes in an XML tree. 

XPath 2.0 is a superset of <bibref ref="XPath"/>, with the added
capability to support a richer set of data types, and to take
advantage of the type information that becomes available when
documents are validated using XML Schema. A backwards compatibility
mode is provided to ensure that nearly all XPath 1.0 expressions
continue to deliver the same result with XPath 2.0; exceptions to this
policy are noted in [<specref ref="id-backwards-compatibility"/>].</p> 

</abstract>

<langusage>
<language id="EN">English</language>
<language id="ebnf">EBNF</language>
</langusage>
<revisiondesc>
<slist>
<sitem>Working Draft. (2001;06;07)</sitem>
</slist>
</revisiondesc>
</header>
<body>

<div1 id="id-introduction">

	<head>Introduction</head> 

	 

	

	<p role="xpath">The primary purpose of XPath is to address the
	nodes of <bibref ref="XML"/> or <bibref ref="XML1.1"/> trees.

	XPath gets its name from its use of a path notation for navigating through the hierarchical structure of an XML
	document.

        XPath uses a compact, non-XML syntax to facilitate use of
        XPath within URIs and XML attribute values.</p>

<p><termdef id="dt-datamodel" term="data model">XPath operates on the abstract,
	logical structure of an XML document, rather than its surface
	syntax.  This logical structure, known as the <term>data
	model</term>,  is defined in <bibref ref="datamodel"/>.</termdef></p>

	<p role="xpath">XPath is designed to be embedded in a
	<term>host language</term> such as <bibref ref="XSLT"/> or
	<bibref ref="xquery"/>. XPath has a natural subset that can be
	used for matching (testing whether or not a node matches a
	pattern); this use of XPath is described in <bibref ref="XSLT"/>.</p>

	<p>XQuery Version 1.0 is an extension of XPath Version 2.0. Any expression that is syntactically valid and
	executes successfully in both XPath 2.0 and XQuery 1.0 will
	return the same result in both languages.  Since these
	languages are so closely related, their grammars and language
	descriptions are generated from a common source to ensure
	consistency, and the editors of these specifications work
	together closely.</p>

	<p>XPath also depends on and is closely related to the
	following specifications:</p>

	<ulist>
	  <item>
            <p><bibref ref="datamodel"/> defines the data model that underlies all XPath expressions.</p>
	  </item>

	  <item>
	  <p><bibref ref="XQueryFormalSemantics"/> defines the static semantics of XPath and also
	  contains a formal but non-normative description of the
	  dynamic semantics that may be useful for implementors and others
	  who require a formal definition.</p></item>

          <item>
	  <p>The type system of XPath is based on <bibref ref="XMLSchema"/>.</p>
	  </item>

	  <item>
	  <p>The built-in function library  and the operators supported by
	  XPath are defined in <bibref ref="FunctionsAndOperators"/>.</p>
	  </item>

	  

        </ulist>
		
	
	<p>This document specifies a grammar for XPath, using the
		same basic EBNF notation used in <bibref ref="XML"/>. Unless otherwise noted (see <specref ref="lexical-structure"/>), whitespace is not significant in <phrase role="xpath">expressions</phrase>. Grammar productions are introduced together with the features that they describe, and a complete grammar is also presented in the appendix [<specref ref="nt-bnf"/>].  The appendix is the normative version.</p><p>In the grammar productions in this document, named symbols are underlined and literal text is enclosed in double quotes. For example, the following  production describes the syntax of a function call:</p><scrap headstyle="show"> 
		  <head/> 
		  <prod num="48" id="fakeid_doc-xpath-FunctionCall"><lhs>FunctionCall</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt>  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>)*)?  ")"</rhs></prod> 
		</scrap><p>The production should be read as follows: A
		function call consists of a QName followed by an
		open-parenthesis. The open-parenthesis is followed by
		an optional argument list. The argument list (if
		present) consists of one or more expressions,
		separated by commas. The optional argument list is
		followed by a close-parenthesis. </p>

		<p>Certain aspects of language
		processing are described in this specification as
		<term>implementation-defined</term> or
		<term>implementation-dependent</term>.</p>

<ulist>
  <item>
    <p><termdef id="dt-implementation-defined" term="implementation defined"><term>Implementation-defined</term>
		indicates an aspect that may differ between
		implementations, but must be specified by the
		implementor for each particular
		implementation.</termdef></p>
  </item>
  <item>
    <p>
      <termdef id="dt-implementation-dependent" term="implementation   dependent"><term>Implementation-dependent</term>
		indicates an aspect that may differ between
		implementations, is not specified by this or any W3C
		specification, and is not required to be specified by
		the implementor for any particular
		implementation.</termdef></p>
  </item>
</ulist>

<p role="xpath">A language aspect described in this specification as
<term>implementation-defined</term> or <term>implementation
dependent</term> may be further constrained by the specifications of a
host language in which XPath is embedded.</p>

<p>This document normatively defines the dynamic semantics of
XPath. The static semantics of XPath are normatively defined
in <bibref ref="XQueryFormalSemantics"/>. In this document, examples
and material labeled as "Note" are provided for explanatory purposes
and are not normative.</p></div1>


<!--
====================================================================
 $Log: xpath20.xml,v $
 Revision 1.2  2007/01/18 23:18:37  cmsmcq
 Suppress link to diffed version of November 2006; no changes to speak of.

 Revision 1.1  2007/01/18 22:04:39  cmsmcq
 Rec publication build 4

 Revision 1.62  2007/01/05 17:18:27  sboag
 Repared CR/LFs for Don.

 Revision 1.61  2006/11/09 15:19:34  NormanWalsh
 Updated by Norm and Don

 Revision 1.58  2005/10/25 20:27:38  sboag
 Removed role-"parse-test" from element that holds a clearly incomplete expression.

 Revision 1.57  2005/10/21 04:27:02  sboag
 Don's latest changes.

 Revision 1.56  2005/09/01 20:36:35  NormanWalsh
 Edits from Don

 Revision 1.55  2005/07/27 02:47:41  sboag
 Added a validate of the unassembled doc for target xquery.html, as a sanity check,
 Removed <nt> brackets around QName and NCName, since the don't work and
 I'm not sure how to fix them, of if they should be fixed, at the moment, and
 added xpath- prefix to to id's that were xpath only, but had xquery equivelents
 elsewhere (escapeQuot and escapeAPos).

 Revision 1.54  2005/07/10 07:13:41  sboag
 July 10 draft.

 Revision 1.52  2005/07/08 16:53:30  sboag
 Don's latest edits.  See changes.txt for details.

 Revision 1.51  2005/03/28 14:16:14  NormanWalsh
 Updates from DC

 Revision 1.42  2004/10/26 17:23:48  NormanWalsh
 Pubrules tweaks

 Revision 1.41  2004/10/18 14:56:39  sboag
 Don's checkin.  See changes.txt (1.5) for this checkin for more info.

 Revision 1.40  2004/07/14 21:02:20  NormanWalsh
 Updated function/datatype namespaces; tweaked status; 23 July draft, pubrules clean

 Revision 1.39  2004/07/13 12:20:39  NormanWalsh
 Log update, I think. Not signficant anyway.

 Revision 1.35  2004/06/07 08:27:13  sboag
 Change of Validation stuff, according to request note from Don.

 Revision 1.33  2004/05/31 18:32:21  sboag
 Latest grammar changes, part of last call comments response.  (Sorry for lack
 of fine-grained detail, but CVS has been down for a week.)  The EBNF is a proposal,
 with change markings.

 Revision 1.31  2004/05/14 20:15:52  sboag
 Latest integration effort between Don and Scott.

 Revision 1.27  2003/12/05 01:04:09  sboag
 Change name of Predicates production to PredicateList.  Approved at Oracle F2F, 11/5/03

 Revision 1.26  2003/12/04 21:54:00  sboag
 Global search-replace: DC requests to change the production-names of
 SchemaMode and SchemaContext to ValidationMode and ValidationContext, to more closely match the explanatory text. Editorial change only. Names of other related productions (SchemaContextLoc etc.) remain unchanged.

 Revision 1.25  2003/12/04 16:45:21  sboag
 Change FilterStep to FilterExpr as per http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Nov/0014.html

 Revision 1.24  2003/11/07 01:58:07  NormanWalsh
 Added xpath-dt-static-typing-feature link

 Revision 1.23  2003/11/04 19:23:32  NormanWalsh
 Added required class attributes; added new informative bibl entries

 Revision 1.22  2003/10/30 04:25:50  sboag
 Changed ComputedXMLComment to CompXMLComment, as per http://lists.w3.org/Archives/Public/public-qt-comments/2003Oct/0056.html (editorial discretion taken)

 Revision 1.21  2003/10/28 19:29:20  NormanWalsh
 Tweaked document order per Jeni

 Revision 1.20  2003/10/28 19:25:16  NormanWalsh
 Ran through crlf to get rid of DOS line breaks...sigh.

 Revision 1.19  2003/10/28 13:55:28  NormanWalsh
 Final edits from Don

 Revision 1.16  2003/08/27 01:52:17  sboag
 Fed through dos2unix, to clean up extra CRs.

 Revision 1.15  2003/08/13 18:31:47  NormanWalsh
 Updates from Don on 7 Aug

 Revision 1.13  2003/07/31 18:09:48  sboag
 Don's latest edits, along with the module namespace changed originally outlined in http://lists.w3.org/Archives/Member/w3c-xml-query-wg/2003Jul/0218.html, and approved by XQuery July 30.

 Revision 1.12  2003/07/22 17:59:09  sboag
 Reduce production names to max 20:
 Original Name	Len	New Name	Len
 MustUnderstandExtension	23	MUExtension	11
 QuoteAttributeContentChar	25	QuotAttrContentChar	18
 AposAttributeContentChar	24	AposAttrContentChar	18
 AbbreviatedForwardStep	22	AbbrevForwardStep	17
 AbbreviatedReverseStep	22	AbbrevReverseStep	17
 ComputedDocumentConstructor	27	CompDocConstructor	18
 ComputedElementConstructor	26	CompElemConstructor	19
 ComputedAttributeConstructor	28	CompAttrConstructor	19
 ComputedNamespaceConstructor	28	LocalNamespaceDecl	17
 ComputedXmlProcessingInstruction	32	CompPIConstructor	9
 ComputedTextConstructor	23	CompTextConstructor	19
 XmlProcessingInstruction	24	DirPIConstructor	5
 QuoteAttributeValueContent	26	QuotAttrValueContent	20
 AposAttributeValueContent	25	AposAttrValueContent	20
 ProcessingInstructionTest	25	PITest	6
 SchemaContextLocation	21	SchemaContextLoc	16
 
 Revision 1.11  2003/07/22 14:26:31  sboag
 Latest edits from Don.  Pre production name reduction.

 Revision 1.10  2003/07/08 15:59:35  sboag
 Fixed 2 obvious expression bugs.

 Revision 1.9  2003/07/01 15:21:19  sboag
 Fixed validation, which includes fixing LF problems, termref/termdef attribute mess, and nt fixes.  (stylesheet fix needs to come with this).

 Revision 1.8  2003/06/30 16:18:23  sboag
 Fix double-dash problems inside comments that Mary entered.

 Revision 1.7  2003/06/26 02:37:00  mfernand

 June 25, 2003 - Mary

 Changes to documents:
 =========================
   Modified files:
     lang/XPathXQuery.xml
     lang/expressions.xml
     lang/introduction.xml
     lang/query-prolog.xml
     lang/shared.html
     lang/xquery.html
     lang/xpath.html

   Added file:
     lang/errors.xml

   o Added markup for error definitions and references in all sections.

     - Error definitions are in new file: lang/errors.xml.

   o Added term definitions and references.

     - Additions required some minor editing to sentences/paragraphs so
       that term definitions were self-contained in Glossary.

     - All term definitions in Secs 1 & 2 should be complete.

       Exceptions: definitions of "Optional Features" are not pithy, thus
       not amenable to definition in a glossary.

     - All references in Secs 1 - 4 to terms defined in Secs 1 and 2
       are marked-up.

     - A smattering of term definitions in Secs 3 & 4 are done.
       Whomever continues with term markup should begin here.

     NB: I did not add any new term definitions - - I simply converted as
     many <term> elements as possible to <termdef>s or <termref>s.
     I did not change any term definitions other than to make them
     self-contained.

 Known styling problems (need help from Norm):
 =============================
   o Need to add "spec" attribute to <termdef> to scope term
     definitions within a particular document (e.g., "XP" or "XQ")

     - Current bug: terms that should only be defined in XQuery book
       also appear in XPath book.

   o Glossary should probably be emitted in alphabetic order.

   o Not sure what to do about errors of this kind:

     "style/issues-spec.xsl:248:20: Warning! Cannot point to resolved
     issue: #xquery-abstract-syntax"

 Issues/Questions:
 =============================
   o Should Glossary be labeled as normative?

   o Should Summary of Error Codes be labeled as normative?

 Revision 1.6  2003/06/12 22:31:50  jrobie

 Made the documents consistent with the following grammar changes:

 (a) Use "declare" consistently in prolog (replacing "define") and get
 rid of all uses of "=" except between prefix and URI. See Issue
 547. Changed terminology accordingly - "function definitions" are now
 "function declarations", "user-defined functions" are now
 "user-declared functions", etc.


 (b) Limit comments, pragmas, and extensions to places inside XQuery
 expressions where insignificant whitespace is allowed. See Issue 550.

 (c) Change if-expr so both then-clause and else-clause take ExprSingle,
 not Expr. See Query/May/0006.

 (d) New clause in Prolog: "declare" "base-uri" StringLiteral
 Scope is the module in which it is declared. Proposed by M. Rys in
 Query/Apr/0001 and adopted by Query WG telcon, 5/7/03.


 (h) Change "." to be a primary expr rather than an abbreviated step.
 See http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Apr/0200.html.

 (i) Change to PITest so it allows an NCName as well as a
 StringLiteral, as proposed by JR.
 See http://lists.w3.org/Archives/Member/w3c-xsl-query/2003Apr/0256.html.

 (16) Change to Prolog syntax: function declarations can now be mixed
 with variable and other declarations. Approved, Query WG F2F, 5/16/03.

 Revision 1.5  2003/06/10 20:53:47  jrobie
 Processing model diagrams.

 Revision 1.4  2003/06/10 20:48:09  jrobie
 *** empty log message ***

 Revision 1.3  2003/04/18 22:01:52  NormanWalsh
 Editorial nits for pubrules

 Revision 1.2  2003/04/18 19:22:04  sboag
 Don's latest revisions, responding to comments from the working groups.

 Revision 1.1  2003/04/07 22:18:05  sboag
 Initial checkin of language build and parser build.

 Revision 1.29  2002/11/07 21:45:36  sboag
 Integrated new XSL from http://www.w3.org/2002/xmlspec/html/1.4/xmlspec.xsl,
 Fixed a couple minor bugs that this helpful stylesheet flagged.

 Revision 1.28  2002/11/07 19:30:56  sboag
 changed to 2.2 xmlspec, and deleted all xmlspec-v21.xxx.  Fixed BNF
 problem with OcurrenceIndicator.  Fixed prevdoc problem.

 Revision 1.27  2002/11/07 00:27:14  sboag
 Minor changes specified by today's editorial meeting, dictated by Don to me over the phone.

 Revision 1.24  2002/11/05 16:18:45  sboag
 Minor parse test fixes.

 Revision 1.23  2002/11/05 16:13:01  sboag
 Don's final Nov. 15 drafts.

 Revision 1.20  2002/08/14 16:06:35  sboag
 Fixed up example URLs to use example.org.

 Revision 1.18  2002/08/12 03:02:22  sboag
 Fixed problems with comments from previous check-in.

 Revision 1.17  2002/08/12 02:40:48  sboag
 Check for role="parse-test" for all legitimate expression examples.  ***status: Did the best I could with <code> and <eg> examples.
 -> fixed discovered bug in grammar where document {...} constructor did not work.
 -> fixed bug with processing instruction content... I had to add a PROCESSING_INSTRUCTION_CONTENT state.
 -> fixed minor bug with end tag not being closed in expressions.xml (ugh, took me 30 minutes to track down).
 -> in section on "Other Constructors", broke samples into separate <eg>s, so they will parse (otherwise they expect an operator between them).
 -> fixed problem with CDataSection outside of element content.  (...if PI, XMLComments work, so should CDataSection, I guess).
 -> broke some/every examples in section on "Quantified Expressions" into two <eg> tags, since they can process sequentially.
      -> Also had to conditionalize these examples for XPath, so that the TypeDeclaration wasn't
           used (actually, it seems useless here).
 -> Fixed many problems with "validate".  However, see note on '"validate" seems to be reserved'.  Two of the fragments currently won't parse.

 Revision 1.15  2002/08/10 22:01:47  sboag
 Changed "default collation at" to "default collation ="

 Revision 1.14  2002/08/04 21:06:21  sboag
 The following changes from the last F2F:

 (1) Delete "precedes" and "follows" operators from OrderComp.

 (2) Change name of TypeAssertion production to TypeDeclaration.

 (3) Add the following new production:

 DefaultCollationDecl ::= "default" "collation" StringLiteral

 (A collation is identified by a URI, so you can use a more specific symbol in place of StringLiteral that indicates that a URI is expected, if you want to.)

 (4) Delete the production for ResultTypeDecl.

 (5) QueryProlog should now include DefaultCollationDecl but not ResultTypeDecl, as follows:

 QueryProlog ::= (NamespaceDecl | DefaultNamespaceDecl | SchemaImport | XMLSpaceDecl
    | DefaultCollationDecl)* FunctionDefn*

 Revision 1.13  2002/07/28 19:53:05  sboag
 Don's new documents.

 Revision 1.12  2002/07/04 18:29:22  sboag
 Simply made prerecap ref refer to itself.  This was a regression, because at one
 point I had deleted this production.

 Revision 1.11  2002/06/28 09:02:07  sboag
 Merged Don's latest work with new grammar proposal.  Changes too numerous
 to detail.

 Revision 1.10  2002/04/24 22:48:30  sboag
 Fixed minor problem with lists-within-lists-within-paragraphs.

 Revision 1.9  2002/04/24 22:21:18  sboag
 Don's changes assigned to him by this morning's telcon.

 Revision 1.8  2002/04/24 02:48:08  sboag
 CSS, HTML, Link validation passes.  Parser tests pass.  Updated to target
 pub date of April 30.

 Revision 1.6  2002/04/23 17:20:33  sboag
 Removed DocumentElement from production 61, as per WG decision.
 Fixed Dana's company and email address.
 Added section on reserved words (list is mechanically generated).
 Addressed the following issues in the lexical section from
 (http://lists.w3.org/Archives/Public/www-xml-query-comments/2002Jan/0002.html),
 lengthy Michael Dyck.  Not all issues have been addressed yet.
 <item priority="2" status="done"> <description>para 1: "Whitespace may be
 		  freely added within patterns" What do you mean by "patterns"? Presumably,
 		  you're either talking about adding the symbol 'Whitespace' to grammar
 		  productions, or adding whitespace (i.e., sequences of characters) to queries.
 		  Don't confuse the two.</description></item>
 <item priority="2" status="done"> <description>"before or after any
 		  token" But you never actually define what a token is. It's not even clear what
 		  the set of token-types is. (Is it the set of left-hand-sides of producbtions 75
 		  through 216? Is it the set of symbols that appear in the "tokens" column of the
 		  TRANITION STATES table? The two are different, and both contain symbols that
 		  probably shouldn't be considered token-types.)</description></item>
 <item status="done"> <description>para 1 and bullets 1 and 2: Note that
 		  the Whitespace symbol derives the empty string, but phrases like "must always
 		  be followed by whitespace" and "whitespace may not occur" obviously mean
 		  "whitespace" in the sense of "a non-empty string of whitespace-characters". I
 		  think this shows correct usage, and there's no reason for Whitespace to be
 		  nullable. (That is, it should be the same as S.)</description></item>
 <item status="done"> <description>bullet 3: "A space" We're interested in
 		  whitespace, not just a space.</description></item>
 <item status="done"> <description>"may be significant" Don't tell us that
 		  it *may* be significant. Tell us exactly when it *is*
 		  significant.</description></item>
 <item status="done"> <description>para 2: "Tokens may be often only
 		  recognized" "may be often only" is clunky.</description></item>
 <item status="done"> <description>"in a specific state" You haven't
 		  defined states yet.</description></item>
 <item status="done"> <description>"within the evaluation": Does
 		  evaluation of a query include its parsing/lexing?</description></item>
 <item status="done"> <description>"may cause the grammar to transition to
 		  a different state" Grammars don't have states or transitions. Automata
 		  do.</description></item>
 <item status="done"> <description>"following the enumeration of tokens"
 		  Change "tokens" to "token-types".</description></item>
 <item status="done"> <description>para 3: "When tokenizing, the longest
 		  possible token is always returned" Issue 109 says this means "the longest
 		  sequence that would form a token in the token-space of the grammar, not the
 		  longest that would be valid in the current syntactic context." Does
 		  it?</description></item>
 <item status="done"> <description>"If there is an ambiguity between two
 		  tokens, ..." Presumably, you mean an ambiguity that isn't resolved by the
 		  longest-match rule.</description></item>
 <item status="done"> <description>"the token that an lower grammar
 		  number" Change "an" to "a".</description></item>
 <item status="done"> <description>is more specific than" Why do we care
 		  which is "more specific"? We want to know which is the right one. I'll assume
 		  that's what you mean.</description></item>

 Revision 1.5  2002/04/22 15:23:24  sboag
 Don says: I believe that these drafts contain all the substantive comments
 that were raised at the Cambridge task force meetings and subsequent
 telcons. These are the drafts that will be reviewed for publication. Additional
 minor editorial changes may be made before the documents are actually
 submitted to w3c.

 Revision 1.1  2002/04/01 20:10:30  sboag
 Jonathan Robie changes, including removal of fragment.xml and inclusion of
 expressions.xml, etc.
 Merge of his grammar with latest.


 Revision 1.42  2001/12/17 20:27:29  sboag
 Fixes for every-header-has-to-have-an-id.

 Revision 1.41  2001/12/16 06:31:59  sboag
 Minor fix to the comment ednote.

 Revision 1.37  2001/12/14 20:47:43  sboag
 Fixed some bad links.

 Revision 1.36  2001/12/14 17:21:26  sboag
 Fixed link.

 Revision 1.28  2001/12/11 17:09:44  sboag
 Don's suggested modifications to the grammar.  Also temporarily commented
 out the pathx1 build, 'till I get it fixed.

 Revision 1.27  2001/12/10 02:45:49  sboag
 Fixed some of the code examples that read <p><code>some example</code></p>.

 Revision 1.25  2001/12/09 22:07:16  sboag
 Fixed problem with comments from previous checkin.

 Revision 1.24  2001/12/09 21:39:37  sboag
 [batch checkin] Added {- - comment - -} type comments.  Added ";" list 
 query processing.  Added some stuff for ^char handling in reg 
 expressions, in order to support CharData better, but backed 
 out of this (but left some of the support in.  Removed old type def 
 and group stuff (can look to previous versions if we want to add this 
 back in).  Changed to case sensitivity in grammar, and updated 
 fragment.xml.  Added optional (AT schemaLocation)? to SchemaImport.  
 Other minor changes in support of WG decisions.

 Revision 1.23  2001/12/08 15:15:25  sboag
 Jonathan and Scott tweaked paragraph about QName escape.

 Revision 1.22  2001/12/07 23:34:28  sboag
 Add note about escaping QNames in the Basics section, pending resolution
 of the issue about what to do about possible EQName token.  Don needs to review.
 Removed paragraph again about enclosed expressions in element constructors. 

 Revision 1.20  2001/12/07 08:55:45  sboag
 Made rule about space before "<" be xquery spec only.

 Revision 1.19  2001/12/07 08:29:26  sboag
 Added ednote about space before "<" rule.

 Revision 1.18  2001/12/07 08:19:17  sboag
 Add <{foo}/> syntax, as per direction of XQuery WG.  Need to check about the
 enclosed expression syntax for attribute names, which I also added.

 Revision 1.17  2001/12/07 07:36:15  sboag
 Fix data-type section for XPath (remove Typeswitch, CaseClause).

 Revision 1.16  2001/12/07 07:06:38  sboag
 Changed BuiltInType to SimpleType in grammar and text.
 Removed Remove *:*.
 Defined IntegerLiteral, DecimalLiteral, and DoubleLiteral.
 Took a shot at fixing the "-" lexical rule in arithmatic section.
 Defined IntegerLiteral, DecimalLiteral, and DoubleLiteral. 

==================================================================== 
-->
<!-- 

float*date

send a value to a function that is expecting a node

"make a list of the errors that can be determined statically"

-->
<div1 id="id-basics"> 
  <head>     Basics</head> 
	 <p>The basic  building block of XPath is the
	 <term>expression</term>, which is a string of <bibref ref="Unicode"/> characters (the version of Unicode to be used is <termref def="dt-implementation-defined">implementation-defined</termref>.)
	 The language provides several kinds of expressions which may be constructed
	 from keywords, symbols, and operands. In general, the operands of an expression
	 are other expressions. XPath allows expressions to be nested with full
generality. </p> 
	 <note><p>This specification contains no 
assumptions or requirements regarding the character set encoding of strings 
of <bibref ref="Unicode"/> characters.</p></note><p>Like XML, XPath is a case-sensitive language. Keywords in
	 XPath use lower-case characters and are not reserved—that is, names in XPath expressions are allowed to be the same as language keywords, except for certain unprefixed function-names listed in <specref ref="id-reserved-fn-names"/>.</p> 
	  
	 <p><termdef term="value" id="dt-value">In the <termref def="dt-datamodel">data model</termref>, a <term>value</term> is always a <termref def="dt-sequence">sequence</termref>.</termdef> <termdef id="dt-sequence" term="sequence">A
<term>sequence</term> is an ordered collection of zero or more
<termref def="dt-item">items</termref>.</termdef>
<termdef id="dt-item" term="item">An
	 <term>item</term> is either an <termref def="dt-atomic-value">atomic value</termref> or a <termref def="dt-node">node</termref>.</termdef>
<termdef id="dt-atomic-value" term="atomic value">An <term>atomic
	 value</term> is a value in the value space of an <term>atomic
	 type</term>, as defined in <bibref ref="XMLSchema"/>.</termdef>
<termdef id="dt-node" term="node">A <term>node</term> is an instance of one of the
	  <term>node kinds</term> defined in <bibref ref="datamodel"/>.</termdef>
Each node has a unique <term>node identity</term>, a <term>typed value</term>, and a <term>string value</term>. In addition, some nodes have a <term>name</term>. The <term>typed value</term> of a node is a sequence
	 of zero or more atomic values. The <term>string value</term> of a node is a
	 value of type <code>xs:string</code>. The <term>name</term> of a node is a value of type <code>xs:QName</code>.</p> 
	 <p><termdef id="dt-singleton" term="singleton">A sequence containing exactly one item is called a
	 <term>singleton</term>.</termdef> An item is identical to a singleton sequence
	 containing that item. Sequences are never nested—for example, combining the
	 values 1, (2, 3), and ( ) into a single sequence results in the sequence (1, 2,
	 3). <termdef id="dt-empty-sequence" term="empty sequence">A sequence containing zero items is called an <term>empty sequence</term>.</termdef></p>
	  <p><termdef id="dt-data-model-instance" term="XDM instance">The term <term>XDM instance</term> is used, synonymously with the term <term>value</term>, to denote an unconstrained sequence of <termref def="dt-node">nodes</termref> and/or <termref def="dt-atomic-value">atomic values</termref> in the <termref def="dt-datamodel">data model</termref>.</termdef> </p><p>Names in XPath are called <term>QNames</term>, and conform to the syntax in <bibref ref="XMLNAMES"/>. <termdef id="dt-qname" term="QName">Lexically, a <term>QName</term> consists of an optional namespace prefix and a local name. If the namespace prefix is present, it is separated from the local name by a colon.</termdef> A lexical QName can be converted into an <term>expanded QName</term> by resolving its namespace prefix to a namespace URI, using the <termref def="dt-static-namespaces">statically known namespaces</termref> <errorref code="0081" class="ST"/>. <termdef id="dt-expanded-qname" term="expanded QName">An <term>expanded QName</term> consists of an optional namespace URI and a local name. An expanded QName also retains its original namespace prefix (if any), to facilitate casting the expanded QName into a string.</termdef> The namespace URI value is 
whitespace normalized according to the rules for the <code>xs:anyURI</code> type in <bibref ref="XMLSchema"/>. Two expanded QNames are equal if their namespace URIs are equal and their local names are equal (even if their namespace prefixes are not equal). Namespace URIs and local names are compared  on a codepoint basis, without further normalization.</p><p><phrase role="xpath">This document uses the following namespace prefixes to represent the namespace URIs with which they are listed. Use of these namespace prefix bindings in this document is not normative.</phrase></p>  <ulist><item><p><code>xs = http://www.w3.org/2001/XMLSchema</code></p></item><item><p><code>fn = http://www.w3.org/2005/xpath-functions</code></p></item><item role="xpath"><p><code>err = http://www.w3.org/2005/xqt-errors</code> (see <specref ref="id-identifying-errors"/>).</p></item></ulist> 
	 <p>Element nodes have a property called <term>in-scope namespaces</term>. <termdef term="in-scope namespaces" id="dt-in-scope-namespaces">The <term>in-scope namespaces</term> property of an element node is a set of <term>namespace bindings</term>, each of which associates a namespace prefix with a URI, thus defining the set of namespace prefixes that are available for interpreting QNames within the scope of the element. For a given element, one namespace binding may have an empty prefix; the URI of this namespace binding is the default namespace within the scope of the element.</termdef></p><p role="xpath">In <bibref ref="XPath"/>, the in-scope namespaces of an element node are represented by a collection of <term>namespace nodes</term> arranged on a <term>namespace axis</term>. In XPath Version 2.0, the namespace axis is deprecated and need not be supported by a host language. A host language that does not support the namespace axis need not represent namespace bindings in the form of nodes.</p><p><termdef term="URI" id="dt-URI">Within this specification, the term <term>URI</term> refers to a Universal Resource Identifier as
defined in <bibref ref="RFC3986"/> and extended in <bibref ref="RFC3987"/> with the new name <term>IRI</term>.</termdef>  The term URI has been retained in preference to IRI to avoid introducing new names for concepts such as "Base URI" that are defined or referenced across the whole family of XML specifications.</p><div2 id="context"> 
		<head>Expression Context</head> 
		<p><termdef id="dt-expression-context" term="expression context">The <term>expression context</term> for a given expression consists of
		all the information that can affect the result of the expression.</termdef> This
		information is organized into two categories called
	 the <termref def="dt-static-context">static
		context</termref> and the <termref def="dt-dynamic-context">dynamic context</termref>.</p> 
		 
		<div3 id="static_context"> 
		  <head>Static Context</head> 
		  <p><termdef id="dt-static-context" term="static context">The <term>static context</term> of an expression is
		  the information that is available during static analysis of the expression, prior
		  to its evaluation.</termdef> This information can be used to decide whether the
		  expression contains a <termref def="dt-static-error">static error</termref>.
		  If analysis of an 
expression relies on some component of the <termref def="dt-static-context">static context</termref> that has not been 
assigned a value, a <termref def="dt-static-error">static
		  error</termref> is raised <errorref code="0001" class="ST"/>.</p> 
		  <p>The individual components of the <termref def="dt-static-context">static context</termref> are summarized below. <phrase role="xpath">A default initial value for each component may be specified by the host language. The scope of each component is specified in <specref ref="id-xp-static-context-components" role="xpath"/>.</phrase> </p> 
		   
		  <ulist> 
			 <item><p><termdef id="dt-xpath-compat-mode" term="XPath 1.0 compatibility     mode"><term>XPath 1.0 compatibility
			 mode.</term>  <phrase role="xpath">This value is <code>true</code> if rules for backward compatibility with XPath Version 1.0 are in effect; otherwise it is <code>false</code>.</phrase></termdef></p></item> 
			 <item> 
				<p><termdef id="dt-static-namespaces" term="statically known namespaces"><term>Statically known namespaces.</term> This is a set of (prefix,
				URI) pairs that define all the namespaces that are known during static processing of a given expression.</termdef> The URI value is 
whitespace normalized according to the rules for the <code>xs:anyURI</code> type in <bibref ref="XMLSchema"/>. Note the difference between <termref def="dt-in-scope-namespaces">in-scope namespaces</termref>, which is a dynamic property of an element node, and <termref def="dt-static-namespaces">statically known namespaces</termref>, which is a static property of an expression.</p> 
			 </item> 
			 <item> 
				<p><termdef id="dt-def-elemtype-ns" term="default element/type namespace"><term>Default element/type namespace.</term> This is a
				namespace URI or "none". The namespace URI, if present, is used for any unprefixed QName appearing in a
				position where an element or type name is expected.</termdef> The URI value is 
whitespace normalized according to the rules for the <code>xs:anyURI</code> type in <bibref ref="XMLSchema"/>.</p> 
			 </item> 
			 <item> 
				<p><termdef id="dt-def-fn-ns" term="default function namespace"><term>Default function namespace.</term> This is a
				namespace URI or "none". The namespace URI, if present, is used for any unprefixed QName appearing in a position where a function name is expected.</termdef> The URI value is 
whitespace normalized according to the rules for the <code>xs:anyURI</code> type in <bibref ref="XMLSchema"/>.</p> 
			  </item> 
			 <item> 
				<p><termdef id="dt-issd" term="in-scope schema definitions"><term>In-scope schema
			 definitions.</term> This is a generic term
			 for all the element declarations, attribute declarations, and schema type
			 definitions that are in scope during
			 processing of an expression.</termdef> It includes the
			 following three
			 parts:</p><ulist><item><p>

			        <termdef id="dt-is-types" term="in-scope schema type"><term>In-scope schema types.</term> Each schema type
			        definition is identified either by an <termref def="dt-expanded-qname">expanded
			        QName</termref> (for a <term>named type</term>)
			        or by an <termref def="dt-implementation-dependent">implementation-dependent</termref> type
			        identifier (for an <term>anonymous
			        type</term>). The in-scope schema types include the predefined schema types described in <specref ref="id-predefined-types"/>.

                                

                         </termdef></p>

</item>


<item><p><termdef id="dt-is-elems" term="in-scope element declarations"><term>In-scope element declarations.</term> Each element
declaration is identified either by an <termref def="dt-expanded-qname">expanded QName</termref> (for a top-level element
declaration) or by an <termref def="dt-implementation-dependent">implementation-dependent</termref> element identifier (for a
local element declaration). </termdef> An element
declaration includes information about the element's <termref def="dt-substitution-group">substitution group</termref> affiliation.</p><p><termdef term="substitution group" id="dt-substitution-group"><term>Substitution groups</term> are defined in <bibref ref="XMLSchema"/> Part 1,  Section 2.2.2.2. Informally, the substitution group headed by a given element (called the <term>head element</term>) consists of  the set of elements that can be substituted for the head element without affecting the outcome of schema validation.</termdef></p></item><item><p><termdef id="dt-is-attrs" term="in-scope attribute declarations"><term>In-scope attribute
declarations.</term> Each attribute declaration is identified either
by an <termref def="dt-expanded-qname">expanded QName</termref> (for a top-level attribute declaration) or by an
<termref def="dt-implementation-dependent">implementation-dependent</termref> attribute identifier (for a local attribute
declaration).  </termdef></p></item></ulist> </item> <item> <p>
<termdef id="dt-in-scope-variables" term="in-scope variables"><term>In-scope variables.</term> This is a set of (expanded QName, type) pairs. It defines the
set of variables that are available for reference within an
expression. The <termref def="dt-expanded-qname">expanded QName</termref> is the name of the variable, and the type is the
<termref def="dt-static-type">static type</termref> of the
variable.</termdef></p><p> An expression that binds a variable (such as a
 <code>for</code>,
<code>some</code>, or <code>every</code> expression) extends the
<termref def="dt-in-scope-variables">in-scope variables</termref> of its subexpressions with the new bound variable
and its type. </p>
				 
			 </item><item><p><termdef term="context item static type" id="dt-context-item-static-type"><term>Context item static type.</term> This component defines the <termref def="dt-static-type">static type</termref> of the context item within the scope of a given expression.</termdef></p></item> 
			 <item> 
				<p><termdef id="dt-function-signature" term="function signature"><term>Function signatures.</term> This component defines the set of functions that are available
				to be called from within an
			 expression. Each function is uniquely
			 identified by its <termref def="dt-expanded-qname">expanded QName</termref> and its arity (number
			 of parameters).</termdef> In addition to the name and arity, each function signature specifies the <termref def="dt-static-type">static types</termref> of the function parameters and  result.</p>

                         <p>The <termref def="dt-function-signature">function signatures</termref> include the signatures of <termref def="dt-constructor-function">constructor functions</termref>, which are
                         discussed in <specref ref="id-constructor-functions"/>.</p>

			 </item> 
			 <item> 
				<p> <termdef id="dt-static-collations" term="statically known collations"><term>Statically known collations.</term> This is an <termref def="dt-implementation-defined">implementation-defined</termref> set of (URI,
				collation) pairs. It defines the names of the collations that are available for
				use in processing  expressions.</termdef> <termdef term="collation" id="dt-collation">A <term>collation</term> is a specification of the manner in which strings and URIs are compared and, by extension, ordered. For a more complete definition of collation, see <bibref ref="FunctionsAndOperators"/>.</termdef></p> 
			 </item> 
			 <item> 

				<p> <termdef id="dt-def-collation" term="default collation"><term>Default
				collation.</term> This identifies one of the collations in <termref def="dt-static-collations">statically known collations</termref> as the  collation to be
				used by functions and operators for comparing and ordering values of type <code>xs:string</code> and <code>xs:anyURI</code> (and types derived from them) when no
				explicit collation is
				specified.</termdef></p>

			 </item> 
			 <item> 
		<p><termdef id="dt-base-uri" term="base URI"><term>Base URI.</term> This is an absolute URI, used when necessary in the resolution of relative URIs (for example, by the <code>fn:resolve-uri</code> function.)</termdef> The URI value is 
whitespace normalized according to the rules for the <code>xs:anyURI</code> type in <bibref ref="XMLSchema"/>.</p> 
			 </item>
<item><p> <termdef id="dt-known-docs" term="statically known  documents"><term>Statically known documents.</term> This is a mapping
from strings onto types.  The string represents the absolute URI of a
resource that is potentially available using the <code>fn:doc</code>
function.  The type is the <termref def="dt-static-type">static type</termref> of a call to <code>fn:doc</code>  with the given URI as its
literal argument. </termdef> 
If the argument to <code>fn:doc</code> is a
string literal that is not present in <term>statically known documents</term>, then the
<termref def="dt-static-type">static type</termref> of
<code>fn:doc</code> is <code>document-node()?</code>.</p>
<note><p>The purpose of the <term>statically known
documents</term> is to provide static type information, not to determine
which documents are available. A URI need not be found in the
<term>statically known documents</term> to be accessed using
<code>fn:doc</code>. </p></note>
</item>

<item><p><termdef id="dt-known-collections" term="statically known  collections"><term>Statically known collections.</term> This is a
mapping from strings onto types.  The string represents the absolute
URI of a resource that is potentially available using the
<code>fn:collection</code> function.  The type is the type of the
sequence of nodes that would result from calling the
<code>fn:collection</code> function with this URI as its
argument.</termdef> If the argument to
<code>fn:collection</code> is a string literal that is not present in
<term>statically known collections</term>, then the <termref def="dt-static-type">static type</termref> of
<code>fn:collection</code> is <code>node()*</code>.</p><note><p>The purpose of the <term>statically known
collections</term> is to provide static type information, not to determine
which collections are available. A URI need not be found in the
<term>statically known collections</term> to be accessed using
<code>fn:collection</code>. 
</p></note></item><item><p><termdef id="dt-known-default-collection" term="statically known default collection type"><term>Statically known default collection type.</term> This is the type of the sequence of nodes that would result from calling the <code>fn:collection</code> function with no arguments.</termdef> Unless initialized to some other value by an implementation, the value of <term>statically known default collection type</term> is <code>node()*</code>.</p></item>
</ulist> 


</div3>
<div3 id="eval_context"> <head>Dynamic Context</head> <p><termdef id="dt-dynamic-context" term="dynamic context">The <term>dynamic
context</term> of an expression is defined as information that is
available at the time the expression is evaluated.</termdef> If
evaluation of an expression relies on some part of the <termref def="dt-dynamic-context">dynamic context</termref> that has not been
assigned a value, a <termref def="dt-dynamic-error">dynamic
error</termref> is raised <errorref class="DY" code="0002"/>.</p><p>The individual
components of the <termref def="dt-dynamic-context">dynamic
context</termref> are summarized below. Further rules governing the
semantics of these components can be found in <specref ref="id-xp-evaluation-context-components" role="xpath"/>.</p><p>The
<termref def="dt-dynamic-context">dynamic context</termref> consists
of all the components of the <termref def="dt-static-context">static
context</termref>, and the additional components listed below.</p>
<p><termdef id="dt-focus" term="focus">The first three components of
the <termref def="dt-dynamic-context">dynamic context</termref>
(context item, context position, and context size) are called the
<term>focus</term> of the expression. </termdef> The focus enables the
processor to keep track of which items are being processed by the
expression.</p> <p>Certain language constructs, notably the <termref def="dt-path-expression">path
expression</termref> <code role="parse-test">E1/E2</code> and the <termref def="dt-predicate">predicate</termref> <code role="parse-test">E1[E2]</code>, create a new focus
for the evaluation of a sub-expression. In these constructs, <code role="parse-test">E2</code> is evaluated once for each item in the
sequence that results from evaluating <code role="parse-test">E1</code>. Each time <code role="parse-test">E2</code> is evaluated, it is evaluated with a
different focus. The focus for evaluating <code role="parse-test">E2</code> is referred to below as the <term>inner
focus</term>, while the focus for evaluating <code role="parse-test">E1</code> is referred to as the <term>outer
focus</term>. The inner focus exists only while <code role="parse-test">E2</code> is being evaluated. When this evaluation
is complete, evaluation of the containing expression continues with
its original focus unchanged.</p> <ulist> <item> <p><termdef id="dt-context-item" term="context item">The <term>context item</term>
is the item currently being processed. An item is
either an atomic value or a node.</termdef><termdef id="dt-context-node" term="context node">When the context item is a
node, it can also be referred to as the <term>context
node</term>.</termdef> The context item is returned by an expression
consisting of a single dot (<code role="parse-test">.</code>). When an expression <code role="parse-test">E1/E2</code> or <code role="parse-test">E1[E2]</code> is evaluated, each item in the
sequence obtained by evaluating <code role="parse-test">E1</code>
becomes the context item in the inner focus for an evaluation of <code role="parse-test">E2</code>. </p> </item> <item> <p><termdef id="dt-context-position" term="context position">The <term>context
position</term> is the position of the context item within the
sequence of items currently being processed.</termdef> It changes whenever the context item
changes. When the focus is defined, the value of the context position is an integer greater than zero. The context
position is returned by the expression <code role="parse-test">fn:position()</code>. When an expression <code role="parse-test">E1/E2</code> or <code role="parse-test">E1[E2]</code> is evaluated, the context position in
the inner focus for an evaluation of <code role="parse-test">E2</code>
is the position of the context item in the sequence obtained by
evaluating <code role="parse-test">E1</code>. The position of the
first item in a sequence is always 1 (one). The context position is
always less than or equal to the context size.</p> </item> <item>
<p><termdef id="dt-context-size" term="context size">The <term>context
size</term> is the number of items in the sequence of items currently
being processed.</termdef> Its value is always an
integer greater than zero. The context size is returned by the
expression <code role="parse-test">fn:last()</code>. When an expression
<code role="parse-test">E1/E2</code> or <code role="parse-test">E1[E2]</code> is evaluated, the context size in the
inner focus for an evaluation of <code role="parse-test">E2</code> is
the number of items in the sequence obtained by evaluating <code role="parse-test">E1</code>. </p> </item>
			  
			 <item> 
				<p> <termdef id="dt-variable-values" term="variable values"><term>Variable values</term>. This is a set of
				(expanded QName, value) pairs. It contains the
				same <termref def="dt-expanded-qname">expanded QNames</termref> as the <termref def="dt-in-scope-variables">in-scope variables</termref> in the
				<termref def="dt-static-context">static context</termref> for the expression. The expanded QName is the name of the variable and the value is the dynamic value of the variable, which includes its <termref def="dt-dynamic-type">dynamic type</termref>.</termdef></p> 
				 
				 
			 </item><item><p><termdef term="function implementation" id="dt-function-implementation"><term>Function implementations</term>. Each function in <termref def="dt-function-signature">function signatures</termref> has a function implementation that enables the function to map instances of its parameter types into an instance of its result type. </termdef></p></item> 
			 <item> 
				<p> <termdef id="dt-date-time" term="current dateTime"><term>Current dateTime.</term> This information represents
				an <termref def="dt-implementation-dependent">implementation-dependent</termref> point in time during the processing of <phrase role="xpath">an expression</phrase>, and includes an explicit timezone. It can be retrieved by the  <code>fn:current-dateTime</code> function. If invoked multiple times during the execution of <phrase role="xpath">an expression</phrase>,
				this function always returns the same result.</termdef></p> 
			 </item><item><p><termdef id="dt-timezone" term="implicit timezone"><term>Implicit timezone.</term> This is the timezone to be used when a date,
time, or dateTime value that does not have a timezone is used in a
comparison or arithmetic operation. The implicit timezone is an  <termref def="dt-implementation-defined">implementation-defined</termref> value of type
<code>xs:dayTimeDuration</code>. See <bibref ref="XMLSchema"/> for the range of legal values
                         of a timezone.</termdef></p></item>
                         <item><p><termdef id="dt-available-docs" term="available documents"><term>Available
                         documents.</term> This is a mapping of
                         strings onto document nodes.  The string
                         represents the absolute URI of a
                         resource. The document node is the root of a tree that represents that resource using the <termref def="dt-datamodel">data model</termref>. The document node is returned by the <code>fn:doc</code> function when applied to that URI.</termdef> The set of available
                         documents is not limited to the set of <termref def="dt-known-docs">statically known
                         documents</termref>, and it may be
                         empty.</p><p>If there are one or more URIs in <termref def="dt-available-docs">available documents</termref> that map to a document
node <code>D</code>, then the document-uri property of <code>D</code> must either be absent, or must
be one of these URIs.</p><note><p>This means that given a document node <code>$N</code>, the result of
<code>fn:doc(fn:document-uri($N)) is $N</code> will always be True, unless
<code>fn:document-uri($N)</code> is an empty sequence.</p></note></item><item><p><termdef id="dt-available-collections" term="available collections"><term>Available
                         collections.</term> This is a mapping of
                         strings onto sequences of nodes. The string
                         represents the absolute URI of a
                         resource. The sequence of nodes represents
                         the result of the <code>fn:collection</code>
                         function when that URI is supplied as the
                         argument. </termdef> The set of available
                         collections is not limited to the set of <termref def="dt-known-collections">statically known
                         collections</termref>, and it may be empty.</p><p>For every document node <code>D</code> that is in the target of a mapping in <termref def="dt-available-collections">available collections</termref>, or that is the root of a tree containing such a node, the document-uri property of <code>D</code> must either be absent, or must be a
URI <code>U</code> such that <termref def="dt-available-docs">available documents</termref> contains a mapping from <code>U</code> to <code>D</code>."

</p><note><p>This means that for any document node <code>$N</code> retrieved using the
<code>fn:collection</code> function, either directly or by navigating to the root of a
node that was returned, the result of <code>fn:doc(fn:document-uri($N)) is $N</code>
will always be True, unless <code>fn:document-uri($N)</code> is an empty sequence. This
implies a requirement for the <code>fn:doc</code> and <code>fn:collection</code> functions to be
consistent in their effect. If the implementation uses catalogs or
user-supplied URI resolvers to dereference URIs supplied to the <code>fn:doc</code>
function, the implementation of the <code>fn:collection</code> function must take these
mechanisms into account. For example, an implementation might achieve this
by mapping the collection URI to a set of document URIs, which are then
resolved using the same catalog or URI resolver that is used by the <code>fn:doc</code> function.</p></note></item>
                         <item><p><termdef id="dt-default-collection" term="default collection"><term>Default collection.</term> This is the sequence of nodes that would result from calling the <code>fn:collection</code> function with no arguments.</termdef> The value of <term>default collection</term> may be initialized by the implementation.</p></item></ulist> </div3> </div2><div2 id="id-processing-model"><head>Processing
                         Model</head><p>XPath is defined in terms
                         of the <termref def="dt-datamodel">data
                         model</termref> and the <termref def="dt-expression-context">expression
                         context</termref>.</p> <graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="ProcMod-XPath.gif" alt="Processing                          Model Overview" role="xpath" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>Figure 1:
                         Processing Model Overview</p>

<p>Figure 1 provides a schematic overview of the processing steps that
are discussed in detail below. Some of these steps are completely
outside the domain of XPath; in Figure 1, these are depicted
outside the line that represents the boundaries of the language, an
area labeled <term>external processing</term>. The external processing
domain includes generation of an <termref def="dt-data-model-instance">XDM instance</termref> that represents the data to be queried (see <specref ref="id-data-model-generation"/>), schema import processing (see
<specref ref="id-schema-import-processing"/>) and serialization (see
<specref ref="id-serialization"/>). The area inside the boundaries of
the language is known as the <phrase role="xpath"><term>XPath processing domain</term></phrase>, which includes the static
analysis and dynamic evaluation phases (see <specref ref="id-expression-processing"/>).  Consistency constraints on the
<phrase role="xpath">XPath</phrase> processing domain are defined in <specref ref="id-consistency-constraints"/>.</p>


<div3 id="id-data-model-generation"><head>Data Model Generation</head>

<p>Before <phrase role="xpath">an expression</phrase> can be processed, its input data must be represented as an <termref def="dt-data-model-instance">XDM instance</termref>. This process occurs outside
the domain of XPath, which is why Figure 1 represents it in the
external processing domain. Here are some steps by which an XML
document might be converted to an <termref def="dt-data-model-instance">XDM instance</termref>:</p>

<olist><item><p>A document may be parsed using an XML parser that
generates an <term>XML Information Set</term> (see <bibref ref="XINFO"/>). The parsed document may then be validated against one
or more schemas. This process, which is described in <bibref ref="XMLSchema"/>, results in an abstract information structure called
the <term>Post-Schema Validation Infoset</term> (PSVI). If a document
has no associated schema, its Information Set is preserved. (See DM1
in Fig. 1.)</p> </item><item><p>The Information Set or PSVI may be
transformed into an <termref def="dt-data-model-instance">XDM instance</termref>
by a process described in <bibref ref="datamodel"/>. (See DM2 in
Fig. 1.)</p> </item></olist><p>The above steps provide an example of how an <termref def="dt-data-model-instance">XDM instance</termref> might be constructed. An XDM instance might
also be synthesized directly from a relational database, or
constructed in some other way (see DM3 in Fig. 1.) XPath is defined in terms
of the <termref def="dt-datamodel">data model</termref>,
but it does not place any constraints on how XDM instances are constructed.</p>

<p><termdef term="type annotation" id="dt-type-annotation">Each element node and attribute node in an <termref def="dt-data-model-instance">XDM instance</termref> has a <term>type annotation</term> (referred to in <bibref ref="datamodel"/> as its <code>type-name</code> property.) The type annotation of a node is a <termref def="dt-schema-type">schema type</termref> that describes the relationship between the <termref def="dt-string-value">string value</termref> of the node and its <termref def="dt-typed-value">typed value</termref>.</termdef>  If the <termref def="dt-data-model-instance">XDM instance</termref> was derived from a validated XML document as described in <xspecref spec="DM" ref="const-psvi"/>, the type annotations of the element and attribute nodes are derived from schema
validation. XPath does
not provide a way to directly access the type annotation of an element
or attribute node.</p><p>The value of an attribute is represented directly within the
attribute node. An attribute node whose type is unknown (such as might
occur in a schemaless document) is given the <termref def="dt-type-annotation">type annotation</termref>
<code>xs:untypedAtomic</code>.</p>

<p>The value of an element is represented by the children of the
element node, which may include text nodes and other element
nodes. The <termref def="dt-type-annotation">type annotation</termref> of an element node indicates how the values in
its child text nodes are to be interpreted. An element that has not been validated (such as might occur in a schemaless document) is annotated
with the schema type <code>xs:untyped</code>. An element that has been validated and found to be partially valid is annotated with the schema type <code>xs:anyType</code>. If an element node is annotated as <code>xs:untyped</code>, all its descendant element nodes are also annotated as <code>xs:untyped</code>. However, if an element node is annotated as <code>xs:anyType</code>, some of its descendant element nodes may have a more specific <termref def="dt-type-annotation">type annotation</termref>.</p>




</div3><div3 id="id-schema-import-processing"><head>Schema Import
Processing</head>

<p role="xpath">The <termref def="dt-issd">in-scope schema
definitions</termref> in the <termref def="dt-static-context">static
context</termref> are provided by the host language (see step SI1 in
Figure 1) and must satisfy the consistency constraints defined in
<specref ref="id-consistency-constraints"/>.

</p></div3><div3 id="id-expression-processing"><head>Expression
Processing</head><p>XPath defines two phases of processing called
the <termref def="dt-static-analysis">static analysis phase</termref>
and the <termref def="dt-dynamic-evaluation">dynamic evaluation
phase</termref> (see Fig. 1).  During the static analysis phase, <termref def="dt-static-error">static errors</termref>,  <termref def="dt-dynamic-error">dynamic errors</termref>, or <termref def="dt-type-error">type errors</termref> may be raised. During the dynamic evaluation phase, only <termref def="dt-dynamic-error">dynamic errors</termref> or <termref def="dt-type-error">type errors</termref> may be raised. These kinds of errors are defined in <specref ref="id-kinds-of-errors"/>.  </p><p>Within each phase, an implementation is free to use any
strategy or algorithm whose result conforms to the
specifications in this document.</p>

<div4 id="id-static-analysis"><head>Static Analysis Phase</head><p><termdef id="dt-static-analysis" term="static analysis phase">The
<term>static analysis phase</term> depends on the expression itself
and on the <termref def="dt-static-context">static context</termref>. The <term>static analysis phase</term> does
not depend on input data (other than schemas).</termdef></p>
<p>During the static analysis phase, the <phrase role="xpath">XPath expression</phrase> is parsed into an
internal representation called the <term>operation tree</term> (step
SQ1 in Figure 1).  A parse error is raised as a <termref def="dt-static-error">static error</termref> <errorref class="ST" code="0003"/>. The <termref def="dt-static-context">static context</termref> is initialized by the implementation (step SQ2).  The <termref def="dt-static-context">static context</termref> is used to resolve schema type names, function names, namespace prefixes, and variable names (step
SQ4). 
If a name of one of these kinds in the <term>operation tree</term> is
not found in the <termref def="dt-static-context">static context</termref>, a <termref def="dt-static-error">static error</termref> (<errorref class="ST" code="0008"/> or <errorref class="ST" code="0017"/>) is raised (however, see exceptions to this rule in <specref ref="id-element-test"/> and <specref ref="id-attribute-test"/>.)</p>

<p>The <term>operation tree</term> is then
<term>normalized</term> by making explicit the implicit operations
such as <termref def="dt-atomization">atomization</termref> and extraction of <termref def="dt-ebv">Effective Boolean Values</termref> (step SQ5). The
normalization process is described in <bibref ref="XQueryFormalSemantics"/>.</p>

<p> Each expression is then assigned a <termref def="dt-static-type">static type</termref> (step SQ6). 
<termdef id="dt-static-type" term="static type">The <term>static type</term> of an expression is a type such that, when the expression is evaluated, the resulting value will always conform to the static type.</termdef>
If the <termref def="dt-xpath-static-typing-feature" role="xpath">Static Typing Feature</termref> is supported, the <termref def="dt-static-type">static types</termref> of various expressions are inferred according to the rules described in <bibref ref="XQueryFormalSemantics"/>. If the <termref def="dt-xpath-static-typing-feature" role="xpath">Static Typing Feature</termref> is not supported, the static types that are assigned are <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p>
<p> During the <termref def="dt-static-analysis">static analysis phase</termref>, if the <termref def="dt-xpath-static-typing-feature" role="xpath">Static Typing Feature</termref>
 is in effect and an operand of an expression is found to have
a <termref def="dt-static-type">static type</termref> that is not appropriate for that operand, a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.  If static type
checking raises no errors and assigns a <termref def="dt-static-type">static type</termref> T to an
expression, then execution of the expression on valid input data is
guaranteed either to produce a value of type T or to raise a <termref def="dt-dynamic-error">dynamic error</termref>.</p><p>The purpose of the  <termref def="dt-xpath-static-typing-feature" role="xpath">Static Typing Feature</termref> is to provide early detection of <termref def="dt-type-error">type errors</termref> and to infer type information that may be useful in optimizing the evaluation of an expression.</p></div4><div4 id="id-dynamic-evaluation"><head>Dynamic Evaluation Phase</head><p><termdef id="dt-dynamic-evaluation" term="dynamic evaluation phase">The <term>dynamic evaluation phase</term> is the phase during which the value of an expression is computed.</termdef> It occurs after completion of the <termref def="dt-static-analysis">static analysis phase</termref>.</p><p>The dynamic evaluation phase can occur only if no errors were detected during the <termref def="dt-static-analysis">static analysis phase</termref>. If the <termref def="dt-xpath-static-typing-feature" role="xpath">Static Typing Feature</termref> is in effect, all <termref def="dt-type-error">type errors</termref> are detected during static analysis and serve to inhibit the dynamic evaluation phase.</p><p>The dynamic evaluation phase depends on the <term>operation
tree</term> of the expression being evaluated (step DQ1), on the input
data (step DQ4), and on the <termref def="dt-dynamic-context">dynamic context</termref> (step DQ5), which in turn draws information from  the external environment (step DQ3) and the <termref def="dt-static-context">static context</termref> (step DQ2). The dynamic evaluation phase may create new data-model values (step DQ4) and it may extend the <termref def="dt-dynamic-context">dynamic context</termref> (step DQ5)—for example, by binding values to variables.</p>

<p><termdef term="dynamic type" id="dt-dynamic-type">A <term>dynamic type</term> is associated with each value as it is computed. The dynamic type of a value may be more specific than the <termref def="dt-static-type">static type</termref> of the expression that computed it (for example, the  static type of an expression might be <code>xs:integer*</code>, denoting a sequence of zero or more integers, but at evaluation time its value may have the dynamic type <code>xs:integer</code>, denoting exactly one integer.)</termdef></p><p> If an operand of an expression is found
to have a <termref def="dt-dynamic-type">dynamic type</termref> that is not appropriate for that operand, a
<termref def="dt-type-error">type error</termref> is
raised <errorref class="TY" code="0004"/>.</p><p>Even though static typing can catch many <termref def="dt-type-error">type errors</termref> before an expression is executed, it is possible for an expression to raise an error during evaluation that was not detected by static  analysis. For example, an expression may contain a cast of a string into an integer, which is statically valid. However, if the actual value of the string at run time cannot be cast into an integer, a <termref def="dt-dynamic-error">dynamic error</termref> will result. Similarly, an expression may apply an arithmetic operator to a value whose <termref def="dt-static-type">static type</termref> is <code>xs:untypedAtomic</code>. This is not a <termref def="dt-static-error">static error</termref>, but at run time, if the value cannot be successfully cast to a <termref def="dt-numeric">numeric</termref> type, a <termref def="dt-dynamic-error">dynamic error</termref> will be raised.</p><p>When the <termref def="dt-xpath-static-typing-feature" role="xpath">Static Typing Feature</termref> is in effect, it is also possible for static analysis of an expression to raise a <termref def="dt-type-error">type error</termref>, even though execution of the expression on certain inputs would be successful. For example, an expression might contain a function that requires an element as its parameter, and the static analysis phase might infer the <termref def="dt-static-type">static type</termref> of the function parameter to be an optional element. This case is treated as a <termref def="dt-type-error">type error</termref> and inhibits evaluation, even though the function call would have been successful for input data in which the optional element is present.</p></div4></div3><div3 id="id-serialization"><head>Serialization</head><p><termdef id="dt-serialization" term="serialization"><term>Serialization</term> is the process of converting an <termref def="dt-data-model-instance">XDM instance</termref> into a sequence of octets (step DM4 in Figure 1.) </termdef> The general
framework for serialization is described in <bibref ref="serialization"/>.</p><p role="xpath">The host language may provide a serialization option.</p></div3><div3 id="id-consistency-constraints">

<head>Consistency Constraints</head><p>In order for XPath to
be well defined, the input <termref def="dt-data-model-instance">XDM instance</termref>, the <termref def="dt-static-context">static context</termref>, and the <termref def="dt-dynamic-context">dynamic context</termref> must be mutually
consistent. The consistency constraints listed below are prerequisites
for correct functioning of an XPath implementation. Enforcement
of these consistency constraints is beyond the scope of this
specification. This specification does not
define the result of   <phrase role="xpath">an expression</phrase> under any condition in which one
or more of these constraints is not satisfied.</p><p>Some of the consistency constraints use the term
<term>data model schema</term>. <termdef id="dt-data-model-schema" term="data model schema">For a given node in an <termref def="dt-data-model-instance">XDM instance</termref>, the
<term>data model schema</term> is defined as the schema from which the
<termref def="dt-type-annotation">type annotation</termref> of that node was derived.</termdef> For a node that was constructed by some
process other than schema validation, the <term>data model schema</term>
consists simply of the schema type definition that is represented by the <termref def="dt-type-annotation">type annotation</termref> of the node.</p>
<ulist>



<item><p>For every  node that has a type annotation, if that type annotation is found in the <termref def="dt-issd">in-scope schema definitions</termref> (ISSD), then its definition in the ISSD must be equivalent to its definition in the <termref def="dt-data-model-schema">data model schema</termref>. Furthermore, all types that are derived by extension from the given type in the <termref def="dt-data-model-schema">data model schema</termref> must also be known by equivalent definitions in the ISSD.</p></item><item><p>For every element name <emph>EN</emph> that is found both in an <termref def="dt-data-model-instance">XDM instance</termref> and in the <termref def="dt-issd">in-scope schema definitions</termref> (ISSD), all elements that are known in the <termref def="dt-data-model-schema">data model schema</termref> to be in the <termref def="dt-substitution-group">substitution group</termref> headed by <emph>EN</emph> must also be known in the ISSD to be in the <termref def="dt-substitution-group">substitution group</termref> headed by <emph>EN</emph>.</p></item><item><p>Every element name, attribute name, or schema type name referenced in <termref def="dt-in-scope-variables">in-scope variables</termref> or <termref def="dt-function-signature">function signatures</termref> must be in the <termref def="dt-issd">in-scope schema definitions</termref>, unless it is an element name referenced as part of an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementTest" xlink:type="simple">ElementTest</nt> or an attribute name referenced as part of an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeTest" xlink:type="simple">AttributeTest</nt>.</p></item><item><p>Any reference to a global element, attribute, or type name in
the <termref def="dt-issd">in-scope schema definitions</termref> must have a corresponding element, attribute or type
definition in the <termref def="dt-issd">in-scope schema definitions</termref>.</p></item>


<item><p> For each mapping of a string to a
document node in <termref def="dt-available-docs">available
documents</termref>, if there exists a mapping of the same string to a document type in <termref def="dt-known-docs">statically known documents</termref>, the document node must match the document type, using the matching rules in <specref ref="id-sequencetype-matching"/>.</p></item>
<item><p> For each mapping of a string to a sequence of nodes in
<termref def="dt-available-collections">available
collections</termref>, if there exists a mapping of the same string to
a type in <termref def="dt-known-collections">statically known collections</termref>, the sequence of nodes must match the type, using the matching rules in  <specref ref="id-sequencetype-matching"/>.</p></item><item><p>The sequence of nodes in the <termref def="dt-default-collection">default collection</termref> must match the <termref def="dt-known-default-collection">statically known default collection type</termref>, using the matching rules in  <specref ref="id-sequencetype-matching"/>.</p></item><item><p>The value of the <termref def="dt-context-item">context item</termref> must match the <termref def="dt-context-item-static-type">context item static type</termref>, using the
matching rules in <specref ref="id-sequencetype-matching"/>.</p></item>
<item><p>For each (variable, type) pair in <termref def="dt-in-scope-variables">in-scope variables</termref> and the corresponding (variable, value) pair in <termref def="dt-variable-values">variable values</termref> such that the variable names are equal, the value must match the type, using the matching rules in  <specref ref="id-sequencetype-matching"/>.</p></item><item><p>In the <termref def="dt-static-namespaces">statically known namespaces</termref>, the prefix <code>xml</code> must not be bound to any namespace URI other than <code>http://www.w3.org/XML/1998/namespace</code>, and no prefix other than <code>xml</code> may be bound to this namespace URI.</p></item>
</ulist>
</div3></div2>

<div2 id="errors">
<head>Error Handling</head>

<div3 id="id-kinds-of-errors"><head>Kinds of Errors</head><p>
As described in <specref ref="id-expression-processing"/>, XPath
defines a <termref def="dt-static-analysis">static analysis phase</termref>, which does not depend on input
data, and a <termref def="dt-dynamic-evaluation">dynamic evaluation
phase</termref>, which does depend on input
data.  Errors may be raised during each phase.</p>

<p><termdef id="dt-static-error" term="static error">
A <term>static error</term> is an 
error that
must be detected during the static analysis phase.
A syntax error is an example of a <termref def="dt-static-error">static error</termref>.</termdef></p>
<p>
<termdef id="dt-dynamic-error" term="dynamic error">A <term>dynamic
error</term> is an error that
must be detected during the dynamic evaluation phase and may be detected
during the static analysis phase.
Numeric overflow is an example of a dynamic error. 
</termdef>
</p>
<p>
<termdef id="dt-type-error" term="type error">A <term>type
error</term> may be raised during the static analysis phase or the dynamic evaluation phase.
During the static analysis phase, a <termref def="dt-type-error">type error</termref> occurs
when the <termref def="dt-static-type">static type</termref> of an expression does not match the expected type
of the context in which the expression occurs.
During the dynamic evaluation phase, a <termref def="dt-type-error">type error</termref> occurs 
when the <termref def="dt-dynamic-type">dynamic type</termref> of a value does not match the expected type of 
the context in which the value occurs.</termdef></p>

<p>The outcome of the <termref def="dt-static-analysis">static analysis
phase</termref> is either success or one or more <termref def="dt-type-error">type errors</termref>, <termref def="dt-static-error">static errors</termref>, or statically-detected <termref def="dt-dynamic-error">dynamic errors</termref>. The result of the <termref def="dt-dynamic-evaluation">dynamic evaluation
phase</termref> is either a result value, a <termref def="dt-type-error">type
error</termref>, or a <termref def="dt-dynamic-error">dynamic error</termref>.</p><p>If more than one error is present, or if an error condition comes within the
scope of more than one error defined in this specification, then any non-empty
subset of these errors may be reported.</p>

<p> During the <termref def="dt-static-analysis">static
analysis phase</termref>, if the <termref def="dt-xpath-static-typing-feature" role="xpath">Static Typing Feature</termref> is in effect and the <termref def="dt-static-type">static type</termref> assigned to an expression other than <code>()</code> or <code>data(())</code> is <code>empty-sequence()</code>, a <termref def="dt-static-error">static error</termref> is raised <errorref class="ST" code="0005"/>. This catches cases in which a query refers to an element or attribute that is not present in the <termref def="dt-issd">in-scope schema definitions</termref>, possibly because of a spelling error.</p><p>Independently of whether the <termref def="dt-xpath-static-typing-feature" role="xpath">Static Typing Feature</termref> is in effect, if an implementation can determine during the 
<termref def="dt-static-analysis">static
analysis phase</termref> that an expression, if evaluated, would necessarily 
raise a <termref def="dt-type-error">type
error</termref> or a <termref def="dt-dynamic-error">dynamic error</termref>, the implementation may (but is not required to) report that 
error during the <termref def="dt-static-analysis">static
analysis phase</termref>. However, the
<code>fn:error()</code> function must not be evaluated during the
<termref def="dt-static-analysis">static analysis
phase</termref>.</p><p><termdef id="dt-warning" term="warning">In addition to <termref def="dt-static-error">static errors</termref>, <termref def="dt-dynamic-error">dynamic errors</termref>, and <termref def="dt-type-error">type
errors</termref>, an XPath
implementation may raise <term>warnings</term>, either during the <termref def="dt-static-analysis">static analysis
phase</termref> or the
<termref def="dt-dynamic-evaluation">dynamic evaluation
phase</termref>. The circumstances in which warnings are raised, and
the ways in which warnings are handled, are <termref def="dt-implementation-defined">implementation-defined</termref>.</termdef></p><p>In addition to the errors defined in this
specification, an implementation may raise a <termref def="dt-dynamic-error">dynamic error</termref> for a reason beyond the scope of this specification. For
example, limitations may exist on the maximum
numbers or sizes of various objects. Any such  limitations, and the
consequences of exceeding them, are <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p></div3><div3 id="id-identifying-errors"><head>Identifying and Reporting Errors</head><p>The errors defined in this specification are identified by QNames that have the form <code role="xpath">err:XPYYnnnn</code>, where:</p><ulist><item><p><code>err</code> denotes the namespace for XPath and XQuery errors, <code>http://www.w3.org/2005/xqt-errors</code>. This binding of the namespace prefix <code>err</code> is used for convenience in this document, and is not normative.</p></item><item role="xpath"><p><code>XP</code> identifies the error as an XPath error.</p></item><item><p><code>YY</code> denotes the error category, using the following encoding:</p><ulist><item><p><code>ST</code> denotes a static error.</p></item><item><p><code>DY</code> denotes a dynamic error.</p></item><item><p><code>TY</code> denotes a type error.</p></item></ulist></item><item><p><code>nnnn</code> is a unique numeric code.</p></item></ulist><note><p>The namespace URI for  XPath and XQuery errors is not expected to 
change from one version of XPath to another. However, the contents of this 
namespace may be extended to include additional error definitions.</p></note><p>The method by which an XPath processor reports error information to the external environment is <termref def="dt-implementation-defined">implementation-defined</termref>.</p><p>An error can be represented by a URI reference that is derived from the error QName as follows: an error with namespace URI <emph><code>NS</code></emph> and local part <emph><code>LP</code></emph> can be represented as the URI reference <emph><code>NS</code></emph><code>#</code><emph><code>LP</code></emph>. For example, an error whose QName is <code>err:XPST0017</code> could be represented as <code>http://www.w3.org/2005/xqt-errors#XPST0017</code>.</p><note><p>Along with a code identifying an error, implementations may wish to return additional information, such 
as the location of the error or the processing phase in which it was detected. If an implementation chooses to do so, then the mechanism that 
it uses to return this information is <termref def="dt-implementation-defined">implementation-defined</termref>.</p></note></div3>

<div3 id="id-handling-dynamic"><head>Handling Dynamic Errors</head>
<p>Except as noted in this document, if any operand of an expression
raises a <termref def="dt-dynamic-error">dynamic error</termref>, the expression also raises a <termref def="dt-dynamic-error">dynamic error</termref>.
If an expression can validly return a value or raise a dynamic
error, the implementation may choose to return the value or raise
the dynamic error.  For example, the logical expression 
<code>expr1 and expr2</code> may return the value <code>false</code> 
if either operand returns <code>false</code>,
or may raise a dynamic error if either operand raises a dynamic
error.</p><p> If more than one operand of an expression raises 
an error, the
implementation may choose which error is raised by the expression.
For example, in this expression:

</p><eg role="parse-test" xml:space="preserve">($x div $y) + xs:decimal($z)</eg><p>

both the sub-expressions <code>($x div $y)</code> and <code>xs:decimal($z)</code> may 
raise an error.  The
implementation may choose which error is raised by the "<code>+</code>"
expression.  Once one operand raises an error, the implementation is
not required, but is permitted, to evaluate any other operands.</p>

<p><termdef id="dt-error-value" term="error value">In addition to its identifying QName, a dynamic error may also carry a descriptive string and one or more additional values called <term>error values</term>.</termdef> An implementation 
may provide a mechanism whereby an
application-defined error handler can process error values and
produce diagnostic messages.</p>

<p>A dynamic error may be raised by a <termref def="dt-built-in-function">built-in 
function</termref> or operator.  For example,
the <code>div</code> operator raises an error if its operands are <code>xs:decimal</code> values and its second operand
is equal to zero. Errors raised by built-in functions and operators are defined in <bibref ref="FunctionsAndOperators"/>.</p>

<p>A dynamic error can also be raised explicitly by calling the
<code>fn:error</code> function, which only raises an error and never
returns a value.  This function is defined in <bibref ref="FunctionsAndOperators"/>. For example, the following
function call raises a dynamic
error, providing a QName that identifies the error, a descriptive string, and a diagnostic value (assuming that the prefix <code>app</code> is bound to a namespace containing application-defined error codes):</p>

<eg role="parse-test" xml:space="preserve">fn:error(xs:QName("app:err057"), "Unexpected value", fn:string($v))</eg>

</div3><div3 id="id-errors-and-opt"><head>Errors and
      Optimization</head><p>Because different implementations may
      choose to evaluate or optimize an expression in different ways,
      certain aspects of the detection and reporting of <termref def="dt-dynamic-error">dynamic errors</termref> are <termref def="dt-implementation-dependent">implementation-dependent</termref>, as described in this section.</p><p>An implementation is always free to evaluate the operands of an operator in any order.</p><p>In some cases,  a processor can determine the result of an expression without accessing all the data that would be implied by the formal expression semantics. For example, the formal description of <termref def="dt-filter-expression">filter expressions</termref> suggests that <code>$s[1]</code> should be evaluated by examining all the items in sequence <code>$s</code>, and selecting all those that satisfy the predicate <code>position()=1</code>. In practice, many implementations will recognize that they can evaluate this expression by taking the first item in the sequence and then exiting. If <code>$s</code> is defined by an expression such as <code>//book[author eq 'Berners-Lee']</code>, then this strategy may avoid a complete scan of a large document and may therefore greatly improve performance. However, a consequence of this strategy is that a dynamic error or type error that would be detected if the expression semantics were followed literally might not be detected at all if the evaluation exits early. In this example, such an error might occur if there is a <code>book</code> element in the input data with more than one <code>author</code> subelement.</p><p>The extent to which a processor may optimize its access to data, at the cost of not detecting errors, is defined by the following rules.</p><p>Consider an expression <emph>Q</emph> that has an operand (sub-expression) <emph>E</emph>. In general the value of <emph>E</emph> is a sequence. At an intermediate stage during evaluation of the sequence, some of its items will be known and others will be unknown. If, at such an intermediate stage of evaluation, a processor is able to establish that there are only two possible outcomes of evaluating <emph>Q</emph>, namely the value <emph>V</emph> or an error, then the processor may deliver the result <emph>V</emph> without evaluating further items in the operand <emph>E</emph>. For this purpose, two values are considered to represent the same outcome if their items are pairwise the same, where nodes are the same if they have the same identity, and values are the same if they are equal and have exactly the same type.</p><p>There is an exception to this rule: If a processor evaluates an operand <emph>E</emph> (wholly or in part), then it  is required to establish that the actual value of the operand <emph>E</emph> does not violate any constraints on its cardinality. For example, the expression <code>$e eq 0</code> results in a type error if the value of <code>$e</code> contains two or more items. A processor is not allowed to decide, after evaluating the first item in the value of <code>$e</code> and finding it equal to zero, that the only possible outcomes are the value <code>true</code> or a type error caused by the cardinality violation. It must establish that the value of <code>$e</code> contains no more than one item.</p>
<p>These rules apply to all the operands of an expression considered in combination: thus if an expression has two operands <emph>E1</emph> and <emph>E2</emph>, it may be evaluated using any samples of the respective sequences that satisfy the above rules.</p><p>The rules cascade: if <emph>A</emph> is an operand of <emph>B</emph> and <emph>B</emph> is an operand of <emph>C</emph>, then the processor needs to evaluate only a sufficient sample of <emph>B</emph> to determine the value of <emph>C</emph>, and needs to evaluate only a sufficient sample of <emph>A</emph> to determine this sample of <emph>B</emph>.</p><p>The effect of these rules is that the processor is free to stop examining further items in a sequence as soon as it can establish that further items would not affect the result except possibly by causing an error. For example, the processor may return <code>true</code> as the result of the expression <code>S1 = S2</code> as soon as it finds a pair of equal values from the two sequences.</p><p>Another consequence of these rules is that where none of the items in a sequence contributes to the result of an expression, the processor is not obliged to evaluate any part of the sequence. Again, however, the processor cannot dispense with a required cardinality check: if an empty sequence is not permitted in the relevant context, then the processor must ensure that the operand is not an empty sequence.</p><p>Examples:</p>

<ulist><item><p>If an implementation can find (for example, by using an index) that at 
least one item returned by <code>$expr1</code> in the following example has the value <code>47</code>, it is allowed to 
return <code>true</code> as the result of the <code>some</code> expression, without searching for 
another item returned by <code>$expr1</code> that would raise an error if it were evaluated.
</p><eg role="parse-test" xml:space="preserve">some $x in $expr1 satisfies $x = 47</eg></item><item><p>In the following example, if an implementation can find (for example, by using an index) the 
<code>product</code> element-nodes that have an <code>id</code> child with the value <code>47</code>, it is allowed to return these nodes as the 
result of the <termref def="dt-path-expression">path expression</termref>, without searching for another <code>product</code> node that 
would raise an error because it has an <code>id</code> child whose value is not an integer.</p><eg role="parse-test" xml:space="preserve">//product[id = 47]</eg></item></ulist><p>For a variety of reasons, including optimization,  implementations are free to rewrite expressions into equivalent expressions.  Other than the raising or not raising of errors, the result of evaluating an equivalent expression must be the same as the result of evaluating the original expression. Expression rewrite is illustrated by the following examples.</p>

<ulist><item><p>Consider the expression <code>//part[color eq "Red"]</code>. An implementation might 
choose to rewrite this expression as <code>//part[color = "Red"][color eq 
"Red"]</code>. The implementation might then process the expression as follows: 
First process the "<code>=</code>" predicate by probing an index on parts by color to 
quickly find all the parts that have a Red color; then process the "<code>eq</code>" 
predicate by checking each of these parts to make sure it has only a 
single color. The result would be as follows: 
<ulist><item><p>Parts that have exactly one color that is Red are returned.</p></item><item><p>If some part has color Red together with some other color, an error is 
raised.</p></item><item><p>The existence of some part that has no color Red but has multiple non-Red 
colors does not trigger an error.</p></item></ulist></p></item><item><p>The expression in the following example cannot raise a casting error if it is evaluated
exactly as written (i.e., left to right). Since neither predicate depends on the context position, an implementation might choose to reorder the predicates to achieve better
performance (for example, by taking advantage of an index). This
reordering could cause the expression to raise an
error.</p><eg role="parse-test" xml:space="preserve">$N[@x castable as xs:date][xs:date(@x) gt xs:date("2000-01-01")]</eg><p>To avoid unexpected errors caused by expression rewrite,
tests that are designed to prevent dynamic errors should be expressed
using conditional  expressions. Conditional  expressions raise only dynamic errors that occur in the branch that is actually selected. Thus, unlike the previous example, the following example cannot raise a dynamic error if <code>@x</code> is not castable into an <code>xs:date</code>:</p><eg role="parse-test" xml:space="preserve">$N[if (@x castable as xs:date)
   then xs:date(@x) gt xs:date("2000-01-01")
   else false()]</eg></item></ulist>






</div3></div2><div2 id="id-important-concepts"><head>Concepts</head>

<p>This section explains some concepts that are important to the processing of XPath expressions.</p>

<div3 id="id-document-order"><head>Document Order</head>

        <p>An ordering called <term>document order</term> is defined among all the nodes accessible during processing of a given <phrase role="xpath">expression</phrase>, which may consist of one or more <term>trees</term> (documents or fragments). Document order is defined in <bibref ref="datamodel"/>, and its definition is repeated here for convenience. <termdef term="reverse document order" id="dt-reverse-document-order">The node ordering that is the reverse of document order is called <term>reverse document order</term>.</termdef></p>

<p>Document order is a total ordering, although the relative order of some nodes is <termref def="dt-implementation-dependent">implementation-dependent</termref>.  <termdef term="document order" id="dt-document-order">Informally, <term>document order</term> is the order in
which nodes appear in the XML serialization of a document.</termdef>  <termdef term="stable" id="stable">Document order is <term>stable</term>, which means that the relative order of two nodes will not change during the processing of a given <phrase role="xpath">expression</phrase>, even if this order is <termref def="dt-implementation-dependent">implementation-dependent</termref>.</termdef></p>

<p>Within a tree, document order satisfies the following constraints:</p>

<olist>
<item><p>The root node is the first node.</p></item>

<item><p>Every node occurs before all of its children and descendants.</p></item>

<item role="xpath"><p>Namespace nodes immediately follow the element node with
which they are associated. The relative order of namespace nodes is
stable but <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p></item>

<item><p>Attribute nodes immediately follow the <phrase role="xpath">namespace nodes of the
</phrase> element node with which they are associated. The relative order of
attribute nodes is stable but <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p></item>

<item><p>The relative order of siblings is the order in which they occur
in the <code>children</code> property of their parent node.</p></item><item><p>Children and descendants occur before following siblings.</p></item>
</olist>

<p>The relative order of nodes in distinct trees is stable but
<termref def="dt-implementation-dependent">implementation-dependent</termref>,
subject to the following constraint: If any node in a given tree T1 is before
any node in a different tree T2, then all nodes in tree T1 are before all nodes in
tree T2.</p>

        </div3>

	 <div3 id="id-atomization"><head>Atomization</head><p>The semantics of some
XPath operators depend on a process called <termref def="dt-atomization">atomization</termref>. Atomization is
applied to a value when the value is used in a context in which a
sequence of atomic values is required. The result of atomization is
either a sequence of atomic values or a <termref def="dt-type-error">type error</termref>  [err:FOTY0012].  <termdef id="dt-atomization" term="atomization"><term>Atomization</term> of a sequence
is defined as the result of invoking the <code>fn:data</code> function
on the sequence, as defined in <bibref ref="FunctionsAndOperators"/>.</termdef></p> <p> The semantics of
<code>fn:data</code> are repeated here for convenience. The result of
<code>fn:data</code> is the sequence of atomic values produced by
applying the following rules to each item in the input
sequence:</p><ulist> <item><p>If the item is an atomic value, it is
returned.</p></item><item><p>If the item is a node, 
its <termref def="dt-typed-value">typed value</termref> is returned (err:FOTY0012 is raised if the node has no typed value.)</p></item>
			  
			 </ulist><p>Atomization is  used in
processing the following types of expressions: </p><ulist><item><p>Arithmetic expressions</p></item><item><p>Comparison expressions</p></item><item><p>Function calls and returns</p></item><item><p>Cast expressions</p></item></ulist></div3><div3 id="id-ebv"><head>Effective Boolean Value</head><p>Under certain circumstances (listed below), it is necessary to find
the <termref def="dt-ebv">effective boolean value</termref> of a
value. <termdef id="dt-ebv" term="effective boolean value">The
<term>effective boolean value</term> of a value is defined as the result
of applying the <code>fn:boolean</code> function to the value, as
defined in <bibref ref="FunctionsAndOperators"/>.</termdef></p>

<p> The dynamic semantics of <code>fn:boolean</code> are repeated here for convenience:</p><olist><item><p>If its operand is an empty sequence, <code>fn:boolean</code> returns <code>false</code>.</p></item><item><p>If its operand is a sequence whose first item is a node, <code>fn:boolean</code> returns <code>true</code>.</p></item><item><p>If its operand is a <termref def="dt-singleton">singleton</termref> value of type <code>xs:boolean</code> or derived from <code>xs:boolean</code>, <code>fn:boolean</code> returns the value of its operand unchanged.</p></item><item><p>If its operand is a <termref def="dt-singleton">singleton</termref> value of type <code>xs:string</code>, <code>xs:anyURI</code>, <code>xs:untypedAtomic</code>, or a type derived from one of these, <code>fn:boolean</code> returns <code>false</code> if the operand value has zero length; otherwise it returns <code>true</code>.</p></item><item><p>If its operand is a <termref def="dt-singleton">singleton</termref> value of any <termref def="dt-numeric">numeric</termref> type or derived from a numeric type, <code>fn:boolean</code> returns <code>false</code> if the operand value is <code>NaN</code> or is numerically equal to zero; otherwise it returns <code>true</code>.</p></item><item><p>



In all other cases, <code>fn:boolean</code> raises a type error [err:FORG0006].
</p></item></olist><note><p>The static semantics of  <code>fn:boolean</code> are defined in <xspecref spec="FS" ref="sec_fn_boolean"/>.</p></note><p>The <termref def="dt-ebv">effective boolean value</termref> of a sequence is computed implicitly during  processing of the following types of expressions: </p><ulist><item><p>Logical expressions (<code>and</code>, <code>or</code>)</p></item><item><p>The <code>fn:not</code> function</p></item><item><p>Certain types of <termref def="dt-predicate">predicates</termref>, such as <code>a[b]</code></p></item><item><p>Conditional expressions (<code>if</code>)</p></item><item><p>Quantified expressions (<code>some</code>, <code>every</code>)</p></item><item role="xpath"><p>General comparisons, in <termref def="dt-xpath-compat-mode">XPath 1.0
		compatibility mode</termref>.</p></item></ulist><note><p>The definition of <termref def="dt-ebv">effective boolean value</termref> is <emph>not</emph> used when casting a value to the type <code>xs:boolean</code>, for example in a <code>cast</code> expression or when passing a value to a function whose expected parameter is of type <code>xs:boolean</code>.</p></note></div3><div3 id="id-input-sources"><head>Input Sources</head><p>XPath has a set of functions that provide access to
    input data. These functions are of particular importance because they provide a way in which an expression can reference a document or a collection of documents. The  input functions are described informally here; they are defined in <bibref ref="FunctionsAndOperators"/>.</p>

    <p>An expression can access input data either by calling one
    of the input functions or by referencing some part of the
    <termref def="dt-dynamic-context">dynamic context</termref> that is initialized by the external
    environment, such as a <termref def="dt-variable-values">variable</termref> or 
    <termref def="dt-context-item">context item</termref>.</p>

    <p>The input functions supported by XPath are as follows:</p>

    <ulist><item><p>The <code>fn:doc</code> function takes a string containing a URI. If that URI is associated with a document in <termref def="dt-available-docs">available documents</termref>, <code>fn:doc</code> returns a document node whose content is the <termref def="dt-datamodel">data model</termref> representation of the given document; otherwise it raises a <termref def="dt-dynamic-error">dynamic error</termref> (see <bibref ref="FunctionsAndOperators"/> for details).</p></item><item><p>The <code>fn:collection</code> function with one argument takes a string containing a URI. If that URI is associated with a collection in <termref def="dt-available-collections">available collections</termref>, <code>fn:collection</code> returns the data model representation of that collection; otherwise it raises a <termref def="dt-dynamic-error">dynamic error</termref> (see <bibref ref="FunctionsAndOperators"/> for details).  A collection may be any sequence of nodes. For example, the expression
    <code>fn:collection("http://example.org")//customer</code>
    identifies all the <code>customer</code> elements that are
    descendants of nodes found in the collection whose URI is
    <code>http://example.org</code>.</p></item><item><p>The <code>fn:collection</code> function with zero arguments returns the <termref def="dt-default-collection">default collection</termref>, an <termref def="dt-implementation-dependent">implementation-dependent</termref> sequence of nodes.</p></item></ulist>

    

    </div3></div2>
	 <div2 id="id-types"> 
		<head>Types</head> 
		<p> The type system of  XPath is based on
		<bibref ref="XMLSchema"/>, and is formally defined in
		<bibref ref="XQueryFormalSemantics"/>.</p><p><termdef id="dt-sequence-type" term="sequence type">A <term>sequence type</term> is a type that can be expressed using the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SequenceType" xlink:type="simple">SequenceType</nt>
syntax. Sequence types are used whenever it is necessary to refer to a type in an XPath expression. The term <term>sequence type</term> suggests that this syntax is used to describe the type of an XPath value, which is always a sequence.</termdef></p><p><termdef id="dt-schema-type" term="schema type">A <term>schema type</term> is a type that is (or could be) defined using the facilities of <bibref ref="XMLSchema"/> (including the built-in types of <bibref ref="XMLSchema"/>).</termdef> A schema type  can be used as a type annotation on an
element or attribute node (unless it is a non-instantiable type such as <code>xs:NOTATION</code> or <code>xs:anyAtomicType</code>, in which case its derived
types can be so used). Every schema type is either a <term>complex type</term> or a
<term>simple type</term>; simple types are further subdivided into <term>list types</term>, <term>union
types</term>, and <term>atomic types</term> (see <bibref ref="XMLSchema"/> for definitions and explanations of these terms.)</p><p>Atomic types represent the intersection between the categories of <termref def="dt-sequence-type">sequence type</termref> and <termref def="dt-schema-type">schema type</termref>. An
atomic type, such as <code>xs:integer</code> or <code>my:hatsize</code>, is both a <termref def="dt-sequence-type">sequence type</termref> and a
<termref def="dt-schema-type">schema type</termref>.</p> 
		 
	
		<div3 id="id-predefined-types"><head>Predefined Schema Types</head>


                 <p role="xpath">The <termref def="dt-is-types">in-scope schema types</termref>
                 in the <termref def="dt-static-context">static
                 context</termref> are initialized with a set of
                 predefined schema types that is determined by the host
                 language. This set may include some or all of the
                 schema types in the
                 namespace
                 <code>http://www.w3.org/2001/XMLSchema</code>,
                 represented in this document by the namespace prefix
                 <code>xs</code>. The schema types in this namespace are defined in <bibref ref="XMLSchema"/>
                 and augmented by additional types defined in <bibref ref="datamodel"/>. The schema types defined in  <bibref ref="datamodel"/> are summarized below.</p>


                   

<olist><item><p><termdef term="xs:untyped" id="dt-untyped"><code>xs:untyped</code> is  used as the <termref def="dt-type-annotation">type annotation</termref> of an element node that has not been validated, or has been validated in <code>skip</code> mode.</termdef> No predefined schema types are derived from <code>xs:untyped</code>.</p></item><item><p><termdef id="dt-untypedAtomic" term="xs:untypedAtomic"><code>xs:untypedAtomic</code>
is an atomic type that is used to denote untyped atomic data, such as text that has not been assigned a more specific type.</termdef> An attribute that has been validated in <code>skip</code> mode is represented in the <termref def="dt-datamodel">data model</termref> by an attribute node with the <termref def="dt-type-annotation">type annotation</termref> <code>xs:untypedAtomic</code>. No predefined schema types are derived from <code>xs:untypedAtomic</code>.</p></item><item><p><termdef term="xs:dayTimeDuration" id="dt-dayTimeDuration"><code>xs:dayTimeDuration</code> is derived by restriction from <code>xs:duration</code>. The  lexical representation of <code>xs:dayTimeDuration</code>
is restricted to contain only day, hour, minute, and second
components.</termdef></p></item><item><p><termdef term="xs:yearMonthDuration" id="dt-yearMonthDuration"><code>xs:yearMonthDuration</code> is derived by restriction from <code>xs:duration</code>. The lexical representation of <code>xs:yearMonthDuration</code> is
restricted to contain only year and month
components.</termdef></p></item><item><p><termdef term="xs:anyAtomicType" id="dt-anyAtomicType"><code>xs:anyAtomicType</code> is an atomic type that includes all atomic values (and no values that
are not atomic). Its base type is
<code>xs:anySimpleType</code> from which all simple types, including atomic,
list, and union types, are derived. All primitive atomic types, such as
<code>xs:integer</code>, <code>xs:string</code>, and <code>xs:untypedAtomic</code>, have <code>xs:anyAtomicType</code> as their base type.</termdef></p><note><p><code>xs:anyAtomicType</code>  will not appear as the type of an actual value in an <termref def="dt-data-model-instance">XDM instance</termref>.</p></note></item></olist><p>The relationships among the schema types in the <code>xs</code> namespace are illustrated in Figure 2. A more complete description of the XPath type hierarchy can be found in <bibref ref="FunctionsAndOperators"/>.</p><graphic xmlns:xlink="http://www.w3.org/1999/xlink" source="types.jpg" alt="Type Hierarchy Diagram" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/><p>Figure 2: Hierarchy of Schema Types used in XPath</p></div3>


<div3 id="id-typed-value"><head>Typed Value and String Value</head>

<p>Every node
has a <term>typed value</term> and a <term>string value</term>.

<termdef term="typed value" id="dt-typed-value">The <term>typed value</term> of a node is a sequence of atomic values
and can be extracted by applying the <code>fn:data</code> function to
the node.</termdef>  <termdef id="dt-string-value" term="string value">The <term>string
 value</term> of a node is a string and 
 can be extracted by applying the <code>fn:string</code>
 function to the node.</termdef>
Definitions of <code>fn:data</code> and <code>fn:string</code> can be found in <bibref ref="FunctionsAndOperators"/>.</p>


<p>An implementation may store both the <termref def="dt-typed-value">typed value</termref> and the <termref def="dt-string-value">string value</termref> of a node, or it may store only one of these and derive the other as needed. The string value of a node must be a valid lexical representation of the typed value of the node, but the node is not required to preserve the string representation from the original source document. For example, if the typed value of a node is the <code>xs:integer</code> value <code>30</code>, its string value might be "<code>30</code>" or "<code>0030</code>".</p><p role="xpath">The <termref def="dt-typed-value">typed value</termref>, <termref def="dt-string-value">string value</termref>, and <termref def="dt-type-annotation">type annotation</termref> of a node are closely related.  If the node was created by mapping from an Infoset or PSVI, the relationships among these properties are defined by rules in <bibref ref="datamodel"/>.</p><p>As a convenience to the reader, the relationship between <termref def="dt-typed-value">typed value</termref> and
 <termref def="dt-string-value">string value</termref> for various kinds of nodes is summarized and illustrated
 by examples below.</p>

<olist><item><p>For text and document nodes, the typed value of the node is the same as its
string value, as an instance of  the type <code>xs:untypedAtomic</code>. The
string value of a document node is formed by concatenating the string
values of all its descendant text nodes, in <termref def="dt-document-order">document
order</termref>.</p></item><item><p>The typed value of a comment<phrase role="xpath">, namespace,</phrase> or processing instruction node is the same as its string value. It is an instance of the type <code>xs:string</code>.</p></item><item><p>The typed value of an attribute node with
the <termref def="dt-type-annotation">type annotation</termref> <code>xs:anySimpleType</code> or <code>xs:untypedAtomic</code> is the same as its
string value, as an instance of <code>xs:untypedAtomic</code>. The
typed value of an attribute node with any other type annotation is
derived from its string value and type annotation using the lexical-to-value-space mapping defined in <bibref ref="XMLSchema"/> Part 2 for
the relevant type.</p><p>Example: A1 is an attribute
having string value <code>"3.14E-2"</code> and type annotation
<code>xs:double</code>.  The typed value of A1 is the
<code>xs:double</code> value whose lexical representation is
<code>3.14E-2</code>. </p><p>Example: A2 is an attribute with type
annotation <code>xs:IDREFS</code>, which is a list datatype whose item type is the atomic datatype <code>xs:IDREF</code>. Its string value is
"<code>bar baz faz</code>". The typed value of A2 is a sequence of
three atomic values ("<code>bar</code>", "<code>baz</code>",
"<code>faz</code>"), each of type <code>xs:IDREF</code>. The typed
value of a node is never treated as an instance of a named list
type. Instead, if the type annotation of a node is a list type (such
as <code>xs:IDREFS</code>), its typed value is treated as a sequence
of the atomic type from which it is derived (such as
<code>xs:IDREF</code>).</p></item><item><p>For an element node, the
relationship between typed value and string value depends on the
node's <termref def="dt-type-annotation">type annotation</termref>, as follows:</p><olist>

<item>

<p>If the type annotation is <code>xs:untyped</code> or <code>xs:anySimpleType</code> or
denotes a complex type with mixed content (including <code>xs:anyType</code>), then the typed value of the
node is equal to its string value, as an instance of
<code>xs:untypedAtomic</code>.  However, if the <code>nilled</code> 
property of the node is <code>true</code>, then its typed value is the empty sequence.</p>



<p>Example: E1 is an element node
having type annotation <code>xs:untyped</code> and string value
"<code>1999-05-31</code>". The typed value of E1 is
"<code>1999-05-31</code>", as an instance of
<code>xs:untypedAtomic</code>.</p>


<p>Example: E2 is an element node
with the type annotation <code>formula</code>, which is a complex type
with mixed content. The content of E2 consists of the character
"<code>H</code>", a child element named <code>subscript</code> with
string value "<code>2</code>", and the character "<code>O</code>". The
typed value of E2 is "<code>H2O</code>" as an instance of
<code>xs:untypedAtomic</code>.</p></item>

<item><p>If the type
annotation denotes a simple type or a complex type with simple
content, then the typed value of the node is derived from its string
value and its type annotation in a way that is consistent with schema
validation. However, if the <code>nilled</code> 
property of the node is <code>true</code>, then its typed value is the empty sequence.</p><p>Example: E3 is an element node with the type
annotation <code>cost</code>, which is a complex type that has several
attributes and a simple content type of <code>xs:decimal</code>. The
string value of E3 is "<code>74.95</code>". The typed value of E3 is
<code>74.95</code>, as an instance of
<code>xs:decimal</code>.</p><p>Example: E4 is an element node with the
type annotation <code>hatsizelist</code>, which is a simple type
derived from the atomic type <code>hatsize</code>, which in turn is
derived from <code>xs:integer</code>. The string value of E4 is
"<code>7 8 9</code>". The typed value of E4 is a sequence of three
values (<code>7</code>, <code>8</code>, <code>9</code>), each of type
<code>hatsize</code>.</p><p>Example: E5 is an element node with the type annotation <code>my:integer-or-string</code> which is a union type with member types <code>xs:integer</code> and <code>xs:string</code>. The string value of E5 is "<code>47</code>". The typed value of E5 is <code>47</code> as an <code>xs:integer</code>, since <code>xs:integer</code> is the member type that validated the content of E5. In general, when the type annotation of a node is a union type, the typed value of the node will be an instance of one of the member types of the union.</p><note><p>If an implementation stores only the string value of a node, and the type annotation of the node is a union type, the implementation must be able to deliver the typed value of the node as an instance of the appropriate member type.</p></note></item><item><p>If the type annotation
denotes a complex type with empty content, then the typed value of the
node is the empty sequence and its string value is the zero-length string.</p></item><item><p>If the type annotation
denotes a complex type with element-only content, then the typed value
of the node is undefined. The <code>fn:data</code> function raises a
<termref def="dt-type-error">type error</termref> [err:FOTY0012] when applied to such a node. The string value of such a node is equal to the concatenated string values of all its text node descendants, in document order.</p><p>Example: E6 is an
element node with the type annotation <code>weather</code>, which is a
complex type whose content type specifies
<code>element-only</code>. E6 has two child elements named
<code>temperature</code> and <code>precipitation</code>. The typed
value of E6 is undefined, and the <code>fn:data</code> function
applied to E6 raises an error.
</p></item></olist></item></olist></div3><div3 id="id-sequencetype-syntax"><head>SequenceType Syntax</head><p>Whenever it is necessary to refer to a type in an XPath expression, the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SequenceType" xlink:type="simple">SequenceType</nt> syntax is used.</p> 
		  <scrap headstyle="show"> 
			 <head/> 
			 <prod num="50" id="doc-xpath-SequenceType"><lhs>SequenceType</lhs><rhs>("empty-sequence"  "("  ")")<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ItemType" xlink:type="simple">ItemType</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt>?)</rhs></prod> 
			 <prod num="52" id="doc-xpath-ItemType"><lhs>ItemType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-KindTest" xlink:type="simple">KindTest</nt>  |  ("item"  "("  ")")  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AtomicType" xlink:type="simple">AtomicType</nt></rhs></prod><prod num="51" id="doc-xpath-OccurrenceIndicator"><lhs>OccurrenceIndicator</lhs><rhs>"?"  |  "*"  |  "+"</rhs></prod><prod num="53" id="doc-xpath-AtomicType"><lhs>AtomicType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt></rhs></prod> 
			 <prod num="54" id="doc-xpath-KindTest"><lhs>KindTest</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-DocumentTest" xlink:type="simple">DocumentTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementTest" xlink:type="simple">ElementTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeTest" xlink:type="simple">AttributeTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-PITest" xlink:type="simple">PITest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-CommentTest" xlink:type="simple">CommentTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TextTest" xlink:type="simple">TextTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AnyKindTest" xlink:type="simple">AnyKindTest</nt></rhs></prod> 
			  
			 <prod num="56" id="doc-xpath-DocumentTest"><lhs>DocumentTest</lhs><rhs>"document-node"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementTest" xlink:type="simple">ElementTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>)?  ")"</rhs></prod> 
			  
			  
			 <prod num="64" id="doc-xpath-ElementTest"><lhs>ElementTest</lhs><rhs>"element"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementNameOrWildcard" xlink:type="simple">ElementNameOrWildcard</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TypeName" xlink:type="simple">TypeName</nt>  "?"?)?)?  ")"</rhs></prod> 
		         <prod num="66" id="doc-xpath-SchemaElementTest"><lhs>SchemaElementTest</lhs><rhs>"schema-element"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementDeclaration" xlink:type="simple">ElementDeclaration</nt>  ")"</rhs></prod><prod num="67" id="doc-xpath-ElementDeclaration"><lhs>ElementDeclaration</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementName" xlink:type="simple">ElementName</nt></rhs></prod><prod num="60" id="doc-xpath-AttributeTest"><lhs>AttributeTest</lhs><rhs>"attribute"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttribNameOrWildcard" xlink:type="simple">AttribNameOrWildcard</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TypeName" xlink:type="simple">TypeName</nt>)?)?  ")"</rhs></prod>

                  
                  
                  

                  <prod num="62" id="doc-xpath-SchemaAttributeTest"><lhs>SchemaAttributeTest</lhs><rhs>"schema-attribute"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeDeclaration" xlink:type="simple">AttributeDeclaration</nt>  ")"</rhs></prod><prod num="63" id="doc-xpath-AttributeDeclaration"><lhs>AttributeDeclaration</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeName" xlink:type="simple">AttributeName</nt></rhs></prod><prod num="65" id="doc-xpath-ElementNameOrWildcard"><lhs>ElementNameOrWildcard</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementName" xlink:type="simple">ElementName</nt>  |  "*"</rhs></prod>
                  <prod num="69" id="doc-xpath-ElementName"><lhs>ElementName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt></rhs></prod><prod num="61" id="doc-xpath-AttribNameOrWildcard"><lhs>AttribNameOrWildcard</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeName" xlink:type="simple">AttributeName</nt>  |  "*"</rhs></prod>
                  <prod num="68" id="doc-xpath-AttributeName"><lhs>AttributeName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt></rhs></prod>


                         
			 
			 
			 		 

                             
<prod num="70" id="doc-xpath-TypeName"><lhs>TypeName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt></rhs></prod><prod num="59" id="doc-xpath-PITest"><lhs>PITest</lhs><rhs>"processing-instruction"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-NCName" xlink:type="simple">NCName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-StringLiteral" xlink:type="simple">StringLiteral</nt>)?  ")"</rhs></prod> 
			 <prod num="58" id="doc-xpath-CommentTest"><lhs>CommentTest</lhs><rhs>"comment"  "("  ")"</rhs></prod> 
			 <prod num="57" id="doc-xpath-TextTest"><lhs>TextTest</lhs><rhs>"text"  "("  ")"</rhs></prod>
			 <prod num="55" id="doc-xpath-AnyKindTest"><lhs>AnyKindTest</lhs><rhs>"node"  "("  ")"</rhs></prod></scrap> 
		  


		  <p>With the
exception of the special  type <code>empty-sequence()</code>, a <termref def="dt-sequence-type">sequence type</termref> consists of
an <term>item type</term> that constrains the type of each item in the sequence, and a <term>cardinality</term> that
constrains the number of items in the sequence. Apart from the item type <code>item()</code>, which
permits any kind of item, item types divide into <term>node types</term> (such as
<code>element()</code>) and <term>atomic types</term> (such as <code>xs:integer</code>).</p><p>Item types representing element and attribute nodes may specify the
required <termref def="dt-type-annotation">type annotations</termref> of those nodes, in the form of a <termref def="dt-schema-type">schema type</termref>. Thus
the item type <code>element(*, us:address)</code> denotes any element node whose type
annotation is (or is derived from) the schema type named <code>us:address</code>.</p><p>Here are some examples of <termref def="dt-sequence-type">sequence types</termref> that
		  might be used in XPath expressions:</p>

		  <ulist> 
			 <item> 
				<p> <code>xs:date</code> refers to the built-in atomic schema type named <code>xs:date</code></p> 
			 </item> 
			 <item> 
				<p> <code>attribute()?</code> refers to an optional attribute node</p> 
			 </item> 
			 <item> 
				<p> <code>element()</code> refers to any element node</p> 
			 </item> 
			 <item> 
				<p> <code>element(po:shipto, po:address)</code> refers to an element node that has the name <code>po:shipto</code> and has the type annotation <code>po:address</code> (or a schema type derived from <code>po:address</code>)</p> 
			 </item><item> 
				<p> <code>element(*, po:address)</code> refers to an element node of any name that has the type annotation <code>po:address</code> (or a type derived from <code>po:address</code>)</p> 
			 </item><item><p><code>element(customer)</code> refers to an element node named <code>customer</code> with any type annotation</p></item> 
			  
			 <item><p><code>schema-element(customer)</code> refers to an element node whose name is <code>customer</code> (or is in the substitution group headed by <code>customer</code>) and whose type annotation matches the schema type declared for a <code>customer</code> element in the <termref def="dt-is-elems">in-scope element declarations</termref></p></item><item> 
				<p> <code>node()*</code> refers to a sequence of zero or more nodes of any kind</p> 
			 </item> 
			 <item> 
				<p> <code>item()+</code> refers to a sequence of one or more nodes or atomic values</p> 
			 </item> 
		  </ulist></div3><div3 id="id-sequencetype-matching"> 
		  <head>SequenceType Matching</head> 
		  <p> <termdef id="dt-sequencetype-matching" term="SequenceType matching">During evaluation of an expression, it is sometimes necessary to determine whether a value with a known <termref def="dt-dynamic-type">dynamic type</termref> "matches" an expected  <termref def="dt-sequence-type">sequence type</termref>. This process is known as <term>SequenceType matching</term>.</termdef> For example, an <code>instance of</code> expression returns <code>true</code> if the <termref def="dt-dynamic-type">dynamic type</termref> of a given value matches a given <termref def="dt-sequence-type">sequence type</termref>, or <code>false</code> if
it does not.</p>





<p>QNames appearing in a <termref def="dt-sequence-type">sequence type</termref> have their
		  prefixes expanded to namespace URIs by means of the
		  <termref def="dt-static-namespaces">statically known namespaces</termref> and (where applicable) the
		  <termref def="dt-def-elemtype-ns">default element/type
		  namespace</termref>. 

                  An unprefixed attribute QName is in no namespace. Equality of QNames is defined by the <code>eq</code> operator.</p><p>The rules for <termref def="dt-sequencetype-matching">SequenceType
matching</termref> compare the <termref def="dt-dynamic-type">dynamic type</termref> of a value
with an expected <termref def="dt-sequence-type">sequence type</termref>. These rules are a subset of the formal rules
that match a value with an expected type defined in <bibref ref="XQueryFormalSemantics"/>, because the Formal Semantics must be
able to match values against  types that are not expressible using the
<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SequenceType" xlink:type="simple">SequenceType</nt> syntax.</p>


<p>Some of the rules for <termref def="dt-sequencetype-matching">SequenceType matching</termref> require determining
whether a given schema type is the same as or derived from an expected
schema type. The given schema type may be
"known"   (defined in the <termref def="dt-issd">in-scope schema definitions</termref>), or "unknown"
(not defined in the <termref def="dt-issd">in-scope
schema definitions</termref>).  An unknown schema type might be encountered,
for example, if a source document has been validated using a schema that was not imported into the <termref def="dt-static-context">static context</termref>. In this
case, an implementation is allowed (but is not required) to provide an
<termref def="dt-implementation-dependent">implementation-dependent</termref> mechanism for determining whether the unknown
schema type is derived from the expected schema type. For example, an
implementation might maintain a data dictionary containing information
about type hierarchies.</p><p><termdef term="subtype substitution" id="dt-subtype-substitution">The use of a value whose <termref def="dt-dynamic-type">dynamic type</termref> is derived from an expected type is known as <term>subtype substitution</term>.</termdef> Subtype substitution does not change the actual type of a value. For example, if an <code>xs:integer</code> value is used where an <code>xs:decimal</code> value is expected, the value retains its type as <code>xs:integer</code>.</p><p>The definition of <termref def="dt-sequencetype-matching">SequenceType
matching</termref> relies on a pseudo-function named <code>derives-from(</code><emph>AT, ET</emph><code>)</code>, which takes
an actual simple or complex schema type <emph>AT</emph> and an expected simple or
complex schema type <emph>ET</emph>, and either returns a boolean value or raises a
<termref def="dt-type-error">type error</termref> <errorref class="TY" code="0004"/>. The pseudo-function <code>derives-from</code>
is
defined below and is defined formally in <bibref ref="XQueryFormalSemantics"/>.</p>



		  
		  <ulist><item><p><code>derives-from(</code><emph>AT</emph>, <emph>ET</emph><code>)</code> returns <code>true</code> if <emph>ET</emph> is a known type and any of the following three conditions is true:</p><olist><item><p><emph>AT</emph> is a schema type found in the <termref def="dt-issd">in-scope schema definitions</termref>, and is the same as
<emph>ET</emph> or is derived by restriction or
extension from <emph>ET</emph></p></item><item><p><emph>AT</emph>
is a schema type not found in the <termref def="dt-issd">in-scope schema definitions</termref>, and an <termref def="dt-implementation-dependent">implementation-dependent</termref> mechanism is able
to determine that <emph>AT</emph> is derived by restriction from
<emph>ET</emph></p></item><item><p>There exists some schema type <emph>IT</emph> such that 
       <code>derives-from(</code><emph>IT, ET</emph><code>)</code> and <code>derives-from(</code><emph>AT, IT</emph><code>)</code> are true. 
</p></item></olist></item><item><p><code>derives-from(</code><emph>AT</emph>,
<emph>ET</emph><code>)</code> returns <code>false</code>
if <emph>ET</emph> is a known type and either the first and third or the second and third of the following conditions are true:</p><olist><item><p><emph>AT</emph> is a schema type found in the <termref def="dt-issd">in-scope schema definitions</termref>, and is not the same as
<emph>ET</emph>, and is not derived by restriction or
extension from <emph>ET</emph></p></item><item><p><emph>AT</emph>
is a schema type not found in the <termref def="dt-issd">in-scope schema definitions</termref>, and an <termref def="dt-implementation-dependent">implementation-dependent</termref> mechanism is able
to determine that <emph>AT</emph> is not derived by restriction from
<emph>ET</emph></p></item><item><p>No schema type <emph>IT</emph> exists such that 
       <code>derives-from(</code><emph>IT, ET</emph><code>)</code> and <code>derives-from(</code><emph>AT, IT</emph><code>)</code> are true. 
</p></item></olist></item><item><p><code>derives-from(</code><emph>AT</emph>,
<emph>ET</emph><code>)</code> raises a <termref def="dt-type-error">type error</termref> <errorref class="TY" code="0004"/>
if:</p><olist><item><p><emph>ET</emph> is an unknown type,
or</p></item><item><p><emph>AT</emph> is an unknown type, and the
implementation is not able to determine whether <emph>AT</emph> is
derived by restriction from
<emph>ET</emph>.</p></item></olist></item></ulist>



<p>The rules for <termref def="dt-sequencetype-matching">SequenceType
matching</termref> are given below, with examples (the examples are
for purposes of illustration, and do not cover all possible
cases).</p>
		   
		   
		  <div4 id="id-matching-value"><head>Matching a SequenceType and a Value</head><ulist><item><p>The <termref def="dt-sequence-type">sequence type</termref> <code>empty-sequence()</code> matches a value that is the empty sequence.</p></item><item><p>An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ItemType" xlink:type="simple">ItemType</nt> with no <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt> matches any value that contains exactly one item if the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ItemType" xlink:type="simple">ItemType</nt> matches that item (see <specref ref="id-matching-item"/>).</p></item><item><p>An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ItemType" xlink:type="simple">ItemType</nt> with an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt> matches a value if the number of items in the value matches the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt> and the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ItemType" xlink:type="simple">ItemType</nt> matches each of the items in the value.</p></item></ulist><p>An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt> specifies the number of items in
		  a sequence, as follows:</p> 
		  <ulist> 
			 <item> 
				<p> <code>?</code> matches zero or one items</p> 
			 </item> 
			 <item> 
				<p> <code>*</code> matches zero or more items</p> 
			 </item> 
			 <item> 
				<p> <code>+</code> matches one or more items</p> 
			 </item> 
		  </ulist>

<p>As a consequence of these rules, any <termref def="dt-sequence-type">sequence type</termref> whose
<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt> is <code>*</code> or <code>?</code> matches a
value that is an empty sequence.</p></div4><div4 id="id-matching-item"><head>Matching an ItemType and an
Item</head><ulist><item><p>An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ItemType" xlink:type="simple">ItemType</nt> consisting simply of a QName is
interpreted as an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AtomicType" xlink:type="simple">AtomicType</nt>. An AtomicType
<emph>AtomicType</emph> matches an atomic value whose actual type is
<emph>AT</emph> if <code>derives-from(</code><emph>AT, AtomicType</emph><code>)</code> is <code>true</code>. If a QName that is used as an
                  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AtomicType" xlink:type="simple">AtomicType</nt> is not defined as an atomic
                  type in the <termref def="dt-is-types">in-scope schema types</termref>, a <termref def="dt-static-error">static error</termref> is
                  raised <errorref class="ST" code="0051"/>.</p><p>Example: The
<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AtomicType" xlink:type="simple">AtomicType</nt> <code>xs:decimal</code> matches the value
<code>12.34</code> (a decimal literal). <code>xs:decimal</code> also
matches a value whose type is <code>shoesize</code>, if
<code>shoesize</code> is an atomic type derived by restriction from
<code>xs:decimal</code>.</p>

<note><p> The names of non-atomic
types such as <code>xs:IDREFS</code> are not accepted in this context,
but can often be replaced by an atomic type with an occurrence
indicator, such as
<code>xs:IDREF+</code>.</p></note></item><item><p><code>item()</code> matches
any single item.</p><p>Example: <code>item()</code> matches the atomic
value <code>1</code> or the element
<code>&lt;a/&gt;</code>.</p></item><item><p><code>node()</code>
matches any node.</p></item><item><p><code>text()</code> matches any
text node.</p></item><item><p><code>processing-instruction()</code>
matches any processing-instruction
node.</p></item><item><p><code>processing-instruction(</code><emph>N</emph><code>)</code>
matches any processing-instruction node whose name (called its
"PITarget" in XML) is equal to <emph>N</emph>, where <emph>N</emph> is
an NCName.</p><p>Example:
<code>processing-instruction(xml-stylesheet)</code> matches any
processing instruction whose PITarget is
<code>xml-stylesheet</code>.</p>

<p>For backward compatibility with
                                XPath 1.0, the PITarget of a
                                processing instruction may also be expressed as a
                                string literal, as in this example:
				<code>processing-instruction("xml-stylesheet")</code>.</p></item><item><p><code>comment()</code> matches any comment node.</p></item>

<item><p><code>document-node()</code> matches any document
node.</p></item><item><p><code>document-node(</code><emph>E</emph><code>)</code>
matches any document node that contains exactly one element node, optionally accompanied by one or more comment and processing instruction nodes, if
<emph>E</emph> is an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementTest" xlink:type="simple">ElementTest</nt> or <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt> that matches the element node (see
<specref ref="id-element-test"/> and <specref ref="id-schema-element-test"/>).</p><p>Example:
<code>document-node(element(book))</code> matches a document node
containing
exactly one element node that is matched by the ElementTest
<code>element(book)</code>.</p></item><item><p>An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ItemType" xlink:type="simple">ItemType</nt> that is an
<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementTest" xlink:type="simple">ElementTest</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeTest" xlink:type="simple">AttributeTest</nt>, or <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt> matches an element or
attribute node as described in the following
sections.</p></item></ulist></div4>

<div4 id="id-element-test"><head>Element Test</head><p>An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementTest" xlink:type="simple">ElementTest</nt> is used to match an
element node by its name and/or <termref def="dt-type-annotation">type annotation</termref>. An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementTest" xlink:type="simple">ElementTest</nt> may take any of the following forms. In these forms, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementName" xlink:type="simple">ElementName</nt> need not be present in the <termref def="dt-is-elems">in-scope element declarations</termref>, but  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TypeName" xlink:type="simple">TypeName</nt> must be present in the <termref def="dt-is-types">in-scope schema types</termref> <errorref class="ST" code="0008"/>. Note that <termref def="dt-substitution-group">substitution groups</termref> do not affect the semantics of <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementTest" xlink:type="simple">ElementTest</nt>.</p><olist><item><p><code>element()</code> and

<code>element(*)</code>  match any
single element node, regardless of its name or
type annotation.</p></item><item><p><code>element(</code><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementName" xlink:type="simple">ElementName</nt><code>)</code>
matches any element node whose name is <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementName" xlink:type="simple">ElementName</nt>, regardless of its type annotation or <code>nilled</code> property.</p><p>Example: <code>element(person)</code> matches any element node whose name is <code>person</code>.</p>







</item><item><p><code>element(</code><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementName" xlink:type="simple">ElementName</nt><code>,</code> <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TypeName" xlink:type="simple">TypeName</nt><code>)</code>
matches an element node whose name is <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementName" xlink:type="simple">ElementName</nt> if <code>derives-from(</code><emph>AT</emph>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TypeName" xlink:type="simple">TypeName</nt> <code>)</code> is <code>true</code>, where <emph>AT</emph> is the type annotation of the element node, and the <code>nilled</code> property of the node is <code>false</code>.</p><p>Example: <code>element(person, surgeon)</code> matches a
non-nilled element node whose name is <code>person</code> and whose
type annotation is <code>surgeon</code> (or is derived from <code>surgeon</code>). </p></item><item><p><code>element(</code><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementName" xlink:type="simple">ElementName</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TypeName" xlink:type="simple">TypeName</nt><code> ?)</code>
matches an element node whose name is <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementName" xlink:type="simple">ElementName</nt> if <code>derives-from(</code><emph>AT</emph>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TypeName" xlink:type="simple">TypeName</nt><code>)</code> is <code>true</code>, where <emph>AT</emph> is the type annotation of the element node. The <code>nilled</code> property of the node may be either <code>true</code> or  <code>false</code>.</p><p>Example: <code>element(person, surgeon?)</code> matches a nilled or non-nilled element node whose name is <code>person</code> and whose type
annotation is <code>surgeon</code> (or is derived from <code>surgeon</code>).</p></item>



<item><p><code>element(*,
</code><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TypeName" xlink:type="simple">TypeName</nt><code>)</code> matches an element
node regardless of its name, if
<code>derives-from(</code><emph>AT</emph>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TypeName" xlink:type="simple">TypeName</nt> <code>)</code> is
<code>true</code>, where <emph>AT</emph> is the type annotation of the element node, and the <code>nilled</code> property of the node is <code>false</code>.</p>

<p>Example: <code>element(*, surgeon)</code>
matches any non-nilled element node whose type annotation is
<code>surgeon</code> (or is derived from <code>surgeon</code>), regardless of its name.</p></item><item><p><code>element(*,
</code><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TypeName" xlink:type="simple">TypeName</nt><code> ?)</code> matches an element
node regardless of its name, if
<code>derives-from(</code><emph>AT</emph>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TypeName" xlink:type="simple">TypeName</nt> <code>)</code> is
<code>true</code>, where <emph>AT</emph> is the type annotation of the element node. The <code>nilled</code> property of the node may be either <code>true</code> or  <code>false</code>.</p>

<p>Example: <code>element(*, surgeon?)</code>
matches any nilled or non-nilled element node whose type annotation is
<code>surgeon</code> (or is derived from <code>surgeon</code>), regardless of its name.</p></item></olist>

</div4>



<div4 id="id-schema-element-test"><head>Schema Element Test</head><p>A <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt> matches an element node against a corresponding
element declaration found in the <termref def="dt-is-elems">in-scope element declarations</termref>.
It takes the following form:</p><p><code>schema-element(</code><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementName" xlink:type="simple">ElementName</nt><code>)</code></p><p>If the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementName" xlink:type="simple">ElementName</nt> specified in the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt> is not found in the <termref def="dt-is-elems">in-scope element declarations</termref>, a <termref def="dt-static-error">static error</termref> is raised
<errorref class="ST" code="0008"/>.</p><p>A <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt> matches a candidate element node if all three of the
following conditions are satisfied:</p><olist><item><p>The name of the candidate node matches the specified <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementName" xlink:type="simple">ElementName</nt> or matches the name of an element in a
<termref def="dt-substitution-group">substitution group</termref> headed by an element named <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementName" xlink:type="simple">ElementName</nt>.</p></item><item><p><code>derives-from(</code><emph>AT, ET</emph><code>)</code> is <code>true</code>, where <emph>AT</emph> is the type annotation of the candidate node and <emph>ET</emph> is the schema type declared for element <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementName" xlink:type="simple">ElementName</nt> in the <termref def="dt-is-elems">in-scope element declarations</termref>.</p></item><item><p>If the element declaration for 
<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementName" xlink:type="simple">ElementName</nt> in the <termref def="dt-is-elems">in-scope element declarations</termref> is not <code>nillable</code>, then the 
<code>nilled</code> property of the candidate node is <code>false</code>.</p></item></olist><p>Example: The <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt> <code>schema-element(customer)</code> matches a candidate element node if <code>customer</code> is a top-level element declaration in the <termref def="dt-is-elems">in-scope element declarations</termref>, the name of the candidate node is <code>customer</code> or is in a <termref def="dt-substitution-group">substitution group</termref> headed by <code>customer</code>, the type annotation of the candidate node  is the same as or derived from the schema type declared for the <code>customer</code> element, and either the candidate node is not <code>nilled</code> or <code>customer</code> is declared to be <code>nillable</code>.</p></div4><div4 id="id-attribute-test"><head>Attribute Test</head>




<p>An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeTest" xlink:type="simple">AttributeTest</nt> is used to match an
attribute node by its name and/or <termref def="dt-type-annotation">type annotation</termref>. An <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeTest" xlink:type="simple">AttributeTest</nt> any take any of the following forms. In these forms, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeName" xlink:type="simple">AttributeName</nt> need not be present in the <termref def="dt-is-attrs">in-scope attribute declarations</termref>, but  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TypeName" xlink:type="simple">TypeName</nt> must be present in the <termref def="dt-is-types">in-scope schema types</termref> <errorref class="ST" code="0008"/>.</p><olist>

<item><p><code>attribute()</code> and <code>attribute(*)</code> match any single attribute node,
regardless of its name or type annotation.</p></item>

<item><p><code>attribute(</code><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeName" xlink:type="simple">AttributeName</nt><code>)</code>
matches any attribute node whose name is <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeName" xlink:type="simple">AttributeName</nt>, regardless of its type annotation.</p><p>Example: <code>attribute(price)</code>
matches any attribute node whose name is <code>price</code>.</p></item><item><p><code>attribute(</code><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeName" xlink:type="simple">AttributeName</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TypeName" xlink:type="simple">TypeName</nt><code>)</code>
matches an attribute node whose name is <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeName" xlink:type="simple">AttributeName</nt> if <code>derives-from(</code><emph>AT</emph>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TypeName" xlink:type="simple">TypeName</nt> <code>)</code> is <code>true</code>, where <emph>AT</emph> is the type annotation of the attribute node.</p>

<p>Example: <code>attribute(price, currency)</code> matches an
attribute node whose name is <code>price</code> and whose type
annotation is
<code>currency</code> (or is derived from <code>currency</code>).</p></item><item><p><code>attribute(*,
</code><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TypeName" xlink:type="simple">TypeName</nt><code>)</code> matches an attribute
node regardless of its name, if
<code>derives-from(</code><emph>AT</emph>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TypeName" xlink:type="simple">TypeName</nt><code>)</code> is
<code>true</code>, where <emph>AT</emph> is the type annotation of the attribute node.</p><p>Example:
<code>attribute(*, currency)</code> matches any attribute node whose
type annotation is <code>currency</code> (or is derived from <code>currency</code>), regardless of its
name.</p></item>

</olist></div4><div4 id="id-schema-attribute-test"><head>Schema Attribute Test</head><p>A <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt> matches an attribute node against a corresponding
attribute declaration found in the <termref def="dt-is-attrs">in-scope attribute declarations</termref>.
It takes the following form:</p><p><code>schema-attribute(</code><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeName" xlink:type="simple">AttributeName</nt><code>)</code></p><p>If the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeName" xlink:type="simple">AttributeName</nt> specified in the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt> is not found in the <termref def="dt-is-attrs">in-scope attribute declarations</termref>, a <termref def="dt-static-error">static error</termref> is raised
<errorref class="ST" code="0008"/>.</p><p>A <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt> matches a candidate attribute node if both of the
following conditions are satisfied:</p><olist><item><p>The name of the candidate node matches the specified <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeName" xlink:type="simple">AttributeName</nt>.</p></item><item><p><code>derives-from(</code><emph>AT, ET</emph><code>)</code> is <code>true</code>, where <emph>AT</emph> is the type annotation of the candidate node and <emph>ET</emph> is the schema type declared for attribute <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeName" xlink:type="simple">AttributeName</nt> in the <termref def="dt-is-attrs">in-scope attribute declarations</termref>.</p></item></olist><p>Example: The <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt> <code>schema-attribute(color)</code> matches a candidate attribute node if <code>color</code> is a top-level attribute declaration in the <termref def="dt-is-attrs">in-scope attribute declarations</termref>, the name of the candidate node is <code>color</code>, and the type annotation of the candidate node  is the same as or derived from the schema type declared for the <code>color</code> attribute.</p></div4></div3>
		 
		
		 
	 </div2> 

<div2 id="comments"><head>Comments</head><scrap headstyle="suppress"><head/><prod num="77" id="doc-xpath-Comment"><lhs>Comment</lhs><rhs>"(:"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-CommentContents" xlink:type="simple">CommentContents</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Comment" xlink:type="simple">Comment</nt>)*  ":)"</rhs></prod><prod num="82" id="doc-xpath-CommentContents"><lhs>CommentContents</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Char" xlink:type="simple">Char</nt>+ - (Char* ('(:' | ':)') Char*))</rhs></prod></scrap><p>Comments may be used to provide informative annotation for <phrase role="xpath">an expression</phrase>. Comments are lexical constructs only, and do not affect  <phrase role="xpath">expression</phrase> processing.</p><p>Comments are strings, delimited by the symbols <code>(:</code> and <code>:)</code>. Comments may be nested.</p>
		
		 
		<p>A comment may be used anywhere <termref def="IgnorableWhitespace">ignorable whitespace</termref> is allowed (see <specref ref="DefaultWhitespaceHandling"/>).</p><p>The following is an example of a comment:</p> 
		<eg xml:space="preserve">(: Houston, we have a problem :)</eg></div2></div1>  
  
<div1 id="id-expressions">
 <head>Expressions</head>  
  <p>This section discusses each of the basic kinds of expression. Each kind of expression has a name such as <code>PathExpr</code>, which is introduced on the left side of the grammar production that defines the expression. Since XPath is a composable language, each kind of expression is defined in terms of other expressions whose operators have a higher precedence. In this way, the precedence of operators is represented explicitly in the grammar.</p><p>The order in which expressions are discussed in this document does not reflect the order of operator precedence. In general, this document introduces the simplest kinds of expressions first, followed by more complex expressions.  For the complete grammar, see Appendix [<specref ref="nt-bnf"/>].</p><p> <phrase role="xpath">The highest-level symbol in the XPath grammar is XPath.</phrase> </p><scrap headstyle="show"> 
		<head/> <prod num="1" id="doc-xpath-XPath"><lhs>XPath</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Expr" xlink:type="simple">Expr</nt></rhs></prod><prod num="2" id="doc-xpath-Expr"><lhs>Expr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs></prod> 
	 <prod num="3" id="doc-xpath-ExprSingle"><lhs>ExprSingle</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ForExpr" xlink:type="simple">ForExpr</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-QuantifiedExpr" xlink:type="simple">QuantifiedExpr</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-IfExpr" xlink:type="simple">IfExpr</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-OrExpr" xlink:type="simple">OrExpr</nt></rhs></prod></scrap><p>The XPath operator that has lowest precedence is the <termref def="dt-comma-operator">comma operator</termref>, which is used to combine two operands to form a sequence. As shown in the grammar, a general expression (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Expr" xlink:type="simple">Expr</nt>) can consist of multiple <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt> operands, separated by commas. The name <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt> denotes an expression that does not contain a top-level <termref def="dt-comma-operator">comma operator</termref> (despite its name, an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt> may evaluate to a sequence containing more than one item.)</p><p>The symbol <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt> is used in various places in the grammar where an expression is not allowed to contain a top-level comma. For example, each of the arguments of a function call must be an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>, because commas are used to separate the arguments of a function call.</p><p>After the comma, the expressions that have next lowest precedence are  <phrase role="xpath"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ForExpr" xlink:type="simple">ForExpr</nt>, </phrase><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-QuantifiedExpr" xlink:type="simple">QuantifiedExpr</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-IfExpr" xlink:type="simple">IfExpr</nt>, and <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-OrExpr" xlink:type="simple">OrExpr</nt>. Each of these expressions is described in a separate section of this document.</p> 
	 <div2 id="id-primary-expressions"> 
	 <head>Primary Expressions</head> 
	 <p> <termdef id="dt-primary-expression" term="primary expression"><term>Primary expressions</term> are the basic primitives of the
	 language. They include literals, variable references,  context item expressions, and function calls. A primary expression may also be created by enclosing any expression in parentheses, which is sometimes helpful in controlling the precedence of operators.</termdef>  </p> 
	 <scrap headstyle="show"> 
		<head/> <prod num="41" id="doc-xpath-PrimaryExpr"><lhs>PrimaryExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Literal" xlink:type="simple">Literal</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-VarRef" xlink:type="simple">VarRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ParenthesizedExpr" xlink:type="simple">ParenthesizedExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ContextItemExpr" xlink:type="simple">ContextItemExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-FunctionCall" xlink:type="simple">FunctionCall</nt></rhs></prod> 
	 </scrap> 
	 <div3 id="id-literals"> 
		<head>Literals</head> 
		<p> <termdef id="dt-literal" term="literal">A <term>literal</term> is a direct syntactic representation of an
		atomic value.</termdef> XPath supports two kinds of literals: numeric literals and
		string literals.</p> 
		<scrap headstyle="show"> 
		  <head/> <prod num="42" id="doc-xpath-Literal"><lhs>Literal</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-NumericLiteral" xlink:type="simple">NumericLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-StringLiteral" xlink:type="simple">StringLiteral</nt></rhs></prod> 
		  <prod num="43" id="doc-xpath-NumericLiteral"><lhs>NumericLiteral</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-IntegerLiteral" xlink:type="simple">IntegerLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-DecimalLiteral" xlink:type="simple">DecimalLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-DoubleLiteral" xlink:type="simple">DoubleLiteral</nt></rhs></prod> 
		  <prod num="71" id="doc-xpath-IntegerLiteral"><lhs>IntegerLiteral</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Digits" xlink:type="simple">Digits</nt></rhs></prod> 
		  <prod num="72" id="doc-xpath-DecimalLiteral"><lhs>DecimalLiteral</lhs><rhs>("."  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Digits" xlink:type="simple">Digits</nt>)  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Digits" xlink:type="simple">Digits</nt>  "."  [0-9]*)</rhs></prod> 
		  <prod num="73" id="doc-xpath-DoubleLiteral"><lhs>DoubleLiteral</lhs><rhs>(("."  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Digits" xlink:type="simple">Digits</nt>)  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Digits" xlink:type="simple">Digits</nt>  ("."  [0-9]*)?))  [eE]  [+-]?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Digits" xlink:type="simple">Digits</nt></rhs></prod> 
		  <prod num="74" id="doc-xpath-StringLiteral"><lhs>StringLiteral</lhs><rhs>('"'  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-EscapeQuot" xlink:type="simple">EscapeQuot</nt>  |  [^"])*  '"')  |  ("'"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-EscapeApos" xlink:type="simple">EscapeApos</nt>  |  [^'])*  "'")</rhs></prod> 
		<prod num="75" id="doc-xpath-EscapeQuot"><lhs>EscapeQuot</lhs><rhs>'""'</rhs></prod><prod num="76" id="doc-xpath-EscapeApos"><lhs>EscapeApos</lhs><rhs>"''"</rhs></prod><prod num="81" id="doc-xpath-Digits"><lhs>Digits</lhs><rhs>[0-9]+</rhs></prod></scrap> 
		<p> The value of a <term>numeric literal</term> containing no "<code>.</code>" and no <code>e</code> or <code>E</code> character is  an atomic value of type <code>xs:integer</code>. The value of a numeric literal containing "<code>.</code>" but no <code>e</code> or <code>E</code> character is an atomic value of type <code>xs:decimal</code>. The value of a numeric literal containing an <code>e</code> or <code>E</code> character is an atomic value of type <code>xs:double</code>. The value of the numeric literal is determined by casting it to the 
appropriate type according to the rules for casting from <code>xs:untypedAtomic</code> 
to a numeric type as specified in <xspecref spec="FO" ref="casting-from-strings"/>.</p><p>The value of a <term>string literal</term> is an atomic value whose  type is <code>xs:string</code> and whose value is the string denoted by the characters between the
		delimiting apostrophes or quotation marks. If the literal is delimited by apostrophes, two adjacent apostrophes within the literal are interpreted as a single apostrophe. Similarly, if the literal is delimited by quotation marks, two adjacent quotation marks within the literal are interpreted as one quotation mark.</p> 
		 
		<p>Here are some examples of literal expressions:</p> 
		<ulist> 
		  <item> 
			 <p> <code role="parse-test">"12.5"</code> denotes the string containing the characters '1', '2', '.', and
			 '5'.</p> 
		  </item> 
		  <item> 
			 <p> <code role="parse-test">12</code> denotes the <code>xs:integer</code> value twelve.</p> 
		  </item> 
		  <item> 
			 <p> <code role="parse-test">12.5</code> denotes the <code>xs:decimal</code> value twelve and one half.</p> 
		  </item> 
		  <item> 
			 <p> <code role="parse-test">125E2</code> denotes the <code>xs:double</code> value twelve thousand, five hundred.</p> 
		  </item><item><p><code>"He said, ""I don't like it."""</code> denotes a string containing two quotation marks and one apostrophe.</p><note role="xpath"><p>When XPath expressions are embedded in contexts where quotation 
marks have special significance, such as inside XML attributes, additional
escaping may be needed.</p></note></item> 
		</ulist> 
		<p>The <code>xs:boolean</code> values <code>true</code> and <code>false</code> can be represented by calls to the <termref def="dt-built-in-function">built-in functions</termref> <code>fn:true()</code> and <code>fn:false()</code>, respectively.</p><p>Values of other atomic types can be constructed by
		calling the <termref def="dt-constructor-function">constructor function</termref> for the given type. The constructor functions for XML Schema
		built-in types are defined in <bibref ref="FunctionsAndOperators"/>. In general, the name of a constructor function for a given type is the same as the name of the type (including its namespace). For
		example:</p> 
		<ulist> 
		   
		  <item> 
			 <p> <code role="parse-test">xs:integer("12")</code> returns the integer value twelve.</p> 
		  </item> 
		  <item> 
			 <p> <code role="parse-test">xs:date("2001-08-25")</code> returns an item whose type is <code>xs:date</code> and whose value represents the date 25th August 2001.</p> 
		  </item><item><p><code>xs:dayTimeDuration("PT5H")</code> returns an item whose type is <code>xs:dayTimeDuration</code> and whose value represents a duration of five hours.</p> </item> 
		</ulist> 
		<p>Constructor functions can also be used to create special values that have no literal representation, as in the following examples:<ulist><item><p><code>xs:float("NaN")</code> returns the special floating-point value, "Not a Number."</p></item><item><p><code>xs:double("INF")</code> returns the special double-precision value, "positive infinity."</p></item></ulist></p><p>It is also possible to construct values of various types by using a <code>cast</code> expression. For example:</p> 
		<ulist> 
		  <item> 
			 <p> <code role="parse-test">9 cast as
                        hatsize</code> returns the atomic value <code>9</code> 
			 whose type is  <code>hatsize</code>.</p> 
		  </item> 
		</ulist> 
	 </div3> 
	 <div3 id="id-variables"> 
		<head>Variable References</head> 
		<scrap headstyle="show"> 
		<head/>  
	 <prod num="44" id="doc-xpath-VarRef"><lhs>VarRef</lhs><rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-VarName" xlink:type="simple">VarName</nt></rhs></prod><prod num="45" id="doc-xpath-VarName"><lhs>VarName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt></rhs></prod></scrap><p> <termdef id="dt-variable-reference" term="variable reference">A <term>variable reference</term> is a QName preceded by a $-sign.</termdef> Two variable references are equivalent if their local names are the same and their namespace prefixes are bound to the same namespace URI in the <termref def="dt-static-namespaces">statically known namespaces</termref>. An unprefixed variable reference is in no namespace.</p><p>Every variable reference must match a name in the <termref def="dt-in-scope-variables">in-scope variables</termref>, which include variables from the following sources:<olist><item><p>The <termref def="dt-in-scope-variables">in-scope variables</termref> may be augmented by <termref def="dt-implementation-defined">implementation-defined</termref> variables.</p></item><item><p>A variable may be bound by an XPath expression. <phrase role="xpath">The kinds of expressions that can bind variables are <code>for</code> expressions (<specref ref="id-for-expressions"/>) and quantified expressions (<specref ref="id-quantified-expressions"/>).</phrase></p></item></olist></p> 
		 
		 
		 
		 
	 <p>Every variable binding has a static scope. The scope defines where
references to the variable can validly occur.

It is a <termref def="dt-static-error">static error</termref> <errorref class="ST" code="0008"/> to reference a variable that is not in scope. If a variable is bound in the <termref def="dt-static-context">static context</termref> for an expression, that variable is in scope for the entire expression.</p><p>If a variable reference matches two or more variable bindings that are in scope,
then the reference is taken as referring to the
inner binding, that is, the one whose scope is smaller.

At evaluation time, the value of a variable reference is the value of
the expression to which the relevant variable is bound.

The scope of a variable binding is defined separately for each kind of
expression that can bind variables.</p></div3> 
	 <div3 id="id-paren-expressions"> 
		<head>Parenthesized Expressions</head> 
		<scrap headstyle="show"> 
<head/> <prod num="46" id="doc-xpath-ParenthesizedExpr"><lhs>ParenthesizedExpr</lhs><rhs>"("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Expr" xlink:type="simple">Expr</nt>?  ")"</rhs></prod> 
 
 
</scrap><p>Parentheses may be used to enforce a particular evaluation order in
		expressions that contain multiple operators. For example, the expression <code role="parse-test">(2 + 4)
		    * 5</code> evaluates to thirty, since the parenthesized expression <code role="parse-test">(2 + 4)</code> is evaluated first and its result is multiplied by five. Without
			 parentheses, the expression <code role="parse-test">2 + 4 * 5</code> evaluates to twenty-two, because the multiplication operator has higher
			 precedence than the addition operator.</p> 
		 
		<p>Empty parentheses are used to denote an empty sequence, as
		described in <specref ref="construct_seq"/>.</p> 
	 </div3> 

         <div3 id="id-context-item-expression">
              <head>Context Item Expression</head>
              <scrap headstyle="show"> <head/><prod num="47" id="doc-xpath-ContextItemExpr"><lhs>ContextItemExpr</lhs><rhs>"."</rhs></prod> </scrap>

              <p>A <term>context item expression</term> evaluates to
              the <termref def="dt-context-item">context item</termref>, which may be either a node (as in the
              expression
              <code>fn:doc("bib.xml")/books/book[fn:count(./author)&gt;1]</code>)
              or an atomic value (as in the expression <code>(1 to
              100)[. mod 5 eq 0]</code>).</p><p>If the <termref def="dt-context-item">context item</termref> is undefined, a context item expression raises a dynamic error <errorref class="DY" code="0002"/>.</p>

         </div3>

	 <div3 id="id-function-calls"> 
		<head>Function Calls</head> 
		<p> <termdef term="built-in function" id="dt-built-in-function">The <term>built-in functions</term> supported by XPath are defined in <bibref ref="FunctionsAndOperators"/>.</termdef> <phrase role="xpath">Additional functions may be provided in
		the <termref def="dt-static-context">static
		context</termref>. XPath per se does not provide a way
		to declare functions, but a host language may provide
		such a mechanism.</phrase>

		</p><scrap headstyle="show"> 
		  <head/> 
		  <prod num="48" id="doc-xpath-FunctionCall"><lhs>FunctionCall</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt>  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>)*)?  ")"</rhs></prod> 
		</scrap><p>A <term>function call</term> consists of a QName followed by a
		parenthesized list of zero or more expressions, called
		<term>arguments</term>. If the QName in the function
		call has no namespace prefix, it is considered to be
		in the <termref def="dt-def-fn-ns">default function
		namespace.</termref></p><p> If the <termref def="dt-expanded-qname">expanded QName</termref> and number of arguments in a function call do not match the name and arity
		of a <termref def="dt-function-signature">function signature</termref> in the <termref def="dt-static-context">static context</termref>,  a <termref def="dt-static-error">static error</termref> is raised <errorref class="ST" code="0017"/>.</p> 
		 
		 

		


		<p>A function call is evaluated as follows:</p> 
		<olist> 
		  <item> 
			 <p>Argument expressions are evaluated, producing argument
			 values. The order of argument evaluation is <termref def="dt-implementation-dependent">implementation-dependent</termref> and a function need not evaluate an argument if the function can evaluate its body without evaluating that argument.</p> 
		  </item> 
		  <item> 
			 <p>Each argument value is converted by applying the
			 function conversion rules listed below.</p> 
		  </item><item role="xpath"><p>The function is evaluated using the converted argument values. The result is either an instance of the function's declared return type  or a dynamic error. The <termref def="dt-dynamic-type">dynamic type</termref> of a function result may be a type that is derived from the declared return type. Errors raised by functions are defined in <bibref ref="FunctionsAndOperators"/>.</p></item> 
		   
		</olist> 
		<p>The <term>function conversion rules</term> are used to convert an
		argument value  to its expected type; that is, to
		the declared type of the function <phrase role="xpath">parameter.</phrase> The expected type is expressed as a <termref def="dt-sequence-type">sequence type</termref>. The function conversion rules are applied to a given value
		as follows:</p> 
		<ulist><item role="xpath"><p>If <termref def="dt-xpath-compat-mode">XPath 1.0
		compatibility mode</termref> is <code>true</code> and an
		argument is not of the expected type, then the
		following conversions are
		applied sequentially to the argument value V:</p><olist><item><p>If the expected type calls for a single item or optional single item (examples: <code>xs:string</code>, <code>xs:string?</code>, <code>xs:untypedAtomic</code>, <code>xs:untypedAtomic?</code>, <code>node()</code>, <code>node()?</code>, <code>item()</code>, <code>item()?</code>), then the value V is effectively replaced by V[1].</p></item><item><p>If the expected type is
		<code>xs:string</code> or <code>xs:string?</code>,
		then the  value <code>V</code> is effectively
		replaced by
		<code>fn:string(V)</code>.</p></item><item><p>If
		the expected type is <code>xs:double</code> or <code>xs:double?</code>, then the value <code>V</code> is effectively replaced by
		<code>fn:number(V)</code>.</p></item></olist></item><item><p>If the
		expected type is a sequence of an atomic type
		(possibly with an occurrence indicator <code>*</code>,
		<code>+</code>, or <code>?</code>), the following
		conversions are applied:</p><olist><item><p><termref def="dt-atomization">Atomization</termref> is applied
		to the given value, resulting in a sequence of atomic
		values.</p></item><item><p>Each item in the atomic
		sequence that is of type
		<code>xs:untypedAtomic</code> is cast to the expected
		atomic type. For <termref def="dt-built-in-function">built-in functions</termref> where the expected type is specified as <termref def="dt-numeric">numeric</termref>, arguments of type <code>xs:untypedAtomic</code> are cast to <code>xs:double</code>.</p></item><item><p>For each <termref def="dt-numeric">numeric</termref> item
		in the atomic sequence that can be
		<termref def="dt-type-promotion">promoted</termref> to the expected atomic type
		using numeric promotion as described in <specref ref="promotion"/>, the promotion is
		done.</p></item><item><p>For each item of type <code>xs:anyURI</code>
		in the atomic sequence that can be
		<termref def="dt-type-promotion">promoted</termref> to the expected atomic type
		using URI promotion as described in <specref ref="promotion"/>, the promotion is
		done.</p></item></olist></item><item><p> If, after the
		above conversions, the resulting value does not match
		the expected type according to the rules for <termref def="dt-sequencetype-matching">SequenceType
		Matching</termref>, a <termref def="dt-type-error">type error</termref> is
		raised <errorref class="TY" code="0004"/>.
		
		Note that the rules for <termref def="dt-sequencetype-matching">SequenceType
		Matching</termref> permit a value of a derived type to
		be substituted for a value of its base
		type. </p></item></ulist>

		 
<p>Since the arguments of a function call are separated by commas, any
argument expression that contains a top-level <termref def="dt-comma-operator">comma operator</termref> must be
enclosed in parentheses. Here are some illustrative examples of
function calls:</p>
		<ulist> 
		  <item> 
			 <p> <code role="parse-test">my:three-argument-function(1,
			2, 3)</code> denotes a function call with three arguments.</p> 
		  </item> 
		  <item> 
			 <p> <code role="parse-test">my:two-argument-function((1,
			2), 3)</code> denotes a function call with two arguments, the first of which is a
			 sequence of two values.</p> 
		  </item> 
		  <item> 
			 <p> <code role="parse-test">my:two-argument-function(1,
			())</code> denotes a function call with two arguments, the second of which is an
			 empty sequence.</p> 
		  </item> 
		  <item> 
			 <p> <code role="parse-test">my:one-argument-function((1, 2,
			3))</code> denotes a function call with one argument that is a sequence of three
			 values. </p> 
		  </item> 
		<item> 
			 <p> <code role="parse-test">my:one-argument-function(( ))</code> denotes a function call with one argument that is an empty sequence.</p> 
		  </item><item> 
			 <p> <code role="parse-test">my:zero-argument-function( )</code> denotes a function call with zero arguments.</p> 
		  </item></ulist> 
	 </div3> 
	  
  </div2> 
  <div2 id="id-path-expressions"> 
	 <head>Path Expressions</head> 
	  
	 <scrap headstyle="show"> 
		<head/> <prod num="25" id="doc-xpath-PathExpr"><lhs>PathExpr</lhs><rhs>("/"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>?)<br/>|  ("//"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>)<br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt></rhs></prod><prod num="26" id="doc-xpath-RelativePathExpr"><lhs>RelativePathExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-StepExpr" xlink:type="simple">StepExpr</nt>  (("/"  |  "//")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-StepExpr" xlink:type="simple">StepExpr</nt>)*</rhs></prod> 
		   
	 </scrap> 
	 <p><termdef id="dt-path-expression" term="path expression">A <term>path expression</term> can be used to locate nodes
	 within trees. A path expression consists of a series of one or more
	 <termref def="dt-step">steps</termref>, separated by "<code>/</code>" or
	 "<code>//</code>", and optionally beginning with
	 "<code>/</code>" or "<code>//</code>".</termdef> An initial
	 "<code>/</code>" or "<code>//</code>" is an abbreviation for
	 one or more initial steps that are implicitly added to the
	 beginning of the path expression, as described below.</p><p>A
	 path expression consisting of a single step is evaluated as
	 described in <specref ref="id-steps"/>.</p><p>A "<code>/</code>"
	 at the beginning of a path expression is an abbreviation for
	 the initial step <code>fn:root(self::node()) treat as
	 document-node()/</code> (however, if the 
	 "<code>/</code>" is the entire path expression, the trailing "<code>/</code>" is omitted from the expansion.) The effect
	 of this initial step is to begin the path at the root node of
	 the tree that contains the context node. If the context item
	 is not a node, a <termref def="dt-type-error">type
	 error</termref> is raised <errorref class="TY" code="0020"/>. At
	 evaluation time, if the root node above the context node is
	 not a document node, a <termref def="dt-dynamic-error">dynamic error</termref> is
	 raised <errorref class="DY" code="0050"/>.</p>

	 <p>A "<code>//</code>" at the beginning of a path expression
	 is an abbreviation for the initial steps
	 <code>fn:root(self::node()) treat as
	 document-node()/descendant-or-self::node()/</code> (however, "<code>//</code>" by itself is not a valid path expression <errorref class="ST" code="0003"/>.)  The
	 effect of these initial steps is to establish an initial node
	 sequence that contains the root of the tree in which the
	 context node is found, plus all nodes descended from this
	 root.
	 This node sequence is used as the input to subsequent steps
	 in the path expression. If the context item is not a node, a
	 <termref def="dt-type-error">type error</termref> is
	 raised <errorref class="TY" code="0020"/>. At evaluation time, if the
	 root node above the context node is not a document node, a
	 <termref def="dt-dynamic-error">dynamic error</termref> is
	 raised <errorref class="DY" code="0050"/>.</p>
	  
	 <note><p>The descendants of a node do not include attribute
	 nodes <phrase role="xpath"> or namespace nodes</phrase>.</p></note><p>Each
	 non-initial occurrence of "<code>//</code>" in a path expression is
	 expanded as described in <specref ref="abbrev"/>, leaving a
	 sequence of steps separated by "<code>/</code>". This sequence
	 of steps is then evaluated from left to right. Each operation
	 <code role="parse-test">E1/E2</code> is evaluated as follows:
	 Expression <code role="parse-test">E1</code> is evaluated,
	 and if the result is not a (possibly empty) sequence of nodes, a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0019"/>. Each node resulting from the evaluation of
	 <code>E1</code> then serves in turn to provide an <term>inner
	 focus</term> for an evaluation of <code>E2</code>, as
	 described in <specref ref="eval_context"/>. The sequences resulting from all the evaluations of <code>E2</code> are combined as follows:</p><olist><item><p>If every evaluation of <code>E2</code> returns a (possibly empty) sequence of 
nodes, these sequences are combined, and duplicate nodes are eliminated 
based on node identity. <phrase role="xpath">The resulting node sequence is returned in <termref def="dt-document-order">document
	 order</termref>.</phrase> </p></item><item><p>If every evaluation of <code>E2</code> returns a (possibly empty) sequence of 
atomic values, these sequences are concatenated<phrase role="xpath">, in order,</phrase> and returned. </p></item><item><p>If the multiple evaluations of <code>E2</code> return at least 
one node and at least one atomic value, a <termref def="dt-type-error">type
	 error</termref> is raised <errorref class="TY" code="0018"/>.</p></item></olist><note><p>Since each step in a path provides context nodes for the following 
step, in effect, only the last step in a path is allowed to return a 
sequence of atomic values.</p></note><p>As an example of a path expression, <code role="parse-test">child::div1/child::para</code> selects the
	 <code>para</code> element children of the <code>div1</code>
	 element children of the context node, or, in other words, the
	 <code>para</code> element grandchildren of the context node
	 that have <code>div1</code> parents.</p>
	  
	 <note><p id="Chg-slash-note">The "<code>/</code>" character can be used either as a complete path expression or as the beginning of a longer path expression such as "<code>/*</code>".      Also, "<code>*</code>" is both the multiply operator and a wildcard in path     expressions.  This can cause
	 parsing difficulties when "<code>/</code>" appears on the left hand side of "<code>*</code>".    This is resolved using the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-leading-lone-slash" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">leading-lone-slash </loc> constraint.    For example, "<code>/*</code>" and "<code>/ *</code>" are valid path
	 expressions containing wildcards, but "<code>/*5</code>" and "<code>/ * 5</code>" raise syntax errors. Parentheses must be used when
	 "<code>/</code>" is used on the left hand side of an operator,
	 as in "<code>(/) * 5</code>". Similarly, "<code>4 + / * 5</code>" raises a syntax error, but "<code>4 + (/) * 5</code>" is a valid expression.  The expression "<code>4 + /</code>" is also valid, because <code>/</code> does not occur on the left hand side of the operator.</p></note><div3 id="id-steps"> 
		<head>Steps</head> 
		<scrap headstyle="show"> 
		  <head/> <prod num="27" id="doc-xpath-StepExpr"><lhs>StepExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-FilterExpr" xlink:type="simple">FilterExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AxisStep" xlink:type="simple">AxisStep</nt></rhs></prod> 
			 <prod num="28" id="doc-xpath-AxisStep"><lhs>AxisStep</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ReverseStep" xlink:type="simple">ReverseStep</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ForwardStep" xlink:type="simple">ForwardStep</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-PredicateList" xlink:type="simple">PredicateList</nt></rhs></prod><prod num="29" id="doc-xpath-ForwardStep"><lhs>ForwardStep</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ForwardAxis" xlink:type="simple">ForwardAxis</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-NodeTest" xlink:type="simple">NodeTest</nt>)  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AbbrevForwardStep" xlink:type="simple">AbbrevForwardStep</nt></rhs></prod> 
			 <prod num="32" id="doc-xpath-ReverseStep"><lhs>ReverseStep</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ReverseAxis" xlink:type="simple">ReverseAxis</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-NodeTest" xlink:type="simple">NodeTest</nt>)  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AbbrevReverseStep" xlink:type="simple">AbbrevReverseStep</nt></rhs></prod> 
		<prod num="39" id="doc-xpath-PredicateList"><lhs>PredicateList</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Predicate" xlink:type="simple">Predicate</nt>*</rhs></prod></scrap> 
		<p><termdef term="step" id="dt-step">A <term>step</term> is a part of a <termref def="dt-path-expression">path expression</termref> that generates a sequence of items
		and then filters the sequence by zero or more
		<termref def="dt-predicate">predicates</termref>. The value of the step
		consists of those items that satisfy the
		predicates, working from left to right. A step may be either an <termref def="dt-axis-step">axis step</termref> or a <termref def="dt-filter-expression">filter expression</termref>.</termdef> Filter expressions are described in <specref ref="id-filter-expr"/>.</p><p><termdef term="axis step" id="dt-axis-step">An <term>axis step</term> returns a sequence of nodes that are reachable from the context node via a specified axis. Such a step has two parts: an
		<term>axis</term>, which defines the "direction of
		movement" for the step, and a <termref def="dt-node-test">node test</termref>,
		which selects nodes based on their kind, name, and/or
		<termref def="dt-type-annotation">type annotation</termref>.</termdef> If the context item is a node, an axis
		step returns a sequence of zero or more
		nodes; otherwise, a <termref def="dt-type-error">type error</termref> is
		raised <errorref class="TY" code="0020"/>.   <phrase role="xpath">The resulting node sequence is returned in <termref def="dt-document-order">document
	 order</termref>.</phrase>  An axis step may be either a <term>forward
		step</term> or a <term>reverse step</term>, followed
		by zero or more <termref def="dt-predicate">predicates</termref>.</p>
		 
		<p>In the <term>abbreviated syntax</term> for a step, the axis can
		be omitted and other shorthand notations can be used as described in
		<specref ref="abbrev"/>.</p> 
		<p>The unabbreviated syntax for an axis step consists of the axis name
		and node test separated by a double colon. The result of the step consists of the nodes
		reachable from the context node via the specified axis that have the node kind, name,
		and/or <termref def="dt-type-annotation">type annotation</termref> specified by the node test. For example, the
		step <code>child::para</code> selects the <code>para</code> element children of the context node: <code>child</code> is the name of the axis, and <code>para</code> is the name of the element nodes to be selected on this axis. The available axes are described in <specref ref="axes"/>. The
		available node tests are described in <specref ref="node-tests"/>. Examples of 
		steps are provided in <specref ref="unabbrev"/> and <specref ref="abbrev"/>.</p> 

		<div4 id="axes"> 
		  <head>Axes</head> 
		  <scrap headstyle="show"> 
			 <head/> <prod num="30" id="doc-xpath-ForwardAxis"><lhs>ForwardAxis</lhs><rhs>("child"  "::")<br/>|  ("descendant"  "::")<br/>|  ("attribute"  "::")<br/>|  ("self"  "::")<br/>|  ("descendant-or-self"  "::")<br/>|  ("following-sibling"  "::")<br/>|  ("following"  "::")<br/>|  ("namespace"  "::")</rhs></prod> 
				<prod num="33" id="doc-xpath-ReverseAxis"><lhs>ReverseAxis</lhs><rhs>("parent"  "::")<br/>|  ("ancestor"  "::")<br/>|  ("preceding-sibling"  "::")<br/>|  ("preceding"  "::")<br/>|  ("ancestor-or-self"  "::")</rhs></prod> 
		  </scrap> 




		  <p role="xpath">XPath defines a full set of <term>axes</term>
		  for traversing documents, but a <term>host language</term> may define a subset
		  of these axes. The following axes are defined:</p> 

		  

		  <ulist> 
			 <item> 

				<p>The <code>child</code> axis
				contains the children of the context
				node, which are the nodes returned by
				the <code>dm:children</code> accessor
				in <bibref ref="datamodel"/>. </p>

                                                   <note>

                                                  <p>Only document
                                                  nodes and element
                                                  nodes have
                                                  children. If the
                                                  context node is any
                                                  other kind of node,
                                                  or if the context
                                                  node is an empty
                                                  document or element
                                                  node, then the child
                                                  axis is an empty
                                                  sequence.  The
                                                  children of a
                                                  document node or
                                                  element node may be
                                                  element, processing
                                                  instruction,
                                                  comment, or text
                                                  nodes.  Attribute<phrase role="xpath">,
                                                  namespace,</phrase> and
                                                  document nodes can
                                                  never appear as
                                                  children.</p></note>

			 </item> <item> <p>the <code>descendant</code>
			 axis is defined as the transitive closure of
			 the child axis; it contains the descendants
			 of the context node (the children, the children of the children, and so on)</p>

			 </item> 

                                       <item> 

                                          <p>the <code>parent</code>
                                          axis contains the sequence
                                          returned by the
                                          <code>dm:parent</code>
                                          accessor in <bibref ref="datamodel"/>, which returns
                                          the parent of the context
                                          node, or an empty sequence
                                          if the context node has no
                                          parent</p>

			 <note><p>An attribute node may have an element node as its parent, even though the attribute node is not a child of the element node.</p></note></item> 

                                        <item> <p>the
                                        <code>ancestor</code> axis is
                                        defined as the transitive
                                        closure of the parent axis; it
                                        contains the ancestors of the
                                        context node (the parent, the
                                        parent of the parent, and so
                                        on)</p>

                                        <note><p>The ancestor axis
                                        includes the root node of the
                                        tree in which the context node
                                        is found, unless the context
                                        node is the root node.</p></note>

			 </item> 

			 <item> <p>the <code>following-sibling</code>
			 axis contains the context node's following
			 siblings, those children of the context
			 node's parent that occur after the context
			 node in <termref def="dt-document-order">document order</termref>; if the context node
			 is an attribute <phrase role="xpath"> or namespace </phrase> node, the
			 <code>following-sibling</code> axis is
			 empty</p>
                                                   </item>

			 <item> <p>the <code>preceding-sibling</code>
			 axis contains the context node's preceding
			 siblings, those children of the context
			 node's parent that occur before the context
			 node in <termref def="dt-document-order">document order</termref>; if the context node
			 is an attribute <phrase role="xpath"> or namespace </phrase> node, the
			 <code>preceding-sibling</code> axis is
			 empty</p> </item>

			 <item> 

				<p>the <code>following</code> axis
				contains all nodes that are
				descendants of the root of the tree in
				which the context node is found, are
				not descendants of the context node,
				and occur after the context node in
				<termref def="dt-document-order">document order</termref></p>

			 </item> 

			 <item> 

				<p>the <code>preceding</code> axis
				contains all nodes that are
				descendants of the root of the tree in
				which the context node is found, are
				not ancestors of the context node, and
				occur before the context node in
				<termref def="dt-document-order">document order</termref></p>

			 </item> 

			 <item> <p>the <code>attribute</code> axis
			 contains the attributes of the context node,
			 which are the nodes returned by the
			 <code>dm:attributes</code> accessor in
			 <bibref ref="datamodel"/>; the axis will be
			 empty unless the context node is an
			 element</p>

			 </item> 
			  
			 <item> 
				<p>the <code>self</code> axis contains just the context node itself</p> 
			 </item> 
			 <item> 
				<p>the <code>descendant-or-self</code> axis contains the context node and the descendants of the context
				node</p> 
			 </item> 
			 <item> 
				<p>the <code>ancestor-or-self</code> axis contains the context node and the ancestors of the context node;
				thus, the ancestor-or-self axis will always include the root node</p> 
			 </item> 

		  <item role="xpath"> 

				<p>the <code>namespace</code> axis
				contains the namespace nodes of the
				context node, which are the nodes
				returned by the
				<code>dm:namespace-nodes</code> accessor in
				<bibref ref="datamodel"/>; this axis
				is empty unless the context node is an
				element node. The
				<code>namespace</code> axis is
				deprecated in XPath 2.0. If <termref def="dt-xpath-compat-mode">XPath 1.0
		compatibility mode</termref> is <code>true</code>, the <code>namespace</code> axis must be supported. If <termref def="dt-xpath-compat-mode">XPath 1.0
		compatibility mode</termref> is <code>false</code>, then support for the
				<code>namespace</code> axis is
				<termref def="dt-implementation-defined">implementation-defined</termref>. An implementation
				that does not support the
				<code>namespace</code> axis when <termref def="dt-xpath-compat-mode">XPath 1.0
		compatibility mode</termref> is <code>false</code> must raise
				a <termref def="dt-static-error">static
				error</termref> <errorref class="ST" code="0010"/> if it is
				used. Applications needing information
				about the <termref def="dt-in-scope-namespaces">in-scope namespaces</termref> of an element
				should use the functions
				<code>fn:in-scope-prefixes</code>
				and
				<code>fn:namespace-uri-for-prefix</code>
				defined in <bibref ref="FunctionsAndOperators"/>.</p>

			 </item></ulist> 
		  <p>Axes can be categorized as <term>forward axes</term> and
		  <term>reverse axes</term>. An axis that only ever contains the context node or
		  nodes that are after the context node in <termref def="dt-document-order">document order</termref> is a forward axis. An
		  axis that only ever contains the context node or nodes that are before the
		  context node in <termref def="dt-document-order">document order</termref> is a reverse axis.</p> 
		  <p>The <code>parent</code>, <code>ancestor</code>, <code>ancestor-or-self</code>, <code>preceding</code>, and <code>preceding-sibling</code> axes are reverse axes; all other axes are forward axes. The <code>ancestor</code>, <code>descendant</code>, <code>following</code>, <code>preceding</code> and <code>self</code> axes partition a document (ignoring attribute <phrase role="xpath">and namespace</phrase> nodes):
		  they do not overlap and together they contain all the nodes in the
		  document.</p> 
		   
		<p><termdef id="dt-principal-node-kind" term="principal node kind">Every axis has a <term>principal node kind</term>. If an axis can
		  contain elements, then the principal node kind is element; otherwise, it is the
		  kind of nodes that the axis can contain.</termdef> Thus:</p> 
		  <ulist> 
			 <item> 
				<p>For the attribute axis, the principal node kind is
				attribute.</p> 
			 </item> 
			 <item role="xpath"> 
				<p>For the namespace axis, the principal node kind is
				namespace.</p> 
			 </item> 
			 <item> 
				<p>For all other axes, the principal node kind is element.</p> 
			 </item> 
		  </ulist>

		</div4> 
		<div4 id="node-tests"> 
		  <head>Node Tests</head> 
		  <p><termdef id="dt-node-test" term="node test">A <term>node test</term> is a condition that must
		  be true for each node selected by a <termref def="dt-step">step</termref>.</termdef> The
		  condition may be based on the kind of the node
		  (element, attribute, text, document, comment,
		  or processing instruction), the name of
		  the node, or (in the case of element, attribute, and document
		  nodes), the <termref def="dt-type-annotation">type annotation</termref> of the node.</p>
		  <scrap headstyle="show"> 
			 <head/> <prod num="35" id="doc-xpath-NodeTest"><lhs>NodeTest</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-KindTest" xlink:type="simple">KindTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-NameTest" xlink:type="simple">NameTest</nt></rhs></prod> 
				<prod num="36" id="doc-xpath-NameTest"><lhs>NameTest</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Wildcard" xlink:type="simple">Wildcard</nt></rhs></prod> 
				<prod num="37" id="doc-xpath-Wildcard"><lhs>Wildcard</lhs><rhs>"*"<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-NCName" xlink:type="simple">NCName</nt>  ":"  "*")<br/>|  ("*"  ":"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-NCName" xlink:type="simple">NCName</nt>)</rhs></prod> 
				 
		  </scrap> 
		   
		  <p><termdef id="dt-name-test" term="name test">A node test that consists only of a QName or a
		  Wildcard is called a <term>name test</term>.</termdef> A name
		  test is true if and only if the <term>kind</term> of
		  the node is the <termref def="dt-principal-node-kind">principal node kind</termref> for the step axis and the
		  <termref def="dt-expanded-qname">expanded QName</termref> of the node is equal (as defined by the <code>eq</code> operator) to the
		  <termref def="dt-expanded-qname">expanded QName</termref> specified by the name test. For
		  example, <code role="parse-test">child::para</code>
		  selects the <code>para</code> element children of
		  the context node; if the context node has no
		  <code>para</code> children, it selects an empty set
		  of nodes. <code role="parse-test">attribute::abc:href</code> selects
		  the attribute of the context node with the QName
		  <code>abc:href</code>; if the context node has no
		  such attribute, it selects an empty set of
		  nodes.</p>
		  <p>A QName in a name test is resolved into an <termref def="dt-expanded-qname">expanded QName</termref> using the
		  <termref def="dt-static-namespaces">statically known namespaces</termref> in the expression
		  context. It is a <termref def="dt-static-error">static error</termref> <errorref class="ST" code="0081"/> if the QName has a prefix that does not
		  correspond to any statically known namespace. An unprefixed QName, when used as a
		  name test on an axis whose <termref def="dt-principal-node-kind">principal node kind</termref> is
		  element, has the namespace URI of the <termref def="dt-def-elemtype-ns">default element/type namespace</termref> in
		  the expression context; otherwise, it has no namespace URI. </p><p>A name test is not satisfied by an element node whose name does not match the <termref def="dt-expanded-qname">expanded QName</termref> of the name test, even if it is in a <termref def="dt-substitution-group">substitution group</termref> whose head is the named element.</p> 
		  <p>A node test <code>*</code> is true for any node of the <termref def="dt-principal-node-kind">principal node kind</termref> of the step axis. For example, <code role="parse-test">child::*</code> will select all element children of the context node, and <code role="parse-test">attribute::*</code> will select all attributes of the context node.</p> 
		  <p>A node test can have the form
		  <code>NCName:*</code>. In this case, the prefix is
		  expanded in the same way as with a QName, using the
		  <termref def="dt-static-namespaces">statically known
		  namespaces</termref> in the <termref def="dt-static-context">static context</termref>. If
		  the prefix is not found in the statically known namespaces,
		  a <termref def="dt-static-error">static
		  error</termref> is raised <errorref class="ST" code="0081"/>.
		  The node test is true for any node of the <termref def="dt-principal-node-kind">principal
		  node kind</termref> of the step axis whose <termref def="dt-expanded-qname">expanded QName</termref> has the namespace URI
		  to which the prefix is bound, regardless of the
		  local part of the name.</p> <p>A node test can also
		  have the form <code>*:NCName</code>. In this case,
		  the node test is true for any node of the <termref def="dt-principal-node-kind">principal
		  node kind</termref> of the step axis whose local name matches the given NCName,
		  regardless of its namespace or lack of a namespace.</p> <p><termdef term="kind test" id="dt-kind-test">An alternative
		  form of a node test called a
		  <term>kind test</term> can select nodes based
		  on their kind, name, and <termref def="dt-type-annotation">type annotation</termref>.</termdef> The syntax
		  and semantics of a kind test are described in
		  <specref ref="id-sequencetype-syntax"/> and <specref ref="id-sequencetype-matching"/>. When a kind test is used
		  in a <termref def="dt-node-test">node test</termref>, only those nodes on the designated
		  axis that match the kind test are selected. Shown
		  below are several examples of kind tests that might
		  be used in path
		  expressions:</p><ulist><item><p><code>node()</code>
		  matches any
		  node.</p></item><item><p><code>text()</code> matches
		  any text
		  node.</p></item><item><p><code>comment()</code>
		  matches any comment
		  node.</p></item><item><p><code>element()</code>
		  matches any element
		  node.</p></item><item><p><code>schema-element(person)</code>
		  matches any element node whose name is
		  <code>person</code> (or is in the <termref def="dt-substitution-group">substitution group</termref>
		  headed by <code>person</code>), and whose type
		  annotation is the same as (or is derived from) the declared type of the <code>person</code>
		  element in the <termref def="dt-is-elems">in-scope element declarations</termref>.</p></item><item><p><code>element(person)</code> matches any element node whose name is
		  <code>person</code>, regardless of its type annotation.</p></item><item><p><code>element(person, surgeon)</code> matches any non-nilled element node whose name
		  is <code>person</code>, and whose type
		  annotation is
		  <code>surgeon</code> or is derived from <code>surgeon</code>.</p></item><item><p><code>element(*,
		  surgeon)</code> matches any non-nilled element node whose type
		  annotation is <code>surgeon</code> (or is derived from <code>surgeon</code>), regardless of
		  its
		  name.</p></item>

                  

                  <item><p><code>attribute()</code> matches any
                  attribute node.</p></item>

                  <item><p><code>attribute(price)</code> matches
                  any attribute whose name is <code>price</code>,
                  regardless of its type annotation.</p></item><item><p><code>attribute(*,
                  xs:decimal)</code> matches any attribute whose type
                  annotation is <code>xs:decimal</code> (or is derived from <code>xs:decimal</code>), regardless of
                  its
                  name.</p></item><item><p><code>document-node()</code>
                  matches any document
                  node.</p></item><item><p><code>document-node(element(book))</code>
                  matches any document node whose content consists of
                  a single element node that satisfies the <termref def="dt-kind-test">kind test</termref>
                  <code>element(book)</code>, interleaved with zero or more
                  comments and processing
                  instructions.</p></item></ulist></div4> </div3>
	  
  <div3 id="id-predicates"> 
	 <head>Predicates</head> 
	  
	 <scrap headstyle="show"> 
		<head/>  
	 <prod num="40" id="doc-xpath-Predicate"><lhs>Predicate</lhs><rhs>"["  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Expr" xlink:type="simple">Expr</nt>  "]"</rhs></prod></scrap> 
	 <p><termdef term="predicate" id="dt-predicate">A <term>predicate</term> consists of an expression, called a <term>predicate
		expression</term>, enclosed in square brackets. A predicate serves to filter a sequence, retaining some items and discarding others.</termdef> In the case of multiple adjacent predicates, the predicates are applied from left to 
right, and the result of applying each predicate serves as the input 
sequence for the following predicate.</p><p>For each item in the input sequence, the predicate expression is evaluated 
using an <term>inner focus</term>, defined as follows: The context item is the item 
currently being tested against the predicate. The context size is the 
number of items in the input sequence. The context position is the 
position of the context item within the input sequence. For the purpose of 
evaluating the context position within a predicate, the input sequence is 
considered to be sorted as follows: into document order if the predicate 
is in a forward-axis step, into reverse document order if the predicate is 
in a reverse-axis step, or in its original order if the predicate is not 
in a step.</p><p>For each item in the input sequence, the result of the predicate 
expression is coerced to an <code>xs:boolean</code> value, called the <term>predicate truth value</term>, as
		described below. Those items for which the predicate truth value is <code>true</code> are retained, and those for which the predicate truth value is <code>false</code> are discarded.</p> 
		<p>The predicate truth value is derived by applying the following rules,
		in order:</p> 
		<olist> 
		   
		  <item> 
			 <p>If the value of the predicate expression is a <termref def="dt-singleton">singleton</termref> atomic value of a
			 <termref def="dt-numeric">numeric</termref> type or derived from a <termref def="dt-numeric">numeric</termref> type, the predicate truth value is <code>true</code> if the value of the predicate expression  is equal (by the <code>eq</code> operator) to the <term>context position</term>, and is <code>false</code> otherwise. <termdef term="numeric predicate" id="dt-numeric-predicate">A predicate whose predicate expression returns a numeric type is called a <term>numeric predicate</term>.</termdef></p> 
		  </item> 
		  <item> 
			 <p>Otherwise, the predicate truth value is the <termref def="dt-ebv">effective boolean value</termref> of the predicate
			 expression.</p> 
		  </item> 
		   
		</olist> 


		 
		<p>Here are some examples of <termref def="dt-axis-step">axis steps</termref> that contain predicates:</p> 
		<ulist> 
		  <item> 
			 <p>This example selects the second <code>chapter</code> element that is a child
			 of the context node:</p> 
			 <eg role="parse-test" xml:space="preserve">child::chapter[2]</eg> 
		</item> 
		<item> 
		  <p>This example selects all the descendants of the
		  context node that are elements named
		  <code>"toy"</code> and whose <code>color</code>
		  attribute has the value <code>"red"</code>:</p>
		  <eg role="parse-test" xml:space="preserve">descendant::toy[attribute::color = "red"]</eg> 
	 </item> 
	 <item> 
		<p>This example selects all the <code>employee</code> children of the context node
		that have both a <code>secretary</code> child element and an <code>assistant</code> child element:</p> 
		<eg role="parse-test" xml:space="preserve">child::employee[secretary][assistant]</eg> 
  </item> 
</ulist> 




 
 
<note><p>When using <termref def="dt-predicate">predicates</termref> with a sequence of nodes selected using a
<term>reverse axis</term>, it is important to remember that the the
context positions for such a sequence are assigned in <termref def="dt-reverse-document-order">reverse
document order</termref>. For example, <code>preceding::foo[1]</code>
returns the first qualifying <code>foo</code> element in <termref def="dt-reverse-document-order">reverse document order</termref>, because the predicate is part of an <termref def="dt-axis-step">axis step</termref> using a reverse axis. By
contrast, <code>(preceding::foo)[1]</code> returns the first qualifying <code>foo</code>
element in <termref def="dt-document-order">document order</termref>, because the parentheses cause  <code>(preceding::foo)</code> to be parsed as a <termref def="dt-primary-expression">primary expression</termref> in which context positions are assigned in document order. Similarly, <code>ancestor::*[1]</code>
returns the nearest ancestor element, because the <code>ancestor</code> axis is a
reverse axis, whereas <code>(ancestor::*)[1]</code> returns the root element (first ancestor in document order).</p><p>The fact that a reverse-axis step assigns context positions in reverse 
document order for the purpose of evaluating predicates does not alter the 
fact that the final result of the step is always in document order.</p></note></div3> 
<div3 id="unabbrev"> 
<head>Unabbreviated Syntax</head> 
<p>This section provides a number of examples of path expressions in which the
axis is explicitly specified in each <termref def="dt-step">step</termref>. The syntax used in these examples is
called the <term>unabbreviated syntax</term>. In many common cases, it is
possible to write path expressions more concisely using an <term>abbreviated
syntax</term>, as explained in <specref ref="abbrev"/>.</p> 
<ulist> 
<item> 
<p> <code role="parse-test">child::para</code> selects 
the <code>para</code> element children of the context node</p> 
</item> 
<item> 
<p> <code role="parse-test">child::*</code> selects all element children of the context node</p> 
</item> 
<item> 
<p> <code role="parse-test">child::text()</code> selects all text node children of the context node</p> 
</item> 
<item> 
<p> <code role="parse-test">child::node()</code> selects all the children of the context node. Note that no attribute nodes are returned, because attributes are not children.</p> 
</item> 
<item> 
<p> <code role="parse-test">attribute::name</code> selects the <code>name</code> attribute of the context node</p> 
</item> 
<item> 
<p> <code role="parse-test">attribute::*</code> selects all the attributes of the context node</p> 
</item><item><p><code>parent::node()</code> selects the parent of the context node. If the context node is an attribute node, this expression returns the element node (if any) to which the attribute node is attached.</p></item> 
<item> 
<p> <code role="parse-test">descendant::para</code> selects the <code>para</code> element descendants of the context node</p> 
</item> 
<item> 
<p> <code role="parse-test">ancestor::div</code> selects all <code>div</code> ancestors of the context node</p> 
</item> 
<item> 
<p> <code role="parse-test">ancestor-or-self::div</code> selects the <code>div</code> ancestors of the context node and, if the context node is a <code>div</code> element, the context node as well</p> 
</item> 
<item> 
<p> <code role="parse-test">descendant-or-self::para</code> selects the <code>para</code> element descendants of the context node and, if the context node is a <code>para</code> element, the context node as well</p> 
</item> 
<item> 
<p> <code role="parse-test">self::para</code> selects the context node if it is a <code>para</code> element, and otherwise returns an empty sequence</p> 
</item> 
<item> 
<p> <code role="parse-test">child::chapter/descendant::para</code> selects the <code>para</code> element 
descendants of the <code>chapter</code> element children of the context node</p> 
</item> 
<item> 
<p> <code role="parse-test">child::*/child::para</code> selects all <code>para</code> grandchildren of the context node</p> 
</item> 
<item> 
<p> <code role="parse-test">/</code> selects the root of the tree that contains the context node, but raises a dynamic error if this root is not a document node</p> 
</item> 
<item> 
<p> <code role="parse-test">/descendant::para</code> selects all the <code>para</code> elements in the same document as the context node</p> 
</item> 
<item> 
<p> <code role="parse-test">/descendant::list/child::member</code> selects all 
the <code>member</code> elements that have a <code>list</code> parent and that are in the same document as the context node</p> 
 
</item> 
<item> 
<p> <code role="parse-test">child::para[fn:position() = 1]</code> selects the first <code>para</code> child of the context node</p> 
</item> 
<item> 
<p> <code role="parse-test">child::para[fn:position() = fn:last()]</code> selects the last <code>para</code> child of the context node</p> 
</item> 
<item> 
<p> <code role="parse-test">child::para[fn:position() = fn:last()-1]</code> selects the last but one <code>para</code> child of the context node</p> 
</item> 
<item> 
<p> <code role="parse-test">child::para[fn:position() &gt; 1]</code> selects all the <code>para</code> children of the context node other than the first <code>para</code> child of the context node</p> 
</item> 
<item> 
<p> <code role="parse-test">following-sibling::chapter[fn:position() = 1]</code>selects the next <code>chapter</code> sibling of the context node</p> 
</item> 
<item> 
<p> <code role="parse-test">preceding-sibling::chapter[fn:position() = 1]</code>selects the previous <code>chapter</code> sibling of the context node</p> 
</item> 
<item> 
<p> <code role="parse-test">/descendant::figure[fn:position() = 42]</code> selects the forty-second <code>figure</code> element in the document containing the context node</p> 
</item> 
<item> 
<p> <code role="parse-test">/child::book/child::chapter[fn:position() = 5]/child::section[fn:position() = 2]</code> selects the 
second <code>section</code> of the fifth <code>chapter</code> of the <code>book</code> whose parent is the document node that contains the context node</p> 
</item> 
<item> 
<p> <code role="parse-test">child::para[attribute::type eq "warning"]</code>selects 
all <code>para</code> children of the context node that have a <code>type</code> attribute with value <code>warning</code> </p> 
</item> 
<item> 
<p> <code role="parse-test">child::para[attribute::type eq 'warning'][fn:position() = 5]</code>selects the fifth <code>para</code> child of the context node that has a <code>type</code> attribute with value <code>warning</code> </p> 
</item> 
<item> 
<p> <code role="parse-test">child::para[fn:position() = 5][attribute::type eq "warning"]</code>selects the fifth <code>para</code> child of the context node if that child has a <code>type</code> attribute with value <code>warning</code> </p> 
</item> 

<item> 
<p> <code role="parse-test">child::chapter[child::title = 'Introduction']</code>selects
the <code>chapter</code> children of the context node that have one or
more <code>title</code> children whose <termref def="dt-typed-value">typed value</termref> is equal to the
string <code>Introduction</code> </p>
</item> 

<item> 
<p> <code role="parse-test">child::chapter[child::title]</code> selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children</p> 
</item> 
<item> 
<p> <code role="parse-test">child::*[self::chapter or self::appendix]</code> 
selects the <code>chapter</code> and <code>appendix</code> children of the context node</p> 
</item> 
<item> 
<p> <code role="parse-test">child::*[self::chapter or
self::appendix][fn:position() = fn:last()]</code> selects the 
last <code>chapter</code> or <code>appendix</code> child of the context node</p> 
</item> 
</ulist> 
</div3> 
<div3 id="abbrev"> 
<head>Abbreviated Syntax</head> 
<scrap headstyle="show"> 
<head/> <prod num="31" id="doc-xpath-AbbrevForwardStep"><lhs>AbbrevForwardStep</lhs><rhs>"@"?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-NodeTest" xlink:type="simple">NodeTest</nt></rhs></prod> 
<prod num="34" id="doc-xpath-AbbrevReverseStep"><lhs>AbbrevReverseStep</lhs><rhs>".."</rhs></prod>
</scrap> 
<p>The abbreviated syntax permits the following abbreviations:</p> 
<olist> 
<item> 
<p>The attribute axis <code>attribute::</code> can be 
abbreviated by <code>@</code>. For example, a path expression <code role="parse-test">para[@type="warning"]</code> is short 
for <code role="parse-test">child::para[attribute::type="warning"]</code> and 
so selects <code>para</code> children with a <code>type</code> attribute with value 
equal to <code>warning</code>.</p> 
</item><item> 
<p>If the axis name is omitted from an <termref def="dt-axis-step">axis step</termref>, the default axis is <code>child</code> unless the axis step contains an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeTest" xlink:type="simple">AttributeTest</nt> or <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt>; in that case, the default axis is <code>attribute</code>.  For example, the path expression <code role="parse-test">section/para</code> is an abbreviation for <code role="parse-test">child::section/child::para</code>, and the path expression <code>section/@id</code> is an abbreviation for <code>child::section/attribute::id</code>.  Similarly, <code>section/attribute(id)</code> is an abbreviation for <code>child::section/attribute::attribute(id)</code>. Note that the latter expression contains both an axis specification and a <termref def="dt-node-test">node test</termref>.</p> 
</item> 
 
<item> 
<p> Each non-initial occurrence of <code>//</code> is effectively replaced by  <code>/descendant-or-self::node()/</code> during processing of a path expression. For example, <code role="parse-test">div1//para</code> is 
short for <code role="parse-test">child::div1/descendant-or-self::node()/child::para</code> and so will select all <code>para</code> descendants of <code>div1</code> children.</p> 
<note><p>The path expression <code role="parse-test">//para[1]</code> does <emph>not</emph> mean the same as the path 
expression <code role="parse-test">/descendant::para[1]</code>. The latter selects the first descendant <code>para</code> element; the former 
selects all descendant <code>para</code> elements that are the first <code>para</code> children of their respective parents.</p></note> 
</item> 
<item> 
<p>A step consisting 
of <code role="parse-test">..</code> is short 
for <code role="parse-test">parent::node()</code>. For example, <code role="parse-test">../title</code> is short for <code role="parse-test">parent::node()/child::title</code> and so will select the <code>title</code> children of the parent of the context node.</p> 
<note>
   <p>The expression <code>.</code>, known as a <term>context item
   expression</term>, is a <termref def="dt-primary-expression">primary expression</termref>,
   and is described in <specref ref="id-context-item-expression"/>.</p>
</note></item> 
</olist>



<p>Here are some examples of path expressions that use the abbreviated
syntax:</p> 
<ulist> 
<item> 
<p> <code>para</code> selects the <code>para</code> element children of the context node</p> 
</item> 
<item> 
<p> <code role="parse-test">*</code> selects all element children of the context node</p> 
</item> 
<item> 
<p> <code role="parse-test">text()</code> selects all text node children of the context node</p> 
</item> 
<item> 
<p> <code role="parse-test">@name</code> selects 
the <code>name</code> attribute of the context node</p> 
</item> 
<item> 
<p> <code role="parse-test">@*</code> selects all the attributes of the context node</p> 
</item> 
<item> 
<p> <code role="parse-test">para[1]</code> selects the first <code>para</code> child of the context node</p> 
</item> 
<item> 
<p> <code role="parse-test">para[fn:last()]</code> selects the last <code>para</code> child of the context node</p> 
</item> 
<item> 
<p> <code role="parse-test">*/para</code> selects 
all <code>para</code> grandchildren of the context node</p> 
</item> 
<item> 
<p> <code role="parse-test">/book/chapter[5]/section[2]</code> selects the 
second <code>section</code> of the fifth <code>chapter</code> of the <code>book</code> whose parent is the document node that contains the context node</p> 
</item> 
<item> 
<p> <code role="parse-test">chapter//para</code> selects the <code>para</code> element descendants of the <code>chapter</code> element children of the context node</p> 
</item> 
<item> 
<p> <code role="parse-test">//para</code> selects all 
the <code>para</code> descendants of the root document node and thus selects all <code>para</code> elements in the same document as the context node</p> 
</item><item><p><code>//@version</code> selects all the <code>version</code> attribute nodes that are in the same document as the context node</p></item> 
<item> 
<p> <code role="parse-test">//list/member</code> selects all the <code>member</code> elements in the same document as the context node that have a <code>list</code> parent</p> 
 
</item> 
 
<item> 
<p> <code role="parse-test">.//para</code> selects 
the <code>para</code> element descendants of the context node</p> 
</item> 
<item> 
<p> <code role="parse-test">..</code> selects the parent of the context node</p> 
</item> 
<item> 
<p> <code role="parse-test">../@lang</code> selects 
the <code>lang</code> attribute of the parent of the context node</p> 
</item> 
<item> 
<p> <code role="parse-test">para[@type="warning"]</code> selects all <code>para</code> children of the context node that have a <code>type</code> attribute with value <code>warning</code> </p> 
</item> 
<item> 
<p> <code role="parse-test">para[@type="warning"][5]</code> selects the fifth <code>para</code> child of the context node that has a <code>type</code> attribute with value <code>warning</code> </p> 
</item> 
<item> 
<p> <code role="parse-test">para[5][@type="warning"]</code> selects the fifth <code>para</code> child of the context node if that child has a <code>type</code> attribute with value <code>warning</code> </p> 
</item> 
<item> 
<p> <code role="parse-test">chapter[title="Introduction"]</code> selects the <code>chapter</code> children of the context node that have one 
or more <code>title</code> children whose <termref def="dt-typed-value">typed value</termref> is equal to the string <code>Introduction</code> </p> 
</item> 
<item> 
<p> <code role="parse-test">chapter[title]</code> selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children</p> 
</item> 
<item> 
<p> <code role="parse-test">employee[@secretary and @assistant]</code> selects all 
the <code>employee</code> children of the context node that have both a <code>secretary</code> attribute and 
an <code>assistant</code> attribute</p> 
</item> 
<item> 
<p> <code role="parse-test">book/(chapter|appendix)/section</code> selects 
every <code>section</code> element that has a parent that is either a <code>chapter</code> or an <code>appendix</code> element, that in turn is a child of a <code>book</code> element that is a child of the context node.</p> 
</item> 
<item><p>If <code>E</code> is any expression that returns a sequence of nodes, then the expression <code>E/.</code> returns the same nodes in <termref def="dt-document-order">document order</termref>, with duplicates eliminated based on node identity.</p></item> 
</ulist> 
</div3>	
</div2>	
<div2 id="id-sequence-expressions"> 
<head>Sequence Expressions</head> 
<p>XPath supports operators to construct, filter,  and combine
<termref def="dt-sequence">sequences</termref> of <termref def="dt-item">items</termref>.
Sequences are never nested—for
example, combining the values <code>1</code>, <code>(2, 3)</code>, and <code>( )</code> into a single sequence results
in the sequence <code>(1, 2, 3)</code>.</p> 
<div3 id="construct_seq"> 
<head>Constructing Sequences</head> 
<scrap headstyle="show"> 
<head/>  
<prod num="2" id="noid_N12B39.doc-xpath-Expr"><lhs>Expr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs></prod> 
<prod num="11" id="doc-xpath-RangeExpr"><lhs>RangeExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt> ( "to"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt> )?</rhs></prod> 
</scrap> 
<p><termdef term="comma operator" id="dt-comma-operator">One way to construct a sequence is by using the <term>comma operator</term>, which evaluates each of its operands and concatenates the resulting sequences, in order, into a single result sequence.</termdef> Empty parentheses can be used to denote an empty sequence.</p><p>A sequence may contain duplicate
atomic values or nodes, but a sequence is never an item in another sequence. When a
new sequence is created by concatenating two or more input sequences, the new
sequence contains all the items of the input sequences and its length is the
sum of the lengths of the input sequences.</p> 
<note><p>In places where the grammar calls for <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>, such as the arguments of a function call, any expression that contains a top-level comma operator must be enclosed in parentheses.</p></note><p>Here are some examples of expressions that construct sequences:
</p>
<ulist> 
<item> 
<p>The result of this expression is a sequence of five integers:</p> 
<eg role="parse-test" xml:space="preserve">(10, 1, 2, 3, 4)</eg> 
</item> 
<item> 
<p>This expression combines four sequences of length one, two, zero, and two, respectively, into a single sequence of length five. The result of this expression is the sequence <code>10, 1, 2, 3, 4</code>.</p> 
<eg role="parse-test" xml:space="preserve">(10, (1, 2), (), (3, 4))</eg> 
 
 
</item> 
<item> 
<p>The result of this expression is a sequence containing 
all <code>salary</code> children of the context node followed by all <code>bonus</code> children.</p> 
<eg role="parse-test" xml:space="preserve">(salary, bonus)</eg> 
</item> 
<item> 
<p>Assuming that <code>$price</code> is bound to 
the value <code>10.50</code>, the result of this expression is the sequence <code>10.50, 10.50</code>.</p> 
<eg role="parse-test" xml:space="preserve">($price, $price)</eg> 
 
 
</item> 
</ulist> 
<p>A <term>range expression</term> can be used to construct a sequence of consecutive
integers. Each of the operands of the <code>to</code> operator is
converted as though it was an argument of a function with the expected
parameter type <code>xs:integer?</code>.
If either operand is an empty sequence, or if the integer derived from the first operand is greater than the integer derived from the second operand, the result of the range expression is an empty sequence. If the two operands convert to the same integer, the result of the range expression is that integer. Otherwise, the result is a sequence containing the two integer operands and
every integer between the two operands, in increasing order. </p> 
<ulist> 
<item> 
<p>This example uses a range expression as one operand in constructing a sequence. It evaluates to the sequence <code>10, 1, 2, 3, 4</code>.</p> 
<eg role="parse-test" xml:space="preserve">(10, 1 to 4)</eg> 
 
</item><item><p>This example constructs a sequence of length one containing the single integer <code>10</code>.</p><eg role="parse-test" xml:space="preserve">10 to 10</eg></item><item><p>The result of this example is a sequence of length zero.</p><eg role="parse-test" xml:space="preserve">15 to 10</eg></item><item><p>This example uses the <code>fn:reverse</code> function to construct a sequence of six integers in decreasing order. It evaluates to the sequence <code>15, 14, 13, 12, 11, 10</code>.</p><eg role="parse-test" xml:space="preserve">fn:reverse(10 to 15)</eg></item> 
</ulist> 
</div3> 
<div3 id="id-filter-expr"><head>Filter Expressions</head><scrap headstyle="show"><head/><prod num="38" id="doc-xpath-FilterExpr"><lhs>FilterExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-PrimaryExpr" xlink:type="simple">PrimaryExpr</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-PredicateList" xlink:type="simple">PredicateList</nt></rhs></prod><prod num="39" id="noid_N12BE0.doc-xpath-PredicateList"><lhs>PredicateList</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Predicate" xlink:type="simple">Predicate</nt>*</rhs></prod></scrap><p><termdef id="dt-filter-expression" term="filter expression">A <term>filter
		expression</term> consists simply of a <term>primary
		expression</term> followed by zero or more
		<termref def="dt-predicate">predicates</termref>. The result of the 
filter expression consists of the items returned by the primary 
expression, filtered by applying each predicate in turn, working from left 
to right.</termdef> If no predicates
		are specified, the result is simply the result of the
		primary expression.  The
		ordering of the items returned by a filter expression is the
		same as their order in the result of the primary
		expression. Context positions are assigned to items based on their ordinal position 
in the result sequence. The first context position is 1.</p><p>Here are some examples of filter expressions:</p><ulist><item><p>Given a sequence of products in a variable, return only those products whose price is greater than 100.</p><eg role="parse-test" xml:space="preserve">$products[price gt 100]</eg></item><item><p>List all the integers from 1 to 100 that are divisible by 5. (See <specref ref="construct_seq"/> for an explanation of the <code>to</code> operator.)</p><eg role="parse-test" xml:space="preserve">(1 to 100)[. mod 5 eq 0]</eg></item><item><p>The result of the following expression is the integer 25:</p><eg role="parse-test" xml:space="preserve">(21 to 29)[5]</eg></item><item><p>The following example returns the fifth through ninth items in the sequence bound to variable <code>$orders</code>.</p><eg role="parse-test" xml:space="preserve">$orders[fn:position() = (5 to 9)]</eg></item><item><p>The following example illustrates the use of a filter expression as a <termref def="dt-step">step</termref> in a <termref def="dt-path-expression">path expression</termref>. It returns the last chapter or appendix within the book bound to variable <code>$book</code>:</p><eg role="parse-test" xml:space="preserve">$book/(chapter | appendix)[fn:last()]</eg></item><item><p>The following example also illustrates the use of a filter expression as a <termref def="dt-step">step</termref> in a <termref def="dt-path-expression">path expression</termref>. It returns the element node within the specified document whose ID value is <code>tiger</code>:</p><eg role="parse-test" xml:space="preserve">fn:doc("zoo.xml")/fn:id('tiger')</eg></item></ulist></div3><div3 id="combining_seq"> 
<head>Combining Node Sequences</head> 
<scrap headstyle="show"> 
<head/> <prod num="14" id="doc-xpath-UnionExpr"><lhs>UnionExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-IntersectExceptExpr" xlink:type="simple">IntersectExceptExpr</nt> ( ("union"  |  "|")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-IntersectExceptExpr" xlink:type="simple">IntersectExceptExpr</nt> )*</rhs></prod> 
<prod num="15" id="doc-xpath-IntersectExceptExpr"><lhs>IntersectExceptExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-InstanceofExpr" xlink:type="simple">InstanceofExpr</nt> ( ("intersect"  |  "except")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-InstanceofExpr" xlink:type="simple">InstanceofExpr</nt> )*</rhs></prod> 
</scrap> 
<p>XPath provides the following operators for combining sequences of
nodes:</p><ulist><item><p>The <code>union</code> and <code>|</code> operators are equivalent. They take two node sequences as operands and
return a sequence containing all the nodes that occur in either of the
operands.</p></item><item><p>The <code>intersect</code> operator takes two node sequences as operands and returns a sequence
containing all the nodes that occur in both operands.</p></item><item><p>The <code>except</code> operator takes two node sequences as operands and returns a sequence
containing all the nodes that occur in the first operand but not in the second
operand.</p></item></ulist><p>   
 All these operators eliminate duplicate nodes from their result sequences based on node identity. <phrase role="xpath">The resulting sequence is returned in <termref def="dt-document-order">document
	 order</termref>.</phrase></p><p>If an operand 
of <code>union</code>, <code>intersect</code>, or <code>except</code> contains an item that is not a node, a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.</p> 
<p>Here are some examples of expressions that combine sequences. Assume the existence of three element nodes that we will refer to by symbolic names A, B, and C. Assume that the variables <code>$seq1</code>,  <code>$seq2</code>  and <code>$seq3</code> are bound to the following sequences of these nodes:</p><ulist><item><p><code>$seq1</code> is bound to (A, B)</p></item><item><p><code>$seq2</code> is bound to (A, B)</p></item><item><p><code>$seq3</code> is bound to (B, C)</p></item></ulist><p>Then: </p> 
<ulist> 
<item> 
<p> <code role="parse-test">$seq1 union $seq2</code>  evaluates to the sequence (A, B). </p> 
</item> 
<item> 
<p> <code role="parse-test">$seq2 union $seq3</code>   evaluates to the sequence (A, B, C). </p> 
</item> 
<item> 
<p> <code role="parse-test">$seq1 intersect $seq2</code>  evaluates to the sequence (A, B). </p> 
</item> 
<item> 
<p> <code role="parse-test">$seq2 intersect $seq3</code>  evaluates to the sequence containing B only.</p> 
</item> 
<item> 
<p> <code role="parse-test">$seq1 except $seq2</code>   evaluates to the empty sequence.</p> 
</item> 
<item> 
<p> <code role="parse-test">$seq2 except $seq3</code>  evaluates to the sequence containing A only.</p> 
</item> 
</ulist> 
<p>In addition to the sequence operators described here, <bibref ref="FunctionsAndOperators"/> includes functions for indexed access to items or
sub-sequences of a sequence, for indexed insertion or removal of items in a
sequence, and for removing duplicate items from a sequence.</p> 
</div3>	
</div2><div2 id="id-arithmetic"> 
<head>Arithmetic Expressions</head> 
<p>XPath provides arithmetic operators for addition, subtraction,
multiplication, division, and modulus, in their usual binary and unary
forms.</p> 
<scrap headstyle="show"> 
<head/> 
<prod num="12" id="doc-xpath-AdditiveExpr"><lhs>AdditiveExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-MultiplicativeExpr" xlink:type="simple">MultiplicativeExpr</nt> ( ("+"  |  "-")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-MultiplicativeExpr" xlink:type="simple">MultiplicativeExpr</nt> )*</rhs></prod> 
<prod num="13" id="doc-xpath-MultiplicativeExpr"><lhs>MultiplicativeExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-UnionExpr" xlink:type="simple">UnionExpr</nt> ( ("*"  |  "div"  |  "idiv"  |  "mod")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-UnionExpr" xlink:type="simple">UnionExpr</nt> )*</rhs></prod> 
<prod num="20" id="doc-xpath-UnaryExpr"><lhs>UnaryExpr</lhs><rhs>("-"  |  "+")* <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ValueExpr" xlink:type="simple">ValueExpr</nt></rhs></prod> 
<prod num="21" id="doc-xpath-ValueExpr"><lhs>ValueExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-PathExpr" xlink:type="simple">PathExpr</nt></rhs></prod></scrap> 
<p>A subtraction operator must be preceded by whitespace if
it could otherwise be interpreted as part of the previous token. For
example, <code role="parse-test">a-b</code> will be interpreted as a
name, but <code role="parse-test">a - b</code> and <code>a -b</code> will be interpreted as arithmetic expressions. (See <specref ref="whitespace-rules"/> for further details on whitespace handling.)</p>
<p>The first step in evaluating an arithmetic expression is to evaluate its operands. The order in which the operands are evaluated is <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p><p role="xpath">If <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref> is <code>true</code>, each operand is evaluated by applying the following steps, in order:</p>
<olist role="xpath"><item><p><termref def="dt-atomization">Atomization</termref> is applied to the operand. The result of this
    operation is called the <term>atomized operand</term>.</p></item><item><p>If the atomized operand is an empty sequence, the result of
    the arithmetic expression is the <code>xs:double</code> value <code>NaN</code>, and the implementation
    need not evaluate the other operand or apply the operator. However,
    an implementation may choose to evaluate the other operand in order
    to determine whether it raises an error.</p></item><item><p>If the atomized operand is a sequence of length greater than one, any items after the first item in the sequence are discarded.</p></item><item><p>If the atomized operand is now an instance of type <code>xs:boolean</code>, <code>xs:string</code>,
<code>xs:decimal</code> (including <code>xs:integer</code>), <code>xs:float</code>, or <code>xs:untypedAtomic</code>, then it
is converted to the type <code>xs:double</code> by applying the <code>fn:number</code> function. (Note that <code>fn:number</code> returns the value <code>NaN</code> if its operand cannot be converted to a number.)</p></item></olist><p><phrase role="xpath">If <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref> is <code>false</code>, each</phrase> operand is evaluated by applying the following steps, in order:</p><olist><item><p><termref def="dt-atomization">Atomization</termref> is applied to the operand. The result of this
    operation is called the <term>atomized operand</term>.</p></item><item><p>If the atomized operand is an empty sequence, the result of
    the arithmetic expression is an empty sequence, and the implementation
    need not evaluate the other operand or apply the operator. However,
    an implementation may choose to evaluate the other operand in order
    to determine whether it raises an error.</p></item><item><p> If the atomized operand is a sequence of
length greater than one, a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.</p></item><item><p>If the atomized operand is of type <code>xs:untypedAtomic</code>, it is cast to  <code>xs:double</code>. If
the cast fails, a <termref def="dt-dynamic-error">dynamic
error</termref> is raised. [err:FORG0001]</p></item></olist><p>After evaluation of the operands, if the types of the operands are a valid combination
for the given arithmetic operator, the operator is applied to the operands,
resulting in an atomic value or a <termref def="dt-dynamic-error">dynamic error</termref> (for example, an error
might result from dividing by zero.) The combinations of atomic types
that are accepted by the various arithmetic operators, and their
respective result types, are listed in <specref ref="mapping"/>
together with the <termref def="dt-operator-function">operator functions</termref>
that define the semantics of the operator for each
type combination, including the dynamic errors that can be raised by the operator. The definitions of the operator functions are found in <bibref ref="FunctionsAndOperators"/>.</p><p>If the types of the operands, after evaluation, are not a valid combination for the given operator, according to the rules in <specref ref="mapping"/>, a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.</p>
<p>XPath supports two division operators named <code>div</code> and <code>idiv</code>. Each of these operators accepts two operands of any <termref def="dt-numeric">numeric</termref> type. As described in <bibref ref="FunctionsAndOperators"/>, <code>$arg1 idiv $arg2</code> is equivalent to <code>($arg1 div $arg2) cast as xs:integer?</code> except for error cases.</p><p>Here are some examples of arithmetic expressions:</p> 
<ulist> 
<item> 
<p>The first expression below returns the <code>xs:decimal</code> value <code role="parse-test">-1.5</code>, and the second expression returns the <code>xs:integer</code> value <code role="parse-test">-1</code>:</p> 
<eg role="parse-test" xml:space="preserve">-3 div 2
-3 idiv 2</eg> 
 </item> 
<item> 
<p>Subtraction of two date values results in a value of type <code>xs:dayTimeDuration</code>:</p> 
<eg role="parse-test" xml:space="preserve">$emp/hiredate - $emp/birthdate</eg> 
</item> 
 
<item> 
<p>This example illustrates the difference between a subtraction operator and a
hyphen:</p> 
<eg role="parse-test" xml:space="preserve">$unit-price - $unit-discount</eg> 
</item> 
<item> 
<p>Unary operators have higher precedence than binary operators, subject of
course to the use of parentheses. Therefore, the following two examples have different meanings:</p> 
<eg xml:space="preserve">-$bellcost + $whistlecost
-($bellcost + $whistlecost)</eg> 
</item> 
</ulist>	
<note><p id="note-consecutive-unary-ops">Multiple consecutive unary arithmetic operators are permitted by XPath for compatibility with <bibref ref="XPath"/>.</p></note></div2>	
<div2 id="id-comparisons"> 
<head>Comparison Expressions</head> 
<p>Comparison expressions allow two values to be compared. XPath provides
three kinds of comparison expressions, called value comparisons, general
comparisons, and node comparisons.</p> 
<scrap headstyle="show"> 
<head/> <prod num="10" id="doc-xpath-ComparisonExpr"><lhs>ComparisonExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-RangeExpr" xlink:type="simple">RangeExpr</nt> ( (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ValueComp" xlink:type="simple">ValueComp</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-GeneralComp" xlink:type="simple">GeneralComp</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-NodeComp" xlink:type="simple">NodeComp</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-RangeExpr" xlink:type="simple">RangeExpr</nt> )?</rhs></prod>
<prod num="23" id="doc-xpath-ValueComp"><lhs>ValueComp</lhs><rhs>"eq"  |  "ne"  |  "lt"  |  "le"  |  "gt"  |  "ge"</rhs></prod><prod num="22" id="doc-xpath-GeneralComp"><lhs>GeneralComp</lhs><rhs>"="  |  "!="  |  "&lt;"  |  "&lt;="  |  "&gt;"  |  "&gt;="</rhs></prod> 
<prod num="24" id="doc-xpath-NodeComp"><lhs>NodeComp</lhs><rhs>"is"  |  "&lt;&lt;"  |  "&gt;&gt;"</rhs></prod> 
 
</scrap> 

<note role="xpath"><p role="xpath">When an XPath expression is written
within an XML document, the XML escaping rules for special characters
must be followed; thus "<code>&lt;</code>" must be written as
"<code>&amp;lt;</code>".</p> </note>


<div3 id="id-value-comparisons"> 
<head>Value Comparisons</head> 
<p>The value comparison operators are <code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>, and <code>ge</code>. Value comparisons are used for comparing single values.</p> 
<p>The first step in evaluating a value comparison is to evaluate its operands. The order in which the operands are evaluated is <termref def="dt-implementation-dependent">implementation-dependent</termref>. Each operand is evaluated by applying the following steps, in order:</p><olist><item><p><termref def="dt-atomization">Atomization</termref> is applied to the operand. The result of this
    operation is called the <term>atomized operand</term>.</p></item><item><p>If the atomized operand is an empty sequence, the result of
    the value comparison is an empty sequence, and the implementation
    need not evaluate the other operand or apply the operator. However,
    an implementation may choose to evaluate the other operand in order
    to determine whether it raises an error.</p></item><item><p> If the atomized operand is a sequence of
length greater than one, a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.</p></item><item><p>If the atomized operand is of type <code>xs:untypedAtomic</code>, it is cast to  <code>xs:string</code>.</p><note><p>The purpose of this rule is to make value comparisons transitive. Users should be aware that the general comparison operators have a different rule for casting of <code>xs:untypedAtomic</code> operands. Users should also be aware that transitivity of value comparisons may be compromised by loss of precision during type conversion (for example, two <code>xs:integer</code> values that differ slightly may both be considered equal to the same <code>xs:float</code> value because <code>xs:float</code> has less precision than <code>xs:integer</code>).</p></note></item></olist><p>Next, if possible, the two operands are converted to their least common 
type by a combination of <termref def="dt-type-promotion">type promotion</termref> and <termref def="dt-subtype-substitution">subtype substitution</termref>.  For 
example, if the operands are of type <code>hatsize</code> (derived from <code>xs:integer</code>) and 
<code>shoesize</code> (derived from <code>xs:float</code>), their least common type is <code>xs:float</code>.</p><p>Finally, if the types of the operands are a valid combination for the 
given operator, the operator is applied to the operands. The combinations of atomic types
that are accepted by the various value comparison operators, and their
respective result types, are listed in <specref ref="mapping"/>
together with the <termref def="dt-operator-function">operator functions</termref>
that define the semantics of the operator for each
type combination. The definitions of the operator functions are found in <bibref ref="FunctionsAndOperators"/>.</p><p>Informally, if both atomized operands consist of exactly one atomic
value, then the result of the comparison is <code>true</code> if the value of the
first operand is (equal, not equal, less than, less than or equal,
greater than, greater than or equal) to the value of the second
operand; otherwise the result of the comparison is <code>false</code>.</p><p>If the types of the operands, after evaluation, are not a valid combination for the given operator, according to the rules in <specref ref="mapping"/>, a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.</p> 
<p>Here are some examples of value comparisons:</p> 
<ulist> 
<item> 
<p>The following comparison atomizes the node(s) that are returned by the expression <code>$book/author</code>. The comparison is true only if the result of atomization is the value "Kennedy" as an instance of <code>xs:string</code> or <code>xs:untypedAtomic</code>. If the result of atomization is an empty sequence, the result of the comparison is an empty sequence. If the result of atomization is a sequence containing more than one value, a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.</p> 
<eg role="parse-test" xml:space="preserve">$book1/author eq "Kennedy"</eg> 
</item><item><p>The following <termref def="dt-path-expression">path expression</termref> contains a predicate that selects products whose weight is greater than 100. For any product that does not have a <code>weight</code> subelement, the value of the predicate is the empty sequence, and the product is not selected. This example assumes that <code>weight</code> is a validated element with a numeric type.</p><eg role="parse-test" xml:space="preserve">//product[weight gt 100]</eg></item><item><p>The following comparison is true if <code>my:hatsize</code> and <code>my:shoesize</code> are both user-defined types that are derived by restriction from a primitive <termref def="dt-numeric">numeric</termref> type:</p><eg role="parse-test" xml:space="preserve">my:hatsize(5) eq my:shoesize(5)</eg></item> 
<item><p>The following comparison is true. The <code>eq</code> operator compares two QNames by performing codepoint-comparisons of their namespace URIs and their local names, ignoring their namespace prefixes.</p><eg role="parse-test" xml:space="preserve">fn:QName("http://example.com/ns1", "this:color")
   eq fn:QName("http://example.com/ns1", "that:color")</eg></item></ulist> 
</div3> 
<div3 id="id-general-comparisons"> 
<head>General Comparisons</head> 
<p>The general comparison operators are <code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>. General comparisons are existentially quantified comparisons that may be applied to operand sequences of any length. The result of a general comparison that does not raise an error is 
always <code>true</code> or <code>false</code>.</p><p role="xpath">If <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref> is <code>true</code>, a general comparison is evaluated by applying the following rules, in order:</p><olist role="xpath"><item><p>If either operand is a single atomic value that is an instance of
<code>xs:boolean</code>, then the other operand is converted to <code>xs:boolean</code> by taking its
<termref def="dt-ebv">effective boolean value</termref>.</p></item><item><p><termref def="dt-atomization">Atomization</termref> is applied to each operand. After atomization, each operand is a sequence of atomic values.</p></item><item><p>If the comparison operator is <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, or <code>&gt;=</code>, then each item in both of the
operand sequences is converted to the type  <code>xs:double</code> by applying the
<code>fn:number</code> function. (Note that <code>fn:number</code> returns the value <code>NaN</code> if its operand cannot be converted to a number.)</p></item><item><p>The result of the comparison is <code>true</code> if and only if there is a pair of
atomic values, one in the first operand sequence and the other in the second operand sequence, that have the required
<term>magnitude relationship</term>. Otherwise the result of the  comparison is
<code>false</code>. The <term>magnitude relationship</term> between two atomic values is determined by
applying the following rules. If a <code>cast</code> operation called for by these rules is not successful, a dynamic error is raised. [err:FORG0001]</p><olist><item><p>If at least one of the two atomic values is an instance of a <termref def="dt-numeric">numeric</termref> type, then both atomic values are converted to the type <code>xs:double</code> by
applying the <code>fn:number</code> function.</p></item><item><p>If at least one of the two atomic values is an instance of <code>xs:string</code>,
or if both atomic values are instances of <code>xs:untypedAtomic</code>, then both
atomic values are cast to the type <code>xs:string</code>.</p></item><item><p>If one of the atomic values is an instance of <code>xs:untypedAtomic</code> and the other is not an instance of <code>xs:string</code>, <code>xs:untypedAtomic</code>, or any <termref def="dt-numeric">numeric</termref> type, then the <code>xs:untypedAtomic</code> value is
cast to the <termref def="dt-dynamic-type">dynamic type</termref> of the other value.</p></item><item><p>After performing the conversions described above, the atomic values are
compared using one of the value comparison operators <code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>, or
<code>ge</code>, depending on whether the general comparison operator was <code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>,
<code>&gt;</code>, or <code>&gt;=</code>. The values have the required <term>magnitude relationship</term> if and only if the result
of this value comparison is <code>true</code>.</p></item></olist></item></olist><p><phrase role="xpath">If <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref> is <code>false</code>, a</phrase> general comparison is evaluated by applying the following rules, in order:</p><olist><item><p><termref def="dt-atomization">Atomization</termref> is applied to each operand. After atomization, each operand is a sequence of atomic values.</p></item><item><p>The result of the comparison is <code>true</code> if and only if there is a pair of
atomic values, one in the first operand sequence and the other in the second operand sequence, that have the required
<term>magnitude relationship</term>. Otherwise the result of the  comparison is
<code>false</code>. The <term>magnitude relationship</term> between two atomic values is determined by
applying the following rules. If a <code>cast</code> operation called for by these rules is not successful, a dynamic error is raised. [err:FORG0001]</p><olist><item><p>If one of the atomic values is an instance of <code>xs:untypedAtomic</code> and the other is an instance of a <termref def="dt-numeric">numeric</termref> type, then the <code>xs:untypedAtomic</code> value is cast to the type <code>xs:double</code>.</p></item><item><p>If one of the atomic values is an instance of <code>xs:untypedAtomic</code> and the other is an instance of <code>xs:untypedAtomic</code> or <code>xs:string</code>, then the <code>xs:untypedAtomic</code> value (or values) is (are) cast to the type <code>xs:string</code>.</p></item><item><p>If one of the atomic values is an instance of <code>xs:untypedAtomic</code> and the other is not an instance of <code>xs:string</code>, <code>xs:untypedAtomic</code>, or any <termref def="dt-numeric">numeric</termref> type, then the <code>xs:untypedAtomic</code> value is
cast to the <termref def="dt-dynamic-type">dynamic type</termref> of the other value.</p></item><item><p>After performing the conversions described above, the atomic values are
compared using one of the value comparison operators <code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>, or
<code>ge</code>, depending on whether the general comparison operator was <code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>,
<code>&gt;</code>, or <code>&gt;=</code>. The values have the required <term>magnitude relationship</term> if and only if the result
of this value comparison is <code>true</code>.</p></item></olist></item></olist><p>When evaluating a general comparison in which either operand is a sequence of items, an implementation may return <code>true</code> as soon as it finds an item in the first operand and an item in the second operand that have the required <term>magnitude relationship</term>. Similarly, a general comparison may raise a <termref def="dt-dynamic-error">dynamic error</termref> as soon as it encounters an error in evaluating either operand, or in comparing a pair of items from the two operands. As a result of these rules, the result of a general comparison is not deterministic in the presence of errors.</p> 
 
 
<p>Here are some examples of  general comparisons:</p> 
<ulist> 
<item> 
<p>The following comparison is true if the <termref def="dt-typed-value">typed value</termref> of any
<code>author</code> subelement of <code>$book1</code> is "Kennedy" as an instance of <code>xs:string</code> or <code>xs:untypedAtomic</code>:</p>
<eg role="parse-test" xml:space="preserve">$book1/author = "Kennedy"</eg> 
</item><item><p>The following example contains three general comparisons. The value of the first two comparisons is <code>true</code>, and the value of the third comparison is <code>false</code>. This example illustrates the fact that general comparisons are not transitive.</p><eg xml:space="preserve">(1, 2) = (2, 3)
(2, 3) = (3, 4)
(1, 2) = (3, 4)</eg></item><item><p>The following example contains two general comparisons, both of which are <code>true</code>. This example illustrates the fact that the <code>=</code> and <code>!=</code> operators are not inverses of each other.</p><eg xml:space="preserve">(1, 2) = (2, 3)
(1, 2) != (2, 3)</eg></item><item><p>Suppose that <code>$a</code>, <code>$b</code>, and <code>$c</code> are bound to element nodes with type annotation <code>xs:untypedAtomic</code>, with <termref def="dt-string-value">string values</termref> "<code>1</code>", "<code>2</code>", and "<code>2.0</code>" respectively. Then <code>($a, $b) = ($c, 3.0)</code> returns <code>false</code>, because <code>$b</code> and <code>$c</code> are compared as strings. However, <code>($a, $b) = ($c, 2.0)</code> returns <code>true</code>, because <code>$b</code> and <code>2.0</code> are compared as numbers.</p></item> 
</ulist> 
</div3> 
<div3 id="id-node-comparisons"> 
<head>Node Comparisons</head> 
<p>Node comparisons are used to compare two nodes, by their identity or by their <termref def="dt-document-order">document order</termref>. The result of a node comparison is defined by the following rules:</p> 
<olist> 
<item> 
<p>The operands of a node comparison are evaluated in <termref def="dt-implementation-dependent">implementation-dependent</termref> order.</p></item> 
<item> 
<p>If either operand is an empty sequence, the result of the
    comparison is an empty sequence, and the implementation need not
    evaluate the other operand or apply the operator. However, an
    implementation may choose to evaluate the other operand in order to
    determine whether it raises an error.</p> 
</item> 
<item><p> Each operand must be either a single node or an empty sequence; otherwise
a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.</p> 
</item><item> 
<p>A comparison with the <code>is</code> operator is <code>true</code> if the two operand nodes have the same identity, and are thus the same node; otherwise it
is <code>false</code>. See <bibref ref="datamodel"/> for a definition of node identity.</p> 
</item> 
<item> 
<p>A comparison with the <code>&lt;&lt;</code> operator returns <code>true</code> if the left operand node precedes the right operand node in
<termref def="dt-document-order">document order</termref>; otherwise it returns <code>false</code>.</p> 
</item> 
<item> 
<p>A comparison with the <code>&gt;&gt;</code> operator returns <code>true</code> if the left operand node follows the right operand node in
<termref def="dt-document-order">document order</termref>; otherwise it returns <code>false</code>.</p> 
</item></olist> 
<p>Here are some examples of node comparisons:</p> 
<ulist> 
<item> 
<p>The following comparison is true only if the left and right sides each
evaluate to exactly the same single node:</p> 
<eg role="parse-test" xml:space="preserve">/books/book[isbn="1558604820"] is /books/book[call="QA76.9 C3845"]</eg> 
</item> 
<item> 
<p>The following comparison is true only if the node identified by the left
side occurs before the node identified by the right side in document order:</p>
<eg role="parse-test" xml:space="preserve">/transactions/purchase[parcel="28-451"] 
   &lt;&lt; /transactions/sale[parcel="33-870"]</eg> 
</item></ulist> 
</div3> 
	
</div2>	
<div2 id="id-logical-expressions"> 
<head>Logical Expressions</head> 
<p>A <term>logical expression</term> is either an <term>and-expression</term> or
an <term>or-expression</term>. If a logical expression does not raise an error, its value is always one
of the boolean values <code>true</code> or <code>false</code>.</p> 
<scrap headstyle="show"> 
<head/> <prod num="8" id="doc-xpath-OrExpr"><lhs>OrExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AndExpr" xlink:type="simple">AndExpr</nt> ( "or"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AndExpr" xlink:type="simple">AndExpr</nt> )*</rhs></prod> 
<prod num="9" id="doc-xpath-AndExpr"><lhs>AndExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ComparisonExpr" xlink:type="simple">ComparisonExpr</nt> ( "and"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ComparisonExpr" xlink:type="simple">ComparisonExpr</nt> )*</rhs></prod> 
</scrap> 
<p>The first step in evaluating a logical expression is to find the  <termref def="dt-ebv">effective boolean value</termref> of each of its operands (see <specref ref="id-ebv"/>).</p> 
 
<p>The value of an and-expression is determined by the effective
boolean values (EBV's) of its operands, as shown in the following table:</p><table border="1" cellpadding="4" cellspacing="1" width="80%" summary="AND EBV"><tbody><tr><td rowspan="1" colspan="1">AND:</td><td rowspan="1" colspan="1">EBV<sub>2</sub> =
<code>true</code></td><td rowspan="1" colspan="1">EBV<sub>2</sub> = <code>false</code></td><td rowspan="1" colspan="1">error in EBV<sub>2</sub>
</td></tr><tr><td rowspan="1" colspan="1">EBV<sub>1</sub> =
<code>true</code></td><td rowspan="1" colspan="1"><code>true</code></td><td rowspan="1" colspan="1"><code>false</code></td><td rowspan="1" colspan="1">error</td></tr><tr><td rowspan="1" colspan="1">EBV<sub>1</sub>
= <code>false</code></td><td rowspan="1" colspan="1"><code>false</code></td><td rowspan="1" colspan="1"><code>false</code></td><td rowspan="1" colspan="1"><phrase role="xpath">if <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref> is <code>true</code>, then <code>false</code>; otherwise either <code>false</code> or error.</phrase></td></tr><tr><td rowspan="1" colspan="1">error in EBV<sub>1</sub>
</td><td rowspan="1" colspan="1">error</td><td rowspan="1" colspan="1"><phrase role="xpath">if <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref> is <code>true</code>, then error; otherwise either <code>false</code> or error.</phrase></td><td rowspan="1" colspan="1">error</td></tr></tbody></table><p>The value of an
or-expression is determined by the effective boolean values (EBV's) of
its operands, as shown in
the following table:</p><table border="1" cellpadding="4" cellspacing="1" width="80%" summary="OR EBV"><tbody><tr><td rowspan="1" colspan="1">OR:</td><td rowspan="1" colspan="1">EBV<sub>2</sub> =
<code>true</code></td><td rowspan="1" colspan="1">EBV<sub>2</sub> = <code>false</code></td><td rowspan="1" colspan="1">error in
EBV<sub>2</sub></td></tr><tr><td rowspan="1" colspan="1">EBV<sub>1</sub> =
<code>true</code></td><td rowspan="1" colspan="1"><code>true</code></td><td rowspan="1" colspan="1"><code>true</code></td><td rowspan="1" colspan="1"><phrase role="xpath">if <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref> is <code>true</code>, then <code>true</code>; otherwise either <code>true</code> or error.</phrase></td></tr><tr><td rowspan="1" colspan="1">EBV<sub>1</sub> =
<code>false</code></td><td rowspan="1" colspan="1"><code>true</code></td><td rowspan="1" colspan="1"><code>false</code></td><td rowspan="1" colspan="1">error</td></tr><tr><td rowspan="1" colspan="1">error
in EBV<sub>1</sub></td><td rowspan="1" colspan="1"><phrase role="xpath">if <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref> is <code>true</code>, then error; otherwise either <code>true</code> or error.</phrase></td><td rowspan="1" colspan="1">error</td><td rowspan="1" colspan="1">error</td></tr></tbody></table><p role="xpath">If <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref> is <code>true</code>, the order in which the operands of a logical expression are evaluated is effectively prescribed. Specifically, it is defined that when there is no
need to evaluate the second operand in order to determine the result, then
no error can occur as a result of evaluating the second operand.</p><p><phrase role="xpath">If <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref> is <code>false</code>, the
order in which the operands of a logical expression are evaluated is
<termref def="dt-implementation-dependent">implementation-dependent</termref>. In this case,</phrase> an or-expression can return <code>true</code> if the first
expression evaluated is true, and it can raise an error if evaluation
of the first expression raises an error. Similarly, an and-expression
can return <code>false</code> if the first expression evaluated is
false, and it can raise an error if evaluation of the first expression
raises an error. As a result of these rules, a logical expression is
not deterministic in the presence of errors, as illustrated in the examples
below.</p><p>Here are some examples of logical expressions:</p>
 
<ulist><item><p>The following expressions return
<code>true</code>:</p><eg role="parse-test" xml:space="preserve">1 eq 1 and 2 eq 2</eg><eg role="parse-test" xml:space="preserve">1 eq 1 or 2 eq 3</eg></item><item><p>The following
expression may return either <code>false</code> or raise a <termref def="dt-dynamic-error">dynamic error</termref><phrase role="xpath"> (in <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref>, the result must be <code>false</code>)</phrase>:</p><eg role="parse-test" xml:space="preserve">1 eq 2 and 3 idiv 0 = 1</eg></item><item><p>The
following expression may return either <code>true</code> or raise a
<termref def="dt-dynamic-error">dynamic error</termref><phrase role="xpath"> (in <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref>, the result must be <code>true</code>)</phrase>:</p><eg role="parse-test" xml:space="preserve">1 eq 1 or 3 idiv 0 = 1</eg></item><item><p>The
following expression must raise a <termref def="dt-dynamic-error">dynamic error</termref>:</p><eg role="parse-test" xml:space="preserve">1 eq 1 and 3 idiv 0 = 1</eg></item></ulist>

<p>In addition to and- and or-expressions, XPath provides a
function named <code>fn:not</code> that takes a general sequence as
parameter and returns a boolean value.  The <code>fn:not</code> function
is defined in <bibref ref="FunctionsAndOperators"/>. The
<code>fn:not</code> function reduces its parameter to an <termref def="dt-ebv">effective boolean value</termref>. It then returns
<code>true</code> if the effective boolean value of its parameter is
<code>false</code>, and <code>false</code> if the effective boolean
value of its parameter is <code>true</code>. If an error is
encountered in finding the effective boolean value of its operand,
<code>fn:not</code> raises the same error.</p>

	
</div2>	
	
<div2 role="xpath" id="id-for-expressions"><head>For Expressions</head><p>XPath provides an iteration facility called a <term>for expression</term>.</p><scrap headstyle="show"> 
<head/> 
 
<prod num="4" id="doc-xpath-ForExpr"><lhs>ForExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SimpleForClause" xlink:type="simple">SimpleForClause</nt>  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod> 
<prod num="5" id="doc-xpath-SimpleForClause"><lhs>SimpleForClause</lhs><rhs>"for"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-VarName" xlink:type="simple">VarName</nt>  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-VarName" xlink:type="simple">VarName</nt>  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs></prod></scrap><p>A <code>for</code> expression is evaluated as follows:</p><olist><item><p>If the <code>for</code> expression uses multiple variables, it is first expanded to a set of nested <code>for</code> expressions, each of which uses only one variable. For example, the expression
<code>for $x in X, $y in Y return $x + $y</code>
is expanded to
<code>for $x in X return 
    for $y in Y return $x + $y</code>.</p></item><item><p>In a single-variable <code>for</code> expression, the variable is called the <term>range variable</term>, the value of the expression that follows the <code>in</code> keyword is called the <term>binding sequence</term>, and the expression that follows the <code>return</code> keyword is called the <term>return expression</term>. The result of the <code>for</code> expression is obtained by evaluating the <code>return</code> expression once for each item in the binding sequence, with the range variable bound to that item. The resulting sequences  are concatenated (as if by the <termref def="dt-comma-operator">comma operator</termref>) in the order of the items in the binding sequence from which they were derived. 
</p></item></olist><p role="xpath">The following example illustrates the use of a <code>for</code> expression in restructuring an input document. The example is based on the following
input:</p> 
<eg xml:space="preserve">&lt;bib&gt;
  &lt;book&gt;
    &lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Advanced Programming in the Unix Environment&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Data on the Web&lt;/title&gt;
    &lt;author&gt;Abiteboul&lt;/author&gt;
    &lt;author&gt;Buneman&lt;/author&gt;
    &lt;author&gt;Suciu&lt;/author&gt;
  &lt;/book&gt;
&lt;/bib&gt;</eg>



<p>The following example transforms the input document into a list in
which each author's name appears only once, followed by a list of
titles of books written by that author. This example assumes that the
context item is the <code>bib</code> element in the input
document.</p>


<eg role="parse-test" xml:space="preserve"><phrase role="parse-test">for $a in fn:distinct-values(book/author)
return (book/author[. = $a][1], book[author = $a]/title)</phrase></eg><p>The result of the above
	expression consists of the following sequence of elements. The
	titles of books written by a given author are listed after the
	name of the author.

The ordering of <code>author</code> elements in the result is <termref def="dt-implementation-dependent">implementation-dependent</termref> due to the semantics of the <code>fn:distinct-values</code> function.</p><eg xml:space="preserve">&lt;author&gt;Stevens&lt;/author&gt; 
&lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
&lt;title&gt;Advanced Programming in the Unix environment&lt;/title&gt;
&lt;author&gt;Abiteboul&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
&lt;author&gt;Buneman&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
&lt;author&gt;Suciu&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;</eg><p>The following example illustrates a <code>for</code> expression containing more than one variable:</p><eg role="parse-test" xml:space="preserve"><phrase role="parse-test">for $i in (10, 20),
    $j in (1, 2)
return ($i + $j)</phrase></eg><p>The result of the above expression, expressed as a sequence of numbers, is as follows: <code>11, 12, 21, 22</code></p><p>The scope of a variable bound in a <code>for</code> expression comprises all subexpressions of the <code>for</code> expression
that appear after the variable binding. The scope does not
include the expression to which the variable is bound. The following example illustrates how a variable binding may reference another variable bound earlier in the same  <code>for</code> expression:</p><eg role="parse-test" xml:space="preserve"><phrase role="parse-test">for $x in $z, $y in f($x)
return g($x, $y)</phrase></eg>

 
<note><p>The focus for evaluation of the <code>return</code> clause of a <code>for</code> expression
is the same as the focus for evaluation of the <code>for</code> expression itself. The
following example, which attempts to find the total value of a set of
order-items, is therefore incorrect:

</p><eg role="error" xml:space="preserve">fn:sum(for $i in order-item return @price *
@qty)</eg><p> 

Instead, the expression must be written to use the variable bound in the <code>for</code> clause:</p><eg role="parse-test" xml:space="preserve">fn:sum(for $i in order-item
    return $i/@price * $i/@qty)</eg></note>



</div2>

	
	
<div2 id="id-conditionals"> 
<head>Conditional Expressions</head> 
<p>XPath supports a conditional expression based on the keywords <code>if</code>, <code>then</code>, and <code>else</code>.</p> 
<scrap headstyle="show"> 
<head/> <prod num="7" id="doc-xpath-IfExpr"><lhs>IfExpr</lhs><rhs>"if"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Expr" xlink:type="simple">Expr</nt>  ")"  "then"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>  "else"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod> 
</scrap> 
<p>The expression following the <code>if</code> keyword is called the <term>test expression</term>, and the expressions
following the <code>then</code> and <code>else</code> keywords are called the <term>then-expression</term> and <term>else-expression</term>, respectively.</p> 
<p>The first step in processing a conditional expression is to find
the <termref def="dt-ebv">effective boolean value</termref> of the test expression, as defined in <specref ref="id-ebv"/>.</p> 
 
<p>The value of a conditional expression is defined as follows: If the
effective boolean value of the test expression is <code>true</code>, the value of the then-expression is returned. If the
effective boolean value of the test expression is <code>false</code>,
the value of the else-expression is returned.</p><p>Conditional expressions have a special rule for propagating <termref def="dt-dynamic-error">dynamic errors</termref>. If the effective value of the test expression is <code>true</code>, the conditional expression ignores (does not raise) any dynamic errors encountered in the else-expression. In this case, since the else-expression can have no observable effect, it need not be evaluated. Similarly, if the effective value of the test expression is <code>false</code>, the conditional expression ignores any <termref def="dt-dynamic-error">dynamic errors</termref> encountered in the then-expression, and the then-expression need not be evaluated.</p> 
<p>Here are some examples of conditional expressions:</p> 
<ulist> 
<item> 
<p>In this example, the test expression is a comparison expression:</p> 
<eg role="parse-test" xml:space="preserve">if ($widget1/unit-cost &lt; $widget2/unit-cost) 
  then $widget1
  else $widget2</eg> 
</item> 
<item> 
<p>In this example, the test expression tests for the existence of an attribute
named <code>discounted</code>, independently of its value:</p> 
<eg role="parse-test" xml:space="preserve">if ($part/@discounted) 
  then $part/wholesale 
  else $part/retail</eg> 
</item> 
</ulist>	
</div2>	
<div2 id="id-quantified-expressions">
<head>Quantified Expressions</head> 
<p>Quantified expressions support existential and universal quantification. The
value of a quantified expression is always <code>true</code> or <code>false</code>.</p>
<scrap headstyle="show">
<head/> 
<prod num="6" id="doc-xpath-QuantifiedExpr"><lhs>QuantifiedExpr</lhs><rhs>("some"  |  "every")  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-VarName" xlink:type="simple">VarName</nt>  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-VarName" xlink:type="simple">VarName</nt>  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>)*  "satisfies"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod>
</scrap>
<p>A <term>quantified expression</term> begins with
a <term>quantifier</term>, which is the keyword <code>some</code> or <code>every</code>, followed by one or more in-clauses that are used to bind variables,
followed by the keyword <code>satisfies</code> and a test expression. Each in-clause associates a variable with an
expression that returns a sequence of items, called the <term>binding sequence</term> for that variable. The in-clauses generate tuples of variable bindings, including a tuple for each combination of items in the binding sequences of the respective variables. Conceptually, the test expression is evaluated for each
tuple of variable bindings. Results depend on the <termref def="dt-ebv">effective boolean value</termref> of the test expressions, as defined in <specref ref="id-ebv"/>. The value of the quantified expression is defined
by the following rules:</p>
<olist>
<item>
<p>If the quantifier is <code>some</code>, the quantified expression is <code>true</code> if at least one evaluation of the test expression has the <termref def="dt-ebv">effective boolean value</termref> <code>true</code>; otherwise the quantified expression is <code>false</code>. This rule implies that, if the in-clauses generate zero binding
tuples, the value of the quantified expression is <code>false</code>.</p>
</item>
<item>
<p>If the quantifier is <code>every</code>, the quantified expression is <code>true</code> if every evaluation of the test expression has the <termref def="dt-ebv">effective boolean value</termref> <code>true</code>; otherwise the quantified expression is <code>false</code>. This rule implies that, if the in-clauses generate zero binding
tuples, the value of the quantified 
expression is <code>true</code>.</p>
</item>
</olist>


<p>The scope of a variable bound in a quantified expression comprises all
subexpressions of the quantified expression that appear after the variable binding. The scope does not include the expression to which the variable is bound.
</p><p>The order in which test expressions are evaluated for the various binding
tuples is <termref def="dt-implementation-dependent">implementation-dependent</termref>. If the quantifier 
is <code>some</code>, an implementation may 
return <code>true</code> as soon as it finds one binding tuple for which the test expression has
an <termref def="dt-ebv">effective boolean value</termref> of <code>true</code>, and it may raise a <termref def="dt-dynamic-error">dynamic error</termref> as soon as it finds one binding tuple for
which the test expression raises an error. Similarly, if the quantifier is <code>every</code>, an implementation may return <code>false</code> as soon as it finds one binding tuple for which the test expression has
an <termref def="dt-ebv">effective boolean value</termref> of <code>false</code>, and it may raise a <termref def="dt-dynamic-error">dynamic error</termref> as soon as it finds one binding tuple for
which the test expression raises an error. As a result of these rules, the
value of a quantified expression is not deterministic in the presence of
errors, as illustrated in the examples below.</p>
<p>Here are some examples of quantified expressions:</p>
<ulist>
<item>
<p>This expression is <code>true</code> if every <code>part</code> element has a <code>discounted</code> attribute (regardless of the values of these attributes):</p> 
<eg role="parse-test" xml:space="preserve">every $part in /parts/part satisfies $part/@discounted</eg>
</item> 
<item>
<p>This expression is <code>true</code> if at least 
one <code>employee</code> element satisfies the given comparison expression:</p> 
<eg role="parse-test" xml:space="preserve">some $emp in /emps/employee satisfies 
     ($emp/bonus &gt; 0.25 * $emp/salary)</eg>
</item>
<item>
<p>In the following examples, each quantified expression evaluates its test
expression over nine tuples of variable bindings, formed from the Cartesian
product of the sequences <code>(1, 2, 3)</code> and <code>(2, 3, 4)</code>. The expression beginning with <code>some</code> evaluates to <code>true</code>, and the expression beginning with <code>every</code> evaluates to <code>false</code>.</p>
<eg role="parse-test" xml:space="preserve"><phrase role="parse-test">some $x in (1, 2, 3), $y in (2, 3, 4) 
     satisfies $x + $y = 4</phrase></eg><eg role="parse-test" xml:space="preserve"><phrase role="parse-test">every $x in (1, 2, 3), $y in (2, 3, 4) 
     satisfies $x + $y = 4</phrase></eg>
</item>
<item>
<p>This quantified expression may either return  <code>true</code> or raise a <termref def="dt-type-error">type error</termref>, since its test expression returns <code>true</code> for one variable binding 
and raises a <termref def="dt-type-error">type error</termref> for another:</p>
<eg role="parse-test" xml:space="preserve">some $x in (1, 2, "cat") satisfies $x * 2 = 4</eg>
</item>
<item>
<p>This quantified expression may either return <code>false</code> or raise a <termref def="dt-type-error">type error</termref>, since its test expression returns <code>false</code> for one variable binding and raises a <termref def="dt-type-error">type error</termref> for another:</p>
<eg role="parse-test" xml:space="preserve">every $x in (1, 2, "cat") satisfies $x * 2 = 4</eg>
</item> 
</ulist>
</div2> 
<div2 id="id-expressions-on-datatypes"> 
<head>Expressions on SequenceTypes</head> 
<p><termref def="dt-sequence-type">sequence types</termref> are used in <code>instance of</code>,  <code>cast</code>, <code>castable</code>, and <code>treat</code> expressions.</p> 
 
 
 
 
 
 
 
 
<div3 id="id-instance-of"><head>Instance Of</head><scrap headstyle="show"> 
<head/> 
<prod num="16" id="doc-xpath-InstanceofExpr"><lhs>InstanceofExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TreatExpr" xlink:type="simple">TreatExpr</nt> ( "instance"  "of"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SequenceType" xlink:type="simple">SequenceType</nt> )?</rhs></prod>    
</scrap><p>The boolean 
operator <code>instance of</code> 
returns <code>true</code> if the value of its first operand matches
the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SequenceType" xlink:type="simple">SequenceType</nt> in its second
operand, according to the rules for <termref def="dt-sequencetype-matching">SequenceType
matching</termref>; otherwise it returns <code>false</code>. For example:</p> 
<ulist><item><p><code role="parse-test">5 instance of xs:integer</code></p><p>This example returns <code>true</code> because the given value is an instance of the given type.</p></item><item><p><code>5 instance of xs:decimal</code></p><p>This example returns <code>true</code> because the given value is an integer literal, and <code>xs:integer</code> is derived by restriction from <code>xs:decimal</code>.</p></item><item><p><code>(5, 6) instance of xs:integer+</code></p><p>This example returns <code>true</code> because the given sequence contains two integers, and is a valid instance of the specified type.</p></item><item><p><code role="parse-test">. instance of element()</code></p><p>This example returns <code>true</code> if the context item is an element node or <code>false</code> if the context item is defined but is not an element node. If the context item is undefined, a <termref def="dt-dynamic-error">dynamic error</termref> is raised <errorref class="DY" code="0002"/>.</p></item></ulist></div3><div3 id="id-cast"><head>Cast</head><scrap headstyle="show"> 
<head/> 
   <prod num="19" id="doc-xpath-CastExpr"><lhs>CastExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-UnaryExpr" xlink:type="simple">UnaryExpr</nt> ( "cast"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SingleType" xlink:type="simple">SingleType</nt> )?</rhs></prod> 
<prod num="49" id="doc-xpath-SingleType"><lhs>SingleType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AtomicType" xlink:type="simple">AtomicType</nt>  "?"?</rhs></prod></scrap><p>Occasionally
it is necessary to convert a value to a specific datatype. For this
purpose, XPath provides a <code>cast</code> expression that
creates a new value of a specific type based on an existing value. A
<code>cast</code> expression takes two operands: an <term>input
expression</term> and a <term>target type</term>. The type of the
input expression is called the <term>input type</term>. The target
type must be an atomic type that is in the <termref def="dt-is-types">in-scope schema types</termref> <errorref class="ST" code="0051"/>. In addition, the target type cannot be <code>xs:NOTATION</code> or <code>xs:anyAtomicType</code> <errorref class="ST" code="0080"/>. The optional occurrence indicator "<code>?</code>" denotes that an empty
sequence is permitted. If the target type has no namespace prefix, it
is considered to be in the <termref def="dt-def-elemtype-ns">default element/type
namespace</termref>. The semantics of the <code>cast</code> expression
are as follows:</p><olist><item><p><termref def="dt-atomization">Atomization</termref> is performed on the input
expression.</p></item><item><p> If the result of atomization is a
sequence of more than one atomic value, a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.</p></item><item><p>If the result
of atomization is an empty sequence:</p><olist><item><p>If
<code>?</code> is specified after the target type, the result of the
<code>cast</code> expression is an empty sequence.</p></item><item><p>
If <code>?</code> is not specified after the target type, a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.</p></item></olist></item><item>
<p>If the result of atomization is a single atomic value, the result
of the cast expression depends on the input type and the target
type. In general, the cast expression attempts to create a new value
of the target type based on the input value. Only certain combinations
of input type and target type are supported. A summary of the rules
are listed below— the normative definition of these rules is
given in <bibref ref="FunctionsAndOperators"/>. For the purpose of
these rules, an implementation may determine
that one type is derived by restriction from another type either by examining the <termref def="dt-issd">in-scope schema definitions</termref> or by using an
alternative, <termref def="dt-implementation-dependent">implementation-dependent</termref> mechanism such as a data
dictionary.</p>

<olist><item><p><code>cast</code> is supported for the combinations of
input type and target type listed in <xspecref spec="FO" ref="casting-from-primitive-to-primitive"/>. For each of these combinations, both
the input type and the target type are primitive <termref def="dt-schema-type">schema types</termref>. For
example, a value of type <code>xs:string</code> can be cast into the
schema type <code>xs:decimal</code>. For each of these built-in combinations,
the semantics of casting are specified in <bibref ref="FunctionsAndOperators"/>.</p><p>If the target type of a <code>cast</code> expression is <code>xs:QName</code>, or is a type that is derived from <code>xs:QName</code> or <code>xs:NOTATION</code>, and if the base type of the input is
not the same as the base type of the target type, then the  input expression must be a string
literal <errorref code="0004" class="TY"/>.</p><note><p>The reason for this rule is that construction of an instance of one of these target types from a string requires knowledge about namespace bindings. If the input expression is a non-literal string, it might be derived from an input document whose namespace bindings are different from the <termref def="dt-static-namespaces">statically known namespaces</termref>.</p></note></item><item><p><code>cast</code> is
supported if the input type is a non-primitive atomic type that is derived by restriction from the target
type. In this case, the input value
is mapped into the value space of the target type, unchanged except
for its type. For example, if <code>shoesize</code> is derived by
restriction from <code>xs:integer</code>, a value of type
<code>shoesize</code> can be cast into the schema type
<code>xs:integer</code>.</p></item><item><p><code>cast</code> is
supported if the target type is a non-primitive atomic type and the input
type is <code>xs:string</code> or <code>xs:untypedAtomic</code>. The
input value is first converted to a value in the lexical space of the
target type by applying the whitespace normalization rules for the
target type (as defined in <bibref ref="XMLSchema"/>); a <termref def="dt-dynamic-error">dynamic error</termref> [err:FORG0001]
is raised if the resulting lexical value does not satisfy the pattern
facet of the target type. The lexical value is then converted to the
value space of the target type using the schema-defined rules for the
target type; a <termref def="dt-dynamic-error">dynamic error</termref> [err:FORG0001]
is raised if the resulting value does not satisfy all the facets of
the target type.</p></item><item><p><code>cast</code> is supported if
the target type is a non-primitive atomic type that is derived by restriction from the input type. The input value must satisfy all the
facets of the target type (in the case of the pattern facet, this is
checked by generating a string representation of the input value,
using the rules for casting to <code>xs:string</code>). The resulting
value is the same as the input value, but with a different <termref def="dt-dynamic-type">dynamic type</termref>.</p></item><item><p>If a primitive type P1 can be cast into a
primitive type P2, then any type derived by restriction from P1 can be cast into any type derived by restriction from P2, provided that the facets of the target type are
satisfied. First the input value is cast to P1 using rule (b)
above. Next, the value of type P1 is cast to the type P2, using rule
(a) above. Finally, the value of type P2 is cast to the target type,
using rule (d) above.</p></item><item><p> For any combination of input
type and target type that is not in the above list, a
<code>cast</code> expression raises a <termref def="dt-type-error">type error</termref> <errorref class="TY" code="0004"/>.</p></item></olist>

</item></olist><p> If casting from the input type to the target type is supported but nevertheless it is not possible to cast the input value into the value space of the target type, a <termref def="dt-dynamic-error">dynamic error</termref> is raised. [err:FORG0001] This includes the case when any facet of the target type is not satisfied. For example, the expression <code>"2003-02-31" cast as xs:date</code> would raise a <termref def="dt-dynamic-error">dynamic error</termref>.</p> 
</div3><div3 id="id-castable"><head>Castable</head><scrap headstyle="show"> 
<head/> 
    
<prod num="18" id="doc-xpath-CastableExpr"><lhs>CastableExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-CastExpr" xlink:type="simple">CastExpr</nt> ( "castable"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SingleType" xlink:type="simple">SingleType</nt> )?</rhs></prod><prod num="49" id="noid_N149B5.doc-xpath-SingleType"><lhs>SingleType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AtomicType" xlink:type="simple">AtomicType</nt>  "?"?</rhs></prod></scrap><p>XPath
provides an expression that tests whether a given value
is castable into a given target type. The target
type must be an atomic type that is in the <termref def="dt-is-types">in-scope schema types</termref> <errorref class="ST" code="0051"/>. In addition, the target type cannot be <code>xs:NOTATION</code> or <code>xs:anyAtomicType</code> <errorref class="ST" code="0080"/>. The optional occurrence indicator "<code>?</code>" denotes that an empty
sequence is permitted. </p><p>The expression <code>V castable
as T</code> returns <code>true</code> if the value <code>V</code> can
be successfully cast into the target type <code>T</code> by using a
<code>cast</code> expression; otherwise it returns
<code>false</code>. The <code>castable</code> expression can be used as a <termref def="dt-predicate">predicate</termref>  to
avoid errors at evaluation time. It can also be used to select an
appropriate type for processing of a given value, as illustrated in
the following example:</p>
<eg role="parse-test" xml:space="preserve">
if ($x castable as hatsize) 
   then $x cast as hatsize 
   else if ($x castable as IQ) 
   then $x cast as IQ 
   else $x cast as xs:string</eg><note><p>If the target type of a <code>castable</code> expression is <code>xs:QName</code>, or is a type that is derived from <code>xs:QName</code> or <code>xs:NOTATION</code>, and the input argument of the expression is of type <code>xs:string</code> but it is not a literal string, the result of the <code>castable</code> expression is <code>false</code>.</p></note></div3><div3 id="id-constructor-functions"><head>Constructor
Functions</head><p>For every atomic type in the <termref def="dt-is-types">in-scope schema types</termref>  (except <code>xs:NOTATION</code> and <code>xs:anyAtomicType</code>, which are not instantiable), a <term>constructor function</term> is implicitly defined. In each case, the name of the constructor function is the same as the name of its target type (including namespace). The signature of the constructor function for type
<emph>T</emph> is as follows:</p>

<eg xml:space="preserve"><emph>T</emph>($arg as xs:anyAtomicType?) as <emph>T?</emph></eg>

<p> <termdef term="constructor function" id="dt-constructor-function">The <term>constructor function</term> for a given type is used to convert instances of other atomic types into the given type. The semantics of the constructor function call <code>T($arg)</code> are defined to be equivalent to the expression <code>(($arg) cast as T?)</code>.</termdef></p><p>The constructor functions for <code>xs:QName</code> and for types derived from <code>xs:QName</code> and <code>xs:NOTATION</code> require their arguments to be string literals or to have a base type that is the same as the base type of the target type; otherwise a type error <errorref code="0004" class="TY"/> is raised. This rule is consistent with the semantics of <code>cast</code> expressions for these types, as defined in <specref ref="id-cast"/>.</p><p>The following examples illustrate the use of constructor functions:</p><ulist><item><p>This
example is equivalent to <code>("2000-01-01" cast as
xs:date?)</code>.</p>

<eg role="parse-test" xml:space="preserve">xs:date("2000-01-01")</eg></item><item><p>This
example is equivalent to 

<code>(($floatvalue * 0.2E-5) cast as xs:decimal?)</code>.</p><eg role="parse-test" xml:space="preserve">xs:decimal($floatvalue * 0.2E-5)</eg></item><item><p>This example returns a
<code>xs:dayTimeDuration</code> value equal to 21 days. It is
equivalent to <code>("P21D" cast as xs:dayTimeDuration?)</code>.</p><eg role="parse-test" xml:space="preserve">xs:dayTimeDuration("P21D")</eg></item><item><p>If
<code>usa:zipcode</code> is a user-defined  atomic type
in the <termref def="dt-is-types">in-scope schema types</termref>, then the
following expression is equivalent to the
expression <code>("12345" cast as
usa:zipcode?)</code>.</p><eg role="parse-test" xml:space="preserve">usa:zipcode("12345")</eg></item></ulist>

<note><p>An instance of an atomic type that is not in a namespace can be constructed in either of the following ways:</p><ulist><item><p>By using a <code>cast</code> expression, if the <termref def="dt-def-elemtype-ns">default element/type
		  namespace</termref> is "none". </p><eg role="parse-test" xml:space="preserve">17 cast as apple</eg></item><item><p>By using a constructor function, if the <termref def="dt-def-fn-ns">default function
		namespace</termref> is "none". </p><eg role="parse-test" xml:space="preserve">apple(17)
</eg></item></ulist></note></div3><div3 id="id-treat"><head>Treat</head><scrap headstyle="show"> <head/> <prod num="17" id="doc-xpath-TreatExpr"><lhs>TreatExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-CastableExpr" xlink:type="simple">CastableExpr</nt> ( "treat"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SequenceType" xlink:type="simple">SequenceType</nt> )?</rhs></prod> </scrap><p>XPath provides an
expression called <code>treat</code> that can be used to modify the
<termref def="dt-static-type">static type</termref> of its
operand.</p><p>Like <code>cast</code>, the <code>treat</code>
expression takes two operands: an expression and a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SequenceType" xlink:type="simple">SequenceType</nt>. Unlike
<code>cast</code>, however, <code>treat</code> does not change the
<termref def="dt-dynamic-type">dynamic type</termref> or value of its operand. Instead, the purpose of
<code>treat</code> is to ensure that an expression has an expected
dynamic type at evaluation time.</p><p>The semantics of <emph><code>expr1</code></emph><code> treat as </code><emph><code>type1</code></emph> are as
follows:</p><ulist><item><p>During static analysis:</p><p> The
<termref def="dt-static-type">static type</termref> of the
<code>treat</code> expression is <emph><code>type1</code></emph>. This enables the
expression to be used as an argument of a function that requires a
parameter of <emph><code>type1</code></emph>.</p></item><item><p>During expression
evaluation:</p><p>If <emph><code>expr1</code></emph> matches <emph><code>type1</code></emph>,
using the rules for <termref def="dt-sequencetype-matching">SequenceType
matching</termref>,
the <code>treat</code> expression returns the value of
<emph><code>expr1</code></emph>; otherwise, it raises a <termref def="dt-dynamic-error">dynamic error</termref> <errorref class="DY" code="0050"/>.
If the value of <emph><code>expr1</code></emph> is returned, its identity is
preserved. The <code>treat</code> expression ensures that the value of
its expression operand conforms to the expected type at
run-time.</p></item><item><p>Example:</p><eg role="parse-test" xml:space="preserve">$myaddress treat as element(*, USAddress)</eg><p>The
<termref def="dt-static-type">static type</termref> of
<code>$myaddress</code> may be <code>element(*, Address)</code>, a
less specific type than <code>element(*, USAddress)</code>. However,
at run-time, the value of <code>$myaddress</code> must match the type
<code>element(*, USAddress)</code> using rules for <termref def="dt-sequencetype-matching">SequenceType
matching</termref>;
otherwise a <termref def="dt-dynamic-error">dynamic error</termref> is
raised <errorref class="DY" code="0050"/>.</p></item></ulist></div3></div2> 
</div1>







</body>
<back id="id-appendices">

<div1 id="nt-bnf"><head>XPath Grammar</head>
<div2 id="id-grammar">
<head>EBNF</head>


<p>The grammar of XPath uses the same simple Extended Backus-Naur Form
(EBNF) notation as <bibref ref="XML"/> with the following minor differences.    </p><ulist><item><p>All named symbols have a name that begins with an uppercase letter.</p></item><item><p>It adds a notation for referring to productions in external specs.</p></item><item><p>Comments or extra-grammatical constraints on grammar productions are between '/*' and
'*/' symbols.</p><ulist><item><p>A 'xgc:' prefix is an extra-grammatical constraint, the
details of which are explained in <specref ref="extra-grammatical-constraints"/></p></item><item><p>A 'ws:' prefix explains the whitespace rules for the production, the
details of which are explained in <specref ref="whitespace-rules"/></p></item><item><p>A 'gn:'
prefix means a 'Grammar Note', and is meant as a clarification for
parsing rules, and is explained in <specref ref="notes-on-parsing"/>.
 These notes are not normative.</p></item></ulist></item></ulist><p>The terminal symbols for this grammar include the quoted
  strings used in the production rules below, and the terminal
  symbols defined in section <specref ref="terminal-symbols"/>.</p><p>The EBNF notation is described in more detail in <specref ref="EBNFNotation"/>.</p><p>To increase readability, the EBNF in the main body of this document omits
    some of these notational features. This appendix is the normative
    version of the EBNF.   </p><scrap id="BNF-Grammar" role="non-terminal-structure-expand" headstyle="show"><head/>
<prod num="1" id="prod-xpath-XPath"><lhs>XPath</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Expr" xlink:type="simple">Expr</nt></rhs></prod><prod num="2" id="prod-xpath-Expr"><lhs>Expr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs></prod><prod num="3" id="prod-xpath-ExprSingle"><lhs>ExprSingle</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ForExpr" xlink:type="simple">ForExpr</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QuantifiedExpr" xlink:type="simple">QuantifiedExpr</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-IfExpr" xlink:type="simple">IfExpr</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-OrExpr" xlink:type="simple">OrExpr</nt></rhs></prod><prod num="4" id="prod-xpath-ForExpr"><lhs>ForExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-SimpleForClause" xlink:type="simple">SimpleForClause</nt>  "return"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod><prod num="5" id="prod-xpath-SimpleForClause"><lhs>SimpleForClause</lhs><rhs>"for"  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-VarName" xlink:type="simple">VarName</nt>  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-VarName" xlink:type="simple">VarName</nt>  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>)*</rhs></prod><prod num="6" id="prod-xpath-QuantifiedExpr"><lhs>QuantifiedExpr</lhs><rhs>("some"  |  "every")  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-VarName" xlink:type="simple">VarName</nt>  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  "$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-VarName" xlink:type="simple">VarName</nt>  "in"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>)*  "satisfies"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod><prod num="7" id="prod-xpath-IfExpr"><lhs>IfExpr</lhs><rhs>"if"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Expr" xlink:type="simple">Expr</nt>  ")"  "then"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>  "else"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt></rhs></prod><prod num="8" id="prod-xpath-OrExpr"><lhs>OrExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AndExpr" xlink:type="simple">AndExpr</nt> ( "or"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AndExpr" xlink:type="simple">AndExpr</nt> )*</rhs></prod><prod num="9" id="prod-xpath-AndExpr"><lhs>AndExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ComparisonExpr" xlink:type="simple">ComparisonExpr</nt> ( "and"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ComparisonExpr" xlink:type="simple">ComparisonExpr</nt> )*</rhs></prod><prod num="10" id="prod-xpath-ComparisonExpr"><lhs>ComparisonExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-RangeExpr" xlink:type="simple">RangeExpr</nt> ( (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ValueComp" xlink:type="simple">ValueComp</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-GeneralComp" xlink:type="simple">GeneralComp</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-NodeComp" xlink:type="simple">NodeComp</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-RangeExpr" xlink:type="simple">RangeExpr</nt> )?</rhs></prod><prod num="11" id="prod-xpath-RangeExpr"><lhs>RangeExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt> ( "to"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AdditiveExpr" xlink:type="simple">AdditiveExpr</nt> )?</rhs></prod><prod num="12" id="prod-xpath-AdditiveExpr"><lhs>AdditiveExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-MultiplicativeExpr" xlink:type="simple">MultiplicativeExpr</nt> ( ("+"  |  "-")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-MultiplicativeExpr" xlink:type="simple">MultiplicativeExpr</nt> )*</rhs></prod><prod num="13" id="prod-xpath-MultiplicativeExpr"><lhs>MultiplicativeExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-UnionExpr" xlink:type="simple">UnionExpr</nt> ( ("*"  |  "div"  |  "idiv"  |  "mod")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-UnionExpr" xlink:type="simple">UnionExpr</nt> )*</rhs></prod><prod num="14" id="prod-xpath-UnionExpr"><lhs>UnionExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-IntersectExceptExpr" xlink:type="simple">IntersectExceptExpr</nt> ( ("union"  |  "|")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-IntersectExceptExpr" xlink:type="simple">IntersectExceptExpr</nt> )*</rhs></prod><prod num="15" id="prod-xpath-IntersectExceptExpr"><lhs>IntersectExceptExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-InstanceofExpr" xlink:type="simple">InstanceofExpr</nt> ( ("intersect"  |  "except")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-InstanceofExpr" xlink:type="simple">InstanceofExpr</nt> )*</rhs></prod><prod num="16" id="prod-xpath-InstanceofExpr"><lhs>InstanceofExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-TreatExpr" xlink:type="simple">TreatExpr</nt> ( "instance"  "of"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-SequenceType" xlink:type="simple">SequenceType</nt> )?</rhs></prod><prod num="17" id="prod-xpath-TreatExpr"><lhs>TreatExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-CastableExpr" xlink:type="simple">CastableExpr</nt> ( "treat"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-SequenceType" xlink:type="simple">SequenceType</nt> )?</rhs></prod><prod num="18" id="prod-xpath-CastableExpr"><lhs>CastableExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-CastExpr" xlink:type="simple">CastExpr</nt> ( "castable"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-SingleType" xlink:type="simple">SingleType</nt> )?</rhs></prod><prod num="19" id="prod-xpath-CastExpr"><lhs>CastExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-UnaryExpr" xlink:type="simple">UnaryExpr</nt> ( "cast"  "as"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-SingleType" xlink:type="simple">SingleType</nt> )?</rhs></prod><prod num="20" id="prod-xpath-UnaryExpr"><lhs>UnaryExpr</lhs><rhs>("-"  |  "+")* <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ValueExpr" xlink:type="simple">ValueExpr</nt></rhs></prod><prod num="21" id="prod-xpath-ValueExpr"><lhs>ValueExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-PathExpr" xlink:type="simple">PathExpr</nt></rhs></prod><prod num="22" id="prod-xpath-GeneralComp"><lhs>GeneralComp</lhs><rhs>"="  |  "!="  |  "&lt;"  |  "&lt;="  |  "&gt;"  |  "&gt;="</rhs></prod><prod num="23" id="prod-xpath-ValueComp"><lhs>ValueComp</lhs><rhs>"eq"  |  "ne"  |  "lt"  |  "le"  |  "gt"  |  "ge"</rhs></prod><prod num="24" id="prod-xpath-NodeComp"><lhs>NodeComp</lhs><rhs>"is"  |  "&lt;&lt;"  |  "&gt;&gt;"</rhs></prod><prod num="25" id="prod-xpath-PathExpr"><lhs>PathExpr</lhs><rhs>("/"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>?)<br/>|  ("//"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>)<br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt></rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-leading-lone-slash" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgs: leading-lone-slash</loc></com></prod><prod num="26" id="prod-xpath-RelativePathExpr"><lhs>RelativePathExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-StepExpr" xlink:type="simple">StepExpr</nt>  (("/"  |  "//")  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-StepExpr" xlink:type="simple">StepExpr</nt>)*</rhs></prod><prod num="27" id="prod-xpath-StepExpr"><lhs>StepExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FilterExpr" xlink:type="simple">FilterExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AxisStep" xlink:type="simple">AxisStep</nt></rhs></prod><prod num="28" id="prod-xpath-AxisStep"><lhs>AxisStep</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ReverseStep" xlink:type="simple">ReverseStep</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ForwardStep" xlink:type="simple">ForwardStep</nt>)  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-PredicateList" xlink:type="simple">PredicateList</nt></rhs></prod><prod num="29" id="prod-xpath-ForwardStep"><lhs>ForwardStep</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ForwardAxis" xlink:type="simple">ForwardAxis</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-NodeTest" xlink:type="simple">NodeTest</nt>)  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AbbrevForwardStep" xlink:type="simple">AbbrevForwardStep</nt></rhs></prod><prod num="30" id="prod-xpath-ForwardAxis"><lhs>ForwardAxis</lhs><rhs>("child"  "::")<br/>|  ("descendant"  "::")<br/>|  ("attribute"  "::")<br/>|  ("self"  "::")<br/>|  ("descendant-or-self"  "::")<br/>|  ("following-sibling"  "::")<br/>|  ("following"  "::")<br/>|  ("namespace"  "::")</rhs></prod><prod num="31" id="prod-xpath-AbbrevForwardStep"><lhs>AbbrevForwardStep</lhs><rhs>"@"?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-NodeTest" xlink:type="simple">NodeTest</nt></rhs></prod><prod num="32" id="prod-xpath-ReverseStep"><lhs>ReverseStep</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ReverseAxis" xlink:type="simple">ReverseAxis</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-NodeTest" xlink:type="simple">NodeTest</nt>)  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AbbrevReverseStep" xlink:type="simple">AbbrevReverseStep</nt></rhs></prod><prod num="33" id="prod-xpath-ReverseAxis"><lhs>ReverseAxis</lhs><rhs>("parent"  "::")<br/>|  ("ancestor"  "::")<br/>|  ("preceding-sibling"  "::")<br/>|  ("preceding"  "::")<br/>|  ("ancestor-or-self"  "::")</rhs></prod><prod num="34" id="prod-xpath-AbbrevReverseStep"><lhs>AbbrevReverseStep</lhs><rhs>".."</rhs></prod><prod num="35" id="prod-xpath-NodeTest"><lhs>NodeTest</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-KindTest" xlink:type="simple">KindTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-NameTest" xlink:type="simple">NameTest</nt></rhs></prod><prod num="36" id="prod-xpath-NameTest"><lhs>NameTest</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Wildcard" xlink:type="simple">Wildcard</nt></rhs></prod><prod num="37" id="prod-xpath-Wildcard"><lhs>Wildcard</lhs><rhs>"*"<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-NCName" xlink:type="simple">NCName</nt>  ":"  "*")<br/>|  ("*"  ":"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-NCName" xlink:type="simple">NCName</nt>)</rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc></com></prod><prod num="38" id="prod-xpath-FilterExpr"><lhs>FilterExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-PrimaryExpr" xlink:type="simple">PrimaryExpr</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-PredicateList" xlink:type="simple">PredicateList</nt></rhs></prod><prod num="39" id="prod-xpath-PredicateList"><lhs>PredicateList</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Predicate" xlink:type="simple">Predicate</nt>*</rhs></prod><prod num="40" id="prod-xpath-Predicate"><lhs>Predicate</lhs><rhs>"["  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Expr" xlink:type="simple">Expr</nt>  "]"</rhs></prod><prod num="41" id="prod-xpath-PrimaryExpr"><lhs>PrimaryExpr</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Literal" xlink:type="simple">Literal</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-VarRef" xlink:type="simple">VarRef</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ParenthesizedExpr" xlink:type="simple">ParenthesizedExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ContextItemExpr" xlink:type="simple">ContextItemExpr</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-FunctionCall" xlink:type="simple">FunctionCall</nt></rhs></prod><prod num="42" id="prod-xpath-Literal"><lhs>Literal</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-NumericLiteral" xlink:type="simple">NumericLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-StringLiteral" xlink:type="simple">StringLiteral</nt></rhs></prod><prod num="43" id="prod-xpath-NumericLiteral"><lhs>NumericLiteral</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-IntegerLiteral" xlink:type="simple">IntegerLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-DecimalLiteral" xlink:type="simple">DecimalLiteral</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-DoubleLiteral" xlink:type="simple">DoubleLiteral</nt></rhs></prod><prod num="44" id="prod-xpath-VarRef"><lhs>VarRef</lhs><rhs>"$"  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-VarName" xlink:type="simple">VarName</nt></rhs></prod><prod num="45" id="prod-xpath-VarName"><lhs>VarName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt></rhs></prod><prod num="46" id="prod-xpath-ParenthesizedExpr"><lhs>ParenthesizedExpr</lhs><rhs>"("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Expr" xlink:type="simple">Expr</nt>?  ")"</rhs></prod><prod num="47" id="prod-xpath-ContextItemExpr"><lhs>ContextItemExpr</lhs><rhs>"."</rhs></prod><prod num="48" id="prod-xpath-FunctionCall"><lhs>FunctionCall</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt>  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ExprSingle" xlink:type="simple">ExprSingle</nt>)*)?  ")"</rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-reserved-function-names" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgs: reserved-function-names</loc></com><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-parens" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">gn: parens</loc></com></prod><prod num="49" id="prod-xpath-SingleType"><lhs>SingleType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AtomicType" xlink:type="simple">AtomicType</nt>  "?"?</rhs></prod><prod num="50" id="prod-xpath-SequenceType"><lhs>SequenceType</lhs><rhs>("empty-sequence"  "("  ")")<br/>|  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ItemType" xlink:type="simple">ItemType</nt>  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt>?)</rhs></prod><prod num="51" id="prod-xpath-OccurrenceIndicator"><lhs>OccurrenceIndicator</lhs><rhs>"?"  |  "*"  |  "+"</rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-occurrence-indicators" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgs: occurrence-indicators</loc></com></prod><prod num="52" id="prod-xpath-ItemType"><lhs>ItemType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-KindTest" xlink:type="simple">KindTest</nt>  |  ("item"  "("  ")")  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AtomicType" xlink:type="simple">AtomicType</nt></rhs></prod><prod num="53" id="prod-xpath-AtomicType"><lhs>AtomicType</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt></rhs></prod><prod num="54" id="prod-xpath-KindTest"><lhs>KindTest</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-DocumentTest" xlink:type="simple">DocumentTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ElementTest" xlink:type="simple">ElementTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AttributeTest" xlink:type="simple">AttributeTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-SchemaAttributeTest" xlink:type="simple">SchemaAttributeTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-PITest" xlink:type="simple">PITest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-CommentTest" xlink:type="simple">CommentTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-TextTest" xlink:type="simple">TextTest</nt><br/>|  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AnyKindTest" xlink:type="simple">AnyKindTest</nt></rhs></prod><prod num="55" id="prod-xpath-AnyKindTest"><lhs>AnyKindTest</lhs><rhs>"node"  "("  ")"</rhs></prod><prod num="56" id="prod-xpath-DocumentTest"><lhs>DocumentTest</lhs><rhs>"document-node"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ElementTest" xlink:type="simple">ElementTest</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-SchemaElementTest" xlink:type="simple">SchemaElementTest</nt>)?  ")"</rhs></prod><prod num="57" id="prod-xpath-TextTest"><lhs>TextTest</lhs><rhs>"text"  "("  ")"</rhs></prod><prod num="58" id="prod-xpath-CommentTest"><lhs>CommentTest</lhs><rhs>"comment"  "("  ")"</rhs></prod><prod num="59" id="prod-xpath-PITest"><lhs>PITest</lhs><rhs>"processing-instruction"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-NCName" xlink:type="simple">NCName</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-StringLiteral" xlink:type="simple">StringLiteral</nt>)?  ")"</rhs></prod><prod num="60" id="prod-xpath-AttributeTest"><lhs>AttributeTest</lhs><rhs>"attribute"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AttribNameOrWildcard" xlink:type="simple">AttribNameOrWildcard</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-TypeName" xlink:type="simple">TypeName</nt>)?)?  ")"</rhs></prod><prod num="61" id="prod-xpath-AttribNameOrWildcard"><lhs>AttribNameOrWildcard</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AttributeName" xlink:type="simple">AttributeName</nt>  |  "*"</rhs></prod><prod num="62" id="prod-xpath-SchemaAttributeTest"><lhs>SchemaAttributeTest</lhs><rhs>"schema-attribute"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AttributeDeclaration" xlink:type="simple">AttributeDeclaration</nt>  ")"</rhs></prod><prod num="63" id="prod-xpath-AttributeDeclaration"><lhs>AttributeDeclaration</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-AttributeName" xlink:type="simple">AttributeName</nt></rhs></prod><prod num="64" id="prod-xpath-ElementTest"><lhs>ElementTest</lhs><rhs>"element"  "("  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ElementNameOrWildcard" xlink:type="simple">ElementNameOrWildcard</nt>  (","  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-TypeName" xlink:type="simple">TypeName</nt>  "?"?)?)?  ")"</rhs></prod><prod num="65" id="prod-xpath-ElementNameOrWildcard"><lhs>ElementNameOrWildcard</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ElementName" xlink:type="simple">ElementName</nt>  |  "*"</rhs></prod><prod num="66" id="prod-xpath-SchemaElementTest"><lhs>SchemaElementTest</lhs><rhs>"schema-element"  "("  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ElementDeclaration" xlink:type="simple">ElementDeclaration</nt>  ")"</rhs></prod><prod num="67" id="prod-xpath-ElementDeclaration"><lhs>ElementDeclaration</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-ElementName" xlink:type="simple">ElementName</nt></rhs></prod><prod num="68" id="prod-xpath-AttributeName"><lhs>AttributeName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt></rhs></prod><prod num="69" id="prod-xpath-ElementName"><lhs>ElementName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt></rhs></prod><prod num="70" id="prod-xpath-TypeName"><lhs>TypeName</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt></rhs></prod>
</scrap>

<div3 id="EBNFNotation"><head>Notation</head><p>The following definitions will be helpful in defining precisely this exposition.</p><p><termdef id="symbol" term="symbol">Each rule in the grammar defines one <term>symbol</term>, using the following format:<eg xml:space="preserve">symbol ::= expression</eg></termdef></p><p><termdef term="terminal" id="terminal">A <term>terminal</term> is a symbol or string or pattern that can appear
    in the right-hand side of a rule, but never appears on the
    left hand side in the main grammar, although it may appear
    on the left-hand side of a rule in the grammar for terminals.</termdef>   The following constructs are used to match strings of one or more characters in a terminal:</p><glist><gitem><label>[a-zA-Z]</label><def><p>matches any
<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Char" xlink:type="simple">Char</nt>
with a value in the range(s) indicated (inclusive).</p></def></gitem><gitem><label>[abc]</label><def><p>matches any
<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Char" xlink:type="simple">Char</nt>
with a value among the characters enumerated. <phrase diff="del">Enumerations and ranges can be mixed in one set of brackets.</phrase></p></def></gitem><gitem><label>[^abc]</label><def><p>matches any
<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Char" xlink:type="simple">Char</nt>
with a value not among the characters given.<phrase diff="del"> Enumerations and ranges of forbidden values can be mixed in one set of brackets.</phrase></p></def></gitem><gitem><label>"string"</label><def><p>matches the sequence of characters that appear inside the double
quotes.</p></def></gitem><gitem><label>'string'</label><def><p>matches the sequence of characters that appear inside the single
quotes.</p></def></gitem><gitem><label>	[http://www.w3.org/TR/REC-example/#NT-Example]</label><def><p>matches any string matched by the production defined in the external specification as per the provided reference.</p></def></gitem></glist><p>Patterns (including the above constructs) can be combined with
grammatical operators to form more complex patterns, matching more
complex sets of character strings. In the examples that follow,
 A and B represent (sub-)patterns.</p><glist><gitem><label>(A)</label><def><p><code>A</code> is treated as a unit and may be combined as described in this list.</p></def></gitem><gitem><label>A?</label><def><p>matches <code>A</code> or nothing; optional <code>A</code>.</p></def></gitem><gitem><label>A B</label><def><p>matches <code>A</code> followed by <code>B</code>.  This operator has higher precedence than alternation; thus <code>A B | C D</code> is identical to <code>(A B) | (C D)</code>.</p></def></gitem><gitem><label>A | B</label><def><p>matches <code>A</code> or <code>B</code> but not both.</p></def></gitem><gitem><label>A - B</label><def><p>matches any string that matches <code>A</code> but does not match <code>B</code>.</p></def></gitem><gitem><label>A+</label><def><p>matches one or more occurrences of <code>A</code>.  Concatenation has higher precedence than alternation; thus <code>A+ | B+</code> is identical to <code>(A+) | (B+)</code>.</p></def></gitem></glist><glist><gitem><label>A*</label><def><p>matches zero or more occurrences of <code>A</code>.   Concatenation has higher precedence than alternation; thus <code>A* | B*</code> is identical to <code>(A*) | (B*)</code></p></def></gitem></glist></div3><div3 id="extra-grammatical-constraints"><head>Extra-grammatical Constraints</head><p>This section contains constraints  on the EBNF productions, which are required to parse legal sentences.  The notes below are referenced from the right side of the production, with the notation: <emph>/* xgc: &lt;id&gt; */</emph>.</p><constraintnote id="parse-note-leading-lone-slash" type="xgc"><head>leading-lone-slash</head><p>A single slash may appear either as a complete path expression
   or as the first part of a path expression in which it is
   followed by a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-RelativePathExpr" xlink:type="simple">RelativePathExpr</nt>, which can take the form
   of a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-NameTest" xlink:type="simple">NameTest</nt> ("*" or a QName).  In contexts where operators
   like "*", "union", etc., can occur, parsers may have
   difficulty distinguishing operators from NameTests.  For
   example, without lookahead the first part of the expression "/
   * 5", for example is easily taken to be a complete expression,
   "/ *", which has a very different interpretation (the child
   nodes of "/").</p><p>To reduce the need for lookahead, therefore, if the token
   immediately following a slash is "*" or a keyword, then the
   slash must be the beginning, but not the entirety, of a
   <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-PathExpr" xlink:type="simple">PathExpr</nt> (and the following token must be a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-NameTest" xlink:type="simple">NameTest</nt>,
   not an operator).</p><p>A single slash may be used as the left-hand argument of an
   operator by parenthesizing it: <code>(/) * 5</code>.  The expression <code>5 *
   /</code>, on the other hand, is legal without parentheses.</p></constraintnote><constraintnote id="parse-note-xml-version" type="xgc"><head>xml-version</head><p>An implementation's choice to support the <bibref ref="XML"/> and <bibref ref="XMLNAMES"/>, or <bibref ref="XML1.1"/>
        and <bibref ref="XMLNAMES11"/> lexical specification determines the external document from which 
        to obtain the definition for this production.  The EBNF only has references to the 1.0 versions.  In some cases, the XML 1.0 and XML 1.1 definitions may be exactly the same.  Also please note that these external productions follow the whitespace rules of their respective specifications, and not the rules of this specification, in particular <specref ref="DefaultWhitespaceHandling"/>.    Thus <code>prefix : localname</code> is not a valid QName for purposes
of this specification, just as it is not permitted in a  XML document.
Also, comments are not permissible on either side of the colon.  Also extra-grammatical constraints such as well-formedness constraints must be taken into account.</p></constraintnote><constraintnote id="parse-note-reserved-function-names" type="xgc"><head>reserved-function-names</head><p>Unprefixed function names spelled the same way as language
   keywords could make the language harder to recognize.  For
   instance, <code>if(foo)</code> could be taken either as a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-FunctionCall" xlink:type="simple">FunctionCall</nt> or
   as the beginning of an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-IfExpr" xlink:type="simple">IfExpr</nt>.  Therefore it is not legal
   syntax for a user to invoke functions with unprefixed names
   which match any of the names in <specref ref="id-reserved-fn-names"/>.</p><p>A function named "if" can be called by binding its namespace
   to a prefix and using the prefixed form:  "library:if(foo)"
   instead of "if(foo)".</p></constraintnote><constraintnote id="parse-note-occurrence-indicators" type="xgc"><head>occurrence-indicators</head><p>As written, the grammar in <specref ref="nt-bnf"/> is ambiguous for some forms
       using the '+' and '*' Kleene operators.  The ambiguity is
       resolved as follows:  these operators are tightly bound
       to the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SequenceType" xlink:type="simple">SequenceType</nt> expression, and have higher precedence
       than other uses of these symbols. Any occurrence of '+'
       and '*', as well as '?', following a sequence type is
       assumed to be an occurrence indicator.  That is, a 
       "+", "*", or "?" immediately following an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ItemType" xlink:type="simple">ItemType</nt> must
       be an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt>.  Thus, <code>4 treat as
       item() + - 5</code> must be interpreted as <code>(4 treat as item()+) - 5</code>,
       taking the '+' as an OccurrenceIndicator and the
       '-' as a subtraction operator. To force the interpretation
       of "+" as an addition operator (and the corresponding
       interpretation of the "-" as a unary minus), parentheses
       may be used:  the form <code>(4 treat as item()) + -5</code> surrounds
       the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SequenceType" xlink:type="simple">SequenceType</nt> expression with parentheses and leads
       to the desired interpretation.</p><p>This rule has as a consequence that certain forms which
       would otherwise be legal and unambiguous are not
       recognized:  in "4 treat as item() + 5", the "+" is
       taken as an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-OccurrenceIndicator" xlink:type="simple">OccurrenceIndicator</nt>, and not as an operator,
       which means this is not a legal expression.</p></constraintnote>
</div3><div3 id="notes-on-parsing"><head>Grammar Notes</head>
<p>This section contains general notes on the EBNF productions, which may be helpful in understanding how to interpret and implement the EBNF.  These notes are not normative.  The notes below are referenced from the right side of the production, with the notation: <emph>/* gn: &lt;id&gt; */</emph>.</p><note><glist><gitem id="parse-note-parens"><label>grammar-note: parens</label><def><p>Look-ahead is required to distinguish <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-FunctionCall" xlink:type="simple">FunctionCall</nt> from a QName or keyword followed by a  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Comment" xlink:type="simple">Comment</nt>. For example: <code>address (: this may be empty :)</code> may be mistaken for a call to a function named "address" unless this lookahead is employed.  Another example is <code>for (: whom the bell :) $tolls in 3 return $tolls</code>, where the keyword "for" must not be mistaken for a function name.</p>  </def></gitem><gitem id="parse-note-comments"><label>grammar-note: comments</label><def><p>Comments are allowed everywhere that <termref def="IgnorableWhitespace">ignorable whitespace</termref> is allowed, and the <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Comment" xlink:type="simple">Comment</nt> symbol does not explicity appear on the right-hand side of the grammar (except in its own production).  See <specref ref="DefaultWhitespaceHandling"/>.  </p><p>A comment can contain nested comments, as long as all "(:" and ":)" patterns are balanced, no matter where they occur within the outer comment.</p><note><p>Lexical analysis may typically handle nested comments by incrementing a counter for each "(:" pattern, and decrementing the counter for each ":)" pattern.  The comment does not terminate until the counter is back to zero.</p></note><p>Some illustrative examples:</p><ulist><item><p><code>(: commenting out a (: comment :) may be confusing, but often helpful :)</code> is a legal Comment, since balanced nesting of comments is allowed.</p></item><item><p><code>"this is just a string :)"</code> is a legal expression.  However, <code>(: "this is just a string :)" :)</code> will cause a syntax error.  Likewise, <code>"this is another string (:"</code> is a legal expression, but <code>(: "this is another string (:" :)</code> will cause a syntax error.    It  is a limitation of nested comments that literal content can cause unbalanced nesting of comments.</p></item><item><p><code>for (: set up loop :) $i in $x return $i</code> is syntactically legal, ignoring the comment.</p></item><item><p><code>5 instance (: strange place for a comment :) of xs:integer</code> is also syntactically legal.</p></item></ulist></def></gitem></glist></note>
</div3></div2><div2 id="lexical-structure">
<head>Lexical structure</head>
<p>The terminal symbols assumed by the grammar above are described
  in this section.</p><p>Quoted strings appearing in production rules are terminal
  symbols.</p><p>Other terminal symbols are defined in <specref ref="terminal-symbols"/>.</p><p role="xpath">A <term>host language</term> may choose whether the lexical rules of  <bibref ref="XML"/> and <bibref ref="XMLNAMES"/>    are followed, or alternatively, the lexical rules of <bibref ref="XML1.1"/> and <bibref ref="XMLNAMES11"/> are followed.</p>

<p>When tokenizing, the  longest possible match that is valid in the current context is used.</p><p>All keywords are case sensitive. Keywords are not reserved—that is, any QName may duplicate a keyword except as noted in <specref ref="id-reserved-fn-names"/>.</p>

<div3 id="terminal-symbols"><head>Terminal Symbols</head><scrap headstyle="show">
		    
		  <head/><prod num="71" id="prod-xpath-IntegerLiteral"><lhs>IntegerLiteral</lhs><rhs><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Digits" xlink:type="simple">Digits</nt></rhs></prod><prod num="72" id="prod-xpath-DecimalLiteral"><lhs>DecimalLiteral</lhs><rhs>("."  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Digits" xlink:type="simple">Digits</nt>)  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Digits" xlink:type="simple">Digits</nt>  "."  [0-9]*)</rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc></com></prod><prod num="73" id="prod-xpath-DoubleLiteral"><lhs>DoubleLiteral</lhs><rhs>(("."  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Digits" xlink:type="simple">Digits</nt>)  |  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Digits" xlink:type="simple">Digits</nt>  ("."  [0-9]*)?))  [eE]  [+-]?  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Digits" xlink:type="simple">Digits</nt></rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc></com></prod><prod num="74" id="prod-xpath-StringLiteral"><lhs>StringLiteral</lhs><rhs>('"'  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-EscapeQuot" xlink:type="simple">EscapeQuot</nt>  |  [^"])*  '"')  |  ("'"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-EscapeApos" xlink:type="simple">EscapeApos</nt>  |  [^'])*  "'")</rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc></com></prod><prod num="75" id="prod-xpath-EscapeQuot"><lhs>EscapeQuot</lhs><rhs>'""'</rhs></prod><prod num="76" id="prod-xpath-EscapeApos"><lhs>EscapeApos</lhs><rhs>"''"</rhs></prod><prod num="77" id="prod-xpath-Comment"><lhs>Comment</lhs><rhs>"(:"  (<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-CommentContents" xlink:type="simple">CommentContents</nt>  |  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Comment" xlink:type="simple">Comment</nt>)*  ":)"</rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws: explicit</loc></com><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-comments" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">gn: comments</loc></com></prod><prod num="78" id="prod-xpath-QName"><lhs>QName</lhs><rhs><xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="Names" ref="NT-QName" xlink:type="simple">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</xnt></rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-xml-version" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgs: xml-version</loc></com></prod><prod num="79" id="prod-xpath-NCName"><lhs>NCName</lhs><rhs><xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="Names" ref="NT-NCName" xlink:type="simple">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</xnt></rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-xml-version" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgs: xml-version</loc></com></prod><prod num="80" id="prod-xpath-Char"><lhs>Char</lhs><rhs><xnt xmlns:xlink="http://www.w3.org/1999/xlink" spec="XML" ref="NT-Char" xlink:type="simple">[http://www.w3.org/TR/REC-xml#NT-Char]</xnt></rhs><com><loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-xml-version" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">xgs: xml-version</loc></com></prod> 
		   
		</scrap><p>The following symbols are used only in the definition of
  terminal symbols; they are not terminal symbols in the
  grammar of <specref ref="id-grammar"/>.</p><scrap headstyle="show">
		    
		  <head/><prod num="81" id="prod-xpath-Digits"><lhs>Digits</lhs><rhs>[0-9]+</rhs></prod><prod num="82" id="prod-xpath-CommentContents"><lhs>CommentContents</lhs><rhs>(<nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-Char" xlink:type="simple">Char</nt>+ - (Char* ('(:' | ':)') Char*))</rhs></prod> 
		   
		</scrap></div3><div3 id="id-terminal-delimitation"><head>Terminal Delimitation</head><p>XPath 2.0 expressions consist of <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#terminal-symbols" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">terminal symbols</loc>
  and <termref def="symbolseparators">symbol separators</termref>.
</p><p>Terminal symbols that are not used exclusively in <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">/* ws: explicit */</loc> productions are of two kinds: delimiting and
  non-delimiting.</p><p><termdef id="delimiting-token" term="delimiting terminal symbol">The <term>delimiting terminal symbols</term>  are: "-", (comma), (colon), "::", "!=", "?", "/", "//", (dot), "..", <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-StringLiteral" xlink:type="simple">StringLiteral</nt>, "(", ")", "[", "]", "@", "$", "*", "+", "&lt;", "&lt;&lt;", "&lt;=", "=", "&gt;", "&gt;=", "&gt;&gt;", "|"</termdef>  </p><p><termdef id="non-delimiting-token" term="non-delimiting terminal symbol">The <term>non-delimiting terminal symbols</term>  are:  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-IntegerLiteral" xlink:type="simple">IntegerLiteral</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-NCName" xlink:type="simple">NCName</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-QName" xlink:type="simple">QName</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-DecimalLiteral" xlink:type="simple">DecimalLiteral</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="prod-xpath-DoubleLiteral" xlink:type="simple">DoubleLiteral</nt>, "ancestor", "ancestor-or-self", "and", "as", "attribute", "cast", "castable", "child", "comment", "descendant", "descendant-or-self", "div", "document-node", "element", "else", "empty-sequence", "eq", "every", "except", "external", "following", "following-sibling", "for", "ge", "gt", "idiv", "if", "in", "instance", "intersect", "is", "item", "le", "lt", "mod", "namespace", "ne", "node", "of", "or", "parent", "preceding", "preceding-sibling", "processing-instruction", "return", "satisfies", "schema-attribute", "schema-element", "self", "some", "text", "then", "to", "treat", "union"</termdef>  </p><p><termdef id="symbolseparators" term="symbol separators"><termref def="Whitespace">Whitespace</termref> and <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Comment" xlink:type="simple">Comments</nt>  function as
  <term>symbol separators</term>.  For the most part, they are not mentioned
  in the grammar, and may occur between any two terminal symbols
  mentioned in the grammar, except where that is forbidden by
  the <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ws-explicit" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">/* ws: explicit */</loc> annotation in the EBNF, or by the 	<loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#parse-note-xml-version" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">/* xgs: xml-version */</loc> annotation.
</termdef></p><p>It is customary to separate consecutive terminal symbols by
  <termref def="Whitespace">whitespace</termref> and <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Comment" xlink:type="simple">Comments</nt>, but this is required only when
  otherwise two non-delimiting symbols would be adjacent to each
  other.  There are two exceptions to this, that of "." and "-", which do require a <termref def="symbolseparators">symbol separator</termref> if they follow a QName or NCName.   Also, "."  requires a separator if it precedes or follows a
numeric literal.</p></div3><div3 id="id-eol-handling"><head>End-of-Line Handling</head><p>The XPath processor must behave as if it normalized all line breaks on input, before parsing. The normalization should be done according to the choice to support either <bibref ref="XML"/> or <bibref ref="XML1.1"/> lexical processing.</p><div4 id="id-xml10-eol-handling"><head>XML 1.0 End-of-Line Handling</head><p>For <bibref ref="XML"/> processing, all of the following must be translated to a single #xA character:</p><olist><item><p>the two-character sequence #xD #xA</p></item><item><p>any #xD character that is not immediately followed by #xA.</p></item></olist></div4><div4 id="id-xml11-eol-handling"><head>XML 1.1 End-of-Line Handling</head><p>For <bibref ref="XML1.1"/> processing, all of the following must be translated to a single #xA character:</p><olist><item><p>the two-character sequence #xD #xA</p></item><item><p>the two-character sequence #xD #x85</p></item><item><p>the single character #x85</p></item><item><p>the single character #x2028</p></item><item><p>any #xD character that is not immediately followed by #xA or #x85.</p></item></olist></div4></div3><div3 id="whitespace-rules"><head>Whitespace Rules</head>
<div4 id="DefaultWhitespaceHandling"><head>Default Whitespace Handling</head><p><termdef id="Whitespace" term="whitespace">A <term>whitespace</term>  character is any of the characters defined by <xnt xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.w3.org/TR/REC-xml#NT-S" xlink:type="simple">[http://www.w3.org/TR/REC-xml#NT-S]</xnt>.</termdef></p><p>  <termdef term="ignorable whitespace" id="IgnorableWhitespace"><term>Ignorable whitespace</term> consists of any <termref def="Whitespace">whitespace</termref> characters that may occur between <termref def="terminal">terminals</termref>, unless these characters occur in the context of a production marked with  a <loc xmlns:xlink="http://www.w3.org/1999/xlink" href="#ExplicitWhitespaceHandling" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ws:explicit</loc> annotation, in which case they can occur only where explicitly specified (see <specref ref="ExplicitWhitespaceHandling"/>).</termdef>  Ignorable whitespace characters are not significant to the semantics of an expression.        Whitespace is allowed before the first terminal and after the last terminal of  a  module.  Whitespace is allowed between any two <termref def="terminal">terminals</termref>.   <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Comment" xlink:type="simple">Comments</nt> may also act as "whitespace" to prevent two adjacent terminals from being recognized as one.  Some illustrative examples are as follows:</p><ulist><item><p><code>foo- foo</code> results in a syntax error.  "foo-" would be recognized as a QName.</p></item><item><p><code>foo -foo</code> is syntactically equivalent to <code>foo - foo</code>, two QNames separated by a subtraction operator.  </p></item><item><p><code>foo(: This is a comment :)- foo</code> is syntactically equivalent to <code>foo - foo</code>.  This is because the comment prevents the two adjacent terminals from being recognized as one.</p></item><item><p><code>foo-foo</code> is syntactically equivalent to single QName.    This is because "-" is a valid character in a QName.
         When used as an operator after the characters of a name, the "-"
         must be separated from the name, e.g. by using whitespace or
         parentheses.</p></item><item><p><code>10div 3</code> results in a syntax error.</p></item><item><p><code>10 div3</code> also results in a syntax error.</p></item><item><p><code>10div3</code> also results in a syntax error.</p></item></ulist></div4><div4 id="ExplicitWhitespaceHandling"><head>Explicit  Whitespace Handling</head><p>Explicit whitespace notation is specified
	 with the EBNF productions, when it is different from the
	 default rules, using the notation shown below.  This notation is  not inherited.  In other words, if an EBNF rule is marked as /* ws: explicit */, the notation does not automatically apply to all the 'child' EBNF productions of that rule.</p><glist><gitem id="ws-explicit"><label>ws: explicit</label><def><p>/* ws: explicit */ means that  the EBNF
	 notation explicitly notates,  with <code>S</code> or otherwise,  where <termref def="Whitespace">whitespace characters</termref> are allowed.  In productions with the /* ws: explicit */ annotation,   <specref ref="DefaultWhitespaceHandling"/> does not apply.  <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Comment" xlink:type="simple">Comments</nt> are also not allowed in these productions.</p></def></gitem>

</glist></div4></div3></div2>

<div2 id="id-reserved-fn-names"><head>Reserved Function Names</head>
<p>The following names are not allowed as function names in an
unprefixed form because expression syntax takes precedence.</p>
<ulist>
<item><p><code>attribute</code></p></item>
<item><p><code>comment</code></p></item>
<item><p><code>document-node</code></p></item>
<item><p><code>element</code></p></item>


<item><p><code>empty-sequence</code></p></item><item><p><code>if</code></p></item>
<item><p><code>item</code></p></item>

<item><p><code>node</code></p></item>
<item><p><code>processing-instruction</code></p></item>
<item><p><code>schema-attribute</code></p></item><item><p><code>schema-element</code></p></item><item><p><code>text</code></p></item>
<item><p><code>typeswitch</code></p><note role="xpath"><p>Although the keyword <code>typeswitch</code> is not used in XPath, it is considered a reserved function name for compatibility with XQuery.</p></note></item>
</ulist>
</div2><div2 id="id-precedence-order"><head>Precedence Order</head><p>  The grammar in <specref ref="id-grammar"/> normatively defines built-in precedence among the operators of XPath. These operators are summarized here to make clear the order of their precedence from lowest to highest.
   Operators that have a lower precedence number cannot be contained by operators with a higher precedence number.   The associativity column indicates the order in which operators of equal precedence in an expression are applied.</p>
  <table border="1">
  <tbody>
  
  <tr><th rowspan="1" colspan="1">#</th><th rowspan="1" colspan="1">Operator</th><th rowspan="1" colspan="1"> 	

Associativity</th></tr><tr><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">, (comma)</td><td rowspan="1" colspan="1">left-to-right</td></tr><tr><td rowspan="1" colspan="1">3</td><td rowspan="1" colspan="1"><phrase role="xpath"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ForExpr" xlink:type="simple">for</nt>, </phrase><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-QuantifiedExpr" xlink:type="simple">some, every</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-IfExpr" xlink:type="simple">if</nt></td><td rowspan="1" colspan="1">left-to-right</td></tr>
  <tr><td rowspan="1" colspan="1">4</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-OrExpr" xlink:type="simple">or</nt></td><td rowspan="1" colspan="1">left-to-right</td></tr><tr><td rowspan="1" colspan="1">5</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AndExpr" xlink:type="simple">and</nt></td><td rowspan="1" colspan="1">left-to-right</td></tr>
  
  
  
  
  <tr><td rowspan="1" colspan="1">6</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ValueComp" xlink:type="simple">eq, ne, lt, le, gt, ge</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-GeneralComp" xlink:type="simple">=, !=, &lt;, &lt;=, &gt;, &gt;=</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-NodeComp" xlink:type="simple">is</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-NodeComp" xlink:type="simple">&lt;&lt;, &gt;&gt;</nt></td><td rowspan="1" colspan="1">left-to-right</td></tr>
  <tr><td rowspan="1" colspan="1">7</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-RangeExpr" xlink:type="simple">to</nt></td><td rowspan="1" colspan="1">left-to-right</td></tr>
  <tr><td rowspan="1" colspan="1">8</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AdditiveExpr" xlink:type="simple">+, -</nt></td><td rowspan="1" colspan="1">left-to-right</td></tr>
  <tr><td rowspan="1" colspan="1">9</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-MultiplicativeExpr" xlink:type="simple">*, div, idiv, mod</nt></td><td rowspan="1" colspan="1">left-to-right</td></tr>
  
  <tr><td rowspan="1" colspan="1">10</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-UnionExpr" xlink:type="simple">union, |</nt></td><td rowspan="1" colspan="1">left-to-right</td></tr>
  <tr><td rowspan="1" colspan="1">11</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-IntersectExceptExpr" xlink:type="simple">intersect, except</nt></td><td rowspan="1" colspan="1">left-to-right</td></tr>
  <tr><td rowspan="1" colspan="1">12</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-InstanceofExpr" xlink:type="simple">instance of</nt> </td><td rowspan="1" colspan="1">left-to-right</td></tr><tr><td rowspan="1" colspan="1">13</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-TreatExpr" xlink:type="simple">treat</nt></td><td rowspan="1" colspan="1">left-to-right</td></tr><tr><td rowspan="1" colspan="1">14</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-CastableExpr" xlink:type="simple">castable</nt></td><td rowspan="1" colspan="1">left-to-right</td></tr><tr><td rowspan="1" colspan="1">15</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-CastExpr" xlink:type="simple">cast</nt></td><td rowspan="1" colspan="1">left-to-right</td></tr><tr><td rowspan="1" colspan="1">16</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-UnaryExpr" xlink:type="simple"> -(unary),  +(unary)</nt></td><td rowspan="1" colspan="1">right-to-left</td></tr><tr><td rowspan="1" colspan="1">17</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-OccurrenceIndicator" xlink:type="simple">?, *(OccurrenceIndicator), +(OccurrenceIndicator)</nt></td><td rowspan="1" colspan="1">left-to-right</td></tr><tr><td rowspan="1" colspan="1">18</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-PathExpr" xlink:type="simple">/, //</nt></td><td rowspan="1" colspan="1">left-to-right</td></tr>
  <tr><td rowspan="1" colspan="1">19</td><td rowspan="1" colspan="1"><nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-Predicate" xlink:type="simple">[ ]</nt>, <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ParenthesizedExpr" xlink:type="simple">( )</nt>, {}</td><td rowspan="1" colspan="1">left-to-right</td></tr>
  </tbody>
  </table>
  </div2>
			

</div1>


<div1 id="id-type-promotion-and-operator-mapping">
<head>Type Promotion and Operator Mapping</head>
<div2 id="promotion">
<head>Type Promotion</head>

<p><termdef term="type promotion" id="dt-type-promotion">Under certain circumstances, an atomic value can be promoted from
one type to another. <term>Type promotion</term> is used in evaluating function calls (see <specref ref="id-function-calls"/>)  and operators that accept numeric or string operands (see <specref ref="mapping"/>).</termdef> The following type promotions are permitted:</p>

<olist><item><p>Numeric type promotion:</p><olist><item><p>A value of type <code>xs:float</code> (or any type
derived by restriction from <code>xs:float</code>) can be promoted to
the type <code>xs:double</code>. The result is the
<code>xs:double</code> value that is the same as the original
value.</p></item>

<item><p>A value of type <code>xs:decimal</code> (or any type derived
by restriction from <code>xs:decimal</code>) can be promoted to either
of the types <code>xs:float</code> or <code>xs:double</code>.  The
result of this promotion is created by casting the original value to
the required type. This kind of promotion may cause loss of
precision.</p></item></olist></item><item><p>URI type promotion: A value of type <code>xs:anyURI</code> (or any type derived by restriction from <code>xs:anyURI</code>) can be promoted to the type <code>xs:string</code>. The result of this promotion is created by casting the original value to the type <code>xs:string</code>.</p><note><p>Since <code>xs:anyURI</code> values can be promoted to <code>xs:string</code>, functions and operators that compare strings using the <termref def="dt-def-collation">default collation</termref> also compare <code>xs:anyURI</code> values using the <termref def="dt-def-collation">default collation</termref>. This ensures that orderings that include strings, <code>xs:anyURI</code> values, or any combination of the two types are consistent and well-defined.</p></note></item>


</olist>
<p>Note that <termref def="dt-type-promotion">type promotion</termref> is different from <termref def="dt-subtype-substitution">subtype substitution</termref>. For example:</p><ulist><item><p>A function that expects a parameter <code>$p</code> of type <code>xs:float</code> can be invoked with a value of type <code>xs:decimal</code>. This is an example of <termref def="dt-type-promotion">type promotion</termref>. The value is actually converted to the expected type. Within the body of the function, <code>$p instance of xs:decimal</code> returns <code>false</code>.</p></item><item><p>A function that expects a parameter <code>$p</code> of type <code>xs:decimal</code> can be invoked with a value of type <code>xs:integer</code>. This is an example of <termref def="dt-subtype-substitution">subtype substitution</termref>. The value retains its original type. Within the body of the function, <code>$p instance of xs:integer</code> returns <code>true</code>.</p></item></ulist></div2>

<div2 id="mapping">
<head>Operator Mapping</head> <p>The operator mapping tables in this section list the
combinations of types for which the various operators of XPath
are defined. <termdef term="operator function" id="dt-operator-function">For each operator and valid combination of operand types, the operator mapping tables specify a result type and an <term>operator function</term> that implements the semantics of the operator for the given types.</termdef> The definitions of the operator functions are given in  <bibref ref="FunctionsAndOperators"/>. The result of an operator may be the raising of an error by its operator function, as defined in <bibref ref="FunctionsAndOperators"/>. In some cases, the operator function does not implement the full semantics of
a given operator. For the definition of each operator (including its
behavior for empty sequences or sequences of length greater than one),
see the descriptive material in the main part of this
document.</p><p>The <code>and</code> and
<code>or</code> operators are defined directly in the main body of
this document, and do not occur in the operator mapping tables.</p><p>If an operator in the operator mapping tables expects an operand of type 
<emph>ET</emph>, that operator can be applied to an operand of type <emph>AT</emph> if type <emph>AT</emph> can 
be converted to type <emph>ET</emph> by a combination of <termref def="dt-type-promotion">type promotion</termref> and <termref def="dt-subtype-substitution">subtype substitution</termref>. For example, a table entry indicates that the <code>gt</code> operator may
be applied to two <code>xs:date</code> operands, returning
<code>xs:boolean</code>. Therefore, the <code>gt</code> operator may
also be applied to two (possibly different) subtypes of
<code>xs:date</code>, also returning <code>xs:boolean</code>.</p><p><termdef id="dt-numeric" term="numeric">When referring to a type, the term <term>numeric</term> denotes the types
<code>xs:integer</code>, <code>xs:decimal</code>,
<code>xs:float</code>, and <code>xs:double</code>.</termdef> An operator whose
operands and result are designated as <termref def="dt-numeric">numeric</termref> might be
thought of as representing four operators, one for each of the numeric
types. For example, the numeric <code>+</code> operator might be
thought of as representing the following four operators:</p>

<table width="80%" border="1" summary="Operators"><tbody><tr><td align="center" rowspan="1" colspan="1">Operator</td><td align="center" rowspan="1" colspan="1">First operand type</td><td align="center" rowspan="1" colspan="1">Second operand type</td><td align="center" rowspan="1" colspan="1">Result type</td></tr><tr><td align="center" rowspan="1" colspan="1"><code>+</code></td><td align="center" rowspan="1" colspan="1"><code>xs:integer</code></td><td align="center" rowspan="1" colspan="1"><code>xs:integer</code></td><td align="center" rowspan="1" colspan="1"><code>xs:integer</code></td></tr><tr><td align="center" rowspan="1" colspan="1"><code>+</code></td><td align="center" rowspan="1" colspan="1"><code>xs:decimal</code></td><td align="center" rowspan="1" colspan="1"><code>xs:decimal</code></td><td align="center" rowspan="1" colspan="1"><code>xs:decimal</code></td></tr><tr><td align="center" rowspan="1" colspan="1"><code>+</code></td><td align="center" rowspan="1" colspan="1"><code>xs:float</code></td><td align="center" rowspan="1" colspan="1"><code>xs:float</code></td><td align="center" rowspan="1" colspan="1"><code>xs:float</code></td></tr><tr><td align="center" rowspan="1" colspan="1"><code>+</code></td><td align="center" rowspan="1" colspan="1"><code>xs:double</code></td><td align="center" rowspan="1" colspan="1"><code>xs:double</code></td><td align="center" rowspan="1" colspan="1"><code>xs:double</code></td></tr></tbody></table><p>A numeric operator may be validly applied to an operand of type <emph>AT</emph> if type 
<emph>AT</emph> can be converted to any of the four numeric types by a combination of 
<termref def="dt-type-promotion">type promotion</termref> and <termref def="dt-subtype-substitution">subtype substitution</termref>. If the result type of an 
operator is listed as numeric, it means "the first type in the ordered list <code>(xs:integer, xs:decimal, xs:float, xs:double)</code> into which all operands can be converted by <termref def="dt-subtype-substitution">subtype substitution</termref> and <termref def="dt-type-promotion">type promotion</termref>." As an example, suppose that the type <code>hatsize</code> is derived from <code>xs:integer</code> and the type <code>shoesize</code> is derived from <code>xs:float</code>.   Then if the <code>+</code> operator is invoked with operands of type <code>hatsize</code> and <code>shoesize</code>, it returns a result of type <code>xs:float</code>.  Similarly, if <code>+</code> is invoked with two operands of type <code>hatsize</code> it returns a result of type <code>xs:integer</code>.</p><p><termdef id="dt-gregorian" term="Gregorian">In the operator mapping tables,
the term <term>Gregorian</term> refers to the types
<code>xs:gYearMonth</code>, <code>xs:gYear</code>,
<code>xs:gMonthDay</code>, <code>xs:gDay</code>, and
<code>xs:gMonth</code>.</termdef>  For binary operators that accept two
Gregorian-type operands, both operands must have the same type (for
example, if one operand is of type <code>xs:gDay</code>, the other
operand must be of type <code>xs:gDay</code>.)</p>

<table border="1" summary="Binary operators" role="small">
<caption>Binary Operators</caption>
<tbody>
<tr>
<th rowspan="1" colspan="1">Operator</th>
<th rowspan="1" colspan="1">Type(A)</th>
<th rowspan="1" colspan="1">Type(B)</th>
<th rowspan="1" colspan="1">Function</th>
<th rowspan="1" colspan="1">Result type</th>
</tr>
<tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">op:numeric-add(A, B)</td><td rowspan="1" colspan="1">numeric</td></tr>
<tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:add-yearMonthDuration-to-date(A, B)</td><td rowspan="1" colspan="1">xs:date</td></tr>
<tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">op:add-yearMonthDuration-to-date(B, A)</td><td rowspan="1" colspan="1">xs:date</td></tr><tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:add-dayTimeDuration-to-date(A, B)</td><td rowspan="1" colspan="1">xs:date</td></tr><tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">op:add-dayTimeDuration-to-date(B, A)</td><td rowspan="1" colspan="1">xs:date</td></tr>
<tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:add-dayTimeDuration-to-time(A, B)</td><td rowspan="1" colspan="1">xs:time</td></tr><tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">op:add-dayTimeDuration-to-time(B, A)</td><td rowspan="1" colspan="1">xs:time</td></tr>

<tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:add-yearMonthDuration-to-dateTime(A, B)</td><td rowspan="1" colspan="1">xs:dateTime</td></tr><tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">op:add-yearMonthDuration-to-dateTime(B, A)</td><td rowspan="1" colspan="1">xs:dateTime</td></tr>
<tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:add-dayTimeDuration-to-dateTime(A, B)</td><td rowspan="1" colspan="1">xs:dateTime</td></tr><tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">op:add-dayTimeDuration-to-dateTime(B, A)</td><td rowspan="1" colspan="1">xs:dateTime</td></tr>
<tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:add-yearMonthDurations(A, B)</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td></tr><tr><td rowspan="1" colspan="1">A + B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:add-dayTimeDurations(A, B)</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td></tr>

<tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">op:numeric-subtract(A, B)</td><td rowspan="1" colspan="1">numeric</td></tr>

<tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">op:subtract-dates(A, B)</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td></tr><tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:subtract-yearMonthDuration-from-date(A, B)</td><td rowspan="1" colspan="1">xs:date</td></tr><tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:subtract-dayTimeDuration-from-date(A, B)</td><td rowspan="1" colspan="1">xs:date</td></tr>
<tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">op:subtract-times(A, B)</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td></tr>
<tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:subtract-dayTimeDuration-from-time(A, B)</td><td rowspan="1" colspan="1">xs:time</td></tr>

<tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">op:subtract-dateTimes(A, B)</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td></tr><tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:subtract-yearMonthDuration-from-dateTime(A, B)</td><td rowspan="1" colspan="1">xs:dateTime</td></tr><tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:subtract-dayTimeDuration-from-dateTime(A, B)</td><td rowspan="1" colspan="1">xs:dateTime</td></tr>
<tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:subtract-yearMonthDurations(A, B)</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td></tr><tr><td rowspan="1" colspan="1">A - B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:subtract-dayTimeDurations(A, B)</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td></tr>

<tr><td rowspan="1" colspan="1">A * B</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">op:numeric-multiply(A, B)</td><td rowspan="1" colspan="1">numeric</td></tr><tr><td rowspan="1" colspan="1">A * B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">op:multiply-yearMonthDuration(A, B)</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td></tr><tr><td rowspan="1" colspan="1">A * B</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:multiply-yearMonthDuration(B, A)</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td></tr><tr><td rowspan="1" colspan="1">A * B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">op:multiply-dayTimeDuration(A, B)</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td></tr><tr><td rowspan="1" colspan="1">A * B</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:multiply-dayTimeDuration(B, A)</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td></tr>
<tr><td rowspan="1" colspan="1">A idiv B</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">op:numeric-integer-divide(A, B)</td><td rowspan="1" colspan="1">xs:integer</td></tr><tr><td rowspan="1" colspan="1">A div B</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">op:numeric-divide(A, B)</td><td rowspan="1" colspan="1">numeric; but xs:decimal if both operands are xs:integer</td></tr><tr><td rowspan="1" colspan="1">A div B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">op:divide-yearMonthDuration(A, B)</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td></tr><tr><td rowspan="1" colspan="1">A div B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">op:divide-dayTimeDuration(A, B)</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td></tr><tr><td rowspan="1" colspan="1">A div B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:divide-yearMonthDuration-by-yearMonthDuration (A, B)</td><td rowspan="1" colspan="1">xs:decimal</td></tr><tr><td rowspan="1" colspan="1">A div B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:divide-dayTimeDuration-by-dayTimeDuration (A, B)</td><td rowspan="1" colspan="1">xs:decimal</td></tr>
<tr><td rowspan="1" colspan="1">A mod B</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">op:numeric-mod(A, B)</td><td rowspan="1" colspan="1">numeric</td></tr>

<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">op:numeric-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">op:boolean-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">op:numeric-equal(fn:compare(A, B), 0)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">op:date-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">op:time-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">op:dateTime-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:duration</td><td rowspan="1" colspan="1">xs:duration</td><td rowspan="1" colspan="1">op:duration-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">Gregorian</td><td rowspan="1" colspan="1">Gregorian</td><td rowspan="1" colspan="1">op:gYear-equal(A, B) etc.</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:hexBinary</td><td rowspan="1" colspan="1">xs:hexBinary</td><td rowspan="1" colspan="1">op:hex-binary-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:base64Binary</td><td rowspan="1" colspan="1">xs:base64Binary</td><td rowspan="1" colspan="1">op:base64-binary-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:anyURI</td><td rowspan="1" colspan="1">xs:anyURI</td><td rowspan="1" colspan="1">op:numeric-equal(fn:compare(A, B), 0)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:QName</td><td rowspan="1" colspan="1">xs:QName</td><td rowspan="1" colspan="1">op:QName-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A eq B</td><td rowspan="1" colspan="1">xs:NOTATION</td><td rowspan="1" colspan="1">xs:NOTATION</td><td rowspan="1" colspan="1">op:NOTATION-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>

<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">fn:not(op:numeric-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">fn:not(op:boolean-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">fn:not(op:numeric-equal(fn:compare(A, B), 0))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">fn:not(op:date-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">fn:not(op:time-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">fn:not(op:dateTime-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:duration</td><td rowspan="1" colspan="1">xs:duration</td><td rowspan="1" colspan="1">fn:not(op:duration-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">Gregorian</td><td rowspan="1" colspan="1">Gregorian</td><td rowspan="1" colspan="1">fn:not(op:gYear-equal(A, B)) etc.</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:hexBinary</td><td rowspan="1" colspan="1">xs:hexBinary</td><td rowspan="1" colspan="1">fn:not(op:hex-binary-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:base64Binary</td><td rowspan="1" colspan="1">xs:base64Binary</td><td rowspan="1" colspan="1">fn:not(op:base64-binary-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:anyURI</td><td rowspan="1" colspan="1">xs:anyURI</td><td rowspan="1" colspan="1">fn:not(op:numeric-equal(fn:compare(A, B), 0))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:QName</td><td rowspan="1" colspan="1">xs:QName</td><td rowspan="1" colspan="1">fn:not(op:QName-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>

<tr><td rowspan="1" colspan="1">A ne B</td><td rowspan="1" colspan="1">xs:NOTATION</td><td rowspan="1" colspan="1">xs:NOTATION</td><td rowspan="1" colspan="1">fn:not(op:NOTATION-equal(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>

<tr><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">op:numeric-greater-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">op:boolean-greater-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">op:numeric-greater-than(fn:compare(A, B), 0)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">op:date-greater-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">op:time-greater-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">op:dateTime-greater-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:yearMonthDuration-greater-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:dayTimeDuration-greater-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A gt B</td><td rowspan="1" colspan="1">xs:anyURI</td><td rowspan="1" colspan="1">xs:anyURI</td><td rowspan="1" colspan="1">op:numeric-greater-than(fn:compare(A, B), 0)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>

<tr><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">op:numeric-less-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">op:boolean-less-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">op:numeric-less-than(fn:compare(A, B), 0)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">op:date-less-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">op:time-less-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">op:dateTime-less-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">op:yearMonthDuration-less-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">op:dayTimeDuration-less-than(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A lt B</td><td rowspan="1" colspan="1">xs:anyURI</td><td rowspan="1" colspan="1">xs:anyURI</td><td rowspan="1" colspan="1">op:numeric-less-than(fn:compare(A, B), 0)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>

<tr><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">op:numeric-greater-than(A, B) or op:numeric-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">fn:not(op:boolean-less-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">op:numeric-greater-than(fn:compare(A, B), -1)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">fn:not(op:date-less-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">fn:not(op:time-less-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">fn:not(op:dateTime-less-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">fn:not(op:yearMonthDuration-less-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">fn:not(op:dayTimeDuration-less-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A ge B</td><td rowspan="1" colspan="1">xs:anyURI</td><td rowspan="1" colspan="1">xs:anyURI</td><td rowspan="1" colspan="1">op:numeric-greater-than(fn:compare(A, B), -1)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>

<tr><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">op:numeric-less-than(A, B) or op:numeric-equal(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">xs:boolean</td><td rowspan="1" colspan="1">fn:not(op:boolean-greater-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">xs:string</td><td rowspan="1" colspan="1">op:numeric-less-than(fn:compare(A, B), 1)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">xs:date</td><td rowspan="1" colspan="1">fn:not(op:date-greater-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">xs:time</td><td rowspan="1" colspan="1">fn:not(op:time-greater-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">xs:dateTime</td><td rowspan="1" colspan="1">fn:not(op:dateTime-greater-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">xs:yearMonthDuration</td><td rowspan="1" colspan="1">fn:not(op:yearMonthDuration-greater-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">xs:dayTimeDuration</td><td rowspan="1" colspan="1">fn:not(op:dayTimeDuration-greater-than(A, B))</td><td rowspan="1" colspan="1">xs:boolean</td></tr><tr><td rowspan="1" colspan="1">A le B</td><td rowspan="1" colspan="1">xs:anyURI</td><td rowspan="1" colspan="1">xs:anyURI</td><td rowspan="1" colspan="1">op:numeric-less-than(fn:compare(A, B), 1)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>

<tr><td rowspan="1" colspan="1">A is B</td><td rowspan="1" colspan="1">node()</td><td rowspan="1" colspan="1">node()</td><td rowspan="1" colspan="1">op:is-same-node(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>


<tr><td rowspan="1" colspan="1">A &lt;&lt; B</td><td rowspan="1" colspan="1">node()</td><td rowspan="1" colspan="1">node()</td><td rowspan="1" colspan="1">op:node-before(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>
<tr><td rowspan="1" colspan="1">A &gt;&gt; B</td><td rowspan="1" colspan="1">node()</td><td rowspan="1" colspan="1">node()</td><td rowspan="1" colspan="1">op:node-after(A, B)</td><td rowspan="1" colspan="1">xs:boolean</td></tr>



<tr><td rowspan="1" colspan="1">A union B</td><td rowspan="1" colspan="1">node()*</td><td rowspan="1" colspan="1">node()*</td><td rowspan="1" colspan="1">op:union(A, B)</td><td rowspan="1" colspan="1">node()*</td></tr>
<tr><td rowspan="1" colspan="1">A | B</td><td rowspan="1" colspan="1">node()*</td><td rowspan="1" colspan="1">node()*</td><td rowspan="1" colspan="1">op:union(A, B)</td><td rowspan="1" colspan="1">node()*</td></tr>
<tr><td rowspan="1" colspan="1">A intersect B</td><td rowspan="1" colspan="1">node()*</td><td rowspan="1" colspan="1">node()*</td><td rowspan="1" colspan="1">op:intersect(A, B)</td><td rowspan="1" colspan="1">node()*</td></tr>
<tr><td rowspan="1" colspan="1">A except B</td><td rowspan="1" colspan="1">node()*</td><td rowspan="1" colspan="1">node()*</td><td rowspan="1" colspan="1">op:except(A, B)</td><td rowspan="1" colspan="1">node()*</td></tr>

<tr><td rowspan="1" colspan="1">A to B</td><td rowspan="1" colspan="1">xs:integer</td><td rowspan="1" colspan="1">xs:integer</td><td rowspan="1" colspan="1">op:to(A, B)</td><td rowspan="1" colspan="1">xs:integer*</td></tr>
<tr><td rowspan="1" colspan="1">A , B</td><td rowspan="1" colspan="1">item()*</td><td rowspan="1" colspan="1">item()*</td><td rowspan="1" colspan="1">op:concatenate(A, B)</td><td rowspan="1" colspan="1">item()*</td></tr>

</tbody>
</table>

<table border="1" summary="Unary operators" role="small">
<caption>Unary Operators</caption>
<tbody>
<tr>
<th rowspan="1" colspan="1">Operator</th>
<th rowspan="1" colspan="1">Operand type</th>
<th rowspan="1" colspan="1">Function</th>
<th rowspan="1" colspan="1">Result type</th>
</tr>
<tr><td rowspan="1" colspan="1">+ A</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">op:numeric-unary-plus(A)</td><td rowspan="1" colspan="1">numeric</td></tr>
<tr><td rowspan="1" colspan="1">- A</td><td rowspan="1" colspan="1">numeric</td><td rowspan="1" colspan="1">op:numeric-unary-minus(A)</td><td rowspan="1" colspan="1">numeric</td></tr>
</tbody>
</table>


</div2>
</div1>

<div1 id="id-xp-context-components" role="xpath"><head>Context Components</head><p>The tables in this
section describe the scope (range of applicability) of the various
components in the static context and dynamic context.</p>

<div2 id="id-xp-static-context-components"><head>Static Context
Components</head><p>The following table describes the components of
the <term>static context</term>. For each component, "global"
indicates that the value of the component applies throughout an XPath
expression, whereas "lexical" indicates that the value of the
component applies only within the subexpression in which it is
defined.</p>

<table width="60%" border="1" summary="Static Context" role="small">

<caption>Static Context Components</caption>
<tbody>
<tr>
<th rowspan="1" colspan="1">Component</th>



<th rowspan="1" colspan="1">Scope</th>

</tr>
<tr>
<td rowspan="1" colspan="1">XPath 1.0 Compatibility Mode</td>



<td rowspan="1" colspan="1">global</td>

</tr><tr>
<td rowspan="1" colspan="1">Statically known namespaces</td>



<td rowspan="1" colspan="1">global</td>

</tr><tr><td rowspan="1" colspan="1">Default element/type namespace</td><td rowspan="1" colspan="1">global</td></tr><tr><td rowspan="1" colspan="1">Default function namespace</td><td rowspan="1" colspan="1">global</td></tr><tr><td rowspan="1" colspan="1">In-scope schema types</td><td rowspan="1" colspan="1">global</td></tr><tr><td rowspan="1" colspan="1">In-scope element declarations</td><td rowspan="1" colspan="1">global</td></tr><tr><td rowspan="1" colspan="1">In-scope attribute declarations</td><td rowspan="1" colspan="1">global</td></tr><tr><td rowspan="1" colspan="1">In-scope variables</td><td rowspan="1" colspan="1">lexical; for-expressions and quantified expressions can bind new variables</td></tr><tr><td rowspan="1" colspan="1">Context item static type</td><td rowspan="1" colspan="1">lexical</td></tr><tr><td rowspan="1" colspan="1">Function signatures</td><td rowspan="1" colspan="1">global</td></tr><tr><td rowspan="1" colspan="1">Statically known collations</td><td rowspan="1" colspan="1">global</td></tr><tr><td rowspan="1" colspan="1">Default collation</td><td rowspan="1" colspan="1">global</td></tr><tr><td rowspan="1" colspan="1">Base URI</td><td rowspan="1" colspan="1">global</td></tr><tr><td rowspan="1" colspan="1">Statically known documents</td><td rowspan="1" colspan="1">global</td></tr><tr><td rowspan="1" colspan="1">Statically known collections</td><td rowspan="1" colspan="1">global  </td></tr><tr><td rowspan="1" colspan="1">Statically known default collection type</td><td rowspan="1" colspan="1">global</td></tr>
</tbody>
</table></div2>

<div2 id="id-xp-evaluation-context-components"><head>Dynamic Context Components</head><p>The following table describes how values are assigned to the various components of the <term>dynamic context</term>. All these components are initialized by mechanisms defined by the host language. For each component, "global" indicates that the value of the component remains constant throughout evaluation of the XPath expression, whereas "dynamic" indicates that the value of the component can be modified by the evaluation of subexpressions.</p><table width="60%" border="1" summary="Static Context" role="small">
<caption>Dynamic Context Components</caption>
<tbody>
<tr>
<th rowspan="1" colspan="1">Component</th>



<th rowspan="1" colspan="1">Scope</th>

</tr>
<tr>
<td rowspan="1" colspan="1">Context item</td>



<td rowspan="1" colspan="1">dynamic; changes during evaluation of path expressions and predicates</td>

</tr><tr>
<td rowspan="1" colspan="1">Context position</td>



<td rowspan="1" colspan="1">dynamic; changes during evaluation of path expressions and predicates</td>

</tr><tr><td rowspan="1" colspan="1">Context size</td><td rowspan="1" colspan="1">dynamic; changes during evaluation of path expressions and predicates</td></tr><tr><td rowspan="1" colspan="1">Variable values</td><td rowspan="1" colspan="1">dynamic; for-expressions and quantified expressions can bind new variables</td></tr><tr><td rowspan="1" colspan="1">Current date and time</td><td rowspan="1" colspan="1">global; must be initialized by implementation</td></tr><tr><td rowspan="1" colspan="1">Implicit timezone</td><td rowspan="1" colspan="1">global; must be initialized by implementation</td></tr><tr><td rowspan="1" colspan="1">Available documents</td><td rowspan="1" colspan="1">global; must be initialized by implementation</td></tr><tr><td rowspan="1" colspan="1">Available collections</td><td rowspan="1" colspan="1">global; must be initialized by implementation</td></tr><tr><td rowspan="1" colspan="1">Default collection</td><td rowspan="1" colspan="1">global; overwriteable by implementation</td></tr>
</tbody>
</table></div2></div1><div1 id="id-impl-defined-items"><head>Implementation-Defined Items</head><p>The following items in this specification are <termref def="dt-implementation-defined">implementation-defined</termref>:</p><olist><item><p>The version of Unicode that is used to construct expressions.</p></item><item><p>The <termref def="dt-static-collations">statically-known collations</termref>.</p></item><item><p>The <termref def="dt-timezone">implicit timezone</termref>.</p></item><item><p>The circumstances in which <termref def="dt-warning">warnings</termref> are raised, and the ways in which warnings are handled.</p></item><item><p>The method by which errors are reported to the external processing environment.</p></item><item><p>Whether the implementation is based on the rules of  <bibref ref="XML"/> and <bibref ref="XMLNAMES"/> or the rules of <bibref ref="XML1.1"/> and <bibref ref="XMLNAMES11"/>. One of these sets of rules must be applied consistently by all aspects of the implementation.</p></item><item role="xpath"><p>Whether the implementation supports the namespace axis.</p></item><item role="xpath"><p>Any <termref def="dt-xpath-static-typing-extension">static typing extensions</termref> supported by the implementation, if the <termref def="dt-xpath-static-typing-feature">Static Typing Feature</termref> is supported.</p></item></olist><note><p>Additional <termref def="dt-implementation-defined">implementation-defined</termref> items are listed in <bibref ref="datamodel"/> and <bibref ref="FunctionsAndOperators"/>.</p></note></div1>
<div1 id="id-references">
<head>References</head>
<div2 id="id-normative-references">
<head>Normative References</head>

<blist>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC2119" key="RFC 2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">S. Bradner. <emph>Key Words for use in RFCs to Indicate Requirement Levels.</emph> IETF RFC 2119. See <loc href="http://rfc.net/rfc2119.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ietf.org/rfc/rfc2119.txt</loc>.</bibl>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC2396" key="RFC2396" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">T. Berners-Lee, R. Fielding, and
L. Masinter.  <emph>Uniform Resource Identifiers (URI): Generic
Syntax</emph>. IETF RFC 2396. See <loc href="http://www.ietf.org/rfc/rfc2396.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ietf.org/rfc/rfc2396.txt</loc>.</bibl>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC3986" key="RFC3986" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">T. Berners-Lee, R. Fielding, and
L. Masinter.  <emph>Uniform Resource Identifiers (URI): Generic
Syntax</emph>. IETF RFC 3986. See <loc href="http://www.ietf.org/rfc/rfc3986.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ietf.org/rfc/rfc3986.txt</loc>.</bibl>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="RFC3987" key="RFC3987" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">M. Duerst and M. Suignard.  <emph>Internationalized Resource Identifiers (IRIs)</emph>. IETF RFC 3987. See <loc href="http://www.ietf.org/rfc/rfc3987.txt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.ietf.org/rfc/rfc3987.txt</loc>.</bibl>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="ISO10646" key="ISO/IEC 10646" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">ISO (International Organization for Standardization). <emph>ISO/IEC 10646:2003. Information technology—Universal Multiple-Octet Coded Character Set (UCS)</emph>, as, from time to time, amended, replaced by a new edition, or expanded by the addition of new parts. [Geneva]: International Organization for Standardization. (See  <loc href="http://www.iso.org" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.iso.org</loc> for the latest version.)</bibl>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="Unicode" key="Unicode" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">The Unicode Consortium. <emph>The Unicode Standard</emph>  Reading, Mass.: Addison-Wesley, 2003, as updated from time to time by the publication of new versions. See <loc href="http://www.unicode.org/unicode/standard/versions" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.unicode.org/unicode/standard/versions</loc> for the latest version and additional information on versions of the standard and of the Unicode Character Database. The version of Unicode to be used is <termref def="dt-implementation-defined">implementation-defined</termref>, but implementations are recommended to use the latest Unicode version.</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XML" key="XML 1.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium.
<emph>Extensible Markup Language (XML) 1.0. (Third Edition)</emph>
W3C Recommendation.
See <loc href="http://www.w3.org/TR/REC-xml" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/REC-xml</loc>
</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XML1.1" key="XML 1.1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium.
<emph>Extensible Markup Language (XML) 1.1.</emph>
W3C Recommendation.
See <loc href="http://www.w3.org/TR/xml11/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xml11/</loc>
</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XMLBASE" key="XML Base" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web
Consortium. <emph>XML Base.</emph> W3C Recommendation. See
<loc href="http://www.w3.org/TR/xmlbase/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xmlbase/</loc></bibl><bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XMLNAMES" key="XML Names" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web
Consortium. <emph>Namespaces in XML.</emph> W3C Recommendation. See
<loc href="http://www.w3.org/TR/REC-xml-names/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/REC-xml-names/</loc></bibl>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XMLNAMES11" key="XML Names 1.1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web
Consortium. <emph>Namespaces in XML 1.1.</emph> W3C Recommendation. See
<loc href="http://www.w3.org/TR/xml-names11/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xml-names11/</loc></bibl>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XMLID" key="XML ID" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium. <emph>xml:id Version 1.0.</emph> W3C Recommendation. See <loc href="http://www.w3.org/TR/xml-id/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xml-id/</loc></bibl>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XMLSchema" key="XML Schema" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web
Consortium. <emph>XML Schema, Parts 0, 1, and 2 (Second Edition)</emph>. W3C Recommendation, 28 October
2004. See <loc href="http://www.w3.org/TR/xmlschema-0/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xmlschema-0/</loc>, <loc href="http://www.w3.org/TR/xmlschema-1/" id="schema1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xmlschema-1/</loc>, and <loc href="http://www.w3.org/TR/xmlschema-2/" id="schema2" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xmlschema-2/</loc>.</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="XQuery/XPath Data Model (XDM)" id="datamodel" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium. <emph>XQuery 1.0 and XPath
2.0 Data Model (XDM)</emph>. W3C Recommendation, 23 Jan. 2007. See <loc href="http://www.w3.org/TR/xpath-datamodel/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xpath-datamodel/</loc>.</bibl>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XQueryFormalSemantics" key="XQuery 1.0 and XPath 2.0 Formal Semantics" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World
Wide Web Consortium. <emph>XQuery 1.0 and XPath 2.0 Formal Semantics</emph>.  W3C Recommendation,
23 Jan. 2007. See <loc href="http://www.w3.org/TR/xquery-semantics/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xquery-semantics/</loc>.</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="FunctionsAndOperators" key="XQuery 1.0 and XPath 2.0 Functions and Operators" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium. <emph>XQuery 1.0 and XPath 2.0 Functions and
     Operators</emph> W3C Recommendation, 23 Jan. 2007. See <loc href="http://www.w3.org/TR/xquery-operators/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xpath-functions/</loc>.</bibl>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="XSLT 2.0 and XQuery 1.0 Serialization" id="serialization" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World
Wide Web Consortium.
<emph>XSLT 2.0 and XQuery 1.0 Serialization</emph>.
W3C Recommendation, 23 Jan.  2007.
See <loc href="http://www.w3.org/TR/xslt-xquery-serialization/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xslt-xquery-serialization/</loc>.</bibl>

</blist>
</div2>
<div2 id="id-non-normative-references">
<head>Non-normative References</head>

<blist>



<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XPath-Requirements" key="XPath 2.0 Requirements" role="xpath" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide
Web Consortium. <emph>XPath Requirements
Version 2.0</emph>. W3C Working Draft 22 August 2003. See <loc href="http://www.w3.org/TR/xpath20req" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xpath20req</loc>.
</bibl>




<bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="XQuery" role="xpath" id="xquery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium. <emph>XQuery 1.0: An XML Query Language</emph>. W3C Recommendation, 23 Jan. 2007. See
<loc href="http://www.w3.org/TR/xquery/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xquery/</loc>.</bibl>
					

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XSLT" key="XSLT 2.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium.  <emph>XSL
Transformations (XSLT) 2.0.</emph> W3C Recommendation, 23 Jan. 2007.  See <loc href="http://www.w3.org/TR/xslt20/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xslt20/</loc></bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="DOM" key="Document Object Model" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium. <emph>Document Object Model (DOM) Level 3 Core Specification.</emph> W3C Recommendation, April 7, 2004. See <loc href="http://www.w3.org/TR/DOM-Level-3-Core/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/DOM-Level-3-Core/</loc>.</bibl>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XINFO" key="XML Infoset" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web
Consortium. <emph>XML Information Set.</emph> W3C Recommendation 24 October 2001. See
<loc href="http://www.w3.org/TR/xml-infoset/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xml-infoset/</loc>
</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" key="XPath 1.0" id="XPath" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"> World Wide Web Consortium. <emph>XML Path
Language (XPath) Version 1.0</emph>. W3C Recommendation, Nov. 16, 1999. See
<loc href="http://www.w3.org/TR/xpath.html" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xpath.html</loc></bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XPTR" key="XPointer" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium. <emph>XML
Pointer Language (XPointer).</emph> W3C Last Call Working Draft 8 January 2001. See <loc href="http://www.w3.org/TR/WD-xptr" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/WD-xptr</loc></bibl>













 

</blist>
</div2>

<div2 id="id-background-material"><head>Background Material</head><blist>
<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="CHARMOD" key="Character Model" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium.
<emph>Character Model for the World Wide Web.</emph> W3C Working
Draft. See <loc href="http://www.w3.org/TR/charmod/" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/charmod/</loc>.</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XSLT1" key="XSLT 1.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium. <emph>XSL
Transformations (XSLT) 1.0.</emph> W3C Recommendation. See <loc href="http://www.w3.org/TR/xslt" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">http://www.w3.org/TR/xslt</loc></bibl>


			




</blist>
</div2>
</div1>

<div1 role="xpath" id="id-xpath-conformance"><head>Conformance</head><p>XPath is
intended primarily as a component that can be used by other
specifications. Therefore, XPath relies on specifications that use it
(such as <bibref ref="XPTR"/> and <bibref ref="XSLT"/>) to specify
conformance criteria for XPath in their respective
environments. Specifications that set conformance criteria for their
use of XPath must not change the syntactic or semantic definitions of XPath as
given in this specification, except by subsetting and/or compatible extensions.</p><div2 id="id-xpath-static-typing"><head>Static Typing Feature</head><p>
                <termdef id="dt-xpath-static-typing-feature" term="static typing feature" role="xpath">The <term>Static
                    Typing Feature</term> is an optional feature of XPath that provides support for the static semantics defined in <bibref ref="XQueryFormalSemantics"/>, and requires implementations to detect and report <termref def="dt-type-error">type errors</termref> during the <termref def="dt-static-analysis">static analysis phase</termref>.</termdef> Specifications that use XPath may specify conformance criteria for use of the Static Typing Feature.</p>
            <p>If an implementation does not support the <termref def="dt-xpath-static-typing-feature">Static Typing Feature</termref>, but can
                nevertheless determine during the static analysis phase that an expression will necessarily
                raise a type error if evaluated at run time, the implementation may raise that error during the static analysis phase. The choice
                of whether to raise such an error at analysis time is <termref def="dt-implementation-dependent">implementation dependent</termref>.</p>
            <div3 id="id-xpath-static-extensions"><head>Static Typing Extensions</head><p>In some cases, the static typing rules defined in <bibref ref="XQueryFormalSemantics"/> are not very precise (see, for example, the type
                    inference rules for the ancestor axes—parent, ancestor, and
                    ancestor-or-self—and for the function <code>fn:root</code>). Some
                    implementations may wish to support more precise
                    static typing rules.</p>
                <p>A conforming implementation that implements the <termref def="dt-xpath-static-typing-feature">Static Typing Feature</termref> may also provide one or more
                        <term>static typing extensions</term>. <termdef term="static typing extension" id="dt-xpath-static-typing-extension">A
                            <term>static typing extension</term> is an <termref def="dt-implementation-defined">implementation-defined</termref> type inference rule that
                        infers a more precise static type than that inferred by the type inference
                        rules in <bibref ref="XQueryFormalSemantics"/>.</termdef> See <xspecref spec="FS" ref="id-static-extensions"/> for a formal definition of the constraints on static typing extensions.</p></div3></div2></div1>
<div1 id="id-errors">	
  <head>Error Conditions</head>	
<error-list>
<error spec="XP" code="0001" class="ST" type="static">
<p>
It is a <termref def="dt-static-error">static error</termref>
if analysis of an 
expression relies on some component of the <termref def="dt-static-context">static context</termref> that has not been 
assigned a value.</p></error>

<error spec="XP" code="0002" class="DY" type="dynamic">
<p>It is a  <termref def="dt-dynamic-error">dynamic error</termref>
if evaluation of an expression relies on some part of the <termref def="dt-dynamic-context">dynamic
context</termref> that has not been assigned a value.</p></error>

<error spec="XP" code="0003" class="ST" type="static">
<p>
It is a <termref def="dt-static-error">static error</termref> if an expression 
is not a valid instance of the grammar defined in <specref ref="id-grammar"/>.</p></error>

<error spec="XP" code="0004" class="TY" type="type">
<p>It is a  <termref def="dt-type-error">type error</termref> 
if, during the <termref def="dt-static-analysis">static analysis phase</termref>, an expression is found to have a <termref def="dt-static-type">static type</termref> that is not appropriate
for the context in which the expression occurs, or during the <termref def="dt-dynamic-evaluation">dynamic evaluation
phase</termref>, the <termref def="dt-dynamic-type">dynamic type</termref> of a value does not match a required type as
specified by the matching rules in <specref ref="id-sequencetype-matching"/>.</p></error>

<error spec="XP" code="0005" class="ST" type="static">
<p>
During the analysis phase,
it is a  <termref def="dt-static-error">static error</termref> 
if the <termref def="dt-static-type">static type</termref> assigned to an
expression other than the expression <code>()</code> or <code>data(())</code> is <code>empty-sequence()</code>.</p></error>

<error spec="XP" code="0006" class="TY" type="type">
<p>
(Not currently used.)</p></error>

<error spec="XP" code="0007" class="TY" type="type">
<p>(Not currently used.)</p>
</error>

<error spec="XP" code="0008" class="ST" type="static">
<p>
It is a  <termref def="dt-static-error">static error</termref>  if
an expression refers to an element name, attribute name,  schema type name, namespace prefix,
or variable name that is not defined in the 
<termref def="dt-static-context">static context</termref>, except for an ElementName in an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-ElementTest" xlink:type="simple">ElementTest</nt> or an AttributeName in an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AttributeTest" xlink:type="simple">AttributeTest</nt>.</p>
</error>







<error spec="XP" code="0010" class="ST" type="static">
<p>
An implementation  must raise a  <termref def="dt-static-error">static error</termref> if 
it encounters a reference to an axis that it does not support.</p>
</error>









<error spec="XP" code="0017" class="ST" type="static">
<p>
It is a <termref def="dt-static-error">static error</termref> if the expanded QName and number of arguments in a function call do
not match the name and arity of a <termref def="dt-function-signature">function signature</termref> in
the <termref def="dt-static-context">static context</termref>.</p>
</error>

<error spec="XP" code="0018" class="TY" type="type">
<p>It is a  <termref def="dt-type-error">type error</termref> if
the result of  the last step in a path expression contains both nodes and atomic values.</p>
</error>

<error spec="XP" code="0019" class="TY" type="type">
<p>
It is a  <termref def="dt-type-error">type error</termref> if
the result of a step (other than the last step) in a path expression contains an atomic value.</p>
</error>

<error spec="XP" code="0020" class="TY" type="type">
<p>
It is a <termref def="dt-type-error">type error</termref> if,
in an axis step, the context item is not a node.</p>
</error>

<error spec="XP" code="0021" class="DY" type="dynamic">
<p>
(Not currently used.)</p>
</error>







































<error spec="XP" code="0050" class="DY" type="dynamic">
<p>It is  a <termref def="dt-dynamic-error">dynamic error</termref>
if the <termref def="dt-dynamic-type">dynamic type</termref> of the operand of a <code>treat</code> expression does not match the <termref def="dt-sequence-type">sequence type</termref> specified by the <code>treat</code> expression. This error might also be raised by a path expression beginning with "<code>/</code>" or "<code>//</code>" if the context node is not in a tree that is rooted at a document node. This is because a leading "<code>/</code>" or "<code>//</code>" in a path expression is an abbreviation for an initial step that includes the clause <code>treat as document-node()</code>.</p></error><error spec="XP" code="0051" class="ST" type="static">
<p>It is  a <termref def="dt-static-error">static error</termref>
if a QName that is used as an <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-AtomicType" xlink:type="simple">AtomicType</nt> in a <nt xmlns:xlink="http://www.w3.org/1999/xlink" def="doc-xpath-SequenceType" xlink:type="simple">SequenceType</nt> is not defined in the <termref def="dt-is-types">in-scope schema types</termref> as an atomic type.</p></error><error spec="XP" code="0080" class="ST" type="static">
<p>It is a 
<termref def="dt-static-error">static
error</termref> if the target type of a <code>cast</code> or <code>castable</code> expression is  <code>xs:NOTATION</code> or <code>xs:anyAtomicType</code>.</p>
</error><error spec="XP" code="0081" class="ST" type="static">
<p>
It is a <termref def="dt-static-error">static
error</termref>
if a QName used in <phrase role="xpath">an expression</phrase> contains a namespace prefix that cannot be expanded into a namespace URI by using the <termref def="dt-static-namespaces">statically known namespaces</termref>.</p>
</error><error spec="XP" code="0083" class="ST" type="static">
<p>
(Not currently used.)</p>
</error></error-list>
</div1>


<inform-div1 id="id-glossary"><head>Glossary</head>
<!-- This processing instruction automatically generates the glossary. -->
<?glossary?>
</inform-div1>











<inform-div1 role="xpath" id="id-backwards-compatibility"><head>Backwards Compatibility with
XPath 1.0</head>

<p>This appendix provides a summary of the areas of incompatibility
between XPath 2.0 and <bibref ref="XPath"/>. </p>

<p>Three separate cases are considered:</p>

<olist>
<item><p>Incompatibilities that exist when source documents have no schema,
and when running with XPath 1.0 compatibility mode set to true. This specification
has been designed to reduce the number of incompatibilities in this situation to
an absolute minumum, but some differences remain and are listed individually.</p></item>

<item><p>Incompatibilities that arise when XPath 1.0 compatibility mode is set to false.
In this case, the number of expressions where compatibility is lost is rather greater.</p></item>

<item><p>Incompatibilities that arise when the source document is processed using a schema
(whether or not XPath 1.0 compatibility mode is set to true). Processing the document with
a schema changes the way that the values of nodes are interpreted, and this can cause an XPath
expression to return different results.</p></item>
</olist>

<div2 id="id-incompat-in-true-mode"><head>Incompatibilities when Compatibility Mode is true</head>

<p>The list below contains all known areas, within the scope of this specification, where
an XPath 2.0 processor running with compatibility mode set to true will produce different
results from an XPath 1.0 processor evaluating the same expression, assuming that the expression
was valid in XPath 1.0, and that the nodes in the source document have no type annotations other than
<code>xs:untyped</code> and <code>xs:untypedAtomic</code>.</p>

<p>Incompatibilities in the behavior of individual functions are not listed here, but are included
in an appendix of <bibref ref="FunctionsAndOperators"/>.</p>

<p>Since both XPath 1.0 and XPath 2.0 leave some aspects of the specification 
implementation-defined, there may be incompatiblities in the behavior of a particular implementation
that are outside the scope of this specification. Equally, some aspects of the behavior of XPath are defined
by the host language.</p>


<olist>
<item><p>Consecutive comparison operators such as <code>A &lt; B &lt; C</code> were 
supported in XPath 1.0, but are not permitted by the XPath 2.0 grammar. In most cases such
comparisons in XPath 1.0 did not have the intuitive meaning, so it is unlikely that
they have been widely used in practice. If such a construct is found, an XPath 2.0 processor
will report a syntax error, and the construct can be rewritten as <code>(A &lt; B) &lt; C</code></p></item>

<item><p>When converting strings to numbers (either explicitly when using the <code>number</code> function,
or implicitly say on a function call), certain strings that converted to the special value <code>NaN</code>
under XPath 1.0 will convert to values other than <code>NaN</code> under XPath 2.0. These include
any number written with a leading <code>+</code> sign, any number in exponential floating point 
notation (for example <code>1.0e+9</code>), and the strings <code>INF</code> and <code>-INF</code>.</p></item>

<item><p>XPath 2.0 does not allow a token starting with a letter to follow immediately after a numeric
literal, without intervening whitespace. For example, <code>10div 3</code> was permitted in XPath 1.0,
but in XPath 2.0 must be written as <code>10 div 3</code>.</p></item>

<item><p>The namespace axis is deprecated in XPath 2.0. Implementations may support 
the namespace axis for backward compatibility with XPath 1.0, but they are not 
required to do so. (XSLT 2.0 requires that if XPath backwards compatibility
mode is supported, then the namespace axis must also be supported; but other host languages
may define the conformance rules differently.)</p></item>


</olist>



</div2>

<div2 id="id-incompat-in-false-mode"><head>Incompatibilities when Compatibility Mode is false</head>

<p>Even when the setting of the XPath 1.0 compatibility mode is false, many XPath
expressions will still produce the same results under XPath 2.0 as under XPath 1.0. The exceptions
are described in this section.</p>

<p>In all cases it is assumed that the expression
in question was valid under XPath 1.0, that XPath 1.0 compatibility mode is false, and that all elements
and attributes are annotated with the types <code>xs:untyped</code> and <code>xs:untypedAtomic</code>
respectively.</p>

<p>In the description below, the terms <emph>node-set</emph> and <emph>number</emph>
are used with their XPath 1.0 meanings, that is, to describe expressions which according 
to the rules of XPath 1.0 would have generated a node-set or a number respectively.</p>

<olist>


<item><p>When a node-set containing more than one node is supplied as an argument to a
function or operator that expects a single node or value, the XPath 1.0 rule was that all nodes after the first were
discarded. Under XPath 2.0, a type error occurs if there is more than one node.
The XPath 1.0 behavior can always be restored by using the predicate <code>[1]</code> to 
explicitly select the first node in the node-set.</p></item>

<item><p>In XPath 1.0, the <code>&lt;</code> and <code>&gt;</code> operators, when applied
to two strings, attempted to convert both the strings to numbers and then made a numeric
comparison between the results. In XPath 2.0, these operators perform a string comparison using the
default collating sequence. (If either value is numeric, however, the results are compatible
with XPath 1.0)</p></item>

<item><p>When an empty node-set is supplied as an argument to a
function or operator that expects a number, the value is no longer converted
implicitly to NaN.
The XPath 1.0 behavior can always be restored by using the <code>number</code>
function to perform an explicit conversion.</p></item>

<item><p>More generally, the supplied arguments to a function or operator are no longer implicitly converted
to the required type, except in the case where the supplied argument is of type <code>xs:untypedAtomic</code>
(which will commonly be the case when a node in a schemaless document is supplied as the argument).
For example, the function call <code>substring-before(10 div 3, ".")</code> raises a type error under XPath 2.0, because the arguments
to the <code>substring-before</code> function must be strings rather than numbers. The XPath 1.0 behavior can be
restored by performing an explicit conversion to the required type using a constructor function
or cast.</p></item>

<item><p>The rules for comparing a node-set to a boolean have changed. In XPath 1.0,
an expression such as <code>$node-set = true()</code> was evaluated by converting the
node-set to a boolean and then performing a boolean comparison: so this expression would return <code>true</code>
if <code>$node-set</code> was non-empty. In XPath 2.0, this expression is handled in 
the same way as other comparisons between a sequence and a singleton: it is <code>true</code> if
<code>$node-set</code> contains at least one node whose value, after atomization and conversion
to a boolean using the casting rules, is <code>true</code>.</p>

<p>This means that if <code>$node-set</code> is empty, the result under XPath 2.0 
will be <code>false</code> regardless of
the value of the boolean operand, and regardless of which operator is used.
If <code>$node-set</code> is non-empty, then in most cases the comparison with a boolean is
likely to fail, giving a dynamic error. But if a node has the value "0",
"1", "true", or "false", evaluation of the expression may succeed.</p></item>

<item><p>Comparisons of a number to a boolean, a number to a string, or a string to a boolean
are not allowed in XPath 2.0: they result in a type error. In XPath 1.0 such comparisons were
allowed, and were handled by converting one of the operands to the type of the other. So for
example in XPath 1.0 <code>4 = true()</code> was true; <code>4 = "+4"</code> was false (because
the string <code>+4</code> converts to <code>NaN</code>), and <code>false = "false"</code> was
false (because the string <code>"false"</code> converts to the boolean <code>true</code>).
In XPath 2.0 all these comparisons are type errors.</p></item>


<item><p>Additional numeric types have been introduced, with the effect that arithmetic
may now be done as an integer, decimal, or single- or double-precision floating point calculation
where previously it was always performed as double-precision floating point. 
The result of the <code>div</code> operator when dividing two integers is now a value 
of type decimal rather than double. The expression <code>10 div 0</code> raises an 
error rather than returning positive infinity.</p></item>

<item><p>The rules for converting numbers to strings have changed. These may affect the
way numbers are displayed in the output of a stylesheet. For numbers whose absolute value
is in the range 1E-6 to 1E+6, the result should be the same, but outside this range,
scientific format is used for non-integral <code>xs:float</code> and <code>xs:double</code> values.</p>
</item>

<item><p>The rules for converting strings to numbers have changed. In addition to the changes
that apply when XPath 1.0 compatibility mode is true, when compatibility mode is false the
strings <code>Infinity</code> and <code>-Infinity</code> are no longer recognized as representations
of positive and negative infinity. Note also that while the <code>number</code> function
continues to convert all unrecognized strings to <code>NaN</code>, operations that cast a string
to a number react to such strings with a dynamic error.</p></item>

<item><p>Many operations in XPath 2.0 produce an empty sequence as their result
when one of the arguments or operands is an empty sequence. Where the operation
expects a string, an empty sequence is usually considered equivalent to a zero-length string, which
is compatible with the XPath 1.0 behavior. Where the operation expects a number, however, the
result is not the same. For example, if <code>@width</code> returns an empty sequence, then
in XPath 1.0 the result of <code>@width+1</code> was <code>NaN</code>, while with XPath 2.0
it is <code>()</code>. This has the effect that a filter expression such as <code>item[@width+1 != 2]</code>
will select items having no <code>width</code> attribute under XPath 1.0, and will not select them
under XPath 2.0.</p></item>

<item><p>The typed value of a comment node, processing instruction node, or namespace node under
XPath 2.0 is of type <code>xs:string</code>, not <code>xs:untypedAtomic</code>. This means that no implicit conversions
are applied if the value is used in a context where a number is expected. If a processing-instruction node is used as an operand of
an arithmetic operator, for example, XPath 1.0 would attempt to convert the string value of the node to a number (and deliver
<code>NaN</code> if unsuccessful), while XPath 2.0 will report a type error.</p></item>

<item><p>In XPath 1.0, it was defined that with an expression of the form <code>A and
B</code>,
B would not be evaluated if A was false. Similarly in the case of <code>A or
B</code>, B would not be evaluated if A was true. This is no longer
guaranteed with XPath 2.0: the implementation is free to evaluate the two
operands in either order or in parallel. This change has been made to give
more scope for optimization in situations where XPath expressions are
evaluated against large data collections supported by indexes. Implementations
may choose to retain backwards compatibility in this area, but they are not
obliged to do so.</p></item>




</olist>



</div2>

<div2 id="id-incompat-when-using-schema"><head>Incompatibilities when using a Schema</head>

<p>An XPath expression applied to a document that has been processed against a schema will not always
give the same results as the same expression applied to the same document in the absence of a schema.
Since schema processing had no effect on the result of an XPath 1.0 expression, this may give rise
to further incompatibilities. This section gives a few examples of the differences that can arise.</p>

<p>Suppose that the context node is an element node derived from 
the following markup: <code>&lt;background color="red green blue"/&gt;</code>. 
In XPath 1.0, the predicate <code>[@color="blue"]</code> would return <code>false</code>. 
In XPath 2.0, if the <code>color</code> attribute is defined in a schema 
to be of type <code>xs:NMTOKENS</code>, the same predicate will return <code>true</code>.</p>

<p>Similarly, consider the expression <code>@birth &lt; @death</code> applied to the
element <code>&lt;person birth="1901-06-06" death="1991-05-09"/&gt;</code>. With XPath 1.0, this
expression would return false, because both attributes are converted to numbers, which returns
<code>NaN</code> in each case. With XPath 2.0, in the presence of a schema that annotates these
attributes as dates, the expression returns <code>true</code>.</p>

<p>Once schema validation is applied, elements and attributes cannot be used as operands and arguments
of expressions that expect a different data type. For example, it is no longer possible to apply the <code>substring</code>
function to a date to extract the year component, or to a number to extract the integer part. Similarly, if an attribute is
annotated as a boolean then it is not possible to compare it with the strings <code>"true"</code> or <code>"false"</code>.
All such operations lead to type errors. The remedy when such errors occur is to introduce an explicit conversion, or
to do the computation in a different way. For example, <code>substring-after(@temperature, "-")</code> might be
rewritten as <code>abs(@temperature)</code>.</p>

<p>In the case of an XPath 2.0 implementation that provides the static typing feature, many further type errors will
be reported in respect of expressions that worked under XPath 1.0. For example, an expression such as
<code>round(../@price)</code> might lead to a static type error because the processor cannot infer statically that
<code>../@price</code> is guaranteed to be numeric.</p>

<p>Schema validation will in many cases perform whitespace normalization on the contents of elements (depending on their type).
This will change the result of operations such as the <code>string-length</code> function.</p>

<p>Schema validation augments the data model by adding default values for omitted attributes and empty elements.</p>

</div2>

</inform-div1>





<inform-div1 id="id-revisions-log"><head>Revision
Log</head>

<p role="xpath">No substantive changes have been made to this document since the Proposed Recommendation Draft of 21 November 2006.</p></inform-div1>

</back>

</spec>