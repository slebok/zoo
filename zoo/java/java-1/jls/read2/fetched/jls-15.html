
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   
      <title>Chapter&nbsp;15.&nbsp;Expressions</title>
      <link rel="stylesheet" type="text/css" href="../../../javaspec.css">
      <meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1">
      <link rel="home" href="index.html" title="The Java&reg; Language Specification">
      <link rel="up" href="index.html" title="The Java&reg; Language Specification">
      <link rel="prev" href="jls-14.html" title="Chapter&nbsp;14.&nbsp;Blocks and Statements">
      <link rel="next" href="jls-16.html" title="Chapter&nbsp;16.&nbsp;Definite Assignment">
      <link rel="copyright" href="jls-0-front.html" title="Legal Notice">
   </head>
   <body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
      <div xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:rx="http://www.renderx.com/XSL/Extensions" id="logo"><img src="http://www.oracleimg.com/us/assets/oralogo-small.gif" alt="Oracle Logo"><br><p><a target="_blank" href="http://www.oracle.com/us/technologies/java/">Oracle
                   Technology Network</a> &gt; <a target="_blank" href="http://docs.oracle.com/javase/">Java SE</a>
                &gt; <a href="index.html">Java Language Specification</a></p>
      </div>
      <div class="navheader">
         <table width="100%" summary="Navigation header">
            <tr>
               <th colspan="3" align="center">Chapter&nbsp;15.&nbsp;Expressions</th>
            </tr>
            <tr>
               <td width="20%" align="left"><a accesskey="p" href="jls-14.html">Prev</a>&nbsp;
               </td>
               <th width="60%" align="center">&nbsp;</th>
               <td width="20%" align="right">&nbsp;<a accesskey="n" href="jls-16.html">Next</a></td>
            </tr>
         </table>
         <hr>
      </div>
      <div lang="en" class="chapter" title="Chapter&nbsp;15.&nbsp;Expressions">
         <div class="titlepage">
            <div>
               <div>
                  <h2 class="title"><a name="jls-15"></a>Chapter&nbsp;15.&nbsp;Expressions
                  </h2>
               </div>
            </div>
         </div>
         <div class="toc">
            <p><b>Table of Contents</b></p>
            <dl>
               <dt><span class="section"><a href="jls-15.html#jls-15.1">15.1. Evaluation, Denotation, and Result</a></span></dt>
               <dt><span class="section"><a href="jls-15.html#jls-15.2">15.2. Forms of Expressions</a></span></dt>
               <dt><span class="section"><a href="jls-15.html#jls-15.3">15.3. Type of an Expression</a></span></dt>
               <dt><span class="section"><a href="jls-15.html#jls-15.4">15.4. FP-strict Expressions</a></span></dt>
               <dt><span class="section"><a href="jls-15.html#jls-15.5">15.5. Expressions and Run-Time Checks</a></span></dt>
               <dt><span class="section"><a href="jls-15.html#jls-15.6">15.6. Normal and Abrupt Completion of Evaluation</a></span></dt>
               <dt><span class="section"><a href="jls-15.html#jls-15.7">15.7. Evaluation Order</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-15.html#jls-15.7.1">15.7.1. Evaluate Left-Hand Operand First</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.7.2">15.7.2. Evaluate Operands before Operation</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.7.3">15.7.3. Evaluation Respects Parentheses and Precedence</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.7.4">15.7.4. Argument Lists are Evaluated Left-to-Right</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.7.5">15.7.5. Evaluation Order for Other Expressions</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-15.html#jls-15.8">15.8. Primary Expressions</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-15.html#jls-15.8.1">15.8.1. Lexical Literals</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.8.2">15.8.2. Class Literals</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.8.3">15.8.3. <code class="literal">this</code></a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.8.4">15.8.4. Qualified <code class="literal">this</code></a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.8.5">15.8.5. Parenthesized Expressions</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-15.html#jls-15.9">15.9. Class Instance Creation
                        Expressions</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-15.html#jls-15.9.1">15.9.1. Determining the Class being Instantiated</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.9.2">15.9.2. Determining Enclosing Instances</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.9.3">15.9.3. Choosing the Constructor and its Arguments</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.9.4">15.9.4. Run-Time Evaluation of Class Instance Creation Expressions</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.9.5">15.9.5. Anonymous Class Declarations</a></span></dt>
                     <dd>
                        <dl>
                           <dt><span class="section"><a href="jls-15.html#jls-15.9.5.1">15.9.5.1. Anonymous Constructors</a></span></dt>
                        </dl>
                     </dd>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-15.html#jls-15.10">15.10. Array Creation and Access Expressions</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-15.html#jls-15.10.1">15.10.1. Array Creation Expressions</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.10.2">15.10.2. Run-Time Evaluation of Array Creation Expressions</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.10.3">15.10.3. Array Access Expressions</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.10.4">15.10.4. Run-Time Evaluation of Array Access Expressions</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-15.html#jls-15.11">15.11. Field Access Expressions</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-15.html#jls-15.11.1">15.11.1. Field Access Using a Primary</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.11.2">15.11.2. Accessing Superclass Members using <code class="literal">super</code></a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-15.html#jls-15.12">15.12. Method Invocation Expressions</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-15.html#jls-15.12.1">15.12.1. Compile-Time Step 1: Determine Class or Interface to Search</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.12.2">15.12.2. Compile-Time Step 2: Determine
                              Method Signature</a></span></dt>
                     <dd>
                        <dl>
                           <dt><span class="section"><a href="jls-15.html#jls-15.12.2.1">15.12.2.1. Identify Potentially Applicable Methods</a></span></dt>
                           <dt><span class="section"><a href="jls-15.html#jls-15.12.2.2">15.12.2.2. Phase 1: Identify Matching Arity
                                    Methods Applicable by Strict Invocation</a></span></dt>
                           <dt><span class="section"><a href="jls-15.html#jls-15.12.2.3">15.12.2.3. Phase 2: Identify Matching Arity
                                    Methods Applicable by Loose Invocation</a></span></dt>
                           <dt><span class="section"><a href="jls-15.html#jls-15.12.2.4">15.12.2.4. Phase 3: Identify Methods
                                    Applicable by Variable Arity Invocation</a></span></dt>
                           <dt><span class="section"><a href="jls-15.html#jls-15.12.2.5">15.12.2.5. Choosing the Most Specific Method</a></span></dt>
                           <dt><span class="section"><a href="jls-15.html#jls-15.12.2.6">15.12.2.6. Method Invocation Type</a></span></dt>
                        </dl>
                     </dd>
                     <dt><span class="section"><a href="jls-15.html#jls-15.12.3">15.12.3. Compile-Time Step 3: Is the Chosen Method Appropriate?</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.12.4">15.12.4. Run-Time Evaluation of Method Invocation</a></span></dt>
                     <dd>
                        <dl>
                           <dt><span class="section"><a href="jls-15.html#jls-15.12.4.1">15.12.4.1. Compute Target Reference (If Necessary)</a></span></dt>
                           <dt><span class="section"><a href="jls-15.html#jls-15.12.4.2">15.12.4.2. Evaluate Arguments</a></span></dt>
                           <dt><span class="section"><a href="jls-15.html#jls-15.12.4.3">15.12.4.3. Check Accessibility of Type and Method</a></span></dt>
                           <dt><span class="section"><a href="jls-15.html#jls-15.12.4.4">15.12.4.4. Locate Method to Invoke</a></span></dt>
                           <dt><span class="section"><a href="jls-15.html#jls-15.12.4.5">15.12.4.5. Create Frame, Synchronize, Transfer Control</a></span></dt>
                        </dl>
                     </dd>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-15.html#jls-15.13">15.13. Method Reference Expressions</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-15.html#jls-15.13.1">15.13.1. Compile-Time Declaration of a Method Reference</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.13.2">15.13.2. Type of a Method Reference</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.13.3">15.13.3. Run-time Evaluation of Method References</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-15.html#jls-15.14">15.14. Postfix Expressions</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-15.html#jls-15.14.1">15.14.1. Expression Names</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.14.2">15.14.2. Postfix Increment Operator <code class="literal">++</code></a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.14.3">15.14.3. Postfix Decrement Operator <code class="literal">--</code></a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-15.html#jls-15.15">15.15. Unary Operators</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-15.html#jls-15.15.1">15.15.1. Prefix Increment Operator <code class="literal">++</code></a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.15.2">15.15.2. Prefix Decrement Operator <code class="literal">--</code></a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.15.3">15.15.3. Unary Plus Operator <code class="literal">+</code></a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.15.4">15.15.4. Unary Minus Operator <code class="literal">-</code></a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.15.5">15.15.5. Bitwise Complement Operator <code class="literal">~</code></a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.15.6">15.15.6. Logical Complement Operator <code class="literal">!</code></a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-15.html#jls-15.16">15.16. Cast Expressions</a></span></dt>
               <dt><span class="section"><a href="jls-15.html#jls-15.17">15.17. Multiplicative Operators</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-15.html#jls-15.17.1">15.17.1. Multiplication Operator <code class="literal">*</code></a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.17.2">15.17.2. Division Operator <code class="literal">/</code></a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.17.3">15.17.3. Remainder Operator <code class="literal">%</code></a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-15.html#jls-15.18">15.18. Additive Operators</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-15.html#jls-15.18.1">15.18.1. String Concatenation Operator <code class="literal">+</code></a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.18.2">15.18.2. Additive Operators (<code class="literal">+</code> and <code class="literal">-</code>) for Numeric Types</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-15.html#jls-15.19">15.19. Shift Operators</a></span></dt>
               <dt><span class="section"><a href="jls-15.html#jls-15.20">15.20. Relational Operators</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-15.html#jls-15.20.1">15.20.1. Numerical Comparison Operators <code class="literal">&lt;</code>,
                              <code class="literal">&lt;=</code>, <code class="literal">&gt;</code>, and <code class="literal">&gt;=</code></a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.20.2">15.20.2. Type Comparison Operator <code class="literal">instanceof</code></a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-15.html#jls-15.21">15.21. Equality Operators</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-15.html#jls-15.21.1">15.21.1. Numerical Equality Operators <code class="literal">==</code> and <code class="literal">!=</code></a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.21.2">15.21.2. Boolean Equality Operators <code class="literal">==</code> and <code class="literal">!=</code></a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.21.3">15.21.3. Reference Equality Operators <code class="literal">==</code> and <code class="literal">!=</code></a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-15.html#jls-15.22">15.22. Bitwise and Logical Operators</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-15.html#jls-15.22.1">15.22.1. Integer Bitwise Operators <code class="literal">&amp;</code>, <code class="literal">^</code>, and <code class="literal">|</code></a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.22.2">15.22.2. Boolean Logical Operators <code class="literal">&amp;</code>, <code class="literal">^</code>, and <code class="literal">|</code></a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-15.html#jls-15.23">15.23. Conditional-And Operator <code class="literal">&amp;&amp;</code></a></span></dt>
               <dt><span class="section"><a href="jls-15.html#jls-15.24">15.24. Conditional-Or Operator <code class="literal">||</code></a></span></dt>
               <dt><span class="section"><a href="jls-15.html#jls-15.25">15.25. Conditional Operator <code class="literal">? :</code></a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-15.html#jls-15.25.1">15.25.1. Boolean Conditional Expressions</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.25.2">15.25.2. Numeric Conditional Expressions</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.25.3">15.25.3. Reference Conditional Expressions</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-15.html#jls-15.26">15.26. Assignment Operators</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-15.html#jls-15.26.1">15.26.1. Simple Assignment Operator <code class="literal">=</code></a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.26.2">15.26.2. Compound Assignment Operators</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-15.html#jls-15.27">15.27. Lambda Expressions</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-15.html#jls-15.27.1">15.27.1. Lambda Parameters</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.27.2">15.27.2. Lambda Body</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.27.3">15.27.3. Type of a Lambda Expression</a></span></dt>
                     <dt><span class="section"><a href="jls-15.html#jls-15.27.4">15.27.4. Run-time Evaluation of Lambda Expressions</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-15.html#jls-15.28">15.28. Constant Expressions</a></span></dt>
            </dl>
         </div>
         <p class="norm"><a name="jls-15-100"></a>Much of the work in a program is
            done by evaluating <span class="emphasis"><em>expressions</em></span>, either for their
            side effects, such as assignments to variables, or for their values,
            which can be used as arguments or operands in larger expressions, or
            to affect the execution sequence in statements, or both.
         </p>
         <p class="norm"><a name="jls-15-110"></a>This chapter specifies the
            meanings of expressions and the rules for their evaluation.
         </p>
         <div class="section" title="15.1.&nbsp;Evaluation, Denotation, and Result">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.1"></a>15.1.&nbsp;Evaluation, Denotation, and Result
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-15.1-100"></a>When an expression in a
               program is <span class="emphasis"><em>evaluated</em></span>
               (<span class="emphasis"><em>executed</em></span>), the result denotes one of three
               things:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.1-100-A"></a>
                              A variable (<a class="xref" href="jls-4.html#jls-4.12" title="4.12.&nbsp;Variables">&sect;4.12</a>) (in C, this would be
                              called an <span class="emphasis"><em>lvalue</em></span>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.1-100-B"></a>
                              A value (<a class="xref" href="jls-4.html#jls-4.2" title="4.2.&nbsp;Primitive Types and Values">&sect;4.2</a>,
                              <a class="xref" href="jls-4.html#jls-4.3" title="4.3.&nbsp;Reference Types and Values">&sect;4.3</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.1-100-C"></a>
                              Nothing (the expression is said to be void)
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm"><a name="jls-15.1-110"></a>If an expression denotes a
               variable, and a value is required for use in further evaluation, then
               the value of that variable is used. In this context, if the expression
               denotes a variable or a value, we may speak simply of
               the <span class="emphasis"><em>value</em></span> of the expression.
            </p>
            <p class="norm"><a name="jls-15.1-120"></a>Value set conversion
               (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>) is applied to the result of every
               expression that produces a value, including when the value of a
               variable of type <code class="literal">float</code> or <code class="literal">double</code> is used.
            </p>
            <p class="norm"><a name="jls-15.1-130"></a>An expression denotes nothing
               if and only if it is a method invocation (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>)
               that invokes a method that does not return a value, that is, a method
               declared <code class="literal">void</code> (<a class="xref" href="jls-8.html#jls-8.4" title="8.4.&nbsp;Method Declarations">&sect;8.4</a>). Such an expression can be
               used only as an expression statement (<a class="xref" href="jls-14.html#jls-14.8" title="14.8.&nbsp;Expression Statements">&sect;14.8</a>),
               because every other context in which an expression can appear requires
               the expression to denote something. An expression statement that is a
               method invocation may also invoke a method that produces a result; in
               this case the value returned by the method is quietly discarded.
            </p>
            <p class="norm"><a name="jls-15.1-200"></a>Evaluation of an expression
               can produce side effects, because expressions may contain embedded
               assignments, increment operators, decrement operators, and method
               invocations.
            </p>
            <p class="norm"><a name="jls-15.1-300"></a>An expression occurs in
               either:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.1-300-A"></a>The declaration of some
                              (class or interface) type that is being declared: in a field
                              initializer, in a static initializer, in an instance
                              initializer, in a constructor declaration, in a method
                              declaration, or in an annotation.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.1-300-B"></a>An annotation on a
                              package declaration or on a top level type declaration.
                     </p>
                  </li>
               </ul>
            </div>
         </div>
         <div class="section" title="15.2.&nbsp;Forms of Expressions">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.2"></a>15.2.&nbsp;Forms of Expressions
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-15.2-100"></a>Expressions can be broadly
               categorized into one of the following syntactic forms:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.2-100-A"></a>
                              Expression names (<a class="xref" href="jls-6.html#jls-6.5.6" title="6.5.6.&nbsp;Meaning of Expression Names">&sect;6.5.6</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.2-100-B"></a>
                              Primary expressions (<a class="xref" href="jls-15.html#jls-15.8" title="15.8.&nbsp;Primary Expressions">&sect;15.8</a> -
                              <a class="xref" href="jls-15.html#jls-15.13" title="15.13.&nbsp;Method Reference Expressions">&sect;15.13</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.2-100-C"></a>
                              Unary operator expressions (<a class="xref" href="jls-15.html#jls-15.14" title="15.14.&nbsp;Postfix Expressions">&sect;15.14</a> -
                              <a class="xref" href="jls-15.html#jls-15.16" title="15.16.&nbsp;Cast Expressions">&sect;15.16</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.2-100-D"></a>
                              Binary operator expressions (<a class="xref" href="jls-15.html#jls-15.17" title="15.17.&nbsp;Multiplicative Operators">&sect;15.17</a> -
                              <a class="xref" href="jls-15.html#jls-15.24" title="15.24.&nbsp;Conditional-Or Operator ||">&sect;15.24</a>, and
                              <a class="xref" href="jls-15.html#jls-15.26" title="15.26.&nbsp;Assignment Operators">&sect;15.26</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.2-100-E"></a>
                              Ternary operator expressions (<a class="xref" href="jls-15.html#jls-15.25" title="15.25.&nbsp;Conditional Operator ? :">&sect;15.25</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.2-100-F"></a>
                              Lambda expressions (<a class="xref" href="jls-15.html#jls-15.27" title="15.27.&nbsp;Lambda Expressions">&sect;15.27</a>)
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm"><a name="jls-15.2-200"></a>Precedence among operators is
               managed by a hierarchy of grammar productions. The lowest precedence
               operator is the arrow of a lambda expression (<code class="literal">-&gt;</code>), followed by
               the assignment operators. Thus, all expressions are syntactically
               included in the <span class="emphasis"><em>LambdaExpression</em></span>
               and <span class="emphasis"><em>AssignmentExpression</em></span> nonterminals:
            </p>
            <div id="jls-15.2-210" class="productionset"><a name="jls-15.2-210"></a>
                 
               <div class="production"><a name="jls-Expression"></a>
                      
                  <div class="lhs">Expression:</div>
                      
                  <div class="rhs">
                           <a href="jls-15.html#jls-LambdaExpression" title="LambdaExpression">LambdaExpression</a> <br>
                           <a href="jls-15.html#jls-AssignmentExpression" title="AssignmentExpression">AssignmentExpression</a>
                         
                  </div>
                    
               </div>
               
            </div>
            <p class="norm-static"><a name="jls-15.2-300"></a>When some
               expressions appear in certain contexts, they are considered 
               <span class="emphasis"><em>poly expressions</em></span>. The following forms of
               expressions may be poly expressions:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.2-300-A"></a>
                              Parenthesized expressions (<a class="xref" href="jls-15.html#jls-15.8.5" title="15.8.5.&nbsp;Parenthesized Expressions">&sect;15.8.5</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.2-300-B"></a>
                              Class instance creation expressions
                              (<a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.2-300-C"></a>
                              Method invocation expressions
                              (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.2-300-D"></a>
                              Method reference expressions
                              (<a class="xref" href="jls-15.html#jls-15.13" title="15.13.&nbsp;Method Reference Expressions">&sect;15.13</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.2-300-E"></a>
                              Conditional expressions (<a class="xref" href="jls-15.html#jls-15.25" title="15.25.&nbsp;Conditional Operator ? :">&sect;15.25</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.2-300-F"></a>
                              Lambda expressions (<a class="xref" href="jls-15.html#jls-15.27" title="15.27.&nbsp;Lambda Expressions">&sect;15.27</a>)
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm"><a name="jls-15.2-310"></a>The rules determining whether
               an expression of one of these forms is a poly expression are given in
               the individual sections that specify these forms of
               expressions.
            </p>
            <p class="norm-static"><a name="jls-15.2-320"></a>Expressions
               that are not poly expressions are <span class="emphasis"><em>standalone
                     expressions</em></span>. Standalone expressions are expressions of the
               forms above when determined not to be poly expressions, as well as all
               expressions of all other forms. Expressions of all other forms are
               said to have a <span class="emphasis"><em>standalone form</em></span>.
            </p>
            <p class="norm-static"><a name="jls-15.2-400"></a>Some
               expressions have a value that can be determined at compile time.
               These are <span class="emphasis"><em>constant expressions</em></span>
               (<a class="xref" href="jls-15.html#jls-15.28" title="15.28.&nbsp;Constant Expressions">&sect;15.28</a>).
            </p>
         </div>
         <div class="section" title="15.3.&nbsp;Type of an Expression">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.3"></a>15.3.&nbsp;Type of an Expression
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-15.3-100"></a>If an expression denotes a variable or
               a value, then the expression has a type known at compile time. The
               type of a standalone expression can be determined entirely from the
               contents of the expression; in contrast, the type of a poly expression
               may be influenced by the expression's target type
               (<a class="xref" href="jls-5.html" title="Chapter&nbsp;5.&nbsp;Conversions and Contexts">&sect;5 (<i>Conversions and Contexts</i>)</a>). The rules for determining the type of an
               expression are explained separately below for each kind of
               expression.
            </p>
            <p class="norm"><a name="jls-15.3-110"></a>The value of an expression is
               assignment compatible (<a class="xref" href="jls-5.html#jls-5.2" title="5.2.&nbsp;Assignment Contexts">&sect;5.2</a>) with the type of the
               expression, unless heap pollution occurs (<a class="xref" href="jls-4.html#jls-4.12.2" title="4.12.2.&nbsp;Variables of Reference Type">&sect;4.12.2</a>).
            </p>
            <p class="norm"><a name="jls-15.3-120"></a>Likewise, the value stored in
               a variable is always compatible with the type of the variable, unless
               heap pollution occurs.
            </p>
            <p class="norm"><a name="jls-15.3-130"></a>In other words, the value of
               an expression whose type is <span class="type">T</span> is always suitable for assignment to a
               variable of type <span class="type">T</span>.
            </p>
            <p class="norm"><a name="jls-15.3-200"></a>Note that an expression whose
               type is a class type <span class="type">F</span> that is declared <code class="literal">final</code> is guaranteed to
               have a value that is either a null reference or an object whose class
               is <span class="type">F</span> itself, because <code class="literal">final</code> types have no subclasses.
            </p>
         </div>
         <div class="section" title="15.4.&nbsp;FP-strict Expressions">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.4"></a>15.4.&nbsp;FP-strict Expressions
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-15.4-100"></a>If the type of an expression
               is <code class="literal">float</code> or <code class="literal">double</code>, then there is a question as to what value set
               (<a class="xref" href="jls-4.html#jls-4.2.3" title="4.2.3.&nbsp;Floating-Point Types, Formats, and Values">&sect;4.2.3</a>) the value of the expression is drawn
               from. This is governed by the rules of value set conversion
               (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>); these rules in turn depend on whether
               or not the expression is <span class="emphasis"><em>FP-strict</em></span>.
            </p>
            <p class="norm"><a name="jls-15.4-110"></a>Every constant expression
               (<a class="xref" href="jls-15.html#jls-15.28" title="15.28.&nbsp;Constant Expressions">&sect;15.28</a>) is FP-strict.
            </p>
            <p class="norm"><a name="jls-15.4-120"></a>If an expression is not a
               constant expression, then consider all the class declarations,
               interface declarations, and method declarations that contain the
               expression. If <span class="emphasis"><em>any</em></span> such declaration bears the
               <code class="literal">strictfp</code> modifier (<a class="xref" href="jls-8.html#jls-8.1.1.3" title="8.1.1.3.&nbsp;strictfp Classes">&sect;8.1.1.3</a>,
               <a class="xref" href="jls-8.html#jls-8.4.3.5" title="8.4.3.5.&nbsp;strictfp Methods">&sect;8.4.3.5</a>, <a class="xref" href="jls-9.html#jls-9.1.1.2" title="9.1.1.2.&nbsp;strictfp Interfaces">&sect;9.1.1.2</a>), then
               the expression is FP-strict.
            </p>
            <p class="norm"><a name="jls-15.4-130"></a>If a class, interface, or
               method, <span class="type">X</span>, is declared <code class="literal">strictfp</code>, then <span class="type">X</span> and any class,
               interface, method, constructor, instance initializer, static
               initializer, or variable initializer within <span class="type">X</span> is said to
               be <span class="emphasis"><em>FP-strict</em></span>.
            </p>
            <p class="note">Note that an annotation's element value
               (<a class="xref" href="jls-9.html#jls-9.7" title="9.7.&nbsp;Annotations">&sect;9.7</a>) is always FP-strict, because it is always
               a constant expression.
            </p>
            <p class="norm"><a name="jls-15.4-200"></a>It follows that an expression
               is not FP-strict if and only if it is not a constant
               expression <span class="emphasis"><em>and</em></span> it does not appear within any
               declaration that has the <code class="literal">strictfp</code> modifier.
            </p>
            <p class="norm"><a name="jls-15.4-300"></a>Within an FP-strict
               expression, all intermediate values must be elements of the float
               value set or the double value set, implying that the results of all
               FP-strict expressions must be those predicted by IEEE 754 arithmetic
               on operands represented using single and double formats.
            </p>
            <p class="norm"><a name="jls-15.4-310"></a>Within an expression that is
               not FP-strict, some leeway is granted for an implementation to use an
               extended exponent range to represent intermediate results; the net
               effect, roughly speaking, is that a calculation might produce "the
               correct answer" in situations where exclusive use of the float value
               set or double value set might result in overflow or underflow.
            </p>
         </div>
         <div class="section" title="15.5.&nbsp;Expressions and Run-Time Checks">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.5"></a>15.5.&nbsp;Expressions and Run-Time Checks
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-15.5-100"></a>If the type of an expression
               is a primitive type, then the value of the expression is of that same
               primitive type.
            </p>
            <p class="norm"><a name="jls-15.5-110"></a>If the type of an expression
               is a reference type, then the class of the referenced object, or even
               whether the value is a reference to an object rather than <code class="literal">null</code>, is
               not necessarily known at compile time. There are a few places in the
               Java programming language where the actual class of a referenced object affects
               program execution in a manner that cannot be deduced from the type of
               the expression. They are as follows:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.5-110-A"></a>
                              Method invocation (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>). The particular
                              method used for an invocation <code class="literal">o.m(...)</code> is
                              chosen based on the methods that are part of the class or
                              interface that is the type of <code class="literal">o</code>. For instance
                              methods, the class of the object referenced by the run-time
                              value of <code class="literal">o</code> participates because a subclass
                              may override a specific method already declared in a parent
                              class so that this overriding method is invoked. (The overriding
                              method may or may not choose to further invoke the original
                              overridden <code class="literal">m</code> method.)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.5-110-B"></a>
                              The <code class="literal">instanceof</code> operator (<a class="xref" href="jls-15.html#jls-15.20.2" title="15.20.2.&nbsp;Type Comparison Operator instanceof">&sect;15.20.2</a>). An
                              expression whose type is a reference type may be tested using
                              <code class="literal">instanceof</code> to find out whether the class of the object
                              referenced by the run-time value of the expression is assignment
                              compatible (<a class="xref" href="jls-5.html#jls-5.2" title="5.2.&nbsp;Assignment Contexts">&sect;5.2</a>) with some other reference
                              type.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.5-110-C"></a>
                              Casting (<a class="xref" href="jls-5.html#jls-5.5" title="5.5.&nbsp;Casting Contexts">&sect;5.5</a>, <a class="xref" href="jls-15.html#jls-15.16" title="15.16.&nbsp;Cast Expressions">&sect;15.16</a>). 
                              The class of the object referenced by the run-time value of the
                              operand expression might not be compatible with the type
                              specified by the cast. For reference types, this may require a
                              run-time check that throws an exception if the class of the
                              referenced object, as determined at run time, is not assignment
                              compatible (<a class="xref" href="jls-5.html#jls-5.2" title="5.2.&nbsp;Assignment Contexts">&sect;5.2</a>) with the target
                              type.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.5-110-D"></a>
                              Assignment to an array component of reference type
                              (<a class="xref" href="jls-10.html#jls-10.5" title="10.5.&nbsp;Array Store Exception">&sect;10.5</a>, <a class="xref" href="jls-15.html#jls-15.13" title="15.13.&nbsp;Method Reference Expressions">&sect;15.13</a>,
                              <a class="xref" href="jls-15.html#jls-15.26.1" title="15.26.1.&nbsp;Simple Assignment Operator =">&sect;15.26.1</a>). The type-checking rules allow
                              the array type <span class="type">S</span><code class="literal">[]</code> to be treated as a subtype of
                              <span class="type">T</span><code class="literal">[]</code> if <span class="type">S</span> is a subtype of <span class="type">T</span>, but this requires a
                              run-time check for assignment to an array component, similar to
                              the check performed for a cast.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.5-110-E"></a>
                              Exception handling (<a class="xref" href="jls-14.html#jls-14.20" title="14.20.&nbsp;The try statement">&sect;14.20</a>). An exception
                              is caught by a <code class="literal">catch</code> clause only if the class of the thrown
                              exception object is an <code class="literal">instanceof</code> the type of the formal
                              parameter of the <code class="literal">catch</code> clause.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm"><a name="jls-15.5-120"></a>Situations where the class of
               an object is not statically known may lead to run-time type
               errors.
            </p>
            <p class="norm"><a name="jls-15.5-200"></a>In addition, there are
               situations where the statically known type may not be accurate at run
               time. Such situations can arise in a program that gives rise to
               compile-time unchecked warnings. Such warnings are given in response
               to operations that cannot be statically guaranteed to be safe, and
               cannot immediately be subjected to dynamic checking because they
               involve non-reifiable types (<a class="xref" href="jls-4.html#jls-4.7" title="4.7.&nbsp;Reifiable Types">&sect;4.7</a>). As a result,
               dynamic checks later in the course of program execution may detect
               inconsistencies and result in run-time type errors.
            </p>
            <p class="norm"><a name="jls-15.5-210"></a>A run-time type error can occur
               only in these situations:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.5-210-A"></a>
                              In a cast, when the actual class of the object referenced by the
                              value of the operand expression is not compatible with the
                              target type specified by the cast operator
                              (<a class="xref" href="jls-5.html#jls-5.5" title="5.5.&nbsp;Casting Contexts">&sect;5.5</a>, <a class="xref" href="jls-15.html#jls-15.16" title="15.16.&nbsp;Cast Expressions">&sect;15.16</a>); in
                              this case a <code class="literal">ClassCastException</code> is thrown.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.5-210-B"></a>
                              In an automatically generated
                              cast introduced to ensure the validity of an operation on a
                              non-reifiable type (<a class="xref" href="jls-4.html#jls-4.7" title="4.7.&nbsp;Reifiable Types">&sect;4.7</a>).
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.5-210-C"></a>
                              In an assignment to an array component of reference type, when
                              the actual class of the object referenced by the value to be
                              assigned is not compatible with the actual run-time component
                              type of the array (<a class="xref" href="jls-10.html#jls-10.5" title="10.5.&nbsp;Array Store Exception">&sect;10.5</a>,
                              <a class="xref" href="jls-15.html#jls-15.13" title="15.13.&nbsp;Method Reference Expressions">&sect;15.13</a>, <a class="xref" href="jls-15.html#jls-15.26.1" title="15.26.1.&nbsp;Simple Assignment Operator =">&sect;15.26.1</a>); in
                              this case an <code class="literal">ArrayStoreException</code> is thrown.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.5-210-D"></a>
                              When an exception is not caught by any <code class="literal">catch</code> clause of a <code class="literal">try</code>
                              statement (<a class="xref" href="jls-14.html#jls-14.20" title="14.20.&nbsp;The try statement">&sect;14.20</a>); in this case the thread
                              of control that encountered the exception first   attempts to invoke an uncaught exception
                              handler (<a class="xref" href="jls-11.html#jls-11.3" title="11.3.&nbsp;Run-Time Handling of an Exception">&sect;11.3</a>)  and then
                              terminates.
                     </p>
                  </li>
               </ul>
            </div>
         </div>
         <div class="section" title="15.6.&nbsp;Normal and Abrupt Completion of Evaluation">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.6"></a>15.6.&nbsp;Normal and Abrupt Completion of Evaluation
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-15.6-100"></a>Every expression has a normal
               mode of evaluation in which certain computational steps are carried
               out. The following sections describe the normal mode of evaluation for
               each kind of expression.
            </p>
            <p class="norm"><a name="jls-15.6-110"></a>If all the steps are carried
               out without an exception being thrown, the expression is said
               to <span class="emphasis"><em>complete normally</em></span>.
            </p>
            <p class="norm"><a name="jls-15.6-120"></a>If, however, evaluation of an
               expression throws an exception, then the expression is said
               to <span class="emphasis"><em>complete abruptly</em></span>. An abrupt completion always
               has an associated reason, which is always a <code class="literal">throw</code> with a given
               value.
            </p>
            <p class="norm"><a name="jls-15.6-200"></a>Run-time exceptions are thrown
               by the predefined operators as follows:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.6-200-A"></a>
                              A class instance creation expression
                              (<a class="xref" href="jls-15.html#jls-15.9.4" title="15.9.4.&nbsp;Run-Time Evaluation of Class Instance Creation Expressions">&sect;15.9.4</a>), array creation expression
                              (<a class="xref" href="jls-15.html#jls-15.10.2" title="15.10.2.&nbsp;Run-Time Evaluation of Array Creation Expressions">&sect;15.10.2</a>), method reference expression
                              (<a class="xref" href="jls-15.html#jls-15.13.3" title="15.13.3.&nbsp;Run-time Evaluation of Method References">&sect;15.13.3</a>), array initializer expression
                              (<a class="xref" href="jls-10.html#jls-10.6" title="10.6.&nbsp;Array Initializers">&sect;10.6</a>), string concatenation operator
                              expression (<a class="xref" href="jls-15.html#jls-15.18.1" title="15.18.1.&nbsp;String Concatenation Operator +">&sect;15.18.1</a>), or lambda expression
                              (<a class="xref" href="jls-15.html#jls-15.27.4" title="15.27.4.&nbsp;Run-time Evaluation of Lambda Expressions">&sect;15.27.4</a>) throws an <code class="literal">OutOfMemoryError</code> if there is
                              insufficient memory available.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.6-200-B"></a>
                              An array creation expression (<a class="xref" href="jls-15.html#jls-15.10.2" title="15.10.2.&nbsp;Run-Time Evaluation of Array Creation Expressions">&sect;15.10.2</a>)
                              throws a <code class="literal">NegativeArraySizeException</code> if the value of any
                              dimension expression is less than zero.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.6-200-C"></a>
                              An array access expression (<a class="xref" href="jls-15.html#jls-15.10.4" title="15.10.4.&nbsp;Run-Time Evaluation of Array Access Expressions">&sect;15.10.4</a>)
                              throws a <code class="literal">NullPointerException</code> if the value of the array reference expression is
                              <code class="literal">null</code>.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.6-200-D"></a>
                              An array access expression (<a class="xref" href="jls-15.html#jls-15.10.4" title="15.10.4.&nbsp;Run-Time Evaluation of Array Access Expressions">&sect;15.10.4</a>)
                              throws an <code class="literal">ArrayIndexOutOfBoundsException</code> if the value of the array index expression is
                              negative or greater than or equal to the <code class="literal">length</code> of the
                              array.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.6-200-E"></a>
                              A field access expression (<a class="xref" href="jls-15.html#jls-15.11" title="15.11.&nbsp;Field Access Expressions">&sect;15.11</a>) throws a
                              <code class="literal">NullPointerException</code> if the value of the object reference expression is
                              <code class="literal">null</code>.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.6-200-F"></a>
                              A method invocation expression (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>)
                              that invokes an instance method throws a <code class="literal">NullPointerException</code> if the target
                              reference is <code class="literal">null</code>.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.6-200-G"></a>
                              A cast expression (<a class="xref" href="jls-15.html#jls-15.16" title="15.16.&nbsp;Cast Expressions">&sect;15.16</a>) throws a <code class="literal">ClassCastException</code>
                              if a cast is found to be impermissible at run time.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.6-200-H"></a>
                              An integer division (<a class="xref" href="jls-15.html#jls-15.17.2" title="15.17.2.&nbsp;Division Operator /">&sect;15.17.2</a>) or integer
                              remainder (<a class="xref" href="jls-15.html#jls-15.17.3" title="15.17.3.&nbsp;Remainder Operator %">&sect;15.17.3</a>) operator throws an
                              <code class="literal">ArithmeticException</code> if the value of the right-hand operand
                              expression is zero.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.6-200-I"></a>
                              An assignment to an array component of reference type
                              (<a class="xref" href="jls-15.html#jls-15.26.1" title="15.26.1.&nbsp;Simple Assignment Operator =">&sect;15.26.1</a>), a method invocation expression
                              (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>), or a prefix or postfix increment
                              (<a class="xref" href="jls-15.html#jls-15.14.2" title="15.14.2.&nbsp;Postfix Increment Operator ++">&sect;15.14.2</a>, <a class="xref" href="jls-15.html#jls-15.15.1" title="15.15.1.&nbsp;Prefix Increment Operator ++">&sect;15.15.1</a>)
                              or decrement operator (<a class="xref" href="jls-15.html#jls-15.14.3" title="15.14.3.&nbsp;Postfix Decrement Operator --">&sect;15.14.3</a>,
                              <a class="xref" href="jls-15.html#jls-15.15.2" title="15.15.2.&nbsp;Prefix Decrement Operator --">&sect;15.15.2</a>) may all throw an <code class="literal">OutOfMemoryError</code> as a
                              result of boxing conversion
                              (<a class="xref" href="jls-5.html#jls-5.1.7" title="5.1.7.&nbsp;Boxing Conversion">&sect;5.1.7</a>).
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.6-200-J"></a>
                              An assignment to an array component of reference type
                              (<a class="xref" href="jls-15.html#jls-15.26.1" title="15.26.1.&nbsp;Simple Assignment Operator =">&sect;15.26.1</a>) throws an <code class="literal">ArrayStoreException</code> when the value
                              to be assigned is not compatible with the component type of the
                              array (<a class="xref" href="jls-10.html#jls-10.5" title="10.5.&nbsp;Array Store Exception">&sect;10.5</a>).
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm"><a name="jls-15.6-210"></a>A method invocation expression
               can also result in an exception being thrown if an exception occurs
               that causes execution of the method body to complete abruptly.
            </p>
            <p class="norm"><a name="jls-15.6-220"></a>A class instance creation
               expression can also result in an exception being thrown if an
               exception occurs that causes execution of the constructor to complete
               abruptly.
            </p>
            <p class="norm"><a name="jls-15.6-230"></a>Various linkage and virtual
               machine errors may also occur during the evaluation of an
               expression. By their nature, such errors are difficult to predict and
               difficult to handle.
            </p>
            <p class="norm"><a name="jls-15.6-300"></a>If an exception occurs, then
               evaluation of one or more expressions may be terminated before all
               steps of their normal mode of evaluation are complete; such
               expressions are said to complete abruptly.
            </p>
            <p class="norm"><a name="jls-15.6-310"></a>If evaluation of an expression
               requires evaluation of a subexpression, then abrupt completion of the
               subexpression always causes the immediate abrupt completion of the
               expression itself, with the same reason, and all succeeding steps in
               the normal mode of evaluation are not performed.
            </p>
            <p class="norm"><a name="jls-15.6-400"></a>The terms "complete normally"
               and "complete abruptly" are also applied to the execution of
               statements (<a class="xref" href="jls-14.html#jls-14.1" title="14.1.&nbsp;Normal and Abrupt Completion of Statements">&sect;14.1</a>). A statement may complete
               abruptly for a variety of reasons, not just because an exception is
               thrown.
            </p>
         </div>
         <div class="section" title="15.7.&nbsp;Evaluation Order">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.7"></a>15.7.&nbsp;Evaluation Order
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-dynamic"><a name="jls-15.7-100"></a>The
               Java programming language guarantees that the operands of operators appear to be
               evaluated in a specific <span class="emphasis"><em>evaluation order</em></span>, namely,
               from left to right.
            </p>
            <p class="note">It is recommended that code not rely crucially on
               this specification. Code is usually clearer when each expression
               contains at most one side effect, as its outermost operation, and when
               code does not depend on exactly which exception arises as a
               consequence of the left-to-right evaluation of expressions.
            </p>
            <div class="section" title="15.7.1.&nbsp;Evaluate Left-Hand Operand First">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.7.1"></a>15.7.1.&nbsp;Evaluate Left-Hand Operand First
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-15.7.1-100"></a>The left-hand operand of a
                  binary operator appears to be fully evaluated before any part of the
                  right-hand operand is evaluated.
               </p>
               <p class="norm"><a name="jls-15.7.1-110"></a>If the operator is a
                  compound-assignment operator (<a class="xref" href="jls-15.html#jls-15.26.2" title="15.26.2.&nbsp;Compound Assignment Operators">&sect;15.26.2</a>), then
                  evaluation of the left-hand operand includes both remembering the
                  variable that the left-hand operand denotes and fetching and saving
                  that variable's value for use in the implied binary
                  operation.
               </p>
               <p class="norm"><a name="jls-15.7.1-120"></a>If evaluation of the
                  left-hand operand of a binary operator completes abruptly, no part of
                  the right-hand operand appears to have been evaluated.
               </p>
               <div class="example"><a name="d5e22964"></a><p class="title"><b>Example&nbsp;15.7.1-1.&nbsp;Left-Hand Operand Is Evaluated First</b></p>
                  <div class="example-contents">
                     <p class="note">In the following program, the <code class="literal">*</code> operator
                        has a left-hand operand that contains an assignment to a variable and
                        a right-hand operand that contains a reference to the same
                        variable. The value produced by the reference will reflect the fact
                        that the assignment occurred first.
                     </p><pre class="programlisting">
class Test1 {
    public static void main(String[] args) {
        int i = 2;
        int j = (i=3) * i;
        System.out.println(j);
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
9
</pre><p class="note">It is not permitted for evaluation of the <code class="literal">*</code>
                        operator to produce <code class="literal">6</code> instead
                        of <code class="literal">9</code>.
                     </p>
                  </div>
               </div><br class="example-break"><div class="example"><a name="d5e22975"></a><p class="title"><b>Example&nbsp;15.7.1-2.&nbsp;Implicit Left-Hand Operand In Operator Of Compound Assigment</b></p>
                  <div class="example-contents">
                     <p class="note">In the following program, the two assignment
                        statements both fetch and remember the value of the left-hand operand,
                        which is <code class="literal">9</code>, before the right-hand operand of the
                        addition operator is evaluated, at which point the variable is set
                        to <code class="literal">3</code>.
                     </p><pre class="programlisting">
class Test2 {
    public static void main(String[] args) {
        int a = 9;
        a += (a = 3);  // first example
        System.out.println(a);
        int b = 9;
        b = b + (b = 3);  // second example
        System.out.println(b);
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
12
12
</pre><p class="note">It is not permitted for either assignment (compound
                        for <code class="literal">a</code>, simple for <code class="literal">b</code>) to produce
                        the result <code class="literal">6</code>. 
                     </p>
                     <p class="note">See also the example in
                        <a class="xref" href="jls-15.html#jls-15.26.2" title="15.26.2.&nbsp;Compound Assignment Operators">&sect;15.26.2</a>.
                     </p>
                  </div>
               </div><br class="example-break"><div class="example"><a name="d5e22989"></a><p class="title"><b>Example&nbsp;15.7.1-3.&nbsp;Abrupt Completion of Evaluation of the Left-Hand Operand</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Test3 {
    public static void main(String[] args) {
        int j = 1;
        try {
            int i = forgetIt() / (j = 2);
        } catch (Exception e) {
            System.out.println(e);
            System.out.println("Now j = " + j);
        }
    }
    static int forgetIt() throws Exception {
        throw new Exception("I'm outta here!");
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
java.lang.Exception: I'm outta here!
Now j = 1
</pre><p class="note">That is, the left-hand
                        operand <code class="literal">forgetIt()</code> of the operator <code class="literal">/</code> throws
                        an exception before the right-hand operand is evaluated and its
                        embedded assignment of <code class="literal">2</code> to <code class="literal">j</code>
                        occurs.
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="15.7.2.&nbsp;Evaluate Operands before Operation">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.7.2"></a>15.7.2.&nbsp;Evaluate Operands before Operation
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-dynamic"><a name="jls-15.7.2-100"></a>The
                  Java programming language guarantees that every operand of an operator (except the
                  conditional operators <code class="literal">&amp;&amp;</code>, <code class="literal">||</code>, and <code class="literal">? :</code>) appears to be
                  fully evaluated before any part of the operation itself is
                  performed.
               </p>
               <p class="norm-error"><a name="jls-15.7.2-110"></a>If the
                  binary operator is an integer division <code class="literal">/</code>
                  (<a class="xref" href="jls-15.html#jls-15.17.2" title="15.17.2.&nbsp;Division Operator /">&sect;15.17.2</a>) or integer remainder <code class="literal">%</code>
                  (<a class="xref" href="jls-15.html#jls-15.17.3" title="15.17.3.&nbsp;Remainder Operator %">&sect;15.17.3</a>), then its execution may raise an
                  <code class="literal">ArithmeticException</code>, but this exception is thrown only after both
                  operands of the binary operator have been evaluated and only if these
                  evaluations completed normally.
               </p>
               <div class="example"><a name="d5e23011"></a><p class="title"><b>Example&nbsp;15.7.2-1.&nbsp;Evaluation of Operands Before Operation</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Test {
    public static void main(String[] args) {
        int divisor = 0;
        try {
            int i = 1 / (divisor * loseBig());
        } catch (Exception e) {
            System.out.println(e);
        }
    }
    static int loseBig() throws Exception {
        throw new Exception("Shuffle off to Buffalo!");
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
java.lang.Exception: Shuffle off to Buffalo!
</pre><p class="note">and not:</p><pre class="screen">
java.lang.ArithmeticException: / by zero
</pre><p class="note">since no part of the division operation, including
                        signaling of a divide-by-zero exception, may appear to occur before
                        the invocation of <code class="literal">loseBig</code> completes, even though
                        the implementation may be able to detect or infer that the division
                        operation would certainly result in a divide-by-zero exception.
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="15.7.3.&nbsp;Evaluation Respects Parentheses and Precedence">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.7.3"></a>15.7.3.&nbsp;Evaluation Respects Parentheses and Precedence
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-dynamic"><a name="jls-15.7.3-100"></a>The
                  Java programming language respects the order of evaluation indicated explicitly by
                  parentheses and implicitly by operator precedence.
               </p>
               <p class="note">An implementation of the Java programming language may not take
                  advantage of algebraic identities such as the associative law to
                  rewrite expressions into a more convenient computational order unless
                  it can be proven that the replacement expression is equivalent in
                  value and in its observable side effects, even in the presence of
                  multiple threads of execution (using the thread execution model in
                  <a class="xref" href="jls-17.html" title="Chapter&nbsp;17.&nbsp;Threads and Locks">&sect;17 (<i>Threads and Locks</i>)</a>), for all possible computational values that
                  might be involved.
               </p>
               <p class="norm-dynamic"><a name="jls-15.7.3-110"></a>In the
                  case of floating-point calculations, this rule applies also for
                  infinity and not-a-number (NaN) values.
               </p>
               <p class="note">For example, <code class="literal">!(x&lt;y)</code> may not be
                  rewritten as <code class="literal">x&gt;=y</code>, because these expressions
                  have different values if either <code class="literal">x</code>
                  or <code class="literal">y</code> is NaN or both are NaN.
               </p>
               <p class="norm-dynamic"><a name="jls-15.7.3-120"></a>Specifically, floating-point calculations that
                  appear to be mathematically associative are unlikely to be
                  computationally associative. Such computations must not be naively
                  reordered.
               </p>
               <p class="note">For example, it is not correct for a Java compiler
                  to rewrite <code class="literal">4.0*x*0.5</code> as <code class="literal">2.0*x</code>;
                  while roundoff happens not to be an issue here, there are large values
                  of <code class="literal">x</code> for which the first expression produces
                  infinity (because of overflow) but the second expression produces a
                  finite result.
               </p>
               <div class="informalexample">
                  <p class="note">So, for example, the test program:</p><pre class="programlisting">
strictfp class Test {
    public static void main(String[] args) {
        double d = 8e+307;
        System.out.println(4.0 * d * 0.5);
        System.out.println(2.0 * d);
    }
}
</pre><p class="note">prints:</p><pre class="screen">
Infinity
1.6e+308
</pre><p class="note">because the first expression overflows and the
                     second does not.
                  </p>
               </div>
               <p class="norm"><a name="jls-15.7.3-130"></a>In contrast, integer
                  addition and multiplication <span class="emphasis"><em>are</em></span> provably
                  associative in the Java programming language.
               </p>
               <p class="note">For example <code class="literal">a+b+c</code>,
                  where <code class="literal">a</code>, <code class="literal">b</code>,
                  and <code class="literal">c</code> are local variables (this simplifying
                  assumption avoids issues involving multiple threads
                  and <code class="literal">volatile</code> variables), will always produce the
                  same answer whether evaluated as <code class="literal">(a+b)+c</code>
                  or <code class="literal">a+(b+c)</code>; if the
                  expression <code class="literal">b+c</code> occurs nearby in the code, a smart
                  Java compiler may be able to use this common subexpression.
               </p>
            </div>
            <div class="section" title="15.7.4.&nbsp;Argument Lists are Evaluated Left-to-Right">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.7.4"></a>15.7.4.&nbsp;Argument Lists are Evaluated Left-to-Right
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-15.7.4-100"></a>In a method or constructor
                  invocation or class instance creation expression, argument expressions
                  may appear within the parentheses, separated by commas. Each argument
                  expression appears to be fully evaluated before any part of any
                  argument expression to its right.
               </p>
               <p class="norm"><a name="jls-15.7.4-110"></a>If evaluation of an argument
                  expression completes abruptly, no part of any argument expression to
                  its right appears to have been evaluated.
               </p>
               <div class="example"><a name="d5e23057"></a><p class="title"><b>Example&nbsp;15.7.4-1.&nbsp;Evaluation Order At Method Invocation</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Test1 {
    public static void main(String[] args) {
        String s = "going, ";
        print3(s, s, s = "gone");
    }
    static void print3(String a, String b, String c) {
        System.out.println(a + b + c);
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
going, going, gone
</pre><p class="note">because the assignment of the string
                        "<code class="literal">gone</code>" to <code class="literal">s</code> occurs after the
                        first two arguments to <code class="literal">print3</code> have been
                        evaluated.
                     </p>
                  </div>
               </div><br class="example-break"><div class="example"><a name="d5e23066"></a><p class="title"><b>Example&nbsp;15.7.4-2.&nbsp;Abrupt Completion of Argument Expression</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Test2 {
    static int id;
    public static void main(String[] args) {
        try {
            test(id = 1, oops(), id = 3);
        } catch (Exception e) {
            System.out.println(e + ", id=" + id);
        }
    }
    static int test(int a, int b, int c) {
        return a + b + c;
    }
    static int oops() throws Exception {
        throw new Exception("oops");
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
java.lang.Exception: oops, id=1
</pre><p class="note">because the assignment of <code class="literal">3</code>
                        to <code class="literal">id</code> is not executed.
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="15.7.5.&nbsp;Evaluation Order for Other Expressions">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.7.5"></a>15.7.5.&nbsp;Evaluation Order for Other Expressions
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-15.7.5-100"></a>The order of evaluation for
                  some expressions is not completely covered by these general rules,
                  because these expressions may raise exceptional conditions at times
                  that must be specified. See the detailed explanations of evaluation
                  order for the following kinds of expressions:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.7.5-100-A"></a>
                                 class instance creation expressions (<a class="xref" href="jls-15.html#jls-15.9.4" title="15.9.4.&nbsp;Run-Time Evaluation of Class Instance Creation Expressions">&sect;15.9.4</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.7.5-100-B"></a>
                                 array creation expressions (<a class="xref" href="jls-15.html#jls-15.10.2" title="15.10.2.&nbsp;Run-Time Evaluation of Array Creation Expressions">&sect;15.10.2</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.7.5-100-C"></a>
                                 array access expressions (<a class="xref" href="jls-15.html#jls-15.10.4" title="15.10.4.&nbsp;Run-Time Evaluation of Array Access Expressions">&sect;15.10.4</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.7.5-100-D"></a>
                                 method invocation expressions (<a class="xref" href="jls-15.html#jls-15.12.4" title="15.12.4.&nbsp;Run-Time Evaluation of Method Invocation">&sect;15.12.4</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.7.5-100-G"></a>
                                 method reference expressions (<a class="xref" href="jls-15.html#jls-15.13.3" title="15.13.3.&nbsp;Run-time Evaluation of Method References">&sect;15.13.3</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.7.5-100-E"></a>
                                 assignments involving array components
                                 (<a class="xref" href="jls-15.html#jls-15.26" title="15.26.&nbsp;Assignment Operators">&sect;15.26</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.7.5-100-F"></a>
                                 lambda expressions (<a class="xref" href="jls-15.html#jls-15.27.4" title="15.27.4.&nbsp;Run-time Evaluation of Lambda Expressions">&sect;15.27.4</a>)
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
         </div>
         <div class="section" title="15.8.&nbsp;Primary Expressions">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.8"></a>15.8.&nbsp;Primary Expressions
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-15.8-100"></a>Primary expressions include
               most of the simplest kinds of expressions, from which all others are
               constructed: literals, object creations, field accesses, method
               invocations, method references, and array accesses. A parenthesized
               expression is also treated syntactically as a primary
               expression.
            </p>
            <div id="jls-15.8-110" class="productionset"><a name="jls-15.8-110"></a>
                 
               <div class="production"><a name="jls-Primary"></a>
                      
                  <div class="lhs">Primary:</div>
                      
                  <div class="rhs">
                           <a href="jls-15.html#jls-PrimaryNoNewArray" title="PrimaryNoNewArray">PrimaryNoNewArray</a> <br>
                           <a href="jls-15.html#jls-ArrayCreationExpression" title="ArrayCreationExpression">ArrayCreationExpression</a>
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-PrimaryNoNewArray"></a>
                      
                  <div class="lhs">PrimaryNoNewArray:</div>
                      
                  <div class="rhs">
                           <a href="jls-3.html#jls-Literal" title="Literal">Literal</a> <br>
                           <a href="jls-6.html#jls-TypeName" title="TypeName">TypeName</a> {<code class="literal">[</code> <code class="literal">]</code>} <code class="literal">.</code> <code class="literal">class</code> <br>
                           <code class="literal">void</code> <code class="literal">.</code> <code class="literal">class</code> <br>
                           <code class="literal">this</code> <br>
                           <a href="jls-6.html#jls-TypeName" title="TypeName">TypeName</a> <code class="literal">.</code> <code class="literal">this</code> <br>
                           <code class="literal">(</code> <a href="jls-15.html#jls-Expression" title="Expression">Expression</a> <code class="literal">)</code> <br>
                           <a href="jls-15.html#jls-ClassInstanceCreationExpression" title="ClassInstanceCreationExpression">ClassInstanceCreationExpression</a> <br>
                           <a href="jls-15.html#jls-FieldAccess" title="FieldAccess">FieldAccess</a> <br>
                           <a href="jls-15.html#jls-ArrayAccess" title="ArrayAccess">ArrayAccess</a> <br>
                           <a href="jls-15.html#jls-MethodInvocation" title="MethodInvocation">MethodInvocation</a> <br>
                           <a href="jls-15.html#jls-MethodReference" title="MethodReference">MethodReference</a>
                         
                  </div>
                    
               </div>
               
            </div>
            <p class="note">This part of the
               grammar of the Java programming language is unusual, in two ways. First, one might
               expect simple names, such as names of local variables and method
               parameters, to be primary expressions. For technical reasons, names
               are grouped together with primary expressions a little later when
               postfix expressions are introduced
               (<a class="xref" href="jls-15.html#jls-15.14" title="15.14.&nbsp;Postfix Expressions">&sect;15.14</a>).
            </p>
            <p class="note">The technical
               reasons have to do with allowing left-to-right parsing of Java
               programs with only one-token lookahead. Consider the
               expressions <code class="literal">(z[3])</code>
               and <code class="literal">(z[])</code>. The first is a parenthesized array
               access (<a class="xref" href="jls-15.html#jls-15.10.3" title="15.10.3.&nbsp;Array Access Expressions">&sect;15.10.3</a>) and the second is the start of a
               cast (<a class="xref" href="jls-15.html#jls-15.16" title="15.16.&nbsp;Cast Expressions">&sect;15.16</a>). At the point that the look-ahead
               symbol is <code class="literal">[</code>, a left-to-right parse will have reduced
               the <code class="literal">z</code> to the nonterminal 
               <span class="emphasis"><em>Name</em></span>. In the context of a cast we prefer not to
               have to reduce the name to a <span class="emphasis"><em>Primary</em></span>, but
               if <span class="emphasis"><em>Name</em></span> were one of the alternatives for
               <span class="emphasis"><em>Primary</em></span>, then we could not tell whether to do the reduction (that
               is, we could not determine whether the current situation would turn
               out to be a parenthesized array access or a cast) without looking
               ahead two tokens, to the token following the <code class="literal">[</code>. The grammar
               presented here avoids the problem by keeping <span class="emphasis"><em>Name</em></span>
               and <span class="emphasis"><em>Primary</em></span> separate and allowing either in certain other syntax
               rules (those
               for <span class="emphasis"><em>ClassInstanceCreationExpression</em></span>, 
               <span class="emphasis"><em>MethodInvocation</em></span>, <span class="emphasis"><em>ArrayAccess</em></span>,
               and <span class="emphasis"><em>PostfixExpression</em></span>, but not
               for <span class="emphasis"><em>FieldAccess</em></span> because this  uses an identifier directly). This strategy effectively defers
               the question of whether a <span class="emphasis"><em>Name</em></span> should be treated
               as a <span class="emphasis"><em>Primary</em></span> until more context can be examined.
            </p>
            <p class="note">The second unusual
               feature avoids a potential grammatical ambiguity in the expression
               "<code class="literal">new int[3][3]</code>" which in Java always means a single
               creation of a multidimensional array, but which, without appropriate
               grammatical finesse, might also be interpreted as meaning the same as
               "<code class="literal">(new int[3])[3]</code>".
            </p>
            <p class="note">This ambiguity is
               eliminated by splitting the expected definition of <span class="emphasis"><em>Primary</em></span> into
               <span class="emphasis"><em>Primary</em></span> and <span class="emphasis"><em>PrimaryNoNewArray</em></span>. (This may be
               compared to the splitting of <span class="emphasis"><em>Statement</em></span>
               into <span class="emphasis"><em>Statement</em></span>
               and <span class="emphasis"><em>StatementNoShortIf</em></span>
               (<a class="xref" href="jls-14.html#jls-14.5" title="14.5.&nbsp;Statements">&sect;14.5</a>) to avoid the "dangling else"
               problem.)
            </p>
            <div class="section" title="15.8.1.&nbsp;Lexical Literals">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.8.1"></a>15.8.1.&nbsp;Lexical Literals
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-15.8.1-100"></a>A literal
                  (<a class="xref" href="jls-3.html#jls-3.10" title="3.10.&nbsp;Literals">&sect;3.10</a>) denotes a fixed, unchanging value.
               </p>
               <p class="note">The following production from
                  <a class="xref" href="jls-3.html#jls-3.10" title="3.10.&nbsp;Literals">&sect;3.10</a> is shown here for convenience:
               </p>
               <div id="d5e23172" class="productionset"><a name="d5e23172"></a>
                    
                  <div class="productionrecap-note">
                     <div class="production">
                            
                        <div class="lhs">Literal:</div>
                            
                        <div class="rhs">
                                 <a href="jls-3.html#jls-IntegerLiteral" title="IntegerLiteral">IntegerLiteral</a> <br>
                                 <a href="jls-3.html#jls-FloatingPointLiteral" title="FloatingPointLiteral">FloatingPointLiteral</a> <br>
                                 <a href="jls-3.html#jls-BooleanLiteral" title="BooleanLiteral">BooleanLiteral</a> <br>
                                 <a href="jls-3.html#jls-CharacterLiteral" title="CharacterLiteral">CharacterLiteral</a> <br>
                                 <a href="jls-3.html#jls-StringLiteral" title="StringLiteral">StringLiteral</a> <br>
                                 <a href="jls-3.html#jls-NullLiteral" title="NullLiteral">NullLiteral</a>
                               
                        </div>
                          
                     </div>
                  </div>
                  
               </div>
               <p class="norm"><a name="jls-15.8.1-200"></a>The type of a literal is
                  determined as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.8.1-200-A"></a>The type of an integer
                               literal (<a class="xref" href="jls-3.html#jls-3.10.1" title="3.10.1.&nbsp;Integer Literals">&sect;3.10.1</a>) that ends
                               with <code class="literal">L</code> or <code class="literal">l</code> is <code class="literal">long</code>
                               (<a class="xref" href="jls-4.html#jls-4.2.1" title="4.2.1.&nbsp;Integral Types and Values">&sect;4.2.1</a>).
                        </p>
                        <p class="norm"><a name="jls-15.8.1-200-A.1"></a>The type of any
                               other integer literal is <code class="literal">int</code>
                               (<a class="xref" href="jls-4.html#jls-4.2.1" title="4.2.1.&nbsp;Integral Types and Values">&sect;4.2.1</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.8.1-200-B"></a>The type of a
                               floating-point literal (<a class="xref" href="jls-3.html#jls-3.10.2" title="3.10.2.&nbsp;Floating-Point Literals">&sect;3.10.2</a>) that ends
                               with <code class="literal">F</code> or <code class="literal">f</code> is <code class="literal">float</code> and
                               its value must be an element of the float value set
                               (<a class="xref" href="jls-4.html#jls-4.2.3" title="4.2.3.&nbsp;Floating-Point Types, Formats, and Values">&sect;4.2.3</a>).
                        </p>
                        <p class="norm"><a name="jls-15.8.1-200-B.1"></a>The type of any
                               other floating-point literal is <code class="literal">double</code> and its value must be an
                               element of the double value set
                               (<a class="xref" href="jls-4.html#jls-4.2.3" title="4.2.3.&nbsp;Floating-Point Types, Formats, and Values">&sect;4.2.3</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.8.1-200-C"></a>The type of a boolean
                               literal (<a class="xref" href="jls-3.html#jls-3.10.3" title="3.10.3.&nbsp;Boolean Literals">&sect;3.10.3</a>) is <code class="literal">boolean</code>
                               (<a class="xref" href="jls-4.html#jls-4.2.5" title="4.2.5.&nbsp;The boolean Type and boolean Values">&sect;4.2.5</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.8.1-200-D"></a>The type of a
                               character literal (<a class="xref" href="jls-3.html#jls-3.10.4" title="3.10.4.&nbsp;Character Literals">&sect;3.10.4</a>) is <code class="literal">char</code>
                               (<a class="xref" href="jls-4.html#jls-4.2.1" title="4.2.1.&nbsp;Integral Types and Values">&sect;4.2.1</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.8.1-200-E"></a>The type of a string
                               literal (<a class="xref" href="jls-3.html#jls-3.10.5" title="3.10.5.&nbsp;String Literals">&sect;3.10.5</a>) is <code class="literal">String</code>
                               (<a class="xref" href="jls-4.html#jls-4.3.3" title="4.3.3.&nbsp;The Class String">&sect;4.3.3</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.8.1-200-F"></a>The type of the null
                               literal <code class="literal">null</code> (<a class="xref" href="jls-3.html#jls-3.10.7" title="3.10.7.&nbsp;The Null Literal">&sect;3.10.7</a>) is the null type
                               (<a class="xref" href="jls-4.html#jls-4.1" title="4.1.&nbsp;The Kinds of Types and Values">&sect;4.1</a>); its value is the null
                               reference.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-15.8.1-210"></a>Evaluation of a lexical
                  literal always completes normally.
               </p>
            </div>
            <div class="section" title="15.8.2.&nbsp;Class Literals">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.8.2"></a>15.8.2.&nbsp;Class Literals
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-15.8.2-100"></a>A <span class="emphasis"><em>class
                        literal</em></span> is an expression consisting of the name of a class,
                  interface, array, or primitive type, or the pseudo-type <code class="literal">void</code>,
                  followed by a '<code class="literal">.</code>' and the token <code class="literal">class</code>.
               </p>
               <p class="norm-static"><a name="jls-15.8.2-110"></a>The type
                  of <span class="type">C</span><code class="literal">.</code><code class="literal">class</code>, where <span class="type">C</span> is the name of a class, interface, or
                  array type (<a class="xref" href="jls-4.html#jls-4.3" title="4.3.&nbsp;Reference Types and Values">&sect;4.3</a>), is
                  <code class="literal">Class</code><code class="literal">&lt;</code><span class="type">C</span><code class="literal">&gt;</code>.
               </p>
               <p class="norm-static"><a name="jls-15.8.2-120"></a>The type
                  of <span class="type">p</span><code class="literal">.</code><code class="literal">class</code>, where <span class="type">p</span> is the name of a
                  primitive type (<a class="xref" href="jls-4.html#jls-4.2" title="4.2.&nbsp;Primitive Types and Values">&sect;4.2</a>), is
                  <code class="literal">Class</code><code class="literal">&lt;</code><span class="type">B</span><code class="literal">&gt;</code>, where <span class="type">B</span> is the
                  type of an expression of type <span class="type">p</span> after boxing conversion
                  (<a class="xref" href="jls-5.html#jls-5.1.7" title="5.1.7.&nbsp;Boxing Conversion">&sect;5.1.7</a>).
               </p>
               <p class="norm"><a name="jls-15.8.2-130"></a>The type of
                  <code class="literal">void</code><code class="literal">.</code><code class="literal">class</code> (<a class="xref" href="jls-8.html#jls-8.4.5" title="8.4.5.&nbsp;Method Result">&sect;8.4.5</a>) is
                  <code class="literal">Class</code><code class="literal">&lt;</code><code class="literal">Void</code><code class="literal">&gt;</code>.
               </p>
               <p class="norm-error"><a name="jls-15.8.2-200"></a>It is a
                  compile-time error if the named type is a type variable
                  (<a class="xref" href="jls-4.html#jls-4.4" title="4.4.&nbsp;Type Variables">&sect;4.4</a>) or a parameterized type
                  (<a class="xref" href="jls-4.html#jls-4.5" title="4.5.&nbsp;Parameterized Types">&sect;4.5</a>) or an array whose element type is a type
                  variable or parameterized type.
               </p>
               <p class="norm-error"><a name="jls-15.8.2-210"></a>It is a
                  compile-time error if the named type does not denote a type that is
                  accessible (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>) and in scope
                  (<a class="xref" href="jls-6.html#jls-6.3" title="6.3.&nbsp;Scope of a Declaration">&sect;6.3</a>) at the point where the class literal
                  appears.
               </p>
               <p class="norm-dynamic"><a name="jls-15.8.2-300"></a>A class
                  literal evaluates to the <code class="literal">Class</code> object for the named type (or for
                  <code class="literal">void</code>) as defined by the defining class loader
                  (<a class="xref" href="jls-12.html#jls-12.2" title="12.2.&nbsp;Loading of Classes and Interfaces">&sect;12.2</a>) of the class of the current
                  instance.
               </p>
            </div>
            <div class="section" title="15.8.3.&nbsp;this">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.8.3"></a>15.8.3.&nbsp;<code class="literal">this</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-error"><a name="jls-15.8.3-100"></a>The keyword
                  <code class="literal">this</code> may be used only in the body of an instance method or default
                  method, or in the body of a constructor of a class, or in an instance
                  initializer of a class, or in the initializer of an instance variable
                  of a class. If it appears anywhere else, a compile-time error
                  occurs.
               </p>
               <p class="norm-error"><a name="jls-15.8.3-110"></a>The keyword <code class="literal">this</code>
                  may be used in a lambda expression only if it is allowed in the
                  context in which the lambda expression appears. Otherwise, a
                  compile-time error occurs.
               </p>
               <p class="norm-dynamic"><a name="jls-15.8.3-200"></a>When used as a
                  primary expression, the keyword <code class="literal">this</code> denotes a value that is a
                  reference to the object for which the instance method or default
                  method was invoked (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>), or to the object
                  being constructed. The value denoted by <code class="literal">this</code> in a lambda body is the
                  same as the value denoted by <code class="literal">this</code> in the surrounding context.
               </p>
               <p class="note">The keyword <code class="literal">this</code> is also used in explicit
                  constructor invocation statements (<a class="xref" href="jls-8.html#jls-8.8.7.1" title="8.8.7.1.&nbsp;Explicit Constructor Invocations">&sect;8.8.7.1</a>).
               </p>
               <p class="norm-static"><a name="jls-15.8.3-300"></a>The type of
                  <code class="literal">this</code> is the class or interface type <span class="type">T</span> within which the keyword
                  <code class="literal">this</code> occurs.
               </p>
               <p class="note">Default methods provide the unique ability to access
                  <code class="literal">this</code> inside an interface. (All other interface methods are either
                  <code class="literal">abstract</code> or <code class="literal">static</code>, so provide no access to <code class="literal">this</code>.) As a result,
                  it is possible for <code class="literal">this</code> to have an interface type.
               </p>
               <p class="norm-dynamic"><a name="jls-15.8.3-400"></a>At run time, the
                  class of the actual object referred to may be <span class="type">T</span>, if <span class="type">T</span> is a class
                  type, or a class that is a subtype of <span class="type">T</span>.
               </p>
               <div class="example"><a name="d5e23295"></a><p class="title"><b>Example&nbsp;15.8.3-1.&nbsp;The <code class="literal">this</code> Expression</b></p>
                  <div class="example-contents"><pre class="programlisting">
class IntVector {
    int[] v;
    boolean equals(IntVector other) {
        if (this == other)
            return true;
        if (v.length != other.v.length)
            return false;
        for (int i = 0; i &lt; v.length; i++) {
            if (v[i] != other.v[i]) return false;
        }
        return true;
    }
}
</pre><p class="note">Here, the class <code class="literal">IntVector</code>
                        implements a method <code class="literal">equals</code>, which compares two
                        vectors. If the other vector is the same vector object as the one for
                        which the <code class="literal">equals</code> method was invoked, then the check
                        can skip the length and value
                        comparisons. The <code class="literal">equals</code> method implements this
                        check by comparing the reference to the other object to <code class="literal">this</code>.
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="15.8.4.&nbsp;Qualified this">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.8.4"></a>15.8.4.&nbsp;Qualified <code class="literal">this</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.8.4-100"></a>Any
                  lexically enclosing instance (<a class="xref" href="jls-8.html#jls-8.1.3" title="8.1.3.&nbsp;Inner Classes and Enclosing Instances">&sect;8.1.3</a>) can be
                  referred to by explicitly qualifying the keyword <code class="literal">this</code>.
               </p>
               <p class="norm-static"><a name="jls-15.8.4-110"></a>Let <span class="type">T</span> be the
                  type denoted by <span class="emphasis"><em>TypeName</em></span>. Let <span class="emphasis"><em>n</em></span> be an
                  integer such that <span class="type">T</span> is the <span class="emphasis"><em>n</em></span>'th lexically enclosing type
                  declaration of the class or interface in which the qualified <code class="literal">this</code>
                  expression appears.
               </p>
               <p class="norm-static"><a name="jls-15.8.4-120"></a>The value of an
                  expression of the form <span class="emphasis"><em>TypeName</em></span><code class="literal">.</code><code class="literal">this</code> is the
                  <span class="emphasis"><em>n</em></span>'th lexically enclosing instance of <code class="literal">this</code>.
               </p>
               <p class="norm-static"><a name="jls-15.8.4-200"></a>The type of the
                  expression is <span class="type">T</span>.
               </p>
               <p class="norm-error"><a name="jls-15.8.4-210"></a>It is a
                  compile-time error if the expression occurs in a class or interface
                  which is not an inner class of class <span class="type">T</span> or <span class="type">T</span> itself.
               </p>
            </div>
            <div class="section" title="15.8.5.&nbsp;Parenthesized Expressions">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.8.5"></a>15.8.5.&nbsp;Parenthesized Expressions
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.8.5-100"></a>A
                  parenthesized expression is a primary expression whose type is the
                  type of the contained expression and whose value at run time is the
                  value of the contained expression. If the contained expression denotes
                  a variable then the parenthesized expression also denotes that
                  variable.
               </p>
               <p class="norm-static"><a name="jls-15.8.5-110"></a>The use
                  of parentheses affects only the <span class="emphasis"><em>order</em></span> of
                  evaluation, except for a corner case
                  whereby <code class="literal">(-2147483648)</code>
                  and <code class="literal">(-9223372036854775808L)</code> are legal
                  but <code class="literal">-(2147483648)</code>
                  and <code class="literal">-(9223372036854775808L)</code> are illegal.
               </p>
               <p class="note">This is because the decimal literals
                  <code class="literal">2147483648</code>
                  and <code class="literal">9223372036854775808L</code> are allowed only as an
                  operand of the unary minus operator
                  (<a class="xref" href="jls-3.html#jls-3.10.1" title="3.10.1.&nbsp;Integer Literals">&sect;3.10.1</a>).
               </p>
               <p class="norm-static"><a name="jls-15.8.5-120"></a>In
                  particular, the presence or absence of parentheses around an
                  expression does not (except for the case noted above) affect in any
                  way:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.8.5-120-A"></a>the choice of value
                               set (<a class="xref" href="jls-4.html#jls-4.2.3" title="4.2.3.&nbsp;Floating-Point Types, Formats, and Values">&sect;4.2.3</a>) for the value of an expression
                               of type <code class="literal">float</code> or <code class="literal">double</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.8.5-120-B"></a>whether a variable is
                               definitely assigned, definitely assigned when <code class="literal">true</code>, definitely
                               assigned when <code class="literal">false</code>, definitely unassigned, definitely
                               unassigned when <code class="literal">true</code>, or definitely unassigned when <code class="literal">false</code>
                               (<a class="xref" href="jls-16.html" title="Chapter&nbsp;16.&nbsp;Definite Assignment">&sect;16 (<i>Definite Assignment</i>)</a>).
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-15.8.5-200"></a>If a parenthesized
                  expression appears in a context of a particular kind with target type
                  <span class="type">T</span> (<a class="xref" href="jls-5.html" title="Chapter&nbsp;5.&nbsp;Conversions and Contexts">&sect;5 (<i>Conversions and Contexts</i>)</a>), its contained expression similarly
                  appears in a context of the same kind with target type <span class="type">T</span>.
               </p>
               <p class="norm-static"><a name="jls-15.8.5-210"></a>If the contained
                  expression is a poly expression (<a class="xref" href="jls-15.html#jls-15.2" title="15.2.&nbsp;Forms of Expressions">&sect;15.2</a>), the
                  parenthesized expression is also a poly expression. Otherwise, it is a
                  standalone expression.
               </p>
            </div>
         </div>
         <div class="section" title="15.9.&nbsp;Class Instance Creation Expressions">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.9"></a>15.9.&nbsp;Class Instance Creation
                        Expressions
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-dynamic"><a name="jls-15.9-100"></a>A class
               instance creation expression is used to create new objects that are
               instances of classes.
            </p>
            <div id="jls-15.9-110" class="productionset"><a name="jls-15.9-110"></a>
                 
               <div class="production"><a name="jls-ClassInstanceCreationExpression"></a>
                      
                  <div class="lhs">ClassInstanceCreationExpression:</div>
                      
                  <div class="rhs">
                           
                           <code class="literal">new</code> [<a href="jls-4.html#jls-TypeArguments" title="TypeArguments">TypeArguments</a>]
                           {<a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>} <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a>
                           
                           [<a href="jls-15.html#jls-TypeArgumentsOrDiamond" title="TypeArgumentsOrDiamond">TypeArgumentsOrDiamond</a>]
                           <code class="literal">(</code> [<a href="jls-15.html#jls-ArgumentList" title="ArgumentList">ArgumentList</a>] <code class="literal">)</code> [<a href="jls-8.html#jls-ClassBody" title="ClassBody">ClassBody</a>] <br>
                     
                           
                           <a href="jls-6.html#jls-ExpressionName" title="ExpressionName">ExpressionName</a> <code class="literal">.</code> <code class="literal">new</code> [<a href="jls-4.html#jls-TypeArguments" title="TypeArguments">TypeArguments</a>]
                           {<a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>} <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a>
                           
                           [<a href="jls-15.html#jls-TypeArgumentsOrDiamond" title="TypeArgumentsOrDiamond">TypeArgumentsOrDiamond</a>]
                           <code class="literal">(</code> [<a href="jls-15.html#jls-ArgumentList" title="ArgumentList">ArgumentList</a>] <code class="literal">)</code> [<a href="jls-8.html#jls-ClassBody" title="ClassBody">ClassBody</a>] <br>
                     
                           
                           <a href="jls-15.html#jls-Primary" title="Primary">Primary</a> <code class="literal">.</code> <code class="literal">new</code> [<a href="jls-4.html#jls-TypeArguments" title="TypeArguments">TypeArguments</a>]
                           {<a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>} <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a>
                           
                           [<a href="jls-15.html#jls-TypeArgumentsOrDiamond" title="TypeArgumentsOrDiamond">TypeArgumentsOrDiamond</a>]
                           <code class="literal">(</code> [<a href="jls-15.html#jls-ArgumentList" title="ArgumentList">ArgumentList</a>] <code class="literal">)</code> [<a href="jls-8.html#jls-ClassBody" title="ClassBody">ClassBody</a>]
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-TypeArgumentsOrDiamond"></a>
                      
                  <div class="lhs">TypeArgumentsOrDiamond:</div>
                      
                  <div class="rhs">
                           <a href="jls-4.html#jls-TypeArguments" title="TypeArguments">TypeArguments</a> <br>
                           <code class="literal">&lt;&gt;</code>
                         
                  </div>
                    
               </div>
               
            </div>
            <p class="note">The following production from
               <a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a> is shown here for convenience:
            </p>
            <div id="d5e23410" class="productionset"><a name="d5e23410"></a>
                 
               <div class="productionrecap-note">
                  <div class="production">
                         
                     <div class="lhs">ArgumentList:</div>
                         
                     <div class="rhs">
                              <a href="jls-15.html#jls-Expression" title="Expression">Expression</a> {<code class="literal">,</code> <a href="jls-15.html#jls-Expression" title="Expression">Expression</a>}
                            
                     </div>
                       
                  </div>
               </div>
               
            </div>
            <p class="norm-static"><a name="jls-15.9-200"></a>A class instance
               creation expression specifies a class to be instantiated, possibly
               followed by type arguments (<a class="xref" href="jls-4.html#jls-4.5.1" title="4.5.1.&nbsp;Type Arguments of Parameterized Types">&sect;4.5.1</a>) or
               a <span class="emphasis"><em>diamond</em></span> (<code class="literal">&lt;&gt;</code>) if the class being
               instantiated is generic (<a class="xref" href="jls-8.html#jls-8.1.2" title="8.1.2.&nbsp;Generic Classes and Type Parameters">&sect;8.1.2</a>), followed by (a
               possibly empty) list of actual value arguments to the
               constructor.
            </p>
            <p class="norm-static"><a name="jls-15.9-210"></a>If the type
               argument list to the class is empty &#8212; the diamond form <code class="literal">&lt;&gt;</code> &#8212;
               the type arguments of the class are inferred. It is legal, though
               strongly discouraged as a matter of style, to have white space between
               the "<code class="literal">&lt;</code>" and "<code class="literal">&gt;</code>" of a diamond.
            </p>
            <p class="norm-static"><a name="jls-15.9-220"></a>If the
               constructor is generic (<a class="xref" href="jls-8.html#jls-8.8.4" title="8.8.4.&nbsp;Generic Constructors">&sect;8.8.4</a>), the type
               arguments to the constructor may similarly either be inferred or
               passed explicitly. If passed explicitly, the type arguments to the
               constructor immediately follow the keyword <code class="literal">new</code>.
            </p>
            <p class="norm-error"><a name="jls-15.9-300"></a>It is a
               compile-time error if a class instance creation expression provides
               type arguments to a constructor but uses the diamond form for type
               arguments to the class.
            </p>
            <p class="note">This rule is introduced because inference of a
               generic class's type arguments may influence the constraints on a
               generic constructor's type arguments.
            </p>
            <p class="norm-error"><a name="jls-15.9-310"></a>If 
               <span class="emphasis"><em>TypeArguments</em></span> is present between <code class="literal">new</code> and
               <span class="emphasis"><em>Identifier</em></span>, or between <span class="emphasis"><em>Identifier</em></span> and <code class="literal">(</code>, then it is a
               compile-time error if any of the type arguments are wildcards
               (<a class="xref" href="jls-4.html#jls-4.5.1" title="4.5.1.&nbsp;Type Arguments of Parameterized Types">&sect;4.5.1</a>).
            </p>
            <p class="norm-static"><a name="jls-15.9-320"></a>The
               exception types that a class instance creation expression can throw
               are specified in <a class="xref" href="jls-11.html#jls-11.2.1" title="11.2.1.&nbsp;Exception Analysis of Expressions">&sect;11.2.1</a>.
            </p>
            <p class="norm"><a name="jls-15.9-400"></a>Class instance creation
               expressions have two forms:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.9-400-A"></a>
                              <span class="emphasis"><em>Unqualified class instance creation
                                    expressions</em></span> begin with the keyword <code class="literal">new</code>.
                     </p>
                     <p class="norm"><a name="jls-15.9-400-A.1"></a>
                              An unqualified class instance creation expression may be used to
                              create an instance of a class, regardless of whether the class
                              is a top level (<a class="xref" href="jls-7.html#jls-7.6" title="7.6.&nbsp;Top Level Type Declarations">&sect;7.6</a>), member
                              (<a class="xref" href="jls-8.html#jls-8.5" title="8.5.&nbsp;Member Type Declarations">&sect;8.5</a>, <a class="xref" href="jls-9.html#jls-9.5" title="9.5.&nbsp;Member Type Declarations">&sect;9.5</a>), local
                              (<a class="xref" href="jls-14.html#jls-14.3" title="14.3.&nbsp;Local Class Declarations">&sect;14.3</a>), or anonymous class
                              (<a class="xref" href="jls-15.html#jls-15.9.5" title="15.9.5.&nbsp;Anonymous Class Declarations">&sect;15.9.5</a>).
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-15.9-400-B"></a>
                              <span class="emphasis"><em>Qualified class instance creation
                                    expressions</em></span> begin with a <span class="emphasis"><em>Primary</em></span> expression or an
                              <span class="emphasis"><em>ExpressionName</em></span>.
                     </p>
                     <p class="norm"><a name="jls-15.9-400-B.1"></a>
                              A qualified class instance creation expression enables the
                              creation of instances of inner member classes and their
                              anonymous subclasses.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm"><a name="jls-15.9-410"></a>Both unqualified and qualified
               class instance creation expressions may optionally end with a class
               body. Such a class instance creation expression declares
               an <span class="emphasis"><em>anonymous class</em></span> (<a class="xref" href="jls-15.html#jls-15.9.5" title="15.9.5.&nbsp;Anonymous Class Declarations">&sect;15.9.5</a>)
               and creates an instance of it.
            </p>
            <p class="norm-static"><a name="jls-15.9-500"></a>A class instance
               creation expression is a poly expression (<a class="xref" href="jls-15.html#jls-15.2" title="15.2.&nbsp;Forms of Expressions">&sect;15.2</a>)
               if it uses the diamond form for type arguments to the class, and it
               appears in an assignment context or an invocation context
               (<a class="xref" href="jls-5.html#jls-5.2" title="5.2.&nbsp;Assignment Contexts">&sect;5.2</a>, <a class="xref" href="jls-5.html#jls-5.3" title="5.3.&nbsp;Invocation Contexts">&sect;5.3</a>). Otherwise, it
               is a standalone expression.
            </p>
            <p class="norm"><a name="jls-15.9-600"></a>We say that a class
               is <span class="emphasis"><em>instantiated</em></span> when an instance of the class is
               created by a class instance creation expression. Class instantiation
               involves determining the class to be instantiated
               (<a class="xref" href="jls-15.html#jls-15.9.1" title="15.9.1.&nbsp;Determining the Class being Instantiated">&sect;15.9.1</a>), the enclosing instances (if any) of
               the newly created instance (<a class="xref" href="jls-15.html#jls-15.9.2" title="15.9.2.&nbsp;Determining Enclosing Instances">&sect;15.9.2</a>), and the
               constructor to be invoked to create the new instance
               (<a class="xref" href="jls-15.html#jls-15.9.3" title="15.9.3.&nbsp;Choosing the Constructor and its Arguments">&sect;15.9.3</a>).
            </p>
            <div class="section" title="15.9.1.&nbsp;Determining the Class being Instantiated">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.9.1"></a>15.9.1.&nbsp;Determining the Class being Instantiated
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.9.1-100"></a>If the
                  class instance creation expression ends in a class body, then the
                  class being instantiated is an anonymous class. Then:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-15.9.1-100-A"></a>
                                 If the class instance creation expression is unqualified:
                        </p>
                        <p class="norm-error"><a name="jls-15.9.1-100-A.1"></a>
                                 The <span class="emphasis"><em>Identifier</em></span> after the <code class="literal">new</code> token must denote a class that
                                 is accessible, non-<code class="literal">final</code>, and not an enum type; or denote an
                                 interface that is accessible. Otherwise a compile-time error
                                 occurs.
                        </p>
                        <p class="norm-error"><a name="jls-15.9.1-100-A.2"></a>
                                 If <span class="emphasis"><em>TypeArgumentsOrDiamond</em></span> is present after the <span class="emphasis"><em>Identifier</em></span>,
                                 and denotes <code class="literal">&lt;&gt;</code>, then a compile-time error occurs
                        </p>
                        <p class="norm-static"><a name="jls-15.9.1-100-A.3"></a>
                                 Let <span class="type">T</span> be the type denoted by <span class="emphasis"><em>Identifier</em></span>
                                 <span class="emphasis"><em>[TypeArgumentsOrDiamond]</em></span> after the <code class="literal">new</code> token. If
                                 <span class="emphasis"><em>TypeArguments</em></span> is present after the <span class="emphasis"><em>Identifier</em></span>, then <span class="type">T</span> must
                                 denote a well-formed parameterized type
                                 (<a class="xref" href="jls-4.html#jls-4.5" title="4.5.&nbsp;Parameterized Types">&sect;4.5</a>), or a compile-time error
                                 occurs.
                        </p>
                        <p class="norm-error"><a name="jls-15.9.1-100-A.4"></a>
                                 If <span class="type">T</span> denotes a class, then an anonymous direct subclass of <span class="type">T</span>
                                 is declared. If <span class="type">T</span> denotes an interface, then an anonymous
                                 direct subclass of <code class="literal">Object</code> that implements <span class="type">T</span> is
                                 declared. In either case, the body of the subclass is
                                 the <span class="emphasis"><em>ClassBody</em></span> given in the class instance
                                 creation expression.
                        </p>
                        <p class="norm-static"><a name="jls-15.9.1-100-A.5"></a>
                                 The class being instantiated is the anonymous subclass.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.9.1-100-B"></a>
                                 If the class instance creation expression is qualified:
                        </p>
                        <p class="norm-error"><a name="jls-15.9.1-100-B.1"></a>
                                 The <span class="emphasis"><em>Identifier</em></span> after the <code class="literal">new</code> token must unambiguously denote
                                 an inner class that is accessible, non-<code class="literal">final</code>, not an enum
                                 type, and a member of the compile-time type of the <span class="emphasis"><em>Primary</em></span>
                                 expression or the <span class="emphasis"><em>ExpressionName</em></span>. Otherwise, a compile-time
                                 error occurs.
                        </p>
                        <p class="norm-error"><a name="jls-15.9.1-100-B.2"></a>
                                 If <span class="emphasis"><em>TypeArgumentsOrDiamond</em></span> is present after the <span class="emphasis"><em>Identifier</em></span>,
                                 and denotes <code class="literal">&lt;&gt;</code>, then a compile-time error occurs.
                        </p>
                        <p class="norm-static"><a name="jls-15.9.100-B.3"></a>
                                 Let <span class="type">T</span> be the type denoted by <span class="emphasis"><em>Identifier</em></span>
                                 <span class="emphasis"><em>[TypeArgumentsOrDiamond]</em></span> after the <code class="literal">new</code> token. If
                                 <span class="emphasis"><em>TypeArguments</em></span> is present after the <span class="emphasis"><em>Identifier</em></span>, then <span class="type">T</span> must
                                 denote a well-formed parameterized type, or a compile-time error
                                 occurs.
                        </p>
                        <p class="norm-static"><a name="jls-15.9.1-100-B.5"></a>
                                 An anonymous direct subclass of <span class="type">T</span> is declared. The body of the
                                 subclass is the <span class="emphasis"><em>ClassBody</em></span> given in the
                                 class instance creation expression.
                        </p>
                        <p class="norm-static"><a name="jls-15.9.1-100-B.6"></a>
                                 The class being instantiated is the anonymous subclass.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-15.9.1-200"></a>If a class instance creation
                  expression does not declare an anonymous class, then:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-15.9.1-200-A"></a>
                                 If the class instance creation expression is unqualified:
                        </p>
                        <p class="norm-error"><a name="jls-15.9.1-200-A.1"></a>
                                 The <span class="emphasis"><em>Identifier</em></span> after the <code class="literal">new</code> token must denote a class that
                                 is accessible, non-<code class="literal">abstract</code>, and not an enum type. Otherwise,
                                 a compile-time error occurs.
                        </p>
                        <p class="norm-error"><a name="jls-15.9.1-200-A.2"></a>
                                 It <span class="emphasis"><em>TypeArgumentsOrDiamond</em></span> is present after the <span class="emphasis"><em>Identifier</em></span>,
                                 and denotes <code class="literal">&lt;&gt;</code>, and the class denoted by <span class="emphasis"><em>Identifier</em></span> is
                                 not generic, then a compile-time error occurs.
                        </p>
                        <p class="norm-static"><a name="jls-15.9.200-A.3"></a>
                                 Let <span class="type">T</span> be the type denoted by <span class="emphasis"><em>Identifier</em></span>
                                 <span class="emphasis"><em>[TypeArgumentsOrDiamond]</em></span> after the <code class="literal">new</code> token. If
                                 <span class="emphasis"><em>TypeArguments</em></span> is present after the <span class="emphasis"><em>Identifier</em></span>, then <span class="type">T</span> must
                                 denote a well-formed parameterized type, or a compile-time error
                                 occurs.
                        </p>
                        <p class="norm-static"><a name="jls-15.9.1-200-A.4"></a>
                                 The class being instantiated is the class denoted by
                                 <span class="emphasis"><em>Identifier</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.9.1-200-B"></a>
                                 If the class instance creation expression is qualified:
                        </p>
                        <p class="norm-error"><a name="jls-15.9.1-200-B.1"></a>
                                 The <span class="emphasis"><em>Identifier</em></span> after the <code class="literal">new</code> token must unambiguously denote
                                 an inner class that is accessible, non-<code class="literal">abstract</code>, not an enum
                                 type, and a member of the compile-time type of the <span class="emphasis"><em>Primary</em></span>
                                 expression or the <span class="emphasis"><em>ExpressionName</em></span>.
                        </p>
                        <p class="norm-error"><a name="jls-15.9.1-200-B.2"></a>
                                 If <span class="emphasis"><em>TypeArgumentsOrDiamond</em></span> is present after the <span class="emphasis"><em>Identifier</em></span>,
                                 and denotes <code class="literal">&lt;&gt;</code>, and the class denoted by <span class="emphasis"><em>Identifier</em></span> is
                                 not generic, then a compile-time error occurs.
                        </p>
                        <p class="norm-static"><a name="jls-15.9.200-B.3"></a>
                                 Let <span class="type">T</span> be the type denoted by <span class="emphasis"><em>Identifier</em></span>
                                 <span class="emphasis"><em>[TypeArgumentsOrDiamond]</em></span> after the <code class="literal">new</code> token. If
                                 <span class="emphasis"><em>TypeArguments</em></span> is present after the <span class="emphasis"><em>Identifier</em></span>, then <span class="type">T</span> must
                                 denote a well-formed parameterized type, or a compile-time error
                                 occurs.
                        </p>
                        <p class="norm-static"><a name="jls-15.9.1-200-B.4"></a>
                                 The class being instantiated is the class denoted by
                                 <span class="emphasis"><em>Identifier</em></span>.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="15.9.2.&nbsp;Determining Enclosing Instances">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.9.2"></a>15.9.2.&nbsp;Determining Enclosing Instances
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-dynamic"><a name="jls-15.9.2-100"></a>Let <span class="type">C</span>
                  be the class being instantiated, and let <code class="varname">i</code> be the instance being
                  created. If <span class="type">C</span> is an inner class, then <code class="varname">i</code> may have
                  an <span class="emphasis"><em>immediately enclosing instance</em></span>
                  (<a class="xref" href="jls-8.html#jls-8.1.3" title="8.1.3.&nbsp;Inner Classes and Enclosing Instances">&sect;8.1.3</a>), determined as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.9.2-100-A"></a>
                                 If <span class="type">C</span> is an anonymous class, then:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.9.2-100-A-A"></a>
                                    	  If the class instance creation expression occurs in a static
                                    	  context, then <code class="varname">i</code> has no immediately enclosing
                                    	  instance.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.9.2-100-A-B"></a>
                                    	  Otherwise, the immediately enclosing instance of <code class="varname">i</code> is
                                              <code class="literal">this</code>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.9.2-100-B"></a>
                                 If <span class="type">C</span> is a local class, then:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.9.2-100-B-A"></a>
                                    	  If <span class="type">C</span> occurs in a static context, then <code class="varname">i</code> has no
                                    	  immediately enclosing instance.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-error"><a name="jls-15.9.2-100-B-B"></a>
                                    	  Otherwise, if the class instance creation expression occurs
                                              in a static context, then a compile-time error
                                              occurs.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.9.2-100-B-C"></a>
                                    	  Otherwise, let <span class="type">O</span> be the immediately enclosing class of
                                              <span class="type">C</span>. Let <span class="emphasis"><em>n</em></span> be an integer such that <span class="type">O</span> is the <span class="emphasis"><em>n</em></span>'th
                                              lexically enclosing type declaration of the class in which
                                              the class instance creation expression appears.
                                 </p>
                                 <p class="norm-dynamic"><a name="jls-15.9.2-100-B-C.1"></a>
                                    	  The immediately enclosing instance of <code class="varname">i</code> is the <span class="emphasis"><em>n</em></span>'th
                                              lexically enclosing instance of <code class="literal">this</code>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.9.2-100-C"></a>
                                 If <span class="type">C</span> is an inner member class, then:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.9.2-100-C-A"></a>
                                    	  If the class instance creation expression is unqualified,
                                    	  then:
                                 </p>
                                 <div class="norm">
                                    <ul class="norm" type="square">
                                       <li class="listitem">
                                          <p class="norm-error"><a name="jls-15.9.2-100-C-A-A"></a>
                                             	      If the class instance creation expression occurs in a
                                             	      static context, then a compile-time error occurs.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-15.9.2-100-C-A-B"></a>
                                             	      Otherwise, if <span class="type">C</span> is a member of a class enclosing the
                                                           class in which the class instance creation expression
                                                           appears, then let <span class="type">O</span> be the immediately enclosing class
                                                           of which <span class="type">C</span> is a member. Let <span class="emphasis"><em>n</em></span> be an integer such
                                                           that <span class="type">O</span> is the <span class="emphasis"><em>n</em></span>'th lexically enclosing type
                                                           declaration of the class in which the class instance
                                                           creation expression appears.
                                          </p>
                                          <p class="norm-dynamic"><a name="jls-15.9.2-100-C-A-B.1"></a>
                                             	      The immediately enclosing instance of <code class="varname">i</code> is the
                                             	      <span class="emphasis"><em>n</em></span>'th lexically enclosing instance of <code class="literal">this</code>.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-error"><a name="jls-15.9.2-100-C-A-C"></a>
                                             	      Otherwise, a compile-time error occurs.
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.9.2-100-C-B"></a>
                                    	  If the class instance creation expression is qualified, then
                                    	  the immediately enclosing instance of <code class="varname">i</code> is the object that
                                    	  is the value of the <span class="emphasis"><em>Primary</em></span> expression or the
                                    	  <span class="emphasis"><em>ExpressionName</em></span>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-15.9.2-200"></a>If <span class="type">C</span>
                  is an anonymous class, and its direct superclass <span class="type">S</span> is an inner
                  class, then <code class="varname">i</code> may have an <span class="emphasis"><em>immediately enclosing instance
                        with respect to <span class="type">S</span></em></span>, determined as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.9.2-200-A"></a>
                                 If <span class="type">S</span> is a local class, then:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.9.2-200-A-A"></a>
                                    	  If <span class="type">S</span> occurs in a static context, then <code class="varname">i</code> has no
                                    	  immediately enclosing instance with respect to <span class="type">S</span>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-error"><a name="jls-15.9.2-200-A-B"></a>
                                    	  Otherwise, if the class instance creation expression occurs
                                    	  in a static context, then a compile-time error
                                    	  occurs.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.9.2-200-A-C"></a>
                                    	  Otherwise, let <span class="type">O</span> be the immediately enclosing class of
                                              <span class="type">S</span>. Let <span class="emphasis"><em>n</em></span> be an integer such that <span class="type">O</span> is the <span class="emphasis"><em>n</em></span>'th
                                              lexically enclosing type declaration of the class in which
                                              the class instance creation expression appears.
                                 </p>
                                 <p class="norm-dynamic"><a name="jls-15.9.2-300-A-C.1"></a>
                                    	  The immediately enclosing instance of <code class="varname">i</code> with respect to
                                              <span class="type">S</span> is the <span class="emphasis"><em>n</em></span>'th lexically enclosing instance of
                                              <code class="literal">this</code>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.9.2-200-B"></a>
                                 If <span class="type">S</span> is an inner member class, then:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.9.2-200-B-A"></a>
                                    	  If the class instance creation expression is unqualified,
                                    	  then:
                                 </p>
                                 <div class="norm">
                                    <ul class="norm" type="square">
                                       <li class="listitem">
                                          <p class="norm-error"><a name="jls-15.9.2-200-B-A-A"></a>
                                             	      If the class instance creation expression occurs in a
                                             	      static context, then a compile-time error occurs.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-15.9.2-200-B-A-B"></a>
                                             	      Otherwise, if <span class="type">S</span> is a member of a class enclosing the class in which the class
                                                           instance creation expression appears, then let <span class="type">O</span> be
                                                           the immediately enclosing class of which <span class="type">S</span> is a
                                                           member. Let <span class="emphasis"><em>n</em></span> be an integer such that <span class="type">O</span> is the
                                                           <span class="emphasis"><em>n</em></span>'th lexically enclosing type declaration of the
                                                           class in which the class instance creation expression
                                                           appears.
                                          </p>
                                          <p class="norm-dynamic"><a name="jls-15.9.2-200-B-A-B.1"></a>
                                             	      The immediately enclosing instance of <code class="varname">i</code> with respect
                                                           to <span class="type">S</span> is the <span class="emphasis"><em>n</em></span>'th lexically enclosing instance of
                                                           <code class="literal">this</code>.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-error"><a name="jls-15.9.2-200-B-A-C"></a>
                                             	      Otherwise, a compile-time error occurs.
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.9.2-200-B-B"></a>
                                    	  If the class instance creation expression is qualified, then
                                              the immediately enclosing instance of <code class="varname">i</code> with respect to
                                              <span class="type">S</span> is the object that is the value of the <span class="emphasis"><em>Primary</em></span>
                                              expression or the <span class="emphasis"><em>ExpressionName</em></span>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="15.9.3.&nbsp;Choosing the Constructor and its Arguments">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.9.3"></a>15.9.3.&nbsp;Choosing the Constructor and its Arguments
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.9.3-100"></a>Let <span class="type">C</span>
                  be the class being instantiated. To create an instance of <span class="type">C</span>, <code class="varname">i</code>, a
                  constructor of <span class="type">C</span> is chosen at compile time by the following
                  rules:
               </p>
               <p class="norm-static"><a name="jls-15.9.3-110"></a>First,
                  the actual arguments to the constructor invocation are
                  determined:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.9.3-110-A"></a>
                                 If <span class="type">C</span> is an anonymous class with direct superclass <span class="type">S</span>,
                                 then:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.9.3-110-A-A"></a>
                                    	  If <span class="type">S</span> is not an inner class, or if <span class="type">S</span> is a local class
                                    	  that occurs in a static context, then the arguments to the
                                    	  constructor are the arguments in the argument list of the
                                    	  class instance creation expression, if any, in the order
                                    	  they appear in the expression.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.9.3-110-A-B"></a>
                                    	  Otherwise, the first argument to the constructor is the
                                              immediately enclosing instance of <code class="varname">i</code> with respect to <span class="type">S</span>
                                              (<a class="xref" href="jls-15.html#jls-15.9.2" title="15.9.2.&nbsp;Determining Enclosing Instances">&sect;15.9.2</a>), and the subsequent arguments
                                              to the constructor are the arguments in the argument list of
                                              the class instance creation expression, if any, in the order
                                              they appear in the class instance creation
                                              expression.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.9.3-110-B"></a>
                                 If <span class="type">C</span> is a local class or a <code class="literal">private</code> inner member class, then
                                 the arguments to the constructor are the arguments in the
                                 argument list of the class instance creation expression, if any,
                                 in the order they appear in the class instance creation
                                 expression.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.9.3-110-C"></a>
                                 If <span class="type">C</span> is a non-<code class="literal">private</code> inner member class, then the first
                                 argument to the constructor is the immediately enclosing
                                 instance of <code class="varname">i</code> 
                                 (<a class="xref" href="jls-8.html#jls-8.8.1" title="8.8.1.&nbsp;Formal Parameters">&sect;8.8.1</a>, <a class="xref" href="jls-15.html#jls-15.9.2" title="15.9.2.&nbsp;Determining Enclosing Instances">&sect;15.9.2</a>), and
                                 the subsequent arguments to its constructor are the arguments in
                                 the argument list of the class instance creation expression, if
                                 any, in the order they appear in the class instance creation
                                 expression.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.9.3-110-D"></a>
                                 Otherwise, the arguments to the constructor are the arguments in
                                 the argument list of the class instance creation expression, if
                                 any, in the order they appear in the expression.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-15.9.3-120"></a>Second, a
                  constructor of <span class="type">C</span> and corresponding return type and <code class="literal">throws</code> clause
                  are determined:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.9.3-120-A"></a>
                                 If the class instance creation expression uses <code class="literal">&lt;&gt;</code> to
                                 elide class type arguments, a list of methods <code class="varname">m<sub>1</sub></code>...<code class="varname">m<sub>n</sub></code> is
                                 defined for the purpose of overload resolution and type argument
                                 inference.
                        </p>
                        <p class="norm"><a name="jls-15.9.3-120-A.1"></a>
                                 Let <code class="varname">c<sub>1</sub></code>...<code class="varname">c<sub>n</sub></code> be the constructors of class
                                 <span class="type">C</span>. Let <code class="literal">#m</code> be an automatically generated
                                 name that is distinct from all constructor and method names in
                                 <span class="type">C</span>. For all <span class="emphasis"><em>j</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>j</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), <code class="varname">m<sub>j</sub></code> is
                                 defined in terms of <code class="varname">c<sub>j</sub></code> as follows:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm"><a name="jls-15.9.3-120-A.1-A"></a>
                                    	  A substitution <span class="symbol">&#952;</span><code class="varname"><sub>j</sub></code> is first defined to instantiate the
                                              types in <code class="varname">c<sub>j</sub></code>.
                                 </p>
                                 <p class="norm"><a name="jls-15.9.3-120-A.1-A.1"></a>
                                    	  Let <span class="type">F<sub>1</sub></span>...<span class="type">F<sub>p</sub></span> be the type parameters of <span class="type">C</span>, and let
                                              <span class="type">G<sub>1</sub></span>...<span class="type">G<sub>q</sub></span> be the type parameters (if any) of <code class="varname">c<sub>j</sub></code>. Let
                                              <span class="type">X<sub>1</sub></span>...<span class="type">X<sub>p</sub></span> and <span class="type">Y<sub>1</sub></span>...<span class="type">Y<sub>q</sub></span> be type variables with distinct
                                              names that are not in scope in the body of <span class="type">C</span>.
                                 </p>
                                 <p class="norm"><a name="jls-15.9.3-120-A.1-A.2"></a>
                                    	  <span class="symbol">&#952;</span><code class="varname"><sub>j</sub></code> is <code class="literal">[<span class="type">F<sub>1</sub></span>:=<span class="type">X<sub>1</sub></span>, ..., <span class="type">F<sub>p</sub></span>:=<span class="type">X<sub>p</sub></span>,
                                                 <span class="type">G<sub>1</sub></span>:=<span class="type">Y<sub>1</sub></span>, ..., <span class="type">G<sub>q</sub></span>:=<span class="type">Y<sub>q</sub></span>]</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-15.9.3-120-A.1-B"></a>
                                    	  The modifiers of <code class="varname">m<sub>j</sub></code> are those of <code class="varname">c<sub>j</sub></code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-15.9.3-120-A.1-C"></a>
                                    	  The type parameters of <code class="varname">m<sub>j</sub></code> are <span class="type">X<sub>1</sub></span>...<span class="type">X<sub>p</sub></span>,<span class="type">Y<sub>1</sub></span>...<span class="type">Y<sub>q</sub></span>. The
                                    	  bound of each parameter, if any, is <span class="symbol">&#952;</span><code class="varname"><sub>j</sub></code> applied to the
                                    	  corresponding parameter bound in <span class="type">C</span> or <code class="varname">c<sub>j</sub></code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-15.9.3-120-A.1-D"></a>
                                    	  The return type of <code class="varname">m<sub>j</sub></code> is <span class="symbol">&#952;</span><code class="varname"><sub>j</sub></code> applied to
                                    	  <span class="type">C</span><code class="literal">&lt;</code><span class="type">F<sub>1</sub></span>,...,<span class="type">F<sub>p</sub></span><code class="literal">&gt;</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-15.9.3-120-A.1-E"></a>
                                    	  The name of <code class="varname">m<sub>j</sub></code> is <code class="literal">#m</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-15.9.3-120-A.1-F"></a>
                                    	  The (possibly empty) list of argument types of <code class="varname">m<sub>j</sub></code> is
                                              <span class="symbol">&#952;</span><code class="varname"><sub>j</sub></code> applied to the argument types of <code class="varname">c<sub>j</sub></code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-15.9.3-120-A.1-G"></a>
                                    	  The (possibly empty) list of thrown types of <code class="varname">m<sub>j</sub></code> is
                                    	  <span class="symbol">&#952;</span><code class="varname"><sub>j</sub></code> applied to the thrown types of <code class="varname">c<sub>j</sub></code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-15.9.3-120-A.1-H"></a>
                                    	  The body of <code class="varname">m<sub>j</sub></code> is irrelevant.
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <p class="norm-static"><a name="jls-15.9.3-120-A.2"></a>
                                 To choose a constructor, we temporarily consider <code class="varname">m<sub>1</sub></code>...<code class="varname">m<sub>n</sub></code> to
                                 be members of <span class="type">C</span>. Then one of <code class="varname">m<sub>1</sub></code>...<code class="varname">m<sub>n</sub></code> is selected, as
                                 determined by the class instance creation's argument
                                 expressions, using the process specified in
                                 <a class="xref" href="jls-15.html#jls-15.12.2" title="15.12.2.&nbsp;Compile-Time Step 2: Determine Method Signature">&sect;15.12.2</a>.
                        </p>
                        <p class="norm-error"><a name="jls-15.9.3-120-A.3"></a>
                                 If there is no unique most specific method that is both
                                 applicable and accessible, then a compile-time error
                                 occurs.
                        </p>
                        <p class="norm-static"><a name="jls-15.9.3-120-A.4"></a>
                                 Otherwise, where <code class="varname">m<sub>j</sub></code> is the selected method, <code class="varname">c<sub>j</sub></code> is the chosen
                                 constructor. The return type and <code class="literal">throws</code> clause of <code class="varname">c<sub>j</sub></code> are the
                                 same as the return type and <code class="literal">throws</code> clause determined for <code class="varname">m<sub>j</sub></code>
                                 (<a class="xref" href="jls-15.html#jls-15.12.2.6" title="15.12.2.6.&nbsp;Method Invocation Type">&sect;15.12.2.6</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.9.3-120-B"></a>
                                 Otherwise, the class instance creation expression does not use
                                 <code class="literal">&lt;&gt;</code> to elide class type arguments.
                        </p>
                        <p class="norm-static"><a name="jls-15.9.3-120-B.1"></a>
                                 Let <span class="type">T</span> be the type denoted by <span class="type">C</span> followed by any class type
                                 arguments in the expression. The process specified in
                                 <a class="xref" href="jls-15.html#jls-15.12.2" title="15.12.2.&nbsp;Compile-Time Step 2: Determine Method Signature">&sect;15.12.2</a>, modified to handle constructors,
                                 is used to select one of the constructors of <span class="type">T</span> and determine
                                 its <code class="literal">throws</code> clause.
                        </p>
                        <p class="norm-error"><a name="jls-15.9.3-120-B.2"></a>
                                 If there is no unique most-specific constructor that is both
                                 applicable and accessible, then a compile-time error occurs (as
                                 in method invocations).
                        </p>
                        <p class="norm-static"><a name="jls-15.9.3-120-B.3"></a>
                                 Otherwise, the return type is <span class="type">T</span>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-error"><a name="jls-15.9.3-200"></a>It is a
                  compile-time error if an argument to a class instance creation
                  expression is not compatible with its target type, as derived from the
                  invocation type (<a class="xref" href="jls-15.html#jls-15.12.2.6" title="15.12.2.6.&nbsp;Method Invocation Type">&sect;15.12.2.6</a>).
               </p>
               <p class="norm-error"><a name="jls-15.9.3-210"></a>If the
                  compile-time declaration is applicable by variable arity invocation
                  (<a class="xref" href="jls-15.html#jls-15.12.2.4" title="15.12.2.4.&nbsp;Phase 3: Identify Methods Applicable by Variable Arity Invocation">&sect;15.12.2.4</a>), then where the last formal
                  parameter type of the invocation type of the constructor is
                  <span class="type">F<sub>n</sub></span><code class="literal">[]</code>, it is a compile-time error if the type which is the
                  erasure of <span class="type">F<sub>n</sub></span> is not accessible at the point of invocation.
               </p>
               <p class="norm-static"><a name="jls-15.9.3-300"></a>The type of the
                  class instance creation expression is the return type of the chosen
                  constructor, as defined above.
               </p>
               <p class="norm-static"><a name="jls-15.9.3-310"></a>Note that
                  the type of the class instance creation expression may be an anonymous
                  class type, in which case the constructor being invoked is an
                  anonymous constructor (<a class="xref" href="jls-15.html#jls-15.9.5.1" title="15.9.5.1.&nbsp;Anonymous Constructors">&sect;15.9.5.1</a>).
               </p>
            </div>
            <div class="section" title="15.9.4.&nbsp;Run-Time Evaluation of Class Instance Creation Expressions">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.9.4"></a>15.9.4.&nbsp;Run-Time Evaluation of Class Instance Creation Expressions
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-15.9.4-100"></a>At run time, evaluation of a
                  class instance creation expression is as follows.
               </p>
               <p class="norm-dynamic"><a name="jls-15.9.4-110"></a>First,
                  if the class instance creation expression is a qualified class
                  instance creation expression, the qualifying primary expression is
                  evaluated. If the qualifying expression evaluates to <code class="literal">null</code>, a <code class="literal">NullPointerException</code>
                  is raised, and the class instance creation expression completes
                  abruptly. If the qualifying expression completes abruptly, the class
                  instance creation expression completes abruptly for the same
                  reason.
               </p>
               <p class="norm-dynamic"><a name="jls-15.9.4-120"></a>Next,
                  space is allocated for the new class instance. If there is
                  insufficient space to allocate the object, evaluation of the class
                  instance creation expression completes abruptly by throwing an
                  <code class="literal">OutOfMemoryError</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-15.9.4-130"></a>The new
                  object contains new instances of all the fields declared in the
                  specified class type and all its superclasses. As each new field
                  instance is created, it is initialized to its default value
                  (<a class="xref" href="jls-4.html#jls-4.12.5" title="4.12.5.&nbsp;Initial Values of Variables">&sect;4.12.5</a>).
               </p>
               <p class="norm-dynamic"><a name="jls-15.9.4-140"></a>Next,
                  the actual arguments to the constructor are evaluated,
                  left-to-right. If any of the argument evaluations completes abruptly,
                  any argument expressions to its right are not evaluated, and the class
                  instance creation expression completes abruptly for the same
                  reason.
               </p>
               <p class="norm-dynamic"><a name="jls-15.9.4-150"></a>Next,
                  the selected constructor of the specified class type is invoked. This
                  results in invoking at least one constructor for each superclass of
                  the class type. This process can be directed by explicit constructor
                  invocation statements (<a class="xref" href="jls-8.html#jls-8.8" title="8.8.&nbsp;Constructor Declarations">&sect;8.8</a>) and is specified in
                  detail in <a class="xref" href="jls-12.html#jls-12.5" title="12.5.&nbsp;Creation of New Class Instances">&sect;12.5</a>.
               </p>
               <p class="norm-dynamic"><a name="jls-15.9.4-200"></a>The
                  value of a class instance creation expression is a reference to the
                  newly created object of the specified class. Every time the expression
                  is evaluated, a fresh object is created.
               </p>
               <div class="example"><a name="d5e23938"></a><p class="title"><b>Example&nbsp;15.9.4-1.&nbsp;Evaluation Order and Out-Of-Memory Detection</b></p>
                  <div class="example-contents">
                     <p class="note">If evaluation of a class instance creation
                        expression finds there is insufficient memory to perform the creation
                        operation, then an <code class="literal">OutOfMemoryError</code> is thrown. This check occurs before any
                        argument expressions are evaluated.
                     </p>
                     <p class="note">So, for example, the test program:</p><pre class="programlisting">
class List {
    int value;
    List next;
    static List head = new List(0);
    List(int n) { value = n; next = head; head = this; }
}
class Test {
    public static void main(String[] args) {
        int id = 0, oldid = 0;
        try {
            for (;;) {
                ++id;
                new List(oldid = id);
            }
        } catch (Error e) {
            List.head = null;
            System.out.println(e.getClass() + ", " + (oldid==id));
        }
    }
}
</pre><p class="note">prints:</p><pre class="screen">
class java.lang.OutOfMemoryError, false
</pre><p class="note">because the out-of-memory condition is detected
                        before the argument expression <code class="literal">oldid = id</code> is
                        evaluated.
                     </p>
                     <p class="note">Compare this to the treatment of array creation
                        expressions, for which the out-of-memory condition is detected after
                        evaluation of the dimension expressions (<a class="xref" href="jls-15.html#jls-15.10.2" title="15.10.2.&nbsp;Run-Time Evaluation of Array Creation Expressions">&sect;15.10.2</a>).
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="15.9.5.&nbsp;Anonymous Class Declarations">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.9.5"></a>15.9.5.&nbsp;Anonymous Class Declarations
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.9.5-100"></a>An
                  anonymous class declaration is automatically derived from a class
                  instance creation expression by the Java compiler.
               </p>
               <p class="norm-static"><a name="jls-15.9.5-110"></a>An
                  anonymous class is never <code class="literal">abstract</code>
                  (<a class="xref" href="jls-8.html#jls-8.1.1.1" title="8.1.1.1.&nbsp;abstract Classes">&sect;8.1.1.1</a>).
               </p>
               <p class="norm-static"><a name="jls-15.9.5-120"></a>An
                  anonymous class is always implicitly <code class="literal">final</code>
                  (<a class="xref" href="jls-8.html#jls-8.1.1.2" title="8.1.1.2.&nbsp;final Classes">&sect;8.1.1.2</a>).
               </p>
               <p class="norm-static"><a name="jls-15.9.5-130"></a>An
                  anonymous class is always an inner class
                  (<a class="xref" href="jls-8.html#jls-8.1.3" title="8.1.3.&nbsp;Inner Classes and Enclosing Instances">&sect;8.1.3</a>); it is never <code class="literal">static</code>
                  (<a class="xref" href="jls-8.html#jls-8.1.1" title="8.1.1.&nbsp;Class Modifiers">&sect;8.1.1</a>, <a class="xref" href="jls-8.html#jls-8.5.1" title="8.5.1.&nbsp;Static Member Type Declarations">&sect;8.5.1</a>).
               </p>
               <div class="section" title="15.9.5.1.&nbsp;Anonymous Constructors">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-15.9.5.1"></a>15.9.5.1.&nbsp;Anonymous Constructors
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-static"><a name="jls-15.9.5.1-100"></a>An
                     anonymous class cannot have an explicitly declared
                     constructor. Instead, an anonymous constructor is implicitly declared
                     for an anonymous class. The form of the anonymous constructor for an
                     anonymous class <span class="type">C</span> with direct superclass <span class="type">S</span> is as follows:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.9.5.1-100-A"></a>
                                    If <span class="type">S</span> is not an inner class, or if <span class="type">S</span> is a local class that
                                    occurs in a static context, then the anonymous constructor has
                                    one formal parameter for each actual argument to the class
                                    instance creation expression in which <span class="type">C</span> is declared.
                           </p>
                           <p class="norm-static"><a name="jls-15.9.5.1-100-A.1"></a>
                                    The actual arguments to the class instance creation expression
                                    are used to determine a constructor <code class="varname">cs</code> of
                                    <span class="type">S</span>, using the same rules as for method invocations
                                    (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>). The type of each formal parameter
                                    of the anonymous constructor must be identical to the
                                    corresponding formal parameter of <code class="varname">cs</code>.
                           </p>
                           <p class="norm-static"><a name="jls-15.9.5.1-100-A.2"></a>
                                    The constructor body consists of an explicit constructor
                                    invocation (<a class="xref" href="jls-8.html#jls-8.8.7.1" title="8.8.7.1.&nbsp;Explicit Constructor Invocations">&sect;8.8.7.1</a>) of the
                                    form <code class="literal">super(...)</code>, where the actual arguments
                                    are the formal parameters of the constructor, in the order they
                                    were declared.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.9.5.1-100-B"></a>
                                    Otherwise, the first formal parameter of the constructor of <span class="type">C</span>
                                    represents the value of the immediately enclosing instance of
                                    <code class="varname">i</code> with respect to <span class="type">S</span> (<a class="xref" href="jls-15.html#jls-15.9.2" title="15.9.2.&nbsp;Determining Enclosing Instances">&sect;15.9.2</a>,
                                    <a class="xref" href="jls-15.html#jls-15.9.3" title="15.9.3.&nbsp;Choosing the Constructor and its Arguments">&sect;15.9.3</a>).  The type of this parameter is
                                    the class type that immediately encloses the declaration of
                                    <span class="type">S</span>.
                           </p>
                           <p class="norm-static"><a name="jls-15.9.5.1-100-B.1"></a>
                                    The constructor has an additional formal parameter for each
                                    actual argument to the class instance creation expression that
                                    declared the anonymous class. The <span class="emphasis"><em>n</em></span>'th formal
                                    parameter <code class="varname">e</code> corresponds to
                                    the <span class="emphasis"><em>n-1</em></span>'th actual argument.
                           </p>
                           <p class="norm-static"><a name="jls-15.9.5.1-100-B.2"></a>
                                    The actual arguments to the class instance creation expression
                                    are used to determine a constructor <code class="varname">cs</code> of
                                    <span class="type">S</span>, using the same rules as for method invocations
                                    (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>). The type of each formal parameter
                                    of the anonymous constructor must be identical to the
                                    corresponding formal parameter of <code class="varname">cs</code>.
                           </p>
                           <p class="norm-static"><a name="jls-15.9.5.1-100-B.3"></a>
                                    The constructor body consists of an explicit constructor
                                    invocation (<a class="xref" href="jls-8.html#jls-8.8.7.1" title="8.8.7.1.&nbsp;Explicit Constructor Invocations">&sect;8.8.7.1</a>) of the
                                    form <code class="literal">o.super(...)</code>, where <code class="literal">o</code>
                                    is the first formal parameter of the constructor, and the actual
                                    arguments are the subsequent formal parameters of the
                                    constructor, in the order they were declared.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm-static"><a name="jls-15.9.5.1-110"></a>In all
                     cases, the <code class="literal">throws</code> clause of an anonymous constructor must list all
                     the checked exceptions thrown by the explicit superclass constructor
                     invocation statement contained within the anonymous constructor, and
                     all checked exceptions thrown by any instance initializers or instance
                     variable initializers of the anonymous class.
                  </p>
                  <p class="norm-static"><a name="jls-15.9.5.1-200"></a>Note
                     that it is possible for the signature of the anonymous constructor to
                     refer to an inaccessible type (for example, if such a type occurred in
                     the signature of the superclass constructor <code class="varname">cs</code>).
                     This does not, in itself, cause any errors at either compile-time or
                     run-time.
                  </p>
               </div>
            </div>
         </div>
         <div class="section" title="15.10.&nbsp;Array Creation and Access Expressions">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.10"></a>15.10.&nbsp;Array Creation and Access Expressions
                     </h2>
                  </div>
               </div>
            </div>
            <div class="section" title="15.10.1.&nbsp;Array Creation Expressions">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.10.1"></a>15.10.1.&nbsp;Array Creation Expressions
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.10.1-100"></a>An array
                  creation expression is used to create new arrays (<a class="xref" href="jls-10.html" title="Chapter&nbsp;10.&nbsp;Arrays">&sect;10 (<i>Arrays</i>)</a>).
               </p>
               <div id="jls-15.10.1-110" class="productionset"><a name="jls-15.10.1-110"></a>
                    
                  <div class="production"><a name="jls-ArrayCreationExpression"></a>
                         
                     <div class="lhs">ArrayCreationExpression:</div>
                         
                     <div class="rhs">
                              <code class="literal">new</code> <a href="jls-4.html#jls-PrimitiveType" title="PrimitiveType">PrimitiveType</a> <a href="jls-15.html#jls-DimExprs" title="DimExprs">DimExprs</a> [<a href="jls-4.html#jls-Dims" title="Dims">Dims</a>] <br>
                        
                              <code class="literal">new</code> <a href="jls-4.html#jls-ClassOrInterfaceType" title="ClassOrInterfaceType">ClassOrInterfaceType</a> <a href="jls-15.html#jls-DimExprs" title="DimExprs">DimExprs</a> [<a href="jls-4.html#jls-Dims" title="Dims">Dims</a>] <br>
                        
                              <code class="literal">new</code> <a href="jls-4.html#jls-PrimitiveType" title="PrimitiveType">PrimitiveType</a> <a href="jls-4.html#jls-Dims" title="Dims">Dims</a> <a href="jls-10.html#jls-ArrayInitializer" title="ArrayInitializer">ArrayInitializer</a> <br>
                        
                              <code class="literal">new</code> <a href="jls-4.html#jls-ClassOrInterfaceType" title="ClassOrInterfaceType">ClassOrInterfaceType</a> <a href="jls-4.html#jls-Dims" title="Dims">Dims</a> <a href="jls-10.html#jls-ArrayInitializer" title="ArrayInitializer">ArrayInitializer</a>
                            
                     </div>
                       
                  </div>
                  
                    
                  <div class="production"><a name="jls-DimExprs"></a>
                         
                     <div class="lhs">DimExprs:</div>
                         
                     <div class="rhs">
                              <a href="jls-15.html#jls-DimExpr" title="DimExpr">DimExpr</a> {<a href="jls-15.html#jls-DimExpr" title="DimExpr">DimExpr</a>}
                            
                     </div>
                       
                  </div>
                  
                    
                  <div class="production"><a name="jls-DimExpr"></a>
                         
                     <div class="lhs">DimExpr:</div>
                         
                     <div class="rhs">
                              {<a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>} <code class="literal">[</code> <a href="jls-15.html#jls-Expression" title="Expression">Expression</a> <code class="literal">]</code>
                            
                     </div>
                       
                  </div>
                  
               </div>
               <p class="note">The following production from
                  <a class="xref" href="jls-4.html#jls-4.3" title="4.3.&nbsp;Reference Types and Values">&sect;4.3</a> is shown here for convenience:
               </p>
               <div id="d5e24048" class="productionset"><a name="d5e24048"></a>
                    
                  <div class="productionrecap-note">
                     <div class="production">
                            
                        <div class="lhs">Dims:</div>
                            
                        <div class="rhs">
                                 {<a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>} <code class="literal">[</code> <code class="literal">]</code> {{<a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>} <code class="literal">[</code> <code class="literal">]</code>}
                               
                        </div>
                          
                     </div>
                  </div>
                  
               </div>
               <p class="norm-dynamic"><a name="jls-15.10.1-120"></a>An
                  array creation expression creates an object that is a new array whose
                  elements are of the type specified by
                  the <span class="emphasis"><em>PrimitiveType</em></span>
                  or <span class="emphasis"><em>ClassOrInterfaceType</em></span>.
               </p>
               <p class="norm-error"><a name="jls-15.10.1-200"></a>It is a
                  compile-time error if the <span class="emphasis"><em>ClassOrInterfaceType</em></span>
                  does not denote a reifiable type
                  (<a class="xref" href="jls-4.html#jls-4.7" title="4.7.&nbsp;Reifiable Types">&sect;4.7</a>). Otherwise,
                  the <span class="emphasis"><em>ClassOrInterfaceType</em></span> may name any named
                  reference type, even an <code class="literal">abstract</code> class type
                  (<a class="xref" href="jls-8.html#jls-8.1.1.1" title="8.1.1.1.&nbsp;abstract Classes">&sect;8.1.1.1</a>) or an interface type.
               </p>
               <p class="note">The rules above imply that the element type in an
                  array creation expression cannot be a parameterized type, unless all
                  type arguments to the parameterized type are unbounded
                  wildcards.
               </p>
               <p class="norm-error"><a name="jls-15.10.1-210"></a>The type of
                  each dimension expression within a <span class="emphasis"><em>DimExpr</em></span> must
                  be a type that is convertible (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) to an
                  integral type, or a compile-time error occurs.
               </p>
               <p class="norm-error"><a name="jls-15.10.1-220"></a>Each
                  dimension expression undergoes unary numeric promotion
                  (<a class="xref" href="jls-5.html#jls-5.6.1" title="5.6.1.&nbsp;Unary Numeric Promotion">&sect;5.6.1</a>). The promoted type must be <code class="literal">int</code>, or a
                  compile-time error occurs.
               </p>
               <p class="norm-static"><a name="jls-15.10.1-300"></a>The type
                  of the array creation expression is an array type that can denoted by
                  a copy of the array creation expression from which the <code class="literal">new</code> keyword
                  and every <span class="emphasis"><em>DimExpr</em></span> expression and array
                  initializer have been deleted.
               </p>
               <div class="informalexample">
                  <p class="note">For example, the type of the creation
                     expression:
                  </p><pre class="screen">
new double[3][3][]
</pre><p class="note">is:</p><pre class="screen">
double[][][]
</pre></div>
            </div>
            <div class="section" title="15.10.2.&nbsp;Run-Time Evaluation of Array Creation Expressions">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.10.2"></a>15.10.2.&nbsp;Run-Time Evaluation of Array Creation Expressions
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-dynamic"><a name="jls-15.10.2-100"></a>At run
                  time, evaluation of an array creation expression behaves as
                  follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.10.2-100-A"></a>
                                 If there are no dimension expressions, then there must be an
                                 array initializer. A newly allocated array will be initialized
                                 with the values provided by the array initializer as described
                                 in <a class="xref" href="jls-10.html#jls-10.6" title="10.6.&nbsp;Array Initializers">&sect;10.6</a>. The value of the array
                                 initializer becomes the value of the array creation
                                 expression.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.10.2-100-B"></a>
                                 Otherwise, there is no array initializer, and:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.10.2-100-B-A"></a>
                                    	  First, the dimension expressions are evaluated,
                                    	  left-to-right. If any of the expression evaluations
                                    	  completes abruptly, the expressions to the right of it are
                                    	  not evaluated.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.10.2-100-B-B"></a>
                                    	  Next, the values of the dimension expressions are
                                    	  checked. If the value of any <span class="emphasis"><em>DimExpr</em></span>
                                    	  expression is less than zero, then a
                                    	  <code class="literal">NegativeArraySizeException</code> is thrown.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.10.2-100-B-C"></a>
                                    	  Next, space is allocated for the new array. If there is
                                    	  insufficient space to allocate the array, evaluation of the
                                    	  array creation expression completes abruptly by throwing an
                                    	  <code class="literal">OutOfMemoryError</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.10.2-100-B-D"></a>
                                    	  Then, if a single <span class="emphasis"><em>DimExpr</em></span> appears, a
                                    	  one-dimensional array is created of the specified length,
                                    	  and each component of the array is initialized to its
                                    	  default value (<a class="xref" href="jls-4.html#jls-4.12.5" title="4.12.5.&nbsp;Initial Values of Variables">&sect;4.12.5</a>).
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.10.2-100-B-E"></a>
                                    	  Otherwise, if <span class="emphasis"><em>n</em></span> <span class="emphasis"><em>DimExpr</em></span>
                                    	  expressions appear, then array creation effectively executes
                                    	  a set of nested loops of depth <span class="emphasis"><em>n</em></span><code class="literal">-1</code>
                                    	  to create the implied arrays of arrays.
                                 </p>
                                 <p class="norm-dynamic"><a name="jls-15.10.2-100-B-E.1"></a>
                                    	  A multidimensional array need not have arrays of the same
                                    	  length at each level.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
               <div class="example"><a name="d5e24104"></a><p class="title"><b>Example&nbsp;15.10.2-1.&nbsp;Array Creation Evaluation</b></p>
                  <div class="example-contents">
                     <p class="note">In an array creation expression with one or more
                        dimension expressions, each dimension expression is fully evaluated
                        before any part of any dimension expression to its right. Thus:
                     </p><pre class="programlisting">
class Test1 {
    public static void main(String[] args) {
        int i = 4;
        int ia[][] = new int[i][i=3];
        System.out.println(
            "[" + ia.length + "," + ia[0].length + "]");
    }
}
</pre><p class="note">prints:</p><pre class="screen">
[4,3]
</pre><p class="note">because the first dimension is calculated
                        as <code class="literal">4</code> before the second dimension expression
                        sets <code class="literal">i</code> to <code class="literal">3</code>.
                     </p>
                     <p class="note">If evaluation of a dimension expression completes
                        abruptly, no part of any dimension expression to its right will appear
                        to have been evaluated. Thus:
                     </p><pre class="programlisting">
class Test2 {
    public static void main(String[] args) {
        int[][] a = { { 00, 01 }, { 10, 11 } };
        int i = 99;
        try {
            a[val()][i = 1]++;
        } catch (Exception e) {
            System.out.println(e + ", i=" + i);
        }
    }
    static int val() throws Exception {
        throw new Exception("unimplemented");
    }
}
</pre><p class="note">prints:</p><pre class="screen">
java.lang.Exception: unimplemented, i=99
</pre><p class="note">because the embedded assignment that
                        sets <code class="literal">i</code> to <code class="literal">1</code> is never
                        executed.
                     </p>
                  </div>
               </div><br class="example-break"><div class="example"><a name="d5e24121"></a><p class="title"><b>Example&nbsp;15.10.2-2.&nbsp;Multi-Dimensional Array Creation</b></p>
                  <div class="example-contents">
                     <p class="note">The declaration:</p><pre class="screen">
float[][] matrix = new float[3][3];
</pre><p class="note">is equivalent in behavior to:</p><pre class="screen">
float[][] matrix = new float[3][];
for (int <code class="varname">d</code> = 0; <code class="varname">d</code> &lt; matrix.length; <code class="varname">d</code>++)
    matrix[<code class="varname">d</code>] = new float[3];
</pre><p class="note">and:</p><pre class="screen">
Age[][][][][] Aquarius = new Age[6][10][8][12][];
</pre><p class="note">is equivalent to:</p><pre class="screen">
Age[][][][][] Aquarius = new Age[6][][][][];
for (int <code class="varname">d1</code> = 0; <code class="varname">d1</code> &lt; Aquarius.length; <code class="varname">d1</code>++) {
    Aquarius[<code class="varname">d1</code>] = new Age[10][][][];
    for (int <code class="varname">d2</code> = 0; <code class="varname">d2</code> &lt; Aquarius[<code class="varname">d1</code>].length; <code class="varname">d2</code>++) {
        Aquarius[<code class="varname">d1</code>][<code class="varname">d2</code>] = new Age[8][][];
        for (int <code class="varname">d3</code> = 0; <code class="varname">d3</code> &lt; Aquarius[<code class="varname">d1</code>][<code class="varname">d2</code>].length; <code class="varname">d3</code>++) {
            Aquarius[<code class="varname">d1</code>][<code class="varname">d2</code>][<code class="varname">d3</code>] = new Age[12][];
        }
    }
}
</pre><p class="note">with <code class="varname">d</code>, <code class="varname">d1</code>, 
                        <code class="varname">d2</code>, and <code class="varname">d3</code> replaced by names
                        that are not already locally declared. Thus, a single <code class="literal">new</code> expression
                        actually creates one array of length 6, 6 arrays of length 10, 6x10 =
                        60 arrays of length 8, and 6x10x8 = 480 arrays of length 12. This
                        example leaves the fifth dimension, which would be arrays containing
                        the actual array elements (references to <code class="literal">Age</code>
                        objects), initialized only to null references. These arrays can be
                        filled in later by other code, such as:
                     </p><pre class="screen">
Age[] Hair = { new Age("quartz"), new Age("topaz") };
Aquarius[1][9][6][9] = Hair;
</pre><p class="note">A triangular matrix may be created by:</p><pre class="screen">
float triang[][] = new float[100][];
for (int i = 0; i &lt; triang.length; i++)
    triang[i] = new float[i+1];
</pre></div>
               </div><br class="example-break"><p class="norm-dynamic"><a name="jls-15.10.2-200"></a>If
                  evaluation of an array creation expression finds there is insufficient
                  memory to perform the creation operation, then an <code class="literal">OutOfMemoryError</code> is
                  thrown.  If the array
                  creation expression does not have an array initializer, then this
                  check occurs only after evaluation of all dimension expressions has
                  completed normally. If the array creation expression does have an
                  array initializer, then an <code class="literal">OutOfMemoryError</code> can occur when an object of
                  reference type is allocated during evaluation of a variable
                  initializer expression, or when space is allocated for an array to
                  hold the values of a (possibly nested) array initializer.
               </p>
               <div class="example"><a name="d5e24166"></a><p class="title"><b>Example&nbsp;15.10.2-3.&nbsp;<code class="literal">OutOfMemoryError</code> and Dimension Expression Evaluation</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Test3 {
    public static void main(String[] args) {
        int len = 0, oldlen = 0;
        Object[] a = new Object[0];
        try {
            for (;;) {
                ++len;
                Object[] temp = new Object[oldlen = len];
                temp[0] = a;
                a = temp;
            }
        } catch (Error e) {
            System.out.println(e + ", " + (oldlen==len));
        }
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
java.lang.OutOfMemoryError, true
</pre><p class="note">because the out-of-memory condition is detected
                        after the dimension expression <code class="literal">oldlen = len</code> is
                        evaluated.
                     </p>
                     <p class="note">Compare this to class instance creation expressions
                        (<a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>), which detect the out-of-memory condition
                        before evaluating argument expressions
                        (<a class="xref" href="jls-15.html#jls-15.9.4" title="15.9.4.&nbsp;Run-Time Evaluation of Class Instance Creation Expressions">&sect;15.9.4</a>).
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="15.10.3.&nbsp;Array Access Expressions">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.10.3"></a>15.10.3.&nbsp;Array Access Expressions
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.10.3-100"></a>An array
                  access expression refers to a variable that is a component of an
                  array.
               </p>
               <div id="jls-15.10.3-110" class="productionset"><a name="jls-15.10.3-110"></a>
                    
                  <div class="production"><a name="jls-ArrayAccess"></a>
                         
                     <div class="lhs">ArrayAccess:</div>
                         
                     <div class="rhs">
                              <a href="jls-6.html#jls-ExpressionName" title="ExpressionName">ExpressionName</a> <code class="literal">[</code> <a href="jls-15.html#jls-Expression" title="Expression">Expression</a> <code class="literal">]</code> <br>
                        
                              <a href="jls-15.html#jls-PrimaryNoNewArray" title="PrimaryNoNewArray">PrimaryNoNewArray</a> <code class="literal">[</code> <a href="jls-15.html#jls-Expression" title="Expression">Expression</a> <code class="literal">]</code>
                            
                     </div>
                       
                  </div>
                  
               </div>
               <p class="norm-static"><a name="jls-15.10.3-120"></a>An array
                  access expression contains two subexpressions, the <span class="emphasis"><em>array
                        reference expression</em></span> (before the left bracket) and
                  the <span class="emphasis"><em>index expression</em></span> (within the
                  brackets).
               </p>
               <p class="note">Note that the array reference expression may be a
                  name or any primary expression that is not an array creation
                  expression (<a class="xref" href="jls-15.html#jls-15.10" title="15.10.&nbsp;Array Creation and Access Expressions">&sect;15.10</a>).
               </p>
               <p class="norm-error"><a name="jls-15.10.3-200"></a>The type of
                  the array reference expression must be an array type (call it
                  <span class="type">T</span><code class="literal">[]</code>, an array whose components are of type <span class="type">T</span>), or a
                  compile-time error occurs.
               </p>
               <p class="norm-error"><a name="jls-15.10.3-210"></a>The index
                  expression undergoes unary numeric promotion
                  (<a class="xref" href="jls-5.html#jls-5.6.1" title="5.6.1.&nbsp;Unary Numeric Promotion">&sect;5.6.1</a>). The promoted type must be <code class="literal">int</code>, or a
                  compile-time error occurs.
               </p>
               <p class="norm-static"><a name="jls-15.10.3-220"></a>The type
                  of the array access expression is the result of applying capture
                  conversion (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>) to <span class="type">T</span>.
               </p>
               <p class="norm-dynamic"><a name="jls-15.10.3-300"></a>The
                  result of an array access expression is a variable of type <span class="type">T</span>, namely
                  the variable within the array selected by the value of the index
                  expression.
               </p>
               <p class="norm-dynamic"><a name="jls-15.10.3-310"></a>This
                  resulting variable, which is a component of the array, is never
                  considered <code class="literal">final</code>, even if the array reference expression denoted a
                  <code class="literal">final</code> variable.
               </p>
            </div>
            <div class="section" title="15.10.4.&nbsp;Run-Time Evaluation of Array Access Expressions">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.10.4"></a>15.10.4.&nbsp;Run-Time Evaluation of Array Access Expressions
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-dynamic"><a name="jls-15.10.4-100"></a>At run
                  time, evaluation of an array access expression behaves as
                  follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.10.4-100-A"></a>
                                 First, the array reference expression is evaluated. If this
                                 evaluation completes abruptly, then the array access completes
                                 abruptly for the same reason and the index expression is not
                                 evaluated.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.10.4-100-B"></a>
                                 Otherwise, the index expression is evaluated. If this evaluation
                                 completes abruptly, then the array access completes abruptly for
                                 the same reason.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.10.4-100-C"></a>
                                 Otherwise, if the value of the array reference expression is
                                 <code class="literal">null</code>, then a <code class="literal">NullPointerException</code> is thrown.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.10.4-100-D"></a>
                                 Otherwise, the value of the array reference expression indeed
                                 refers to an array. If the value of the index expression is less
                                 than zero, or greater than or equal to the array's <code class="literal">length</code>,
                                 then an <code class="literal">ArrayIndexOutOfBoundsException</code> is thrown.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.10.4-100-E"></a>
                                 Otherwise, the result of the array access is the variable of
                                 type <span class="type">T</span>, within the array, selected by the value of the index
                                 expression.
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="example"><a name="d5e24231"></a><p class="title"><b>Example&nbsp;15.10.4-1.&nbsp;Array Reference Is Evaluated First</b></p>
                  <div class="example-contents">
                     <p class="note">In an array access, the expression to the left of
                        the brackets appears to be fully evaluated before any part of the
                        expression within the brackets is evaluated. For example, in the
                        (admittedly monstrous) expression <code class="literal">a[(a=b)[3]]</code>, the
                        expression <code class="literal">a</code> is fully evaluated before the
                        expression <code class="literal">(a=b)[3]</code>; this means that the original
                        value of <code class="literal">a</code> is fetched and remembered while the
                        expression <code class="literal">(a=b)[3]</code> is evaluated. This array
                        referenced by the original value of <code class="literal">a</code> is then
                        subscripted by a value that is element <code class="literal">3</code> of another
                        array (possibly the same array) that was referenced
                        by <code class="literal">b</code> and is now also referenced
                        by <code class="literal">a</code>.
                     </p>
                     <p class="note">Thus, the program:</p><pre class="programlisting">
class Test1 {
    public static void main(String[] args) {
        int[] a = { 11, 12, 13, 14 };
        int[] b = { 0, 1, 2, 3 };
        System.out.println(a[(a=b)[3]]);
    }
}
</pre><p class="note">prints:</p><pre class="screen">
14
</pre><p class="note">because the monstrous expression's value is
                        equivalent to <code class="literal">a[b[3]]</code> or <code class="literal">a[3]</code>
                        or <code class="literal">14</code>.
                     </p>
                  </div>
               </div><br class="example-break"><div class="example"><a name="d5e24251"></a><p class="title"><b>Example&nbsp;15.10.4-2.&nbsp;Abrupt Completion of Array Reference Evaluation</b></p>
                  <div class="example-contents">
                     <p class="note">If evaluation of the expression to the left of the
                        brackets completes abruptly, no part of the expression within the
                        brackets will appear to have been evaluated. Thus, the program:
                     </p><pre class="programlisting">
class Test2 {
    public static void main(String[] args) {
        int index = 1;
        try {
            skedaddle()[index=2]++;
        } catch (Exception e) {
            System.out.println(e + ", index=" + index);
        }
    }
    static int[] skedaddle() throws Exception {
        throw new Exception("Ciao");
    }
}
</pre><p class="note">prints:</p><pre class="screen">
java.lang.Exception: Ciao, index=1
</pre><p class="note">because the embedded assignment
                        of <code class="literal">2</code> to <code class="literal">index</code> never
                        occurs.
                     </p>
                  </div>
               </div><br class="example-break"><div class="example"><a name="d5e24260"></a><p class="title"><b>Example&nbsp;15.10.4-3.&nbsp;<code class="literal">null</code> Array Reference</b></p>
                  <div class="example-contents">
                     <p class="note">If the array reference expression produces <code class="literal">null</code>
                        instead of a reference to an array, then a <code class="literal">NullPointerException</code> is thrown at run
                        time, but only after all parts of the array access expression have
                        been evaluated and only if these evaluations completed normally. Thus,
                        the program:
                     </p><pre class="programlisting">
class Test3 {
    public static void main(String[] args) {
        int index = 1;
        try {
            nada()[index=2]++;
        } catch (Exception e) {
            System.out.println(e + ", index=" + index);
        }
    }
    static int[] nada() { return null; }
}
</pre><p class="note">prints:</p><pre class="screen">
java.lang.NullPointerException, index=2
</pre><p class="note">because the embedded assignment
                        of <code class="literal">2</code> to <code class="literal">index</code> occurs before the
                        check for a <code class="literal">null</code> array reference expression. As a related example,
                        the program:
                     </p><pre class="programlisting">
class Test4 {
    public static void main(String[] args) {
        int[] a = null;
        try {
            int i = a[vamoose()];
            System.out.println(i);
        } catch (Exception e) {
            System.out.println(e);
        }
    }
    static int vamoose() throws Exception {
        throw new Exception("Twenty-three skidoo!");
    }
}
</pre><p class="note">always prints:</p><pre class="screen">
java.lang.Exception: Twenty-three skidoo!
</pre><p class="note">A <code class="literal">NullPointerException</code> never occurs, because the index expression
                        must be completely evaluated before any further part of the array
                        access occurs, and that includes the check as to whether the value of
                        the array reference expression is <code class="literal">null</code>.
                     </p>
                  </div>
               </div><br class="example-break"></div>
         </div>
         <div class="section" title="15.11.&nbsp;Field Access Expressions">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.11"></a>15.11.&nbsp;Field Access Expressions
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-dynamic"><a name="jls-15.11-100"></a>A field
               access expression may access a field of an object or array, a
               reference to which is the value of either an expression or the special
               keyword <code class="literal">super</code>.
            </p>
            <div id="jls-15.11-110" class="productionset"><a name="jls-15.11-110"></a>
                 
               <div class="production"><a name="jls-FieldAccess"></a>
                      
                  <div class="lhs">FieldAccess:</div>
                      
                  <div class="rhs">
                           <a href="jls-15.html#jls-Primary" title="Primary">Primary</a> <code class="literal">.</code> <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a> <br>
                           <code class="literal">super</code> <code class="literal">.</code> <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a> <br>
                           <a href="jls-6.html#jls-TypeName" title="TypeName">TypeName</a> <code class="literal">.</code> <code class="literal">super</code> <code class="literal">.</code> <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a>
                         
                  </div>
                    
               </div>
               
            </div>
            <p class="norm"><a name="jls-15.11-120"></a>The meaning of a field access
               expression is determined using the same rules as for qualified names
               (<a class="xref" href="jls-6.html#jls-6.5.6.2" title="6.5.6.2.&nbsp;Qualified Expression Names">&sect;6.5.6.2</a>), but limited by the fact that an
               expression cannot denote a package, class type, or interface
               type.
            </p>
            <p class="norm-dynamic"><a name="jls-15.11-130"></a>It is
               also possible to refer to a field of the current instance or current
               class by using a simple name (<a class="xref" href="jls-6.html#jls-6.5.6.1" title="6.5.6.1.&nbsp;Simple Expression Names">&sect;6.5.6.1</a>).
            </p>
            <div class="section" title="15.11.1.&nbsp;Field Access Using a Primary">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.11.1"></a>15.11.1.&nbsp;Field Access Using a Primary
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-error"><a name="jls-15.11.1-100"></a>The type
                  of the <span class="emphasis"><em>Primary</em></span> must be a reference type <span class="type">T</span>, or a compile-time error
                  occurs.
               </p>
               <p class="norm-static"><a name="jls-15.11.1-110"></a>The
                  meaning of the field access expression is determined as
                  follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-15.11.1-110-A"></a>
                                 If the identifier names several accessible
                                 (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>) member fields in type <span class="type">T</span>, then the
                                 field access is ambiguous and a compile-time error
                                 occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-15.11.1-110-B"></a>
                                 If the identifier does not name an accessible member field in
                                 type <span class="type">T</span>, then the field access is undefined and a compile-time
                                 error occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.11.1-110-C"></a>
                                 Otherwise, the identifier names a single accessible member field
                                 in type <span class="type">T</span>, and the type of the field access expression is the
                                 type of the member field after capture conversion
                                 (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>).
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-15.11.1-200"></a>At run time,
                  the result of the field access expression is computed as
                  follows: (assuming that the program is correct with respect
                  to definite assignment analysis, i.e. every blank <code class="literal">final</code> variable is
                  definitely assigned before access)
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.11.1-200-A"></a>
                                 If the field is <code class="literal">static</code>:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.11.1-200-A-A"></a>
                                    	  The <span class="emphasis"><em>Primary</em></span> expression is evaluated, and the result is
                                    	  discarded. If evaluation of the <span class="emphasis"><em>Primary</em></span> expression
                                    	  completes abruptly, the field access expression completes
                                    	  abruptly for the same reason.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.11.1-200-A-B"></a>
                                    	  If the field is a non-blank <code class="literal">final</code>
                                    	  field, then the result is the value of the specified class
                                    	  variable in the class or interface that is the type of the
                                    	  <span class="emphasis"><em>Primary</em></span> expression.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.11.1-200-A-C"></a>
                                    	  If the field is not <code class="literal">final</code>, or is a blank <code class="literal">final</code>
                                    	  and the field access occurs in a static initializer or class
                                    	  variable initializer, then the result is a
                                    	  variable, namely, the specified class variable in the class
                                    	  that is the type of the <span class="emphasis"><em>Primary</em></span> expression.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.11.1-200-B"></a>
                                 If the field is not <code class="literal">static</code>:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.11.1-200-B-A"></a>
                                    	  The <span class="emphasis"><em>Primary</em></span> expression is evaluated. If evaluation of the
                                    	  <span class="emphasis"><em>Primary</em></span> expression completes abruptly, the field access
                                    	  expression completes abruptly for the same reason.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.11.1-200-B-2"></a>
                                    	  If the value of the <span class="emphasis"><em>Primary</em></span> is <code class="literal">null</code>, then a <code class="literal">NullPointerException</code> is
                                    	  thrown.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.11.1-200-B-C"></a>
                                    	  If the field is a non-blank <code class="literal">final</code>,
                                    	  then the result is the value of the named member field in type <span class="type">T</span>
                                    	  found in the object referenced by the value of the
                                    	  <span class="emphasis"><em>Primary</em></span>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.11.1-200-B-D"></a>
                                    	  If the field is not <code class="literal">final</code>, or is a blank <code class="literal">final</code>
                                    	  and the field access occurs in a constructor or instance
                                    	  variable initializer, then the result is a
                                    	  variable, namely the named member field in type <span class="type">T</span>
                                    	  found in the object referenced by the value of the
                                    	  <span class="emphasis"><em>Primary</em></span>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-15.11.1-210"></a>Note
                  that only the type of the <span class="emphasis"><em>Primary</em></span> expression, not the class of the
                  actual object referred to at run time, is used in determining which
                  field to use.
               </p>
               <div class="example"><a name="d5e24366"></a><p class="title"><b>Example&nbsp;15.11.1-1.&nbsp;Static Binding for Field Access</b></p>
                  <div class="example-contents"><pre class="programlisting">
class S           { int x = 0; }
class T extends S { int x = 1; }
class Test1 {
    public static void main(String[] args) {
        T t = new T();
        System.out.println("t.x=" + t.x + when("t", t));
        S s = new S();
        System.out.println("s.x=" + s.x + when("s", s));
        s = t;
        System.out.println("s.x=" + s.x + when("s", s));
    }
    static String when(String name, Object t) {
        return " when " + name + " holds a "
                        + t.getClass() + " at run time.";
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
t.x=1 when t holds a class T at run time.
s.x=0 when s holds a class S at run time.
s.x=0 when s holds a class T at run time.
</pre><p class="note">The last line shows that, indeed, the field that is
                        accessed does not depend on the run-time class of the referenced
                        object; even if <code class="literal">s</code> holds a reference to an object of
                        class <code class="literal">T</code>, the expression <code class="literal">s.x</code>
                        refers to the <code class="literal">x</code> field of
                        class <code class="literal">S</code>, because the type of the
                        expression <code class="literal">s</code> is <code class="literal">S</code>. Objects of
                        class <code class="literal">T</code> contain two fields
                        named <code class="literal">x</code>, one for class <code class="literal">T</code> and one
                        for its superclass <code class="literal">S</code>.
                     </p>
                     <p class="note">This lack of dynamic lookup for field accesses
                        allows programs to be run efficiently with straightforward
                        implementations. The power of late binding and overriding is
                        available, but only when instance methods are used. Consider the same
                        example using instance methods to access the fields:
                     </p><pre class="programlisting">
class S           { int x = 0; int z() { return x; } }
class T extends S { int x = 1; int z() { return x; } }
class Test2 {
    public static void main(String[] args) {
        T t = new T();
        System.out.println("t.z()=" + t.z() + when("t", t));
        S s = new S();
        System.out.println("s.z()=" + s.z() + when("s", s));
        s = t;
        System.out.println("s.z()=" + s.z() + when("s", s));
    }
    static String when(String name, Object t) {
        return " when " + name + " holds a "
                        + t.getClass() + " at run time.";
    }
}
</pre><p class="note">Now the output is:</p><pre class="screen">
t.z()=1 when t holds a class T at run time.
s.z()=0 when s holds a class S at run time.
s.z()=1 when s holds a class T at run time.
</pre><p class="note">The last line shows that, indeed, the method that is
                        accessed <span class="emphasis"><em>does</em></span> depend on the run-time class of the
                        referenced object; when <code class="literal">s</code> holds a reference to an
                        object of class <code class="literal">T</code>, the
                        expression <code class="literal">s.z()</code> refers to the <code class="literal">z</code>
                        method of class <code class="literal">T</code>, despite the fact that the type
                        of the expression <code class="literal">s</code>
                        is <code class="literal">S</code>. Method <code class="literal">z</code> of
                        class <code class="literal">T</code> overrides method <code class="literal">z</code> of
                        class <code class="literal">S</code>.
                     </p>
                  </div>
               </div><br class="example-break"><div class="example"><a name="d5e24400"></a><p class="title"><b>Example&nbsp;15.11.1-2.&nbsp;Receiver Variable Is Irrelevant For <code class="literal">static</code> Field Access</b></p>
                  <div class="example-contents">
                     <p class="note">The following program demonstrates that a null
                        reference may be used to access a class (<code class="literal">static</code>) variable without
                        causing an exception:
                     </p><pre class="programlisting">
class Test3 {
    static String mountain = "Chocorua";
    static Test3 favorite(){
        System.out.print("Mount ");
        return null;
    }
    public static void main(String[] args) {
        System.out.println(favorite().mountain);
    }
}
</pre><p class="note">It compiles, executes, and prints:</p><pre class="screen">
Mount Chocorua
</pre><p class="note">Even though the result
                        of <code class="literal">favorite()</code> is <code class="literal">null</code>, a <code class="literal">NullPointerException</code> is not
                        thrown. That "<code class="literal">Mount </code>" is printed demonstrates that
                        the <span class="emphasis"><em>Primary</em></span> expression is indeed fully evaluated at run time,
                        despite the fact that only its type, not its value, is used to
                        determine which field to access (because the
                        field <code class="literal">mountain</code> is <code class="literal">static</code>).
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="15.11.2.&nbsp;Accessing Superclass Members using super">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.11.2"></a>15.11.2.&nbsp;Accessing Superclass Members using <code class="literal">super</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.11.2-100"></a>The form <code class="literal">super</code><code class="literal">.</code><span class="emphasis"><em>Identifier</em></span>
                  refers to the field named <span class="emphasis"><em>Identifier</em></span> of the current object, but with
                  the current object viewed as an instance of the superclass of the
                  current class.
               </p>
               <p class="norm-static"><a name="jls-15.11.2-110"></a>The form
                  <span class="type">T</span><code class="literal">.</code><code class="literal">super</code><code class="literal">.</code><span class="emphasis"><em>Identifier</em></span> refers to the field named
                  <span class="emphasis"><em>Identifier</em></span> of the lexically enclosing instance corresponding to <span class="type">T</span>,
                  but with that instance viewed as an instance of the superclass of
                  <span class="type">T</span>.
               </p>
               <p class="norm-error"><a name="jls-15.11.2-200"></a>The forms
                  using the keyword <code class="literal">super</code> are valid only in an instance method,
                  instance initializer, or constructor of a class, or in the initializer
                  of an instance variable of a class. If they appear anywhere else, a
                  compile-time error occurs.
               </p>
               <p class="note">These are exactly the same situations in which the
                  keyword <code class="literal">this</code> may be used in a class declaration
                  (<a class="xref" href="jls-15.html#jls-15.8.3" title="15.8.3.&nbsp;this">&sect;15.8.3</a>).
               </p>
               <p class="norm-error"><a name="jls-15.11.2-210"></a>It is a
                  compile-time error if the forms using the keyword <code class="literal">super</code> appear in
                  the declaration of class <code class="literal">Object</code>, since <code class="literal">Object</code> has no
                  superclass.
               </p>
               <p class="norm-error"><a name="jls-15.11.2-300"></a>Suppose that a
                  field access expression <code class="literal">super</code><code class="literal">.</code><code class="varname">f</code> appears within class <span class="type">C</span>, and
                  the immediate superclass of <span class="type">C</span> is class <span class="type">S</span>. If <code class="varname">f</code> in <span class="type">S</span> is
                  accessible from class <span class="type">C</span> (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>), then
                  <code class="literal">super</code><code class="literal">.</code><code class="varname">f</code> is treated as if it had been the expression
                  <code class="literal">this</code><code class="literal">.</code><code class="varname">f</code> in the body of class <span class="type">S</span>. Otherwise, a compile-time
                  error occurs.
               </p>
               <p class="note">Thus, <code class="literal">super</code><code class="literal">.</code><code class="varname">f</code> can access the field <code class="varname">f</code> that
                  is accessible in class <span class="type">S</span>, even if that field is hidden by a
                  declaration of a field <code class="varname">f</code> in class <span class="type">C</span>.
               </p>
               <p class="norm-error"><a name="jls-15.11.2-400"></a>Suppose that a
                  field access expression <span class="type">T</span><code class="literal">.</code><code class="literal">super</code><code class="literal">.</code><code class="varname">f</code> appears within class
                  <span class="type">C</span>, and the immediate superclass of the class denoted by <span class="type">T</span> is a
                  class whose fully qualified name is <span class="type">S</span>. If <code class="varname">f</code> in <span class="type">S</span> is accessible
                  from <span class="type">C</span>, then <span class="type">T</span><code class="literal">.</code><code class="literal">super</code><code class="literal">.</code><code class="varname">f</code> is treated as if it had been
                  the expression <code class="literal">this</code><code class="literal">.</code><code class="varname">f</code> in the body of class <span class="type">S</span>. Otherwise, a
                  compile-time error occurs.
               </p>
               <p class="note">Thus, <span class="type">T</span><code class="literal">.</code><code class="literal">super</code><code class="literal">.</code><code class="varname">f</code> can access the field
                  <code class="varname">f</code> that is accessible in class <span class="type">S</span>, even if that field is hidden by a
                  declaration of a field <code class="varname">f</code> in class <span class="type">T</span>.
               </p>
               <p class="norm-error"><a name="jls-15.11.2-410"></a>It is a
                  compile-time error if the current class is not an inner class of class
                  <span class="type">T</span> or <span class="type">T</span> itself.
               </p>
               <div class="example"><a name="d5e24502"></a><p class="title"><b>Example&nbsp;15.11.2-1.&nbsp;The <code class="literal">super</code> Expression</b></p>
                  <div class="example-contents"><pre class="programlisting">
interface I           { int x = 0; }
class T1 implements I { int x = 1; }
class T2 extends T1   { int x = 2; }
class T3 extends T2 {
    int x = 3;
    void test() {
        System.out.println("x=\t\t"          + x);
        System.out.println("super.x=\t\t"    + super.x);
        System.out.println("((T2)this).x=\t" + ((T2)this).x);
        System.out.println("((T1)this).x=\t" + ((T1)this).x);
        System.out.println("((I)this).x=\t"  + ((I)this).x);
    }
}
class Test {
    public static void main(String[] args) {
        new T3().test();
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
x=              3
super.x=        2
((T2)this).x=   2
((T1)this).x=   1
((I)this).x=    0
</pre><p class="note">Within class <code class="literal">T3</code>, the
                        expression <code class="literal">super.x</code> has the same effect
                        as <code class="literal">((T2)this).x</code> when <code class="literal">x</code> has
                        package access. Note that <code class="literal">super.x</code> is not specified
                        in terms of a cast, due to difficulties around access to <code class="literal">protected</code>
                        members of the superclass.
                     </p>
                  </div>
               </div><br class="example-break"></div>
         </div>
         <div class="section" title="15.12.&nbsp;Method Invocation Expressions">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.12"></a>15.12.&nbsp;Method Invocation Expressions
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-15.12-100"></a>A method
               invocation expression is used to invoke a class or instance
               method.
            </p>
            <div id="jls-15.12-110" class="productionset"><a name="jls-15.12-110"></a>
                 
               <div class="production"><a name="jls-MethodInvocation"></a>
                      
                  <div class="lhs">MethodInvocation:</div>
                      
                  <div class="rhs">
                           
                           <a href="jls-6.html#jls-MethodName" title="MethodName">MethodName</a> <code class="literal">(</code> [<a href="jls-15.html#jls-ArgumentList" title="ArgumentList">ArgumentList</a>] <code class="literal">)</code> <br>
                     
                           
                           <a href="jls-6.html#jls-TypeName" title="TypeName">TypeName</a> <code class="literal">.</code> [<a href="jls-4.html#jls-TypeArguments" title="TypeArguments">TypeArguments</a>] <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a>
                           <code class="literal">(</code> [<a href="jls-15.html#jls-ArgumentList" title="ArgumentList">ArgumentList</a>] <code class="literal">)</code> <br>
                     
                           
                           <a href="jls-6.html#jls-ExpressionName" title="ExpressionName">ExpressionName</a> <code class="literal">.</code> [<a href="jls-4.html#jls-TypeArguments" title="TypeArguments">TypeArguments</a>] <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a>
                           <code class="literal">(</code> [<a href="jls-15.html#jls-ArgumentList" title="ArgumentList">ArgumentList</a>] <code class="literal">)</code> <br>
                     
                           
                           <a href="jls-15.html#jls-Primary" title="Primary">Primary</a> <code class="literal">.</code> [<a href="jls-4.html#jls-TypeArguments" title="TypeArguments">TypeArguments</a>] <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a>
                           <code class="literal">(</code> [<a href="jls-15.html#jls-ArgumentList" title="ArgumentList">ArgumentList</a>] <code class="literal">)</code> <br>
                     
                           
                           <code class="literal">super</code> <code class="literal">.</code> [<a href="jls-4.html#jls-TypeArguments" title="TypeArguments">TypeArguments</a>] <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a>
                           <code class="literal">(</code> [<a href="jls-15.html#jls-ArgumentList" title="ArgumentList">ArgumentList</a>] <code class="literal">)</code> <br>
                     
                           
                           <a href="jls-6.html#jls-TypeName" title="TypeName">TypeName</a> <code class="literal">.</code> <code class="literal">super</code> <code class="literal">.</code> [<a href="jls-4.html#jls-TypeArguments" title="TypeArguments">TypeArguments</a>] <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a>
                           <code class="literal">(</code> [<a href="jls-15.html#jls-ArgumentList" title="ArgumentList">ArgumentList</a>] <code class="literal">)</code>
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-ArgumentList"></a>
                      
                  <div class="lhs">ArgumentList:</div>
                      
                  <div class="rhs">
                           <a href="jls-15.html#jls-Expression" title="Expression">Expression</a> {<code class="literal">,</code> <a href="jls-15.html#jls-Expression" title="Expression">Expression</a>}
                         
                  </div>
                    
               </div>
               
            </div>
            <p class="norm"><a name="jls-15.12-120"></a>Resolving a method name at
               compile time is more complicated than resolving a field name because
               of the possibility of method overloading. Invoking a method at run time
               is also more complicated than accessing a field because of the
               possibility of instance method overriding.
            </p>
            <p class="norm"><a name="jls-15.12-130"></a>Determining the method that
               will be invoked by a method invocation expression involves several
               steps. The following three sections describe the compile-time
               processing of a method invocation. The determination of the type of
               the method invocation expression is specified in
               <a class="xref" href="jls-15.html#jls-15.12.3" title="15.12.3.&nbsp;Compile-Time Step 3: Is the Chosen Method Appropriate?">&sect;15.12.3</a>.
            </p>
            <p class="norm-static"><a name="jls-15.12-140"></a>The
               exception types that a method invocation expression can throw are
               specified in <a class="xref" href="jls-11.html#jls-11.2.1" title="11.2.1.&nbsp;Exception Analysis of Expressions">&sect;11.2.1</a>.
            </p>
            <p class="norm-error"><a name="jls-15.12-200"></a>
               It is a compile-time error if the name to the left of the rightmost
               "<code class="literal">.</code>" that occurs before the <code class="literal">(</code> in a
               <span class="emphasis"><em>MethodInvocation</em></span> cannot be classified as a
               <span class="emphasis"><em>TypeName</em></span> or an <span class="emphasis"><em>ExpressionName</em></span> (<a class="xref" href="jls-6.html#jls-6.5.2" title="6.5.2.&nbsp;Reclassification of Contextually Ambiguous Names">&sect;6.5.2</a>).
            </p>
            <p class="norm-error"><a name="jls-15.12-210"></a>
               If <span class="emphasis"><em>TypeArguments</em></span> is present to the left of
               <span class="emphasis"><em>Identifier</em></span>, then it is a compile-time error if any of the type
               arguments are wildcards (<a class="xref" href="jls-4.html#jls-4.5.1" title="4.5.1.&nbsp;Type Arguments of Parameterized Types">&sect;4.5.1</a>).
            </p>
            <p class="norm-static"><a name="jls-15.12-300"></a>
               A method invocation expression is a poly expression if all of the
               following are true:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.12-300-A"></a>
                              The invocation appears in an assignment context or an invocation
                              context (<a class="xref" href="jls-5.html#jls-5.2" title="5.2.&nbsp;Assignment Contexts">&sect;5.2</a>,
                              <a class="xref" href="jls-5.html#jls-5.3" title="5.3.&nbsp;Invocation Contexts">&sect;5.3</a>).
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.12-300-B"></a>
                              If the invocation is qualified (that is, any form
                              of <span class="emphasis"><em>MethodInvocation</em></span> except for the first),
                              then the invocation elides <span class="emphasis"><em>TypeArguments</em></span> to
                              the left of the <span class="emphasis"><em>Identifier</em></span>.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.12-300-C"></a>
                              The method to be invoked, as determined by the following
                              subsections, is generic (<a class="xref" href="jls-8.html#jls-8.4.4" title="8.4.4.&nbsp;Generic Methods">&sect;8.4.4</a>) and has a
                              return type that mentions at least one of the method's type
                              parameters.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm-static"><a name="jls-15.12-310"></a>Otherwise, the
               method invocation expression is a standalone expression.
            </p>
            <div class="section" title="15.12.1.&nbsp;Compile-Time Step 1: Determine Class or Interface to Search">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.12.1"></a>15.12.1.&nbsp;Compile-Time Step 1: Determine Class or Interface to Search
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.12.1-100"></a>The
                  first step in processing a method invocation at compile time is to
                  figure out the name of the method to be invoked and which class or
                  interface to search for definitions of methods of that name.
               </p>
               <p class="norm-static"><a name="jls-15.12.1-110"></a>The name
                  of the method is specified by the <span class="emphasis"><em>MethodName</em></span> or <span class="emphasis"><em>Identifier</em></span> which
                  immediately precedes the left parenthesis of
                  the <span class="emphasis"><em>MethodInvocation</em></span>.
               </p>
               <p class="norm-static"><a name="jls-15.12.1-120"></a>For the
                  class or interface to search, there are six cases to consider,
                  depending on the form that precedes the left parenthesis of
                  the <span class="emphasis"><em>MethodInvocation</em></span>:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.1-120-A"></a>If
                                 the form is <span class="emphasis"><em>MethodName</em></span>, that is, just an <span class="emphasis"><em>Identifier</em></span>,
                                 then:
                        </p>
                        <p class="norm-static"><a name="jls-15.12.1-120-A.1"></a>
                                 If the <span class="emphasis"><em>Identifier</em></span> appears in the scope of a visible method
                                 declaration with that name (<a class="xref" href="jls-6.html#jls-6.3" title="6.3.&nbsp;Scope of a Declaration">&sect;6.3</a>,
                                 <a class="xref" href="jls-6.html#jls-6.4.1" title="6.4.1.&nbsp;Shadowing">&sect;6.4.1</a>), then:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.12.1-120-A.1-A"></a>If there is an enclosing type
                                              declaration of which that method is a member, let <span class="type">T</span> be the
                                              innermost such type declaration. The class or interface to
                                              search is <span class="type">T</span>.
                                 </p>
                                 <p class="note">This search policy is called the "comb
                                    	  rule". It effectively looks for methods in a nested class's
                                    	  superclass hierarchy before looking for methods in an
                                    	  enclosing class and its superclass hierarchy. See
                                    	  <a class="xref" href="jls-6.html#jls-6.5.7.1" title="6.5.7.1.&nbsp;Simple Method Names">&sect;6.5.7.1</a> for an example.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.12.1-120-A.1-B"></a>Otherwise, the visible method declaration may
                                    	  be in scope due to one or more single-static-import or
                                    	  static-import-on-demand declarations. There is no class or
                                    	  interface to search, as the method to be invoked is
                                    	  determined later (<a class="xref" href="jls-15.html#jls-15.12.2.1" title="15.12.2.1.&nbsp;Identify Potentially Applicable Methods">&sect;15.12.2.1</a>).
                                    	
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.1-120-B"></a>
                                 If the form is <span class="emphasis"><em>TypeName</em></span> <code class="literal">.</code> <span class="emphasis"><em>[TypeArguments]</em></span>
                                 <span class="emphasis"><em>Identifier</em></span>, then the type to search is the type denoted by
                                 <span class="emphasis"><em>TypeName</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.1-120-C"></a>
                                 If the form is <span class="emphasis"><em>ExpressionName</em></span> <code class="literal">.</code> <span class="emphasis"><em>[TypeArguments]</em></span>
                                 <span class="emphasis"><em>Identifier</em></span>, then the class or interface to search is the
                                 declared type <span class="type">T</span> of the variable denoted by <span class="emphasis"><em>ExpressionName</em></span> if
                                 <span class="type">T</span> is a class or interface type, or the upper bound of <span class="type">T</span> if
                                 <span class="type">T</span> is a type variable.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.1-120-D"></a>
                                 If the form is <span class="emphasis"><em>Primary</em></span> <code class="literal">.</code> <span class="emphasis"><em>[TypeArguments]</em></span> <span class="emphasis"><em>Identifier</em></span>,
                                 then let <span class="type">T</span> be the type of the <span class="emphasis"><em>Primary</em></span> expression. The class
                                 or interface to search is <span class="type">T</span> if <span class="type">T</span> is a class or interface
                                 type, or the upper bound of <span class="type">T</span> if <span class="type">T</span> is a type
                                 variable.
                        </p>
                        <p class="norm-error"><a name="jls-15.12.1-120-D.2"></a>
                                 It is a compile-time error if <span class="type">T</span> is not a reference
                                 type.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.1-120-E"></a>
                                 If the form is <code class="literal">super</code> <code class="literal">.</code> <span class="emphasis"><em>[TypeArguments]</em></span> <span class="emphasis"><em>Identifier</em></span>,
                                 then the class to search is the superclass of the class whose
                                 declaration contains the method invocation.
                        </p>
                        <p class="norm-error"><a name="jls-15.12.1-120-E.1"></a>
                                 Let <span class="type">T</span> be the type declaration immediately enclosing the method
                                 invocation. It is a compile-time error if <span class="type">T</span> is the class
                                 <code class="literal">Object</code> or <span class="type">T</span> is an interface.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.1-120-F"></a>
                                 If the form is <span class="emphasis"><em>TypeName</em></span> <code class="literal">.</code> <code class="literal">super</code> <code class="literal">.</code>
                                 <span class="emphasis"><em>[TypeArguments]</em></span> <span class="emphasis"><em>Identifier</em></span>, then:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.12.1-120-F-A"></a>
                                    	  It is a compile-time error if <span class="emphasis"><em>TypeName</em></span> denotes neither a
                                    	  class nor an interface.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.12.1-120-F-B"></a>
                                    	  If <span class="emphasis"><em>TypeName</em></span> denote a class, <span class="type">C</span>, then the class to search
                                    	  is the superclass of <span class="type">C</span>.
                                 </p>
                                 <p class="norm-error"><a name="jls-15.12.1-120-F-B.1"></a>
                                    	  It is a compile-time error if <span class="type">C</span> is not a lexically
                                    	  enclosing type declaration of the current class, or if <span class="type">C</span>
                                    	  is the class <code class="literal">Object</code>.
                                 </p>
                                 <p class="norm-error"><a name="jls-15.12.1-120-F-B.2"></a>
                                    	  Let <span class="type">T</span> be the type declaration immediately enclosing the
                                    	  method invocation. It is a compile-time error if <span class="type">T</span> is the
                                    	  class <code class="literal">Object</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.12.1-120-F-C"></a>
                                    	  Otherwise, <span class="emphasis"><em>TypeName</em></span> denotes the interface to be searched,
                                    	  <span class="type">I</span>.
                                 </p>
                                 <p class="norm-error"><a name="jls-15.12.1-120-F-C.1"></a>
                                    	  Let <span class="type">T</span> be the type declaration immediately enclosing the
                                    	  method invocation. It is a compile-time error if <span class="type">I</span> is not
                                    	  a direct superinterface of <span class="type">T</span>, or if there exists some
                                    	  other direct superclass or direct superinterface of <span class="type">T</span>,
                                    	  <span class="type">J</span>, such that <span class="type">J</span> is a subtype of <span class="type">I</span>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
               <div class="informalexample">
                  <p class="note">The <span class="emphasis"><em>TypeName</em></span> <code class="literal">.</code> <code class="literal">super</code> syntax is overloaded:
                     traditionally, the <span class="emphasis"><em>TypeName</em></span> refers to a lexically enclosing type
                     declaration which is a class, and the target is the superclass of this
                     class, as if the invocation were an unqualified <code class="literal">super</code> in the
                     lexically enclosing type declaration.
                  </p><pre class="screen">
class Superclass {
    void foo() { System.out.println("Hi"); }
}

class Subclass1 extends Superclass {
    void foo() { throw new UnsupportedOperationException(); }

    Runnable tweak = new Runnable() {
        void run() {
            Subclass1.super.foo();  // Gets the 'println' behavior
        }
    };
}
</pre><p class="note">To support invocation of default methods in
                     superinterfaces, the <span class="emphasis"><em>TypeName</em></span> may also refer to a direct
                     superinterface of the current class or interface, and the target is
                     that superinterface.
                  </p><pre class="screen">
interface Superinterface {
    default void foo() { System.out.println("Hi"); }
}

class Subclass2 implements Superinterface {
    void foo() { throw new UnsupportedOperationException(); }

    void tweak() {
        Superinterface.super.foo();  // Gets the 'println' behavior
    }
}
</pre><p class="note">No syntax supports a combination of these forms,
                     that is, invoking a superinterface method of a lexically enclosing
                     type declaration which is a class, as if the invocation were of the
                     form <span class="emphasis"><em>InterfaceName</em></span> <code class="literal">.</code> <code class="literal">super</code> in the lexically
                     enclosing type declaration.
                  </p><pre class="screen">
class Subclass3 implements Superinterface {
    void foo() { throw new UnsupportedOperationException(); }

    Runnable tweak = new Runnable() {
        void run() {
            Subclass3.Superinterface.super.foo();  // Illegal
        }
    };
}
</pre><p class="note">A workaround is to introduce a <code class="literal">private</code> method in
                     the lexically enclosing type declaration, that performs the interface
                     <code class="literal">super</code> call.
                  </p>
               </div>
            </div>
            <div class="section" title="15.12.2.&nbsp;Compile-Time Step 2: Determine Method Signature">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.12.2"></a>15.12.2.&nbsp;Compile-Time Step 2: Determine
                           Method Signature
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-15.12.2-100"></a>The second step searches the type
                  determined in the previous step for member methods. This step uses the
                  name of the method and  the argument expressions to
                  locate methods that are both <span class="emphasis"><em>accessible</em></span>
                  and <span class="emphasis"><em>applicable</em></span>, that is, declarations that can be
                  correctly invoked on the given arguments.
               </p>
               <p class="norm"><a name="jls-15.12.2-110"></a>There may be more than one
                  such method, in which case the <span class="emphasis"><em>most specific</em></span> one
                  is chosen. The descriptor (signature plus return type) of the most
                  specific method is the one used at run time to perform the method
                  dispatch.
               </p>
               <p class="norm"><a name="jls-15.12.2-120"></a>A method
                  is <span class="emphasis"><em>applicable</em></span> if it is applicable by one of
                  strict invocation (<a class="xref" href="jls-15.html#jls-15.12.2.2" title="15.12.2.2.&nbsp;Phase 1: Identify Matching Arity Methods Applicable by Strict Invocation">&sect;15.12.2.2</a>), loose invocation
                  (<a class="xref" href="jls-15.html#jls-15.12.2.3" title="15.12.2.3.&nbsp;Phase 2: Identify Matching Arity Methods Applicable by Loose Invocation">&sect;15.12.2.3</a>), or variable arity invocation
                  (<a class="xref" href="jls-15.html#jls-15.12.2.4" title="15.12.2.4.&nbsp;Phase 3: Identify Methods Applicable by Variable Arity Invocation">&sect;15.12.2.4</a>).
               </p>
               <p class="norm"><a name="jls-15.12.2-130"></a>Certain argument expressions that
                  contain implicitly typed lambda expressions
                  (<a class="xref" href="jls-15.html#jls-15.27.1" title="15.27.1.&nbsp;Lambda Parameters">&sect;15.27.1</a>) or inexact method references
                  (<a class="xref" href="jls-15.html#jls-15.13.1" title="15.13.1.&nbsp;Compile-Time Declaration of a Method Reference">&sect;15.13.1</a>) are ignored by the applicability
                  tests, because their meaning cannot be determined until a target type
                  is selected.
               </p>
               <p class="norm"><a name="jls-15.12.2-140"></a>Although the method invocation may be a
                  poly expression, only its argument expressions
                  - <span class="emphasis"><em>not</em></span> the invocation's target type - influence
                  the selection of applicable methods.
               </p>
               <p class="norm"><a name="jls-15.12.2-200"></a>The process of determining
                  applicability begins by determining the potentially applicable methods
                  (<a class="xref" href="jls-15.html#jls-15.12.2.1" title="15.12.2.1.&nbsp;Identify Potentially Applicable Methods">&sect;15.12.2.1</a>).
               </p>
               <p class="norm"><a name="jls-15.12.2-210"></a>The remainder of the
                  process is split into three phases, to ensure compatibility with
                  versions of the Java programming language prior to Java SE 5.0. The phases
                  are:
               </p>
               <div class="orderedlist">
                  <ol class="orderedlist" type="1">
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.12.2-210-A"></a>
                                 The first phase (<a class="xref" href="jls-15.html#jls-15.12.2.2" title="15.12.2.2.&nbsp;Phase 1: Identify Matching Arity Methods Applicable by Strict Invocation">&sect;15.12.2.2</a>) performs
                                 overload resolution without permitting boxing or unboxing
                                 conversion, or the use of variable arity method invocation. If
                                 no applicable method is found during this phase then processing
                                 continues to the second phase.
                        </p>
                        <p class="note">
                                 This guarantees that any calls that were valid in the Java programming language
                                 before Java SE 5.0 are not considered ambiguous as the result of
                                 the introduction of variable arity methods, implicit boxing
                                 and/or unboxing. However, the declaration of a variable arity
                                 method (<a class="xref" href="jls-8.html#jls-8.4.1" title="8.4.1.&nbsp;Formal Parameters">&sect;8.4.1</a>) can change the method
                                 chosen for a given method method invocation expression, because
                                 a variable arity method is treated as a fixed arity method in
                                 the first phase. For example,
                                 declaring <code class="literal">m(Object...)</code> in a class which
                                 already declares <code class="literal">m(Object)</code>
                                 causes <code class="literal">m(Object)</code> to no longer be chosen for
                                 some invocation expressions (such
                                 as <code class="literal">m(null)</code>),
                                 as <code class="literal">m(Object[])</code> is more specific.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.12.2-210-B"></a>
                                 The second phase (<a class="xref" href="jls-15.html#jls-15.12.2.3" title="15.12.2.3.&nbsp;Phase 2: Identify Matching Arity Methods Applicable by Loose Invocation">&sect;15.12.2.3</a>) performs
                                 overload resolution while allowing boxing and unboxing, but
                                 still precludes the use of variable arity method invocation. If
                                 no applicable method is found during this phase then processing
                                 continues to the third phase.
                        </p>
                        <p class="note">
                                 This ensures that a method is never chosen through variable
                                 arity method invocation if it is applicable through fixed arity
                                 method invocation.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-15.12.2-210-C"></a>
                                 The third phase (<a class="xref" href="jls-15.html#jls-15.12.2.4" title="15.12.2.4.&nbsp;Phase 3: Identify Methods Applicable by Variable Arity Invocation">&sect;15.12.2.4</a>) allows
                                 overloading to be combined with variable arity methods, boxing,
                                 and unboxing.
                        </p>
                     </li>
                  </ol>
               </div>
               <p class="norm"><a name="jls-15.12.2-220"></a>Deciding whether a method is applicable
                  will, in the case of generic methods (<a class="xref" href="jls-8.html#jls-8.4.4" title="8.4.4.&nbsp;Generic Methods">&sect;8.4.4</a>),
                  require an analysis of the type arguments. Type arguments may be
                  passed explicitly or implicitly. If they are passed implicitly, bounds
                  of the type arguments must be inferred (<a class="xref" href="jls-18.html" title="Chapter&nbsp;18.&nbsp;Type Inference">&sect;18 (<i>Type Inference</i>)</a>)
                  from  the argument expressions.
               </p>
               <p class="norm"><a name="jls-15.12.2-230"></a>If several applicable
                  methods have been identified during one of the three phases of
                  applicability testing, then the most specific one is chosen, as
                  specified in section <a class="xref" href="jls-15.html#jls-15.12.2.5" title="15.12.2.5.&nbsp;Choosing the Most Specific Method">&sect;15.12.2.5</a>.
               </p>
               <p class="note">To check for applicability, the types of an
                  invocation's arguments cannot, in general, be inputs to the analysis.
                  This is because:
               </p>
               <div class="note">
                  <ul class="note" type="disc">
                     <li class="listitem">
                        <p class="note">The arguments to a method invocation may be
                                 poly expressions
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="note">Poly expressions cannot be typed in the
                                 absence of a target type
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="note">Overload resolution has to be completed before
                                 the arguments' target types will be known
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="note">Instead, the input to the applicability check is a
                  list of argument expressions, which <span class="emphasis"><em>can</em></span> be
                  checked for compatibility with potential target types, even if the
                  ultimate types of the expressions are unknown.
               </p>
               <p class="note">Note that overload resolution is independent of a
                  target type. This is for two reasons:
               </p>
               <div class="note">
                  <ul class="note" type="disc">
                     <li class="listitem">
                        <p class="note">First, it makes the user model more accessible
                                 and less error-prone. The meaning of a method name (i.e., the
                                 declaration corresponding to the name) is too fundamental to the
                                 meaning of a program to depend on subtle contextual hints. (In
                                 contrast, other poly expressions may have different behavior
                                 depending on a target type; but the variation in behavior is
                                 always limited and essentially equivalent, while no such
                                 guarantees can be made about the behavior of an arbitrary set of
                                 methods that share a name and arity.)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="note">Second, it allows other properties - such as
                                 whether or not the method is a poly expression
                                 (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>) or how to categorize a conditional
                                 expression (<a class="xref" href="jls-15.html#jls-15.25" title="15.25.&nbsp;Conditional Operator ? :">&sect;15.25</a>) - to depend on the
                                 meaning of the method name, even before a target type is
                                 known.
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="example"><a name="d5e24788"></a><p class="title"><b>Example&nbsp;15.12.2-1.&nbsp;Method Applicability</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Doubler {
            static int two()      { return two(1); }
    private static int two(int i) { return 2*i;    }
}
class Test extends Doubler {	
    static long two(long j) { return j+j; }

    public static void main(String[] args) {
        System.out.println(two(3));
        System.out.println(Doubler.two(3)); // compile-time error
    }
}
</pre><p class="note">For the method invocation <code class="literal">two(1)</code>
                        within class <code class="literal">Doubler</code>, there are two accessible
                        methods named <code class="literal">two</code>, but only the second one is
                        applicable, and so that is the one invoked at run time.
                     </p>
                     <p class="note">For the method invocation <code class="literal">two(3)</code>
                        within class <code class="literal">Test</code>, there are two applicable
                        methods, but only the one in class <code class="literal">Test</code> is
                        accessible, and so that is the one to be invoked at run time (the
                        argument <code class="literal">3</code> is converted to
                        type <code class="literal">long</code>).
                     </p>
                     <p class="note">For the method
                        invocation <code class="literal">Doubler.two(3)</code>, the
                        class <code class="literal">Doubler</code>, not class <code class="literal">Test</code>,
                        is searched for methods named <code class="literal">two</code>; the only
                        applicable method is not accessible, and so this method invocation
                        causes a compile-time error.
                     </p>
                     <p class="note">Another example is:</p><pre class="programlisting">
class ColoredPoint {
    int x, y;
    byte color;
    void setColor(byte color) { this.color = color; }
}
class Test {
    public static void main(String[] args) {
        ColoredPoint cp = new ColoredPoint();
        byte color = 37;
        cp.setColor(color);
        cp.setColor(37);  // compile-time error
    }
}
</pre><p class="note">Here, a compile-time error occurs for the second
                        invocation of <code class="literal">setColor</code>, because no applicable
                        method can be found at compile time. The type of the
                        literal <code class="literal">37</code> is <code class="literal">int</code>, and <code class="literal">int</code> cannot be converted
                        to <code class="literal">byte</code> by invocation conversion. Assignment conversion, which is
                        used in the initialization of the variable <code class="literal">color</code>,
                        performs an implicit conversion of the constant from type <code class="literal">int</code> to
                        <code class="literal">byte</code>, which is permitted because the value <code class="literal">37</code> is
                        small enough to be represented in type <code class="literal">byte</code>; but such a conversion
                        is not allowed for invocation conversion.
                     </p>
                     <p class="note">If the method <code class="literal">setColor</code> had,
                        however, been declared to take an <code class="literal">int</code> instead of a <code class="literal">byte</code>, then both
                        method invocations would be correct; the first invocation would be
                        allowed because invocation conversion does permit a widening
                        conversion from <code class="literal">byte</code> to <code class="literal">int</code>. However, a narrowing cast would then
                        be required in the body of <code class="literal">setColor</code>:
                     </p><pre class="screen">
void setColor(int color) { this.color = (byte)color; }
</pre><p class="note">Here is an example of overloading
                        ambiguity. Consider the program:
                     </p><pre class="programlisting">
class Point { int x, y; }
class ColoredPoint extends Point { int color; }
class Test {
    static void test(ColoredPoint p, Point q) {
        System.out.println("(ColoredPoint, Point)");
    }
    static void test(Point p, ColoredPoint q) {
        System.out.println("(Point, ColoredPoint)");
    }
    public static void main(String[] args) {
        ColoredPoint cp = new ColoredPoint();
        test(cp, cp);  // compile-time error
    }
}
</pre><p class="note">This example produces an error at compile time. The
                        problem is that there are two declarations of <code class="literal">test</code>
                        that are applicable and accessible, and neither is more specific than
                        the other. Therefore, the method invocation is ambiguous.
                     </p>
                     <p class="note">If a third definition of <code class="literal">test</code>
                        were added:
                     </p><pre class="screen">
static void test(ColoredPoint p, ColoredPoint q) {
    System.out.println("(ColoredPoint, ColoredPoint)");
}
</pre><p class="note">then it would be more specific than the other two,
                        and the method invocation would no longer be ambiguous.
                     </p>
                  </div>
               </div><br class="example-break"><div class="example"><a name="d5e24835"></a><p class="title"><b>Example&nbsp;15.12.2-2.&nbsp;Return Type Not Considered During Method Selection</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Point { int x, y; }
class ColoredPoint extends Point { int color; }
class Test {
    static int test(ColoredPoint p) {
        return p.color;
    }
    static String test(Point p) {
        return "Point";
    }
    public static void main(String[] args) {
        ColoredPoint cp = new ColoredPoint();
        String s = test(cp);  // compile-time error
    }
}
</pre><p class="note">Here, the most specific declaration of
                        method <code class="literal">test</code> is the one taking a parameter of
                        type <code class="literal">ColoredPoint</code>. Because the result type of the
                        method is <code class="literal">int</code>, a compile-time error occurs because an <code class="literal">int</code> cannot
                        be converted to a <code class="literal">String</code> by assignment conversion. This example
                        shows that the result types of methods do not participate in resolving
                        overloaded methods, so that the second <code class="literal">test</code> method,
                        which returns a <code class="literal">String</code>, is not chosen, even though it has a result
                        type that would allow the example program to compile without
                        error.
                     </p>
                  </div>
               </div><br class="example-break"><div class="example"><a name="d5e24846"></a><p class="title"><b>Example&nbsp;15.12.2-3.&nbsp;Choosing The Most Specific Method</b></p>
                  <div class="example-contents">
                     <p class="note">The most specific method is chosen at compile time;
                        its descriptor determines what method is actually executed at run
                        time. If a new method is added to a class, then source code that was
                        compiled with the old definition of the class might not use the new
                        method, even if a recompilation would cause this method to be
                        chosen.
                     </p>
                     <p class="note">So, for example, consider two compilation units, one
                        for class <code class="literal">Point</code>:
                     </p><pre class="programlisting">
package points;
public class Point {
    public int x, y;
    public Point(int x, int y) { this.x = x; this.y = y; }
    public String toString() { return toString(""); }
    public String toString(String s) {
        return "(" + x + "," + y + s + ")";
    }
}
</pre><p class="note">and one for
                        class <code class="literal">ColoredPoint</code>:
                     </p><pre class="programlisting">
package points;
public class ColoredPoint extends Point {
    public static final int
        RED = 0, GREEN = 1, BLUE = 2;
    public static String[] COLORS =
        { "red", "green", "blue" };

    public byte color;
    public ColoredPoint(int x, int y, int color) {
        super(x, y);
        this.color = (byte)color;
    }

    /** Copy all relevant fields of the argument into
        this ColoredPoint object. */
    public void adopt(Point p) { x = p.x; y = p.y; }

    public String toString() {
        String s = "," + COLORS[color];
        return super.toString(s);
    }
}
</pre><p class="note">Now consider a third compilation unit that
                        uses <code class="literal">ColoredPoint</code>:
                     </p><pre class="programlisting">
import points.*;
class Test {
    public static void main(String[] args) {
        ColoredPoint cp =
            new ColoredPoint(6, 6, ColoredPoint.RED);
        ColoredPoint cp2 =
            new ColoredPoint(3, 3, ColoredPoint.GREEN);
        cp.adopt(cp2);
        System.out.println("cp: " + cp);
    }
}
</pre><p class="note">The output is:</p><pre class="screen">
cp: (3,3,red)
</pre><p class="note">The programmer who coded
                        class <code class="literal">Test</code> has expected to see the
                        word <code class="literal">green</code>, because the actual argument,
                        a <code class="literal">ColoredPoint</code>, has a <code class="literal">color</code>
                        field, and <code class="literal">color</code> would seem to be a "relevant
                        field". (Of course, the documentation for the
                        package <code class="literal">points</code> ought to have been much more
                        precise!)
                     </p>
                     <p class="note">Notice, by the way, that the most specific method
                        (indeed, the only applicable method) for the method invocation
                        of <code class="literal">adopt</code> has a signature that indicates a method of
                        one parameter, and the parameter is of
                        type <code class="literal">Point</code>. This signature becomes part of the
                        binary representation of class <code class="literal">Test</code> produced by the
                        Java compiler and is used by the method invocation at run time.
                     </p>
                     <p class="note">Suppose the programmer reported this software error
                        and the maintainer of the <code class="literal">points</code> package decided,
                        after due deliberation, to correct it by adding a method to
                        class <code class="literal">ColoredPoint</code>:
                     </p><pre class="programlisting">

public void adopt(ColoredPoint p) {
    adopt((Point)p);
    color = p.color;
}

</pre><p class="note">If the programmer then runs the old binary file
                        for <code class="literal">Test</code> with the new binary file
                        for <code class="literal">ColoredPoint</code>, the output is still:
                     </p><pre class="screen">
cp: (3,3,red)
</pre><p class="note">because the old binary file
                        for <code class="literal">Test</code> still has the descriptor "one parameter,
                        whose type is <code class="literal">Point</code>; <code class="literal">void</code>" associated with the
                        method call <code class="literal">cp.adopt(cp2)</code>. If the source code
                        for <code class="literal">Test</code> is recompiled, the Java compiler will then
                        discover that there are now two applicable <code class="literal">adopt</code>
                        methods, and that the signature for the more specific one is "one
                        parameter, whose type is <code class="literal">ColoredPoint</code>; <code class="literal">void</code>";
                        running the program will then produce the desired output:
                     </p><pre class="screen">
cp: (3,3,green)
</pre><p class="note">With forethought about such problems, the maintainer
                        of the <code class="literal">points</code> package could fix
                        the <code class="literal">ColoredPoint</code> class to work with both newly
                        compiled and old code, by adding defensive code to the
                        old <code class="literal">adopt</code> method for the sake of old code that
                        still invokes it on <code class="literal">ColoredPoint</code> arguments:
                     </p><pre class="programlisting">

public void adopt(Point p) {
    if (p instanceof ColoredPoint)
        color = ((ColoredPoint)p).color;
    x = p.x; y = p.y;
}

</pre><p class="note">Ideally, source code should be recompiled whenever
                        code that it depends on is changed. However, in an environment where
                        different classes are maintained by different organizations, this is
                        not always feasible. Defensive programming with careful attention to
                        the problems of class evolution can make upgraded code much more
                        robust. See <a class="xref" href="jls-13.html" title="Chapter&nbsp;13.&nbsp;Binary Compatibility">&sect;13 (<i>Binary Compatibility</i>)</a> for a detailed discussion of
                        binary compatibility and type evolution.
                     </p>
                  </div>
               </div><br class="example-break"><div class="section" title="15.12.2.1.&nbsp;Identify Potentially Applicable Methods">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-15.12.2.1"></a>15.12.2.1.&nbsp;Identify Potentially Applicable Methods
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-static"><a name="jls-15.12.2.1-100"></a>The
                     class or interface determined by compile-time step 1
                     (<a class="xref" href="jls-15.html#jls-15.12.1" title="15.12.1.&nbsp;Compile-Time Step 1: Determine Class or Interface to Search">&sect;15.12.1</a>) is searched for all member methods
                     that are potentially applicable to this method invocation; members
                     inherited from superclasses and superinterfaces are included in this
                     search.
                  </p>
                  <p class="norm-static"><a name="jls-15.12.2.1-110"></a>In
                     addition, if the form of the method invocation expression is
                     <span class="emphasis"><em>MethodName</em></span> - that is, a single <span class="emphasis"><em>Identifier</em></span> - then the search for
                     potentially applicable methods also examines all member methods that
                     are imported by single-static-import declarations and
                     static-import-on-demand declarations of the compilation unit where the
                     method invocation occurs (<a class="xref" href="jls-7.html#jls-7.5.3" title="7.5.3.&nbsp;Single-Static-Import Declarations">&sect;7.5.3</a>,
                     <a class="xref" href="jls-7.html#jls-7.5.4" title="7.5.4.&nbsp;Static-Import-on-Demand Declarations">&sect;7.5.4</a>) and that are not shadowed at the point
                     where the method invocation appears.
                  </p>
                  <p class="norm-static"><a name="jls-15.12.2.1-200"></a>A
                     member method is <span class="emphasis"><em>potentially applicable</em></span> to a
                     method invocation if and only if all of the following are true:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.1-200-A"></a>
                                    The name of the member is identical to the name of the method in
                                    the method invocation.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.1-200-B"></a>
                                    The member is accessible (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>) to the
                                    class or interface in which the method invocation
                                    appears.
                           </p>
                           <p class="note">Whether a member method is accessible at a
                                    method invocation depends on the access modifier (<code class="literal">public</code>,
                                    <code class="literal">protected</code>, no modifier (package access), or <code class="literal">private</code>) in the
                                    member's declaration and on where the method invocation
                                    appears.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.1-200-C"></a>
                                    If the member is a fixed arity method with arity <span class="emphasis"><em>n</em></span>, the
                                    arity of the method invocation is equal to <span class="emphasis"><em>n</em></span>, and for all
                                    <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), the <span class="emphasis"><em>i</em></span>'th argument of
                                    the method invocation is <span class="emphasis"><em>potentially
                                          compatible</em></span>, as defined below, with the type of the
                                    <span class="emphasis"><em>i</em></span>'th parameter of the method.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.1-200-D"></a>
                                    If the member is a variable arity method with arity <span class="emphasis"><em>n</em></span>, then
                                    for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>-1), the <span class="emphasis"><em>i</em></span>'th
                                    argument of the method invocation is <span class="emphasis"><em>potentially
                                          compatible</em></span> with the type of the <span class="emphasis"><em>i</em></span>'th parameter
                                    of the method; and, where the <span class="emphasis"><em>n</em></span>th parameter of the method
                                    has type <span class="type">T</span><code class="literal">[]</code>, one of the following is true:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.1-200-D-A"></a>
                                       	  The arity of the method invocation is equal to <span class="emphasis"><em>n</em></span>-1.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.1-200-D-B"></a>
                                       	  The arity of the method invocation is equal to <span class="emphasis"><em>n</em></span>, and
                                                 the <span class="emphasis"><em>n</em></span>th argument of the method invocation is
                                                 potentially compatible with either <span class="type">T</span> or
                                                 <span class="type">T</span><code class="literal">[]</code>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.1-200-D-C"></a>
                                       	  The arity of the method invocation is <span class="emphasis"><em>m</em></span>, where <span class="emphasis"><em>m</em></span>
                                       	  &gt; <span class="emphasis"><em>n</em></span>, and for all <span class="emphasis"><em>i</em></span> (<span class="emphasis"><em>n</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span>
                                       	  <span class="emphasis"><em>m</em></span>), the <span class="emphasis"><em>i</em></span>'th argument of the method invocation is
                                       	  potentially compatible with <span class="type">T</span>.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.1-200-E"></a>
                                    If the method invocation includes explicit type arguments, and
                                    the member is a generic method, then the number of type
                                    arguments is equal to the number of type parameters of the
                                    method.
                           </p>
                           <p class="note">This clause implies that a non-generic method
                                    may be potentially applicable to an invocation that supplies
                                    explicit type arguments. Indeed, it may turn out to be
                                    applicable. In such a case, the type arguments will simply be
                                    ignored.
                           </p>
                           <p class="note">This rule stems from issues of compatibility and
                                    principles of substitutability. Since interfaces or superclasses
                                    may be generified independently of their subtypes, we may
                                    override a generic method with a non-generic one. However, the
                                    overriding (non-generic) method must be applicable to calls to
                                    the generic method, including calls that explicitly pass type
                                    arguments. Otherwise the subtype would not be substitutable for
                                    its generified supertype.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm-error"><a name="jls-15.12.2.1-210"></a>If the
                     search does not yield at least one method that is potentially
                     applicable, then a compile-time error occurs.
                  </p>
                  <p class="norm-static"><a name="jls-15.12.2.1-300"></a>An expression
                     is <span class="emphasis"><em>potentially compatible</em></span> with a target type
                     according to the following rules:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.1-300-A"></a>
                                    A lambda expression (<a class="xref" href="jls-15.html#jls-15.27" title="15.27.&nbsp;Lambda Expressions">&sect;15.27</a>) is potentially
                                    compatible with a functional interface type
                                    (<a class="xref" href="jls-9.html#jls-9.8" title="9.8.&nbsp;Functional Interfaces">&sect;9.8</a>) if all of the following are
                                    true:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.1-300-A-A"></a>
                                       	  The arity of the target type's function type is the same as
                                                 the arity of the lambda expression.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.1-300-A-B"></a>
                                       	  If the target type's function type has a <code class="literal">void</code> return, then
                                                 the lambda body is either a statement expression
                                                 (<a class="xref" href="jls-14.html#jls-14.8" title="14.8.&nbsp;Expression Statements">&sect;14.8</a>) or a void-compatible block
                                                 (<a class="xref" href="jls-15.html#jls-15.27.2" title="15.27.2.&nbsp;Lambda Body">&sect;15.27.2</a>).
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.1-300-A-C"></a>
                                       	  If the target type's function type has a (non-<code class="literal">void</code>) return
                                                 type, then the lambda body is either an expression or a
                                                 value-compatible block (<a class="xref" href="jls-15.html#jls-15.27.2" title="15.27.2.&nbsp;Lambda Body">&sect;15.27.2</a>).
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.1-310-B"></a>
                                    A method reference expression (<a class="xref" href="jls-15.html#jls-15.13" title="15.13.&nbsp;Method Reference Expressions">&sect;15.13</a>) is
                                    potentially compatible with a functional interface type if,
                                    where the type's function type arity is <span class="emphasis"><em>n</em></span>, there exists at
                                    least one potentially applicable method for the method reference
                                    expression with arity <span class="emphasis"><em>n</em></span> (<a class="xref" href="jls-15.html#jls-15.13.1" title="15.13.1.&nbsp;Compile-Time Declaration of a Method Reference">&sect;15.13.1</a>),
                                    and one of the following is true:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.1-310-B-A"></a>
                                       	  The method reference expression has the form <span class="emphasis"><em>ReferenceType</em></span>
                                                 <code class="literal">::</code> <span class="emphasis"><em>[TypeArguments]</em></span> <span class="emphasis"><em>Identifier</em></span> and at least
                                                 one potentially applicable method is i) <code class="literal">static</code> and
                                                 supports arity <span class="emphasis"><em>n</em></span>, or ii) not <code class="literal">static</code> and supports
                                                 arity <span class="emphasis"><em>n</em></span>-1.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.1-310-B-B"></a>
                                       	  The method reference expression has some other form and at
                                                 least one potentially applicable method is not <code class="literal">static</code>.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.1-310-C"></a>
                                    A lambda expression or a method reference expression is
                                    potentially compatible with a type variable if the type variable
                                    is a type parameter of the candidate method.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.1-310-D"></a>
                                    A parenthesized expression (<a class="xref" href="jls-15.html#jls-15.8.5" title="15.8.5.&nbsp;Parenthesized Expressions">&sect;15.8.5</a>) is
                                    potentially compatible with a type if its contained expression
                                    is potentially compatible with that type.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.1-310-E"></a>
                                    A conditional expression (<a class="xref" href="jls-15.html#jls-15.25" title="15.25.&nbsp;Conditional Operator ? :">&sect;15.25</a>) is
                                    potentially compatible with a type if each of its second and
                                    third operand expressions are potentially compatible with that
                                    type.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.1-310-F"></a>
                                    A class instance creation expression, a method invocation
                                    expression, or an expression of a standalone form
                                    (<a class="xref" href="jls-15.html#jls-15.2" title="15.2.&nbsp;Forms of Expressions">&sect;15.2</a>) is potentially compatible with any
                                    type.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="note">The definition of potential applicability goes
                     beyond a basic arity check to also take into account the presence and
                     "shape" of functional interface target types. In some cases involving
                     type argument inference, a lambda expression appearing as a method
                     invocation argument cannot be properly typed until after overload
                     resolution. These rules allow the form of the lambda expression to
                     still be taken into account, discarding obviously incorrect target
                     types that might otherwise cause ambiguity errors.
                  </p>
               </div>
               <div class="section" title="15.12.2.2.&nbsp;Phase 1: Identify Matching Arity Methods Applicable by Strict Invocation">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-15.12.2.2"></a>15.12.2.2.&nbsp;Phase 1: Identify Matching Arity
                              Methods Applicable by Strict Invocation
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-static"><a name="jls-15.12.2.2-100"></a>An
                     argument expression is considered <span class="emphasis"><em>pertinent to
                           applicability</em></span> for a potentially applicable method <code class="varname">m</code>
                     unless it has one of the following forms:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.2-100-A"></a>
                                    An implicitly typed lambda expression
                                    (<a class="xref" href="jls-15.html#jls-15.27.1" title="15.27.1.&nbsp;Lambda Parameters">&sect;15.27.1</a>).
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.2-100-B"></a>
                                    An inexact method reference expression
                                    (<a class="xref" href="jls-15.html#jls-15.13.1" title="15.13.1.&nbsp;Compile-Time Declaration of a Method Reference">&sect;15.13.1</a>).
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.2-100-C"></a>
                                    If <code class="varname">m</code> is a generic method and the method invocation does not
                                    provide explicit type arguments, an explicitly typed lambda
                                    expression or an exact method reference expression for which the
                                    corresponding target type (as derived from the signature of <code class="varname">m</code>)
                                    is a type parameter of <code class="varname">m</code>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.2-100-D"></a>
                                    An explicitly typed lambda expression whose body is an
                                    expression that is not pertinent to applicability.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.2-100-E"></a>
                                    An explicitly typed lambda expression whose body is a block,
                                    where at least one result expression is not pertinent to
                                    applicability.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.2-100-F"></a>
                                    A parenthesized expression (<a class="xref" href="jls-15.html#jls-15.8.5" title="15.8.5.&nbsp;Parenthesized Expressions">&sect;15.8.5</a>) whose
                                    contained expression is not pertinent to applicability.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.2-100-G"></a>
                                    A conditional expression (<a class="xref" href="jls-15.html#jls-15.25" title="15.25.&nbsp;Conditional Operator ? :">&sect;15.25</a>) whose
                                    second or third operand is not pertinent to applicability.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm-static"><a name="jls-15.12.2.2-200"></a>Let
                     <code class="varname">m</code> be a potentially applicable method
                     (<a class="xref" href="jls-15.html#jls-15.12.2.1" title="15.12.2.1.&nbsp;Identify Potentially Applicable Methods">&sect;15.12.2.1</a>) with arity <span class="emphasis"><em>n</em></span> and formal
                     parameter types <span class="type">F<sub>1</sub></span> ... <span class="type">F<sub>n</sub></span>, and let <code class="varname">e<sub>1</sub></code>, ..., <code class="varname">e<sub>n</sub></code> be the actual
                     argument expressions of the method invocation. Then:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.2-200-A"></a>
                                    If <code class="varname">m</code> is a generic method and the method invocation does not
                                    provide explicit type arguments, then the applicability of the
                                    method is inferred as specified in <a class="xref" href="jls-18.html#jls-18.5.1" title="18.5.1.&nbsp;Invocation Applicability Inference">&sect;18.5.1</a>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.2-200-B"></a>
                                    If <code class="varname">m</code> is a generic method and the method invocation provides
                                    explicit type arguments, then let <span class="type">R<sub>1</sub></span> ... <span class="type">R<sub>p</sub></span> (<span class="emphasis"><em>p</em></span> <span class="symbol">&#8805;</span> 1)
                                    be the type parameters of <code class="varname">m</code>, let <span class="type">B<sub>l</sub></span> be the declared bound of
                                    <span class="type">R<sub>l</sub></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>l</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>p</em></span>), and let <span class="type">U<sub>1</sub></span>, ..., <span class="type">U<sub>p</sub></span> be
                                    the explicit type arguments given in the method invocation. Then
                                    <code class="varname">m</code> is <span class="emphasis"><em>applicable by strict invocation</em></span> if
                                    both of the following are true:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.2-200-B-A"></a>
                                       	  For 1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>, if <code class="varname">e<sub>i</sub></code> is pertinent to
                                                 applicability then <code class="varname">e<sub>i</sub></code> is compatible in a strict invocation
                                                 context with <span class="type">F<sub>i</sub></span><code class="literal">[</code><span class="type">R<sub>1</sub></span>:=<span class="type">U<sub>1</sub></span>, ...,
                                                 <span class="type">R<sub>p</sub></span>:=<span class="type">U<sub>p</sub></span><code class="literal">]</code>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.2-200-B-B"></a>
                                       	  For 1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>l</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>p</em></span>, <span class="type">U<sub>l</sub></span> <code class="literal">&lt;:</code>
                                                 <span class="type">B<sub>l</sub></span><code class="literal">[</code><span class="type">R<sub>1</sub></span>:=<span class="type">U<sub>1</sub></span>, ..., <span class="type">R<sub>p</sub></span>:=<span class="type">U<sub>p</sub></span><code class="literal">]</code>.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.2-200-C"></a>
                                    If <code class="varname">m</code> is not a generic method, then <code class="varname">m</code> is <span class="emphasis"><em>applicable
                                          by strict invocation</em></span> if, for 1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span>
                                    <span class="emphasis"><em>n</em></span>, either <code class="varname">e<sub>i</sub></code> is compatible in a strict invocation context
                                    with <span class="type">F<sub>i</sub></span> or <code class="varname">e<sub>i</sub></code> is not pertinent to applicability.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm-static"><a name="jls-15.12.2.2-210"></a>If no
                     method applicable by strict invocation is found, the search for
                     applicable methods continues with phase 2 (<a class="xref" href="jls-15.html#jls-15.12.2.3" title="15.12.2.3.&nbsp;Phase 2: Identify Matching Arity Methods Applicable by Loose Invocation">&sect;15.12.2.3</a>).
                  </p>
                  <p class="norm-static"><a name="jls-15.12.2.2-220"></a>
                     Otherwise, the most specific method (<a class="xref" href="jls-15.html#jls-15.12.2.5" title="15.12.2.5.&nbsp;Choosing the Most Specific Method">&sect;15.12.2.5</a>)
                     is chosen among the methods that are applicable by strict
                     invocation.
                  </p>
                  <p class="note">The meaning of an implicitly typed lambda expression
                     or an inexact method reference expression is sufficiently vague prior
                     to resolving a target type that arguments containing these expressions
                     are not considered <span class="emphasis"><em>pertinent to applicability</em></span>;
                     they are simply ignored (except for their expected arity) until
                     overload resolution is finished.
                  </p>
               </div>
               <div class="section" title="15.12.2.3.&nbsp;Phase 2: Identify Matching Arity Methods Applicable by Loose Invocation">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-15.12.2.3"></a>15.12.2.3.&nbsp;Phase 2: Identify Matching Arity
                              Methods Applicable by Loose Invocation
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-static"><a name="jls-15.12.2.3-100"></a>Let
                     <code class="varname">m</code> be a potentially applicable method
                     (<a class="xref" href="jls-15.html#jls-15.12.2.1" title="15.12.2.1.&nbsp;Identify Potentially Applicable Methods">&sect;15.12.2.1</a>) with arity <span class="emphasis"><em>n</em></span> and formal
                     parameter types <span class="type">F<sub>1</sub></span>, ..., <span class="type">F<sub>n</sub></span>, and let <code class="varname">e<sub>1</sub></code>, ..., <code class="varname">e<sub>n</sub></code> be the actual
                     argument expressions of the method invocation. Then:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.3-100-A"></a>
                                    If <code class="varname">m</code> is a generic method and the method invocation does not
                                    provide explicit type arguments, then the applicability of the
                                    method is inferred as specified in <a class="xref" href="jls-18.html#jls-18.5.1" title="18.5.1.&nbsp;Invocation Applicability Inference">&sect;18.5.1</a>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.3-100-B"></a>
                                    If <code class="varname">m</code> is a generic method and the method invocation provides
                                    explicit type arguments, then let <span class="type">R<sub>1</sub></span> ... <span class="type">R<sub>p</sub></span> (<span class="emphasis"><em>p</em></span> <span class="symbol">&#8805;</span> 1)
                                    be the type parameters of <code class="varname">m</code>, let <span class="type">B<sub>l</sub></span> be the declared bound of
                                    <span class="type">R<sub>l</sub></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>l</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>p</em></span>), and let <span class="type">U<sub>1</sub></span> ... <span class="type">U<sub>p</sub></span> be the
                                    explicit type arguments given in the method invocation. Then <code class="varname">m</code>
                                    is <span class="emphasis"><em>applicable by loose invocation</em></span> if both
                                    of the following are true:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.3-100-B-A"></a>
                                       	  For 1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>, if <code class="varname">e<sub>i</sub></code> is pertinent to
                                                 applicability (<a class="xref" href="jls-15.html#jls-15.12.2.2" title="15.12.2.2.&nbsp;Phase 1: Identify Matching Arity Methods Applicable by Strict Invocation">&sect;15.12.2.2</a>) then <code class="varname">e<sub>i</sub></code> is
                                                 compatible in a loose invocation context with
                                                 <span class="type">F<sub>i</sub></span><code class="literal">[</code><span class="type">R<sub>1</sub></span>:=<span class="type">U<sub>1</sub></span>, ..., <span class="type">R<sub>p</sub></span>:=<span class="type">U<sub>p</sub></span><code class="literal">]</code>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.3-100-B-B"></a>
                                       	  For 1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>l</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>p</em></span>, <span class="type">U<sub>l</sub></span> <code class="literal">&lt;:</code>
                                                 <span class="type">B<sub>l</sub></span><code class="literal">[</code><span class="type">R<sub>1</sub></span>:=<span class="type">U<sub>1</sub></span>, ..., <span class="type">R<sub>p</sub></span>:=<span class="type">U<sub>p</sub></span><code class="literal">]</code>.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.3-100-C"></a>
                                    If <code class="varname">m</code> is not a generic method, then <code class="varname">m</code> is <span class="emphasis"><em>applicable
                                          by loose invocation</em></span> if, for 1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span>
                                    <span class="emphasis"><em>n</em></span>, either <code class="varname">e<sub>i</sub></code> is compatible in a loose invocation context
                                    with <span class="type">F<sub>i</sub></span> or <code class="varname">e<sub>i</sub></code> is not pertinent to applicability.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm-static"><a name="jls-15.12.2.3-110"></a>If no
                     method applicable by loose invocation is found, the search for
                     applicable methods continues with phase 3
                     (<a class="xref" href="jls-15.html#jls-15.12.2.4" title="15.12.2.4.&nbsp;Phase 3: Identify Methods Applicable by Variable Arity Invocation">&sect;15.12.2.4</a>).
                  </p>
                  <p class="norm-static"><a name="jls-15.12.2.3-120"></a>
                     Otherwise, the most specific method (<a class="xref" href="jls-15.html#jls-15.12.2.5" title="15.12.2.5.&nbsp;Choosing the Most Specific Method">&sect;15.12.2.5</a>)
                     is chosen among the methods that are applicable by loose
                     invocation.
                  </p>
               </div>
               <div class="section" title="15.12.2.4.&nbsp;Phase 3: Identify Methods Applicable by Variable Arity Invocation">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-15.12.2.4"></a>15.12.2.4.&nbsp;Phase 3: Identify Methods
                              Applicable by Variable Arity Invocation
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-static"><a name="jls-15.12.2.4-100"></a>Where
                     a variable arity method has formal parameter types <span class="type">F<sub>1</sub></span>, ..., <span class="type">F<sub>n-1</sub></span>,
                     <span class="type">F<sub>n</sub></span><code class="literal">[]</code>, let the <span class="emphasis"><em>i</em></span>'th <span class="emphasis"><em>variable arity parameter
                           type</em></span> of the method be defined as follows:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.4-100-A"></a>
                                    For <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>-1, the <span class="emphasis"><em>i</em></span>'th variable arity parameter
                                    type is <span class="type">F<sub>i</sub></span>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.4-100-B"></a>
                                    For <span class="emphasis"><em>i</em></span> <span class="symbol">&#8805;</span> <span class="emphasis"><em>n</em></span>, the <span class="emphasis"><em>i</em></span>'th variable arity parameter
                                    type is <span class="type">F<sub>n</sub></span>.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm-static"><a name="jls-15.12.2.4-200"></a>Let
                     <code class="varname">m</code> be a potentially applicable method
                     (<a class="xref" href="jls-15.html#jls-15.12.2.1" title="15.12.2.1.&nbsp;Identify Potentially Applicable Methods">&sect;15.12.2.1</a>) with variable arity, let <span class="type">T<sub>1</sub></span>, ...,
                     <span class="type">T<sub>k</sub></span> be the first <span class="emphasis"><em>k</em></span> variable arity parameter types of <code class="varname">m</code>, and
                     let <code class="varname">e<sub>1</sub></code>, ..., <code class="varname">e<sub>k</sub></code> be the actual argument expressions of the method
                     invocation. Then:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.4-200-A"></a>
                                    If <code class="varname">m</code> is a generic method and the method invocation does not
                                    provide explicit type arguments, then the applicability of the
                                    method is inferred as specified in <a class="xref" href="jls-18.html#jls-18.5.1" title="18.5.1.&nbsp;Invocation Applicability Inference">&sect;18.5.1</a>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.4-200-B"></a>
                                    If <code class="varname">m</code> is a generic method and the method invocation provides
                                    explicit type arguments, then let <span class="type">R<sub>1</sub></span> ... <span class="type">R<sub>p</sub></span> (<span class="emphasis"><em>p</em></span> <span class="symbol">&#8805;</span> 1)
                                    be the type parameters of <code class="varname">m</code>, let <span class="type">B<sub>l</sub></span> be the declared bound of
                                    <span class="type">R<sub>l</sub></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>l</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>p</em></span>), and let <span class="type">U<sub>1</sub></span> ... <span class="type">U<sub>p</sub></span> be the
                                    explicit type arguments given in the method invocation. Then <code class="varname">m</code>
                                    is <span class="emphasis"><em>applicable by variable arity invocation</em></span>
                                    if:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.4-200-B-A"></a>
                                       	  For 1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>k</em></span>, if <code class="varname">e<sub>i</sub></code> is pertinent to
                                                 applicability (<a class="xref" href="jls-15.html#jls-15.12.2.2" title="15.12.2.2.&nbsp;Phase 1: Identify Matching Arity Methods Applicable by Strict Invocation">&sect;15.12.2.2</a>) then <code class="varname">e<sub>i</sub></code> is
                                                 compatible in a loose invocation context with
                                                 <span class="type">T<sub>i</sub></span><code class="literal">[</code><span class="type">R<sub>1</sub></span>:=<span class="type">U<sub>1</sub></span>, ..., <span class="type">R<sub>p</sub></span>:=<span class="type">U<sub>p</sub></span><code class="literal">]</code>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.4-200-B-B"></a>
                                       	  For 1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>l</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>p</em></span>, <span class="type">U<sub>l</sub></span> <code class="literal">&lt;:</code>
                                                 <span class="type">B<sub>l</sub></span><code class="literal">[</code><span class="type">R<sub>1</sub></span>:=<span class="type">U<sub>1</sub></span>, ..., <span class="type">R<sub>p</sub></span>:=<span class="type">U<sub>p</sub></span><code class="literal">]</code>.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.4-200-C"></a>
                                    If <code class="varname">m</code> is not a generic method, then <code class="varname">m</code> is <span class="emphasis"><em>applicable
                                          by variable arity invocation</em></span> if, for 1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span>
                                    <span class="symbol">&#8804;</span> <span class="emphasis"><em>k</em></span>, either <code class="varname">e<sub>i</sub></code> is compatible in a loose invocation
                                    context with <span class="type">T<sub>i</sub></span> or <code class="varname">e<sub>i</sub></code> is not pertinent to applicability
                                    (<a class="xref" href="jls-15.html#jls-15.12.2.2" title="15.12.2.2.&nbsp;Phase 1: Identify Matching Arity Methods Applicable by Strict Invocation">&sect;15.12.2.2</a>).
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm-error"><a name="jls-15.12.2.4-210"></a>If no
                     method applicable by variable arity invocation is found, a
                     compile-time error occurs.
                  </p>
                  <p class="norm-static"><a name="jls-15.12.2.4-220"></a>
                     Otherwise, the most specific method (<a class="xref" href="jls-15.html#jls-15.12.2.5" title="15.12.2.5.&nbsp;Choosing the Most Specific Method">&sect;15.12.2.5</a>)
                     is chosen among the methods applicable by variable arity
                     invocation.
                  </p>
               </div>
               <div class="section" title="15.12.2.5.&nbsp;Choosing the Most Specific Method">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-15.12.2.5"></a>15.12.2.5.&nbsp;Choosing the Most Specific Method
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm"><a name="jls-15.12.2.5-100"></a>If more than one member
                     method is both accessible and applicable to a method invocation, it is
                     necessary to choose one to provide the descriptor for the run-time
                     method dispatch. The Java programming language uses the rule that the <span class="emphasis"><em>most
                           specific</em></span> method is chosen.
                  </p>
                  <p class="norm"><a name="jls-15.12.2.5-110"></a>The informal intuition is that one
                     method is more specific than another if any invocation handled by the
                     first method could be passed on to the other one without a
                     compile-time error. In cases such as an explicitly typed lambda
                     expression argument (<a class="xref" href="jls-15.html#jls-15.27.1" title="15.27.1.&nbsp;Lambda Parameters">&sect;15.27.1</a>) or a variable
                     arity invocation (<a class="xref" href="jls-15.html#jls-15.12.2.4" title="15.12.2.4.&nbsp;Phase 3: Identify Methods Applicable by Variable Arity Invocation">&sect;15.12.2.4</a>), some flexibility
                     is allowed to adapt one signature to the other.
                  </p>
                  <p class="norm-static"><a name="jls-15.12.2.5-200"></a>One applicable
                     method <code class="varname">m<sub>1</sub></code> is <span class="emphasis"><em>more specific</em></span> than another
                     applicable method <code class="varname">m<sub>2</sub></code>, for an invocation with argument expressions
                     <code class="varname">e<sub>1</sub></code>, ..., <code class="varname">e<sub>k</sub></code>, if any of the following are true:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.5-200-A"></a>
                                    <code class="varname">m<sub>2</sub></code> is generic and <code class="varname">m<sub>1</sub></code> is inferred to be more specific than
                                    <code class="varname">m<sub>2</sub></code> for argument expressions <code class="varname">e<sub>1</sub></code>, ..., <code class="varname">e<sub>k</sub></code> by
                                    <a class="xref" href="jls-18.html#jls-18.5.4" title="18.5.4.&nbsp;More Specific Method Inference">&sect;18.5.4</a>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.5-200-B"></a>
                                    <code class="varname">m<sub>2</sub></code> is not generic, <code class="varname">m<sub>1</sub></code> and <code class="varname">m<sub>2</sub></code> are applicable by strict or
                                    loose invocation, and where <code class="varname">m<sub>1</sub></code> has formal parameter types
                                    <span class="type">S<sub>1</sub></span>, ..., <span class="type">S<sub>n</sub></span> and <code class="varname">m<sub>2</sub></code> has formal parameter types <span class="type">T<sub>1</sub></span>, ...,
                                    <span class="type">T<sub>n</sub></span>, the type <span class="type">S<sub>i</sub></span> is <span class="emphasis"><em>more specific</em></span> than
                                    <span class="type">T<sub>i</sub></span> for argument <code class="varname">e<sub>i</sub></code> for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span>
                                    <span class="emphasis"><em>n</em></span>, <span class="emphasis"><em>n</em></span> = <span class="emphasis"><em>k</em></span>).
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.5-200-C"></a>
                                    <code class="varname">m<sub>2</sub></code> is not generic, <code class="varname">m<sub>1</sub></code> and <code class="varname">m<sub>2</sub></code> are applicable by variable
                                    arity invocation, and where the first <span class="emphasis"><em>k</em></span> variable arity
                                    parameter types of <code class="varname">m<sub>1</sub></code> are <span class="type">S<sub>1</sub></span>, ..., <span class="type">S<sub>k</sub></span> and the first <span class="emphasis"><em>k</em></span>
                                    variable arity parameter types of <code class="varname">m<sub>2</sub></code> are <span class="type">T<sub>1</sub></span>, ..., <span class="type">T<sub>k</sub></span>, the
                                    type <span class="type">S<sub>i</sub></span> is <span class="emphasis"><em>more specific</em></span> than <span class="type">T<sub>i</sub></span> for
                                    argument <code class="varname">e<sub>i</sub></code> for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span>
                                    <span class="emphasis"><em>k</em></span>). Additionally, if <code class="varname">m<sub>2</sub></code> has <span class="emphasis"><em>k</em></span>+1 parameters, then the
                                    <span class="emphasis"><em>k</em></span><span class="emphasis"><em>+1</em></span>'th variable arity parameter type of
                                    <code class="varname">m<sub>1</sub></code> is a subtype of the <span class="emphasis"><em>k</em></span><span class="emphasis"><em>+1</em></span>'th
                                    variable arity parameter type of <code class="varname">m<sub>2</sub></code>.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm"><a name="jls-15.12.2.5-210"></a>The above conditions are
                     the only circumstances under which one method may be more specific
                     than another.
                  </p>
                  <p class="norm-static"><a name="jls-15.12.2.5-300"></a>A type <span class="type">S</span>
                     is <span class="emphasis"><em>more specific</em></span> than a type <span class="type">T</span>
                     for <span class="emphasis"><em>any</em></span> expression if <span class="type">S</span> <code class="literal">&lt;:</code> <span class="type">T</span>
                     (<a class="xref" href="jls-4.html#jls-4.10" title="4.10.&nbsp;Subtyping">&sect;4.10</a>).
                  </p>
                  <p class="norm-static"><a name="jls-15.12.2.5-310"></a>A functional
                     interface type <span class="type">S</span> is <span class="emphasis"><em>more specific</em></span> than a
                     functional interface type <span class="type">T</span> for an expression <code class="varname">e</code> if <span class="type">T</span> is not a
                     subtype of <span class="type">S</span> and one of the following is true (where <span class="type">U<sub>1</sub></span> ... <span class="type">U<sub>k</sub></span>
                     and <span class="type">R<sub>1</sub></span> are the parameter types and return type of the function type
                     of the capture of <span class="type">S</span>, and <span class="type">V<sub>1</sub></span> ... <span class="type">V<sub>k</sub></span> and <span class="type">R<sub>2</sub></span> are the parameter
                     types and return type of the function type of <span class="type">T</span>):
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.5-310-A"></a>
                                    If <code class="varname">e</code> is an explicitly typed lambda expression
                                    (<a class="xref" href="jls-15.html#jls-15.27.1" title="15.27.1.&nbsp;Lambda Parameters">&sect;15.27.1</a>), then one of the following is
                                    true:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.5-310-A-A"></a>
                                       	  <span class="type">R<sub>2</sub></span> is <code class="literal">void</code>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.5-310-A-B"></a>
                                       	  <span class="type">R<sub>1</sub></span> <code class="literal">&lt;:</code> <span class="type">R<sub>2</sub></span>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.5-310-A-C"></a>
                                       	  <span class="type">R<sub>1</sub></span> and <span class="type">R<sub>2</sub></span> are functional interface types, and <span class="type">R<sub>1</sub></span> is
                                                 more specific than <span class="type">R<sub>2</sub></span> for each result expression of <code class="varname">e</code>.
                                    </p>
                                    <p class="norm-static"><a name="jls-15.12.2.5-310-A-C.1"></a>
                                       	  The result expression of a lambda expression with a block
                                       	  body is defined in <a class="xref" href="jls-15.html#jls-15.27.2" title="15.27.2.&nbsp;Lambda Body">&sect;15.27.2</a>; the result
                                       	  expression of a lambda expression with an expression body is
                                       	  simply the body itself.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.5-310-A-D"></a>
                                       	  <span class="type">R<sub>1</sub></span> is a primitive type, <span class="type">R<sub>2</sub></span> is a reference type, and each
                                                 result expression of <code class="varname">e</code> is a standalone expression
                                                 (<a class="xref" href="jls-15.html#jls-15.2" title="15.2.&nbsp;Forms of Expressions">&sect;15.2</a>) of a primitive type.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.5-310-A-E"></a>
                                       	  <span class="type">R<sub>1</sub></span> is a reference type, <span class="type">R<sub>2</sub></span> is a primitive type, and each
                                                 result expression of <code class="varname">e</code> is either a standalone expression
                                                 of a reference type or a poly expression.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.5-310-B"></a>
                                    If <code class="varname">e</code> is an exact method reference expression
                                    (<a class="xref" href="jls-15.html#jls-15.13.1" title="15.13.1.&nbsp;Compile-Time Declaration of a Method Reference">&sect;15.13.1</a>), then i) for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span>
                                    <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>k</em></span>), <span class="type">U<sub>i</sub></span> is the same as <span class="type">V<sub>i</sub></span>, and ii) one of
                                    the following is true:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.5-310-B-A"></a>
                                       	  <span class="type">R<sub>2</sub></span> is <code class="literal">void</code>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.5-310-B-B"></a>
                                       	  <span class="type">R<sub>1</sub></span> <code class="literal">&lt;:</code> <span class="type">R<sub>2</sub></span>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.5-310-B-C"></a>
                                       	  <span class="type">R<sub>1</sub></span> is a primitive type, <span class="type">R<sub>2</sub></span> is a reference type, and the
                                       	  compile-time declaration for the method reference has a
                                       	  return type which is a primitive type.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.5-310-B-D"></a>
                                       	  <span class="type">R<sub>1</sub></span> is a reference type, <span class="type">R<sub>2</sub></span> is a primitive type, and the
                                                 compile-time declaration for the method reference has a
                                                 return type which is a reference type.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.5-310-C"></a>
                                    If <code class="varname">e</code> is a parenthesized expression, then one of these
                                    conditions applies recursively to the contained
                                    expression.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.5-310-D"></a>
                                    If <code class="varname">e</code> is a conditional expression, then for each of the second
                                    and third operands, one of these conditions applies
                                    recursively.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm-static"><a name="jls-15.12.2.5-500"></a>A
                     method <code class="varname">m<sub>1</sub></code> is <span class="emphasis"><em>strictly more specific</em></span> than
                     another method <code class="varname">m<sub>2</sub></code> if and only if <code class="varname">m<sub>1</sub></code> is more specific than <code class="varname">m<sub>2</sub></code> and
                     <code class="varname">m<sub>2</sub></code> is not more specific than <code class="varname">m<sub>1</sub></code>.
                  </p>
                  <p class="norm-static"><a name="jls-15.12.2.5-510"></a>A
                     method is said to be <span class="emphasis"><em>maximally specific</em></span> for a
                     method invocation if it is accessible and applicable and there is no
                     other method that is applicable and accessible that is strictly more
                     specific.
                  </p>
                  <p class="norm-static"><a name="jls-15.12.2.5-520"></a>If
                     there is exactly one maximally specific method, then that method is in
                     fact the <span class="emphasis"><em>most specific method</em></span>; it is necessarily
                     more specific than any other accessible method that is applicable. It
                     is then subjected to some further compile-time checks as specified in
                     <a class="xref" href="jls-15.html#jls-15.12.3" title="15.12.3.&nbsp;Compile-Time Step 3: Is the Chosen Method Appropriate?">&sect;15.12.3</a>.
                  </p>
                  <p class="norm-static"><a name="jls-15.12.2.5-530"></a>It is
                     possible that no method is the most specific, because there are two or
                     more methods that are maximally specific. In this case:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.5-530-A"></a>
                                    If all the maximally specific methods have override-equivalent
                                    signatures (<a class="xref" href="jls-8.html#jls-8.4.2" title="8.4.2.&nbsp;Method Signature">&sect;8.4.2</a>), then:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.5-530-A-A"></a>
                                       	  If exactly one of the maximally specific methods is concrete
                                       	  (that is, non-<code class="literal">abstract</code> or default), it is the most
                                       	  specific method.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.5-530-A-B"></a>
                                                 Otherwise, if all the maximally specific methods are
                                                 <code class="literal">abstract</code> or default, and the signatures of all of the
                                                 maximally specific methods have the same erasure
                                                 (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>), then the most specific method
                                                 is chosen arbitrarily among the subset of the maximally
                                                 specific methods that have the most specific return
                                                 type.
                                    </p>
                                    <p class="norm-static"><a name="jls-15.12.2.5-530-A-B.1"></a>
                                       	  In this case, the most specific method is considered to be
                                       	  <code class="literal">abstract</code>. Also, the most specific method is considered to
                                       	  throw a checked exception if and only if that exception or
                                       	  its erasure is declared in the <code class="literal">throws</code> clauses of each of
                                       	  the maximally specific methods.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="listitem">
                           <p class="norm-error"><a name="jls-15.12.2.5-530-B"></a>
                                    Otherwise, the method invocation
                                    is <span class="emphasis"><em>ambiguous</em></span>, and a compile-time error
                                    occurs.
                           </p>
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="section" title="15.12.2.6.&nbsp;Method Invocation Type">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-15.12.2.6"></a>15.12.2.6.&nbsp;Method Invocation Type
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-static"><a name="jls-15.12.2.6-100"></a>The 
                     <span class="emphasis"><em>invocation type</em></span> of a most specific accessible and
                     applicable method is a method type (<a class="xref" href="jls-8.html#jls-8.2" title="8.2.&nbsp;Class Members">&sect;8.2</a>)
                     expressing the target types of the invocation arguments, the result
                     (return type or <code class="literal">void</code>) of the invocation, and the exception types of
                     the invocation. It is determined as follows:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.6-100-A"></a>
                                    If the chosen method is generic and the method invocation does
                                    not provide explicit type arguments, the invocation type is
                                    inferred as specified in <a class="xref" href="jls-18.html#jls-18.5.2" title="18.5.2.&nbsp;Invocation Type Inference">&sect;18.5.2</a>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.6-100-B"></a>
                                    If the chosen method is generic and the method invocation
                                    provides explicit type arguments, let <span class="type">P<sub>i</sub></span> be the type
                                    parameters of the method and let <span class="type">T<sub>i</sub></span> be the explicit type
                                    arguments provided for the method invocation (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span>
                                    <span class="symbol">&#8804;</span> <span class="emphasis"><em>p</em></span>). Then:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.6-100-B-A"></a>
                                       	  If unchecked conversion was necessary for the method to be
                                       	  applicable, then the invocation type's parameter types are
                                       	  obtained by applying the substitution <code class="literal">[</code><span class="type">P<sub>1</sub></span>:=<span class="type">T<sub>1</sub></span>,
                                       	  ..., <span class="type">P<sub>p</sub></span>:=<span class="type">T<sub>p</sub></span><code class="literal">]</code> to the parameter types of the
                                       	  method's type, and the invocation type's return type and
                                       	  thrown types are given by the erasure of the return type and
                                       	  thrown types of the method's type.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.6-100-B-B"></a>
                                       	  If unchecked conversion was not necessary for the method to
                                       	  be applicable, then the invocation type is obtained by
                                       	  applying the substitution <code class="literal">[</code><span class="type">P<sub>1</sub></span>:=<span class="type">T<sub>1</sub></span>, ...,
                                       	  <span class="type">P<sub>p</sub></span>:=<span class="type">T<sub>p</sub></span><code class="literal">]</code> to the method's type.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="listitem">
                           <p class="norm-static"><a name="jls-15.12.2.6-100-C"></a>
                                    If the chosen method is not generic, then:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.6-100-C-A"></a>
                                       	  If unchecked conversion was necessary for the method to be
                                       	  applicable, the parameter types of the invocation type are
                                       	  the parameter types of the method's type, and the return
                                       	  type and thrown types are given by the erasures of the
                                       	  return type and thrown types of the method's type.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.6-100-C-B"></a>
                                       	  Otherwise, if the chosen method is
                                       	  the <code class="literal">getClass</code> method of the class <code class="literal">Object</code>
                                       	  (<a class="xref" href="jls-4.html#jls-4.3.2" title="4.3.2.&nbsp;The Class Object">&sect;4.3.2</a>), the invocation type is the
                                       	  same as the method's type, except that the return type is
                                       	  <code class="literal">Class</code><code class="literal">&lt;</code><code class="literal">?</code> <code class="literal">extends</code> <span class="type">T</span><code class="literal">&gt;</code>, where <span class="type">T</span> is
                                       	  the type that was searched, as determined by
                                       	  <a class="xref" href="jls-15.html#jls-15.12.1" title="15.12.1.&nbsp;Compile-Time Step 1: Determine Class or Interface to Search">&sect;15.12.1</a>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-static"><a name="jls-15.12.2.6-100-C-C"></a>
                                       	  Otherwise, the invocation type is the same as the method's
                                       	  type.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                     </ul>
                  </div>
               </div>
            </div>
            <div class="section" title="15.12.3.&nbsp;Compile-Time Step 3: Is the Chosen Method Appropriate?">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.12.3"></a>15.12.3.&nbsp;Compile-Time Step 3: Is the Chosen Method Appropriate?
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.12.3-100"></a>If there
                  is a most specific method declaration for a method invocation, it is
                  called the <span class="emphasis"><em>compile-time declaration</em></span> for the
                  method invocation.
               </p>
               <p class="norm-error"><a name="jls-15.12.3-200"></a>
                  It is a compile-time error if an argument to a method invocation is
                  not compatible with its target type, as derived from the invocation
                  type of the compile-time declaration.
               </p>
               <p class="norm-error"><a name="jls-15.12.3-210"></a>
                  If the compile-time declaration is applicable by variable arity
                  invocation, then where the last formal parameter type of the
                  invocation type of the method is <span class="type">F<sub>n</sub></span><code class="literal">[]</code>, it is a compile-time
                  error if the type which is the erasure of <span class="type">F<sub>n</sub></span> is not accessible at
                  the point of invocation.
               </p>
               <p class="norm-error"><a name="jls-15.12.3-220"></a>If the
                  compile-time declaration is <code class="literal">void</code>, then the method invocation must be
                  a top level expression (that is, the <span class="emphasis"><em>Expression</em></span> in an expression
                  statement or in the <span class="emphasis"><em>ForInit</em></span>
                  or <span class="emphasis"><em>ForUpdate</em></span> part of a <code class="literal">for</code> statement), or a
                  compile-time error occurs. Such a method invocation produces no value
                  and so must be used only in a situation where a value is not
                  needed.
               </p>
               <p class="norm-static"><a name="jls-15.12.3-300"></a>In
                  addition, whether the compile-time declaration is appropriate may
                  depend on the form of the method invocation expression before the left
                  parenthesis, as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.3-300-A"></a>
                                 If the form is <span class="emphasis"><em>MethodName</em></span> - that is, just an <span class="emphasis"><em>Identifier</em></span> -
                                 and the compile-time declaration is an instance method,
                                 then:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-error"><a name="jls-15.12.3-300-A-A"></a>
                                    	  It is a compile-time error if the method invocation occurs
                                    	  in a static context (<a class="xref" href="jls-8.html#jls-8.1.3" title="8.1.3.&nbsp;Inner Classes and Enclosing Instances">&sect;8.1.3</a>).
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-error"><a name="jls-15.12.3-300-A-B"></a>
                                    	  Otherwise, let <span class="type">C</span> be the immediately enclosing class of
                                    	  which the compile-time declaration is a member. If the
                                    	  method invocation is not directly enclosed by <span class="type">C</span> or an
                                    	  inner class of <span class="type">C</span>, then a compile-time error occurs.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-15.12.3-300-B"></a>
                                 If the form is <span class="emphasis"><em>TypeName</em></span> <code class="literal">.</code> <span class="emphasis"><em>[TypeArguments]</em></span>
                                 <span class="emphasis"><em>Identifier</em></span>, then the compile-time declaration must be
                                 <code class="literal">static</code>, or a compile-time error occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-error"><a name="jls-15.12.3-300-C"></a>
                                 If the form is <span class="emphasis"><em>ExpressionName</em></span> <code class="literal">.</code> <span class="emphasis"><em>[TypeArguments]</em></span>
                                 <span class="emphasis"><em>Identifier</em></span> or <span class="emphasis"><em>Primary</em></span> <code class="literal">.</code> <span class="emphasis"><em>[TypeArguments]</em></span>
                                 <span class="emphasis"><em>Identifier</em></span>, then the compile-time declaration must not be a
                                 <code class="literal">static</code> method declared in an interface, or a compile-time
                                 error occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.3-300-D"></a>
                                 If the form is <code class="literal">super</code> <code class="literal">.</code> <span class="emphasis"><em>[TypeArguments]</em></span> <span class="emphasis"><em>Identifier</em></span>,
                                 then:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-error"><a name="jls-15.12.3-300-D-A"></a>
                                    	  It is a compile-time error if the compile-time declaration
                                    	  is <code class="literal">abstract</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-error"><a name="jls-15.12.3-300-D-B"></a>
                                    	  It is a compile-time error if the method invocation occurs
                                    	  in a static context.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.3-300-E"></a>
                                 If the form is <span class="emphasis"><em>TypeName</em></span> <code class="literal">.</code> <code class="literal">super</code> <code class="literal">.</code>
                                 <span class="emphasis"><em>[TypeArguments]</em></span> <span class="emphasis"><em>Identifier</em></span>, then:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-error"><a name="jls-15.12.3-300-E-A"></a>
                                    	  It is a compile-time error if the compile-time declaration
                                    	  is <code class="literal">abstract</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-error"><a name="jls-15.12.3-300-E-B"></a>
                                    	  It is a compile-time error if the method invocation occurs
                                    	  in a static context.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-error"><a name="jls-15.12.3-300-E-C"></a>
                                    	  If <span class="emphasis"><em>TypeName</em></span> denotes a class <span class="type">C</span>, then if the method
                                              invocation is not directly enclosed by <span class="type">C</span> or an inner class
                                              of <span class="type">C</span>, a compile-time error occurs.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-error"><a name="jls-15.12.3-300-E-D"></a>
                                    	  If <span class="emphasis"><em>TypeName</em></span> denotes an interface, let <span class="type">T</span> be the type
                                    	  declaration immediately enclosing the method invocation. A
                                    	  compile-time error occurs if there exists a method, distinct
                                    	  from the compile-time declaration, that overrides
                                    	  (<a class="xref" href="jls-9.html#jls-9.4.1" title="9.4.1.&nbsp;Inheritance and Overriding">&sect;9.4.1</a>) the compile-time declaration
                                    	  from a direct superclass or direct superinterface of
                                    	  <span class="type">T</span>.
                                 </p>
                                 <p class="note">In the case that a superinterface
                                              overrides a method declared in a grandparent interface, this
                                              rule prevents the child interface from "skipping" the
                                              override by simply adding the grandparent to its list of
                                              direct superinterfaces. The appropriate way to access
                                              functionality of a grandparent is through the direct
                                              superinterface, and only if that interface chooses to expose
                                              the desired behavior. (Alternately, the developer is free
                                              to define his own additional superinterface that exposes the
                                              desired behavior with a <code class="literal">super</code> method invocation.)
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-15.12.3-400"></a>The
                  <span class="emphasis"><em>compile-time parameter types</em></span>
                  and <span class="emphasis"><em>compile-time result</em></span> are determined as
                  follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.3-400-A"></a>
                                 If the compile-time declaration for the method invocation
                                 is <span class="emphasis"><em>not</em></span> a signature polymorphic method, then
                                 the compile-time parameter types are the types of the formal
                                 parameters of the compile-time declaration, and the compile-time
                                 result is the result chosen for the compile-time declaration
                                 (<a class="xref" href="jls-15.html#jls-15.12.2.6" title="15.12.2.6.&nbsp;Method Invocation Type">&sect;15.12.2.6</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.3-400-B"></a>
                                 If the compile-time declaration for the method invocation is a
                                 signature polymorphic method, then:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.12.3-400-B-A"></a>
                                    	  The compile-time parameter types are the static types of the
                                              actual argument expressions. An argument expression which is
                                              the null literal <code class="literal">null</code> (<a class="xref" href="jls-3.html#jls-3.10.7" title="3.10.7.&nbsp;The Null Literal">&sect;3.10.7</a>) is
                                              treated as having the static type <code class="literal">Void</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.12.3-400-B-B"></a>
                                    	  The compile-time result is determined as follows:
                                 </p>
                                 <div class="norm">
                                    <ul class="norm" type="square">
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-15.12.3-400-B-B-A"></a>
                                             	      If the method invocation expression is an expression
                                                           statement, the compile-time result is <code class="literal">void</code>.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-15.12.3-400-B-B-B"></a>
                                             	      Otherwise, if the method invocation expression is the
                                             	      operand of a cast expression
                                             	      (<a class="xref" href="jls-15.html#jls-15.16" title="15.16.&nbsp;Cast Expressions">&sect;15.16</a>), the compile-time result
                                             	      is the erasure of the type of the cast expression
                                             	      (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>).
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-15.12.3-400-B-B-C"></a>
                                             	      Otherwise, the compile-time result is the signature
                                             	      polymorphic method's declared return type,
                                             	      <code class="literal">Object</code>.
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-15.12.3-410"></a>A method
                  is <span class="emphasis"><em>signature polymorphic</em></span> if all of the following
                  are true:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.3-410-A"></a>
                                 It is declared in the <code class="literal">java.lang.invoke.MethodHandle</code> class.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.3-410-B"></a>
                                 It takes a single variable arity parameter
                                 (<a class="xref" href="jls-8.html#jls-8.4.1" title="8.4.1.&nbsp;Formal Parameters">&sect;8.4.1</a>) whose declared type is
                                 <code class="literal">Object</code><code class="literal">[]</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.3-410-C"></a>
                                 It has a return type of <code class="literal">Object</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.3-410-D"></a>
                                 It is <code class="literal">native</code>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="note">In Java SE 8, the only signature polymorphic methods
                  are the <code class="literal">invoke</code> and <code class="literal">invokeExact</code> methods of the class
                  <code class="literal">java.lang.invoke.MethodHandle</code>.
               </p>
               <p class="norm-static"><a name="jls-15.12.3-500"></a>The
                  following compile-time information is then associated with the method
                  invocation for use at run time:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.3-500-A"></a>
                                 The name of the method.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.3-500-B"></a>
                                 The qualifying type of the method invocation
                                 (<a class="xref" href="jls-13.html#jls-13.1" title="13.1.&nbsp;The Form of a Binary">&sect;13.1</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.3-500-C"></a>
                                 The number of parameters and the compile-time parameter types,
                                 in order.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.3-500-D"></a>
                                 The compile-time result, or <code class="literal">void</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.12.3-500-E"></a>
                                 The invocation mode, computed as follows:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.12.3-500-E-A"></a>
                                    	  If the qualifying type of the method declaration is a class,
                                    	  then:
                                 </p>
                                 <div class="norm">
                                    <ul class="norm" type="square">
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-15.12.3-500-E-A-A"></a>
                                             	      If the compile-time declaration has the <code class="literal">static</code>
                                             	      modifier, then the invocation mode is <code class="literal">static</code>.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-15.12.3-500-E-A-B"></a>
                                             	      Otherwise, if the compile-time declaration has the
                                             	      <code class="literal">private</code> modifier, then the invocation mode is
                                             	      <code class="literal">nonvirtual</code>.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-15.12.3-500-E-A-C"></a>
                                             	      Otherwise, if the part of the method invocation before
                                             	      the left parenthesis is of the form <code class="literal">super</code> <code class="literal">.</code>
                                             	      <span class="emphasis"><em>Identifier</em></span> or of the form <span class="emphasis"><em>TypeName</em></span> <code class="literal">.</code> <code class="literal">super</code>
                                             	      <code class="literal">.</code> <span class="emphasis"><em>Identifier</em></span>, then the invocation mode is
                                             	      <code class="literal">super</code>.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-15.12.3-500-E-A-D"></a>
                                             	      Otherwise, the invocation mode is <code class="literal">virtual</code>.
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.12.3-500-E-B"></a>
                                    	  If the qualifying type of the method invocation is an
                                    	  interface, then the invocation mode is <code class="literal">interface</code>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-15.12.3-600"></a>
                  If the result of the invocation type of the compile-time declaration
                  is not <code class="literal">void</code>, then the type of the method invocation expression is
                  obtained by applying capture conversion (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>)
                  to the return type of the invocation type of the compile-time
                  declaration.
               </p>
            </div>
            <div class="section" title="15.12.4.&nbsp;Run-Time Evaluation of Method Invocation">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.12.4"></a>15.12.4.&nbsp;Run-Time Evaluation of Method Invocation
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-15.12.4-100"></a>At run time, method
                  invocation requires five steps. First, a <span class="emphasis"><em>target
                        reference</em></span> may be computed. Second, the argument expressions
                  are evaluated. Third, the accessibility of the method to be invoked is
                  checked. Fourth, the actual code for the method to be executed is
                  located. Fifth, a new activation frame is created, synchronization is
                  performed if necessary, and control is transferred to the method
                  code.
               </p>
               <div class="section" title="15.12.4.1.&nbsp;Compute Target Reference (If Necessary)">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-15.12.4.1"></a>15.12.4.1.&nbsp;Compute Target Reference (If Necessary)
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-dynamic"><a name="jls-15.12.4.1-100"></a>There
                     are six cases to consider, depending on the form of the method
                     invocation:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm-dynamic"><a name="jls-15.12.4.1-100-A"></a>
                                    If the form is <span class="emphasis"><em>MethodName</em></span> - that is, just an <span class="emphasis"><em>Identifier</em></span> -
                                    then:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm-dynamic"><a name="jls-15.12.4.1-100-A-A"></a>
                                       	  If the invocation mode is <code class="literal">static</code>, then there is no target
                                       	  reference.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-dynamic"><a name="jls-15.12.4.1-100-A-B"></a>
                                       	  Otherwise, let <span class="type">T</span> be the enclosing type declaration of
                                       	  which the method is a member, and let <span class="emphasis"><em>n</em></span> be an integer
                                       	  such that <span class="type">T</span> is the <span class="emphasis"><em>n</em></span>'th lexically enclosing type
                                       	  declaration of the class whose declaration immediately
                                       	  contains the method invocation. The target reference is the
                                       	  <span class="emphasis"><em>n</em></span>'th lexically enclosing instance of <code class="literal">this</code>.
                                    </p>
                                    <p class="norm-error"><a name="jls-15.12.4.1-100-A-B.1"></a>
                                       	  It is a compile-time error if the <span class="emphasis"><em>n</em></span>'th lexically
                                       	  enclosing instance of <code class="literal">this</code> does not exist.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="listitem">
                           <p class="norm-dynamic"><a name="jls-15.12.4.1-100-B"></a>
                                    If the form is <span class="emphasis"><em>TypeName</em></span> <code class="literal">.</code> <span class="emphasis"><em>[TypeArguments]</em></span>
                                    <span class="emphasis"><em>Identifier</em></span>, then there is no target reference.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-dynamic"><a name="jls-15.12.4.1-100-C"></a>
                                    If form is <span class="emphasis"><em>ExpressionName</em></span> <code class="literal">.</code> <span class="emphasis"><em>[TypeArguments]</em></span>
                                    <span class="emphasis"><em>Identifier</em></span>, then:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm-dynamic"><a name="jls-15.12.4.1-100-C-A"></a>
                                       	  If the invocation mode is <code class="literal">static</code>, then there is no target
                                       	  reference. The <span class="emphasis"><em>ExpressionName</em></span> is evaluated, but the result
                                       	  is then discarded.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-dynamic"><a name="jls-15.12.4.1-100-C-B"></a>
                                       	  Otherwise, the target reference is the value denoted by
                                       	  <span class="emphasis"><em>ExpressionName</em></span>.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="listitem">
                           <p class="norm-dynamic"><a name="jls-15.12.4.1-100-D"></a>
                                    If the form is <span class="emphasis"><em>Primary</em></span> <code class="literal">.</code> <span class="emphasis"><em>[TypeArguments]</em></span> <span class="emphasis"><em>Identifier</em></span>
                                    involved, then:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm-dynamic"><a name="jls-15.12.4.1-100-D-A"></a>
                                       	  If the invocation mode is <code class="literal">static</code>, then there is no target
                                                 reference. The <span class="emphasis"><em>Primary</em></span> expression is evaluated, but the
                                                 result is then discarded.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-dynamic"><a name="jls-15.12.4.1-100-D-B"></a>
                                       	  Otherwise, the <span class="emphasis"><em>Primary</em></span> expression is evaluated and the
                                                 result is used as the target reference.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                           <p class="norm-dynamic"><a name="jls-15.12.4.1-100-D.1"></a>
                                    In either case, if the evaluation of the <span class="emphasis"><em>Primary</em></span> expression
                                    completes abruptly, then no part of any argument expression
                                    appears to have been evaluated, and the method invocation
                                    completes abruptly for the same reason.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-dynamic"><a name="jls-15.12.4.1-100-E"></a>
                                    If the form is <code class="literal">super</code> <code class="literal">.</code> <span class="emphasis"><em>[TypeArguments]</em></span> <span class="emphasis"><em>Identifier</em></span>,
                                    then the target reference is the value of <code class="literal">this</code>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-dynamic"><a name="jls-15.12.4.1-100-F"></a>
                                    If the form is <span class="emphasis"><em>TypeName</em></span> <code class="literal">.</code> <code class="literal">super</code> <code class="literal">.</code>
                                    <span class="emphasis"><em>[TypeArguments]</em></span> <span class="emphasis"><em>Identifier</em></span>, then if <span class="emphasis"><em>TypeName</em></span> denotes a
                                    class, the target reference is the value of
                                    <span class="emphasis"><em>TypeName</em></span><code class="literal">.</code><code class="literal">this</code>; otherwise, the target reference is the
                                    value of <code class="literal">this</code>.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div class="example"><a name="d5e26002"></a><p class="title"><b>Example&nbsp;15.12.4.1-1.&nbsp;Target References and <code class="literal">static</code> Methods</b></p>
                     <div class="example-contents">
                        <p class="note">When a target reference is computed and then
                           discarded because the invocation mode is <code class="literal">static</code>, the reference is
                           not examined to see whether it is <code class="literal">null</code>:
                        </p><pre class="programlisting">
class Test1 {
    static void mountain() {
        System.out.println("Monadnock");
    }
    static Test1 favorite(){
        System.out.print("Mount ");
        return null;
    }
    public static void main(String[] args) {
        favorite().mountain();
    }
}
</pre><p class="note">which prints:</p><pre class="screen">
Mount Monadnock
</pre><p class="note">Here <code class="literal">favorite()</code> returns <code class="literal">null</code>,
                           yet no <code class="literal">NullPointerException</code> is thrown.
                        </p>
                     </div>
                  </div><br class="example-break"><div class="example"><a name="d5e26015"></a><p class="title"><b>Example&nbsp;15.12.4.1-2.&nbsp;Evaluation Order During Method Invocation</b></p>
                     <div class="example-contents">
                        <p class="note">As part of an instance method invocation
                           (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>), there is an expression that denotes the
                           object to be invoked. This expression appears to be fully evaluated
                           before any part of any argument expression to the method invocation is
                           evaluated.
                        </p>
                        <p class="note">So, for example, in:</p><pre class="programlisting">
class Test2 {
    public static void main(String[] args) {
        String s = "one";
        if (s.startsWith(s = "two"))
            System.out.println("oops");
    }
}
</pre><p class="note">the occurrence of <code class="literal">s</code> before
                           "<code class="literal">.startsWith</code>" is evaluated first, before the
                           argument expression <code class="literal">s = "two"</code>. Therefore, a
                           reference to the string <code class="literal">"one"</code> is remembered as the
                           target reference before the local variable <code class="literal">s</code> is
                           changed to refer to the string <code class="literal">"two"</code>. As a result,
                           the <code class="literal">startsWith</code> method is invoked for target
                           object <code class="literal">"one"</code> with
                           argument <code class="literal">"two"</code>, so the result of the invocation is
                           <code class="literal">false</code>, as the string <code class="literal">"one"</code> does not start
                           with <code class="literal">"two"</code>. It follows that the test program does
                           not print "<code class="literal">oops</code>".
                        </p>
                     </div>
                  </div><br class="example-break"></div>
               <div class="section" title="15.12.4.2.&nbsp;Evaluate Arguments">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-15.12.4.2"></a>15.12.4.2.&nbsp;Evaluate Arguments
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-dynamic"><a name="jls-15.12.4.2-100"></a>The
                     process of evaluating the argument list differs, depending on whether
                     the method being invoked is a fixed arity method or a variable arity
                     method (<a class="xref" href="jls-8.html#jls-8.4.1" title="8.4.1.&nbsp;Formal Parameters">&sect;8.4.1</a>).
                  </p>
                  <p class="norm"><a name="jls-15.12.4.2-110"></a>If the method being
                     invoked is a variable arity method <code class="varname">m</code>, it
                     necessarily has <span class="emphasis"><em>n</em></span> &gt; 0 formal parameters. The final formal
                     parameter of <code class="varname">m</code> necessarily has type <span class="type">T</span><code class="literal">[]</code>
                     for some <span class="type">T</span>, and <code class="varname">m</code> is necessarily being invoked
                     with <span class="emphasis"><em>k</em></span> <span class="symbol">&#8805;</span> 0 actual argument expressions.
                  </p>
                  <p class="norm-dynamic"><a name="jls-15.12.4.2-200"></a>If <code class="varname">m</code> is being
                     invoked with <span class="emphasis"><em>k</em></span> <span class="symbol">&#8800;</span> <span class="emphasis"><em>n</em></span> actual argument expressions, or, if
                     <code class="varname">m</code> is being invoked with <span class="emphasis"><em>k</em></span> = <span class="emphasis"><em>n</em></span> actual argument expressions
                     and the type of the <span class="emphasis"><em>k</em></span>'th argument expression is not assignment
                     compatible with <span class="type">T</span><code class="literal">[]</code>, then the argument list (<code class="varname">e<sub>1</sub></code>, ...,
                     <code class="varname">e<sub>n-1</sub></code>, <code class="varname">e<sub>n</sub></code>, ..., <code class="varname">e<sub>k</sub></code>) is evaluated as if it were written as (<code class="varname">e<sub>1</sub></code>,
                     ..., <code class="varname">e<sub>n-1</sub></code>, <code class="literal">new</code> |<span class="type">T</span><code class="literal">[]</code>| <code class="literal">{</code> <code class="varname">e<sub>n</sub></code>, ..., <code class="varname">e<sub>k</sub></code> <code class="literal">}</code>),
                     where |<span class="type">T</span><code class="literal">[]</code>| denotes the erasure (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>)
                     of <span class="type">T</span><code class="literal">[]</code>.
                  </p>
                  <p class="note">The preceding paragraphs are crafted to handle the
                     interaction of parameterized types and array types that occurs in a
                     Java Virtual Machine with erased generics. Namely, if the element type <span class="type">T</span> of the
                     variable array parameter is non-reifiable,
                     e.g. <code class="literal">List<code class="literal">&lt;</code>String<code class="literal">&gt;</code></code>, then special care
                     must be taken with the array creation expression
                     (<a class="xref" href="jls-15.html#jls-15.10" title="15.10.&nbsp;Array Creation and Access Expressions">&sect;15.10</a>) because the created array's element type
                     must be reifiable. By erasing the array type of the final expression
                     in the argument list, we are guaranteed to obtain a reifiable element
                     type. Then, since the array creation expression appears in an
                     invocation context (<a class="xref" href="jls-5.html#jls-5.3" title="5.3.&nbsp;Invocation Contexts">&sect;5.3</a>), an unchecked
                     conversion is possible from the array type with reifiable element type
                     to an array type with non-reifiable element type, specifically that of
                     the variable arity parameter. A Java compiler is required to give a
                     compile-time unchecked warning at this conversion. Oracle's reference
                     implementation of a Java compiler identifies the unchecked warning
                     here as a more informative <span class="emphasis"><em>unchecked generic array
                           creation</em></span>.
                  </p>
                  <p class="norm-dynamic"><a name="jls-15.12.4.2-210"></a>The
                     argument expressions (possibly rewritten as described above) are now
                     evaluated to yield <span class="emphasis"><em>argument values</em></span>. Each argument
                     value corresponds to exactly one of the method's <span class="emphasis"><em>n</em></span> formal
                     parameters.
                  </p>
                  <p class="norm-dynamic"><a name="jls-15.12.4.2-220"></a>The
                     argument expressions, if any, are evaluated in order, from left to
                     right. If the evaluation of any argument expression completes
                     abruptly, then no part of any argument expression to its right appears
                     to have been evaluated, and the method invocation completes abruptly
                     for the same reason. The result of evaluating the <span class="emphasis"><em>j</em></span>'th argument
                     expression is the <span class="emphasis"><em>j</em></span>'th argument value, for 1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>j</em></span> <span class="symbol">&#8804;</span>
                     <span class="emphasis"><em>n</em></span>. Evaluation then continues, using the argument values, as
                     described below.
                  </p>
               </div>
               <div class="section" title="15.12.4.3.&nbsp;Check Accessibility of Type and Method">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-15.12.4.3"></a>15.12.4.3.&nbsp;Check Accessibility of Type and Method
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm"><a name="jls-15.12.4.3-100"></a>Let <span class="type">C</span> be the class
                     containing the method invocation, and let <span class="type">T</span> be the qualifying type
                     of the method invocation (<a class="xref" href="jls-13.html#jls-13.1" title="13.1.&nbsp;The Form of a Binary">&sect;13.1</a>), and let <code class="varname">m</code> be
                     the name of the method as determined at compile time
                     (<a class="xref" href="jls-15.html#jls-15.12.3" title="15.12.3.&nbsp;Compile-Time Step 3: Is the Chosen Method Appropriate?">&sect;15.12.3</a>).
                  </p>
                  <p class="norm-dynamic"><a name="jls-15.12.4.3-110"></a>An
                     implementation of the Java programming language must ensure, as part of linkage, that
                     the method <code class="varname">m</code> still exists in the type <span class="type">T</span>. If this is not true, then
                     a <code class="literal">NoSuchMethodError</code> (which is a subclass of <code class="literal">IncompatibleClassChangeError</code>) occurs.
                  </p>
                  <p class="norm-dynamic"><a name="jls-15.12.4.3-120"></a>If
                     the invocation mode is <code class="literal">interface</code>, then the implementation must also
                     check that the target reference type still implements the specified
                     interface. If the target reference type does not still implement the
                     interface, then an <code class="literal">IncompatibleClassChangeError</code> occurs.
                  </p>
                  <p class="norm-dynamic"><a name="jls-15.12.4.3-130"></a>The
                     implementation must also ensure, during linkage, that the type <span class="type">T</span> and
                     the method <code class="varname">m</code> are accessible:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.4.3-130-A"></a>For the type
                                    <span class="type">T</span>:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.4.3-130-A-1"></a>If <span class="type">T</span> is in
                                       	  the same package as <span class="type">C</span>, then <span class="type">T</span> is accessible.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.4.3-130-A-2"></a>If <span class="type">T</span> is in
                                       	  a different package than <span class="type">C</span>, and <span class="type">T</span> is <code class="literal">public</code>, then <span class="type">T</span>
                                       	  is accessible.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.4.3-130-A-3"></a>If <span class="type">T</span> is in
                                       	  a different package than <span class="type">C</span>, and <span class="type">T</span> is <code class="literal">protected</code>, then
                                       	  <span class="type">T</span> is accessible if and only if <span class="type">C</span> is a subclass of
                                       	  <span class="type">T</span>.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="listitem">
                           <p class="norm"><a name="jls-15.12.4.3-130-B"></a>For the
                                    method <code class="varname">m</code>:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="circle">
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.4.3-130-B-1"></a>If <code class="varname">m</code> is
                                       	  <code class="literal">public</code>, then <code class="varname">m</code> is accessible. (All members of interfaces
                                       	  are <code class="literal">public</code> (<a class="xref" href="jls-9.html#jls-9.2" title="9.2.&nbsp;Interface Members">&sect;9.2</a>).)
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.4.3-130-B-2"></a>If <code class="varname">m</code> is
                                       	  <code class="literal">protected</code>, then <code class="varname">m</code> is accessible if and only if either
                                       	  <span class="type">T</span> is in the same package as <span class="type">C</span>, or <span class="type">C</span> is <span class="type">T</span> or a
                                       	  subclass of <span class="type">T</span>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.4.3-130-B-3"></a>If <code class="varname">m</code> has
                                       	  package access, then <code class="varname">m</code> is accessible if and only if <span class="type">T</span> is
                                       	  in the same package as <span class="type">C</span>.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm"><a name="jls-15.12.4.3-130-B-4"></a>If <code class="varname">m</code> is
                                       	  <code class="literal">private</code>, then <code class="varname">m</code> is accessible if and only if <span class="type">C</span> is <span class="type">T</span>,
                                       	  or <span class="type">C</span> encloses <span class="type">T</span>, or <span class="type">T</span> encloses <span class="type">C</span>, or <span class="type">T</span> and <span class="type">C</span> are
                                       	  both enclosed by a third class.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                     </ul>
                  </div>
                  <p class="norm"><a name="jls-15.12.4.3-140"></a>If either <span class="type">T</span>
                     or <code class="varname">m</code> is not accessible, then an <code class="literal">IllegalAccessError</code> occurs
                     (<a class="xref" href="jls-12.html#jls-12.3" title="12.3.&nbsp;Linking of Classes and Interfaces">&sect;12.3</a>).
                  </p>
               </div>
               <div class="section" title="15.12.4.4.&nbsp;Locate Method to Invoke">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-15.12.4.4"></a>15.12.4.4.&nbsp;Locate Method to Invoke
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm"><a name="jls-15.12.4.4-100"></a>The strategy for method
                     lookup depends on the invocation mode.
                  </p>
                  <p class="norm-dynamic"><a name="jls-15.12.4.4-110"></a>If
                     the invocation mode is <code class="literal">static</code>, no target reference is needed and
                     overriding is not allowed. Method <code class="varname">m</code> of class <span class="type">T</span> is the one to be
                     invoked.
                  </p>
                  <p class="norm-dynamic"><a name="jls-15.12.4.4-120"></a>
                     Otherwise, an instance method is to be invoked and there is a target
                     reference. If the target reference is <code class="literal">null</code>, a <code class="literal">NullPointerException</code> is thrown at
                     this point. Otherwise, the target reference is said to refer to
                     a <span class="emphasis"><em>target object</em></span> and will be used as the value of
                     the keyword <code class="literal">this</code> in the invoked method. The other four possibilities
                     for the invocation mode are then considered.
                  </p>
                  <p class="norm-dynamic"><a name="jls-15.12.4.4-200"></a>If
                     the invocation mode is <code class="literal">nonvirtual</code>, overriding is not allowed. Method
                     <code class="varname">m</code> of class <span class="type">T</span> is the one to be invoked.
                  </p>
                  <p class="norm-dynamic"><a name="jls-15.12.4.4-210"></a>Otherwise, if the
                     invocation mode is <code class="literal">virtual</code>, and <span class="type">T</span> and <code class="varname">m</code> jointly indicate a
                     signature polymorphic method (<a class="xref" href="jls-15.html#jls-15.12.3" title="15.12.3.&nbsp;Compile-Time Step 3: Is the Chosen Method Appropriate?">&sect;15.12.3</a>), then the
                     target object is an instance of <code class="literal">java.lang.invoke.MethodHandle</code>. The method handle
                     encapsulates a <span class="emphasis"><em>type</em></span> which is matched against the
                     information associated with the method invocation at compile time
                     (<a class="xref" href="jls-15.html#jls-15.12.3" title="15.12.3.&nbsp;Compile-Time Step 3: Is the Chosen Method Appropriate?">&sect;15.12.3</a>). Details of this matching are given in
                     <em class="citetitle">The Java Virtual Machine Specification, Java SE 8 Edition</em> and the Java SE platform API. If matching succeeds,
                     the <span class="emphasis"><em>target method</em></span> encapsulated by the method
                     handle is directly and immediately invoked,
                     <span class="emphasis"><em>and the procedure in <a class="xref" href="jls-15.html#jls-15.12.4.5" title="15.12.4.5.&nbsp;Create Frame, Synchronize, Transfer Control">&sect;15.12.4.5</a> is not
                           executed</em></span>.
                  </p>
                  <p class="norm-dynamic"><a name="jls-15.12.4.4-220"></a>
                     Otherwise, the invocation mode is <code class="literal">interface</code>, <code class="literal">virtual</code>, or <code class="literal">super</code>,
                     and overriding may occur. A <span class="emphasis"><em>dynamic method lookup</em></span>
                     is used. The dynamic lookup process starts from a class <span class="type">S</span>,
                     determined as follows:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm-dynamic"><a name="jls-15.12.4.4-220-A"></a>
                                    If the invocation mode is <code class="literal">interface</code> or <code class="literal">virtual</code>, then <span class="type">S</span> is
                                    initially the actual run-time class <span class="type">R</span> of the target
                                    object.
                           </p>
                           <p class="note">This is true even if the target object is an
                                    array instance. (Note that for invocation mode <code class="literal">interface</code>, <span class="type">R</span>
                                    necessarily implements <span class="type">T</span>; for invocation mode <code class="literal">virtual</code>, <span class="type">R</span>
                                    is necessarily either <span class="type">T</span> or a subclass of <span class="type">T</span>.)
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-dynamic"><a name="jls-15.12.4.4-220-B"></a>
                                    If the invocation mode is <code class="literal">super</code>, then <span class="type">S</span> is initially the
                                    qualifying type (<a class="xref" href="jls-13.html#jls-13.1" title="13.1.&nbsp;The Form of a Binary">&sect;13.1</a>) of the method
                                    invocation.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm-dynamic"><a name="jls-15.12.4.4-230"></a>The dynamic
                     method lookup uses the following procedure to search class <span class="type">S</span>, and
                     then the superclasses and superinterfaces of class <span class="type">S</span>, as necessary,
                     for method <code class="varname">m</code>.
                  </p>
                  <p class="norm"><a name="jls-15.12.4.4-240"></a>Let <span class="type">X</span> be the
                     compile-time type of the target reference of the method
                     invocation. Then:
                  </p>
                  <div class="orderedlist">
                     <ol class="orderedlist" type="1">
                        <li class="listitem">
                           <p class="norm-dynamic"><a name="jls-15.12.4.4-240-A"></a>
                                    If class <span class="type">S</span> contains a declaration for a method named <code class="varname">m</code> with
                                    the same descriptor (same number of parameters, the same
                                    parameter types, and the same return type) required by the
                                    method invocation as determined at compile time
                                    (<a class="xref" href="jls-15.html#jls-15.12.3" title="15.12.3.&nbsp;Compile-Time Step 3: Is the Chosen Method Appropriate?">&sect;15.12.3</a>), then:
                           </p>
                           <div class="norm">
                              <ul class="norm" type="disc">
                                 <li class="listitem">
                                    <p class="norm-dynamic"><a name="jls-15.12.4.4-240-A-A"></a>
                                       	  If the invocation mode is <code class="literal">super</code> or <code class="literal">interface</code>, then this
                                       	  is the method to be invoked, and the procedure
                                       	  terminates.
                                    </p>
                                 </li>
                                 <li class="listitem">
                                    <p class="norm-dynamic"><a name="jls-15.12.4.4-240-A-B"></a>
                                       	  If the invocation mode is <code class="literal">virtual</code>, and the declaration in
                                       	  <span class="type">S</span> overrides <span class="type">X</span><code class="literal">.</code><code class="varname">m</code> (<a class="xref" href="jls-8.html#jls-8.4.8.1" title="8.4.8.1.&nbsp;Overriding (by Instance Methods)">&sect;8.4.8.1</a>),
                                       	  then the method declared in <span class="type">S</span> is the method to be invoked,
                                       	  and the procedure terminates.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li class="listitem">
                           <p class="norm-dynamic"><a name="jls-15.12.4.4-240-B"></a>
                                    Otherwise, if <span class="type">S</span> has a superclass, the lookup procedure of
                                    steps 1 and 2 is performed recursively using the direct
                                    superclass of <span class="type">S</span> in place of <span class="type">S</span>; the method to be invoked, if
                                    any, is the result of the recursive invocation of this lookup
                                    procedure.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-dynamic"><a name="jls-15.12.4.4-240-C"></a>
                                    If no method is found by the previous two steps, the
                                    superinterfaces of <span class="type">S</span> are searched for a suitable method.
                           </p>
                           <p class="norm-dynamic"><a name="jls-15.12.4.4-240-C.1"></a>
                                    A set of candidate methods is considered with the following
                                    properties: i) each method is declared in a (direct or indirect)
                                    superinterface of <span class="type">S</span>; ii) each method has the name and
                                    descriptor required by the method invocation; iii) each method
                                    is non-<code class="literal">static</code>; iv) for each method, where the method's
                                    declaring interface is <span class="type">I</span>, there is no other method satisfying
                                    (i) through (iii) that is declared in a subinterface of
                                    <span class="type">I</span>.
                           </p>
                           <p class="norm-dynamic"><a name="jls-15.12.4.4-240-C.2"></a>
                                    If this set contains a default method, one such method is the
                                    method to be invoked. Otherwise, an <code class="literal">abstract</code> method in the set
                                    is selected as the method to be invoked.
                           </p>
                        </li>
                     </ol>
                  </div>
                  <p class="norm-error"><a name="jls-15.12.4.4-250"></a>Dynamic method
                     lookup may cause the following errors to occur:
                  </p>
                  <div class="norm">
                     <ul class="norm" type="disc">
                        <li class="listitem">
                           <p class="norm-error"><a name="jls-15.12.4.4-250-A"></a>
                                    If the method to be invoked is <code class="literal">abstract</code>, an <code class="literal">AbstractMethodError</code> is thrown.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-error"><a name="jls-15.12.4.4-250-B"></a>
                                    If the method to be invoked is default, and more than one
                                    default method appears in the set of candidates in step 3 above,
                                    an <code class="literal">IncompatibleClassChangeError</code> is thrown.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="norm-error"><a name="jls-15.12.4.4-250-C"></a>
                                    If the invocation mode is <code class="literal">interface</code> and the selected method is
                                    not <code class="literal">public</code>, an <code class="literal">IllegalAccessError</code> is thrown.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="norm-static"><a name="jls-15.12.4.4-260"></a>The above
                     procedure (if it terminates without error)
                     will  find a non-<code class="literal">abstract</code>, accessible method to invoke,
                     provided that all classes and interfaces in the program have been
                     consistently compiled. However, if this is not the case, then various
                     errors may occur, as specified above; additional details about the
                     behavior of the Java Virtual Machine under these circumstances are given by
                     <em class="citetitle">The Java Virtual Machine Specification, Java SE 8 Edition</em>.
                  </p>
                  <p class="note">The dynamic lookup process, while described here
                     explicitly, will often be implemented implicitly, for example as a
                     side-effect of the construction and use of per-class method dispatch
                     tables, or the construction of other per-class structures used for
                     efficient dispatch.
                  </p>
                  <div class="example"><a name="d5e26307"></a><p class="title"><b>Example&nbsp;15.12.4.4-1.&nbsp;Overriding and Method Invocation</b></p>
                     <div class="example-contents"><pre class="programlisting">
class Point {
    final int EDGE = 20;
    int x, y;
    void move(int dx, int dy) {
        x += dx; y += dy;
        if (Math.abs(x) &gt;= EDGE || Math.abs(y) &gt;= EDGE)
            clear();
    }
    void clear() {
        System.out.println("\tPoint clear");
        x = 0; y = 0;
    }
}
class ColoredPoint extends Point {
    int color;
    void clear() {
        System.out.println("\tColoredPoint clear");
        super.clear();
        color = 0;
    }
}
</pre><p class="note">Here, the subclass <code class="literal">ColoredPoint</code>
                           extends the <code class="literal">clear</code> abstraction defined by its
                           superclass <code class="literal">Point</code>. It does so by overriding
                           the <code class="literal">clear</code> method with its own method, which invokes
                           the <code class="literal">clear</code> method of its superclass, using the
                           form <code class="literal">super.clear()</code>.
                        </p>
                        <p class="note">This method is then invoked whenever the target
                           object for an invocation of <code class="literal">clear</code> is
                           a <code class="literal">ColoredPoint</code>. Even the
                           method <code class="literal">move</code> in <code class="literal">Point</code> invokes
                           the <code class="literal">clear</code> method of
                           class <code class="literal">ColoredPoint</code> when the class of <code class="literal">this</code>
                           is <code class="literal">ColoredPoint</code>, as shown by the output of this
                           test program:
                        </p><pre class="programlisting">
class Test1 {
    public static void main(String[] args) {
        Point p = new Point();
        System.out.println("p.move(20,20):");
        p.move(20, 20);

        ColoredPoint cp = new ColoredPoint();
        System.out.println("cp.move(20,20):");
        cp.move(20, 20);

        p = new ColoredPoint();
        System.out.println("p.move(20,20), p colored:");
        p.move(20, 20);
    }
}
</pre><p class="note">which is:</p><pre class="screen">
p.move(20,20):
        Point clear
cp.move(20,20):
        ColoredPoint clear
        Point clear
p.move(20,20), p colored:
        ColoredPoint clear
        Point clear
</pre><p class="note">Overriding is sometimes called "late-bound
                           self-reference"; in this example it means that the reference
                           to <code class="literal">clear</code> in the body
                           of <code class="literal">Point.move</code> (which is really syntactic shorthand
                           for <code class="literal">this.clear</code>) invokes a method chosen "late" (at
                           run time, based on the run-time class of the object referenced by
                           <code class="literal">this</code>) rather than a method chosen "early" (at compile time, based
                           only on the type of <code class="literal">this</code>). This provides the programmer a powerful
                           way of extending abstractions and is a key idea in object-oriented
                           programming.
                        </p>
                     </div>
                  </div><br class="example-break"><div class="example"><a name="d5e26335"></a><p class="title"><b>Example&nbsp;15.12.4.4-2.&nbsp;Method Invocation Using <code class="literal">super</code></b></p>
                     <div class="example-contents">
                        <p class="note">An overridden instance method of a superclass may be
                           accessed by using the keyword <code class="literal">super</code> to access the members of the
                           immediate superclass, bypassing any overriding declaration in the
                           class that contains the method invocation.
                        </p>
                        <p class="note">When accessing an instance variable, <code class="literal">super</code> means
                           the same as a cast of <code class="literal">this</code> (<a class="xref" href="jls-15.html#jls-15.11.2" title="15.11.2.&nbsp;Accessing Superclass Members using super">&sect;15.11.2</a>), but this
                           equivalence does not hold true for method invocation. This is
                           demonstrated by the example:
                        </p><pre class="programlisting">
class T1 {
    String s() { return "1"; }
}
class T2 extends T1 {
    String s() { return "2"; }
}
class T3 extends T2 {
    String s() { return "3"; }
    void test() {
        System.out.println("s()=\t\t"          + s());
        System.out.println("super.s()=\t"      + super.s());
        System.out.println("((T2)this).s()=\t" + ((T2)this).s());
        System.out.println("((T1)this).s()=\t" + ((T1)this).s());
    }
}
class Test2 {
    public static void main(String[] args) {
        T3 t3 = new T3();
        t3.test();
    }
}
</pre><p class="note">which produces the output:</p><pre class="screen">
s()=            3
super.s()=      2
((T2)this).s()= 3
((T1)this).s()= 3
</pre><p class="note">The casts to types <code class="literal">T1</code>
                           and <code class="literal">T2</code> do not change the method that is invoked,
                           because the instance method to be invoked is chosen according to the
                           run-time class of the object referred to by <code class="literal">this</code>. A cast does not
                           change the class of an object; it only checks that the class is
                           compatible with the specified type.
                        </p>
                     </div>
                  </div><br class="example-break"></div>
               <div class="section" title="15.12.4.5.&nbsp;Create Frame, Synchronize, Transfer Control">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="jls-15.12.4.5"></a>15.12.4.5.&nbsp;Create Frame, Synchronize, Transfer Control
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p class="norm-dynamic"><a name="jls-15.12.4.5-100"></a>A
                     method <code class="varname">m</code> in some class <span class="type">S</span> has been identified as the one to be
                     invoked.
                  </p>
                  <p class="norm-dynamic"><a name="jls-15.12.4.5-110"></a>Now a
                     new <span class="emphasis"><em>activation frame</em></span> is created, containing the
                     target reference (if any) and the argument values (if any), as well as
                     enough space for the local variables and stack for the method to be
                     invoked and any other bookkeeping information that may be required by
                     the implementation (stack pointer, program counter, reference to
                     previous activation frame, and the like). If there is not sufficient
                     memory available to create such an activation frame, a <code class="literal">StackOverflowError</code> is
                     thrown.
                  </p>
                  <p class="norm-dynamic"><a name="jls-15.12.4.5-120"></a>The
                     newly created activation frame becomes the current activation
                     frame. The effect of this is to assign the argument values to
                     corresponding freshly created parameter variables of the method, and
                     to make the target reference available as <code class="literal">this</code>, if there is a target
                     reference. Before each argument value is assigned to its corresponding
                     parameter variable, it is subjected to invocation conversion
                     (<a class="xref" href="jls-5.html#jls-5.3" title="5.3.&nbsp;Invocation Contexts">&sect;5.3</a>), which includes any required value set
                     conversion (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>).
                  </p>
                  <p class="norm-dynamic"><a name="jls-15.12.4.5-130"></a>If
                     the erasure (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>) of the type of the method
                     being invoked differs in its signature from the erasure of the type of
                     the compile-time declaration for the method invocation
                     (<a class="xref" href="jls-15.html#jls-15.12.3" title="15.12.3.&nbsp;Compile-Time Step 3: Is the Chosen Method Appropriate?">&sect;15.12.3</a>), then if any of the argument values is
                     an object which is not an instance of a subclass or subinterface of
                     the erasure of the corresponding formal parameter type in the
                     compile-time declaration for the method invocation, then a <code class="literal">ClassCastException</code> is
                     thrown.
                  </p>
                  <p class="norm"><a name="jls-15.12.4.5-140"></a>If the method <code class="varname">m</code> is a
                     <code class="literal">native</code> method but the necessary native, implementation-dependent
                     binary code has not been loaded or otherwise cannot be dynamically
                     linked, then an <code class="literal">UnsatisfiedLinkError</code> is thrown.
                  </p>
                  <p class="norm"><a name="jls-15.12.4.5-200"></a>If the method <code class="varname">m</code> is not
                     <code class="literal">synchronized</code>, control is transferred to the body of the method <code class="varname">m</code>
                     to be invoked.
                  </p>
                  <p class="norm"><a name="jls-15.12.4.5-210"></a>If the method <code class="varname">m</code> is
                     <code class="literal">synchronized</code>, then an object must be locked before the transfer of
                     control. No further progress can be made until the current thread can
                     obtain the lock. If there is a target reference, then the target
                     object must be locked; otherwise the <code class="literal">Class</code> object for class <span class="type">S</span>, the
                     class of the method <code class="varname">m</code>, must be locked. Control is then transferred
                     to the body of the method <code class="varname">m</code> to be invoked. The object is
                     automatically unlocked when execution of the body of the method has
                     completed, whether normally or abruptly. The locking and unlocking
                     behavior is exactly as if the body of the method were embedded in a
                     <code class="literal">synchronized</code> statement (<a class="xref" href="jls-14.html#jls-14.19" title="14.19.&nbsp;The synchronized Statement">&sect;14.19</a>).
                  </p>
                  <div class="example"><a name="d5e26384"></a><p class="title"><b>Example&nbsp;15.12.4.5-1.&nbsp;Invoked Method Signature Has Different Erasure Than
                           Compile-Time Method Signature</b></p>
                     <div class="example-contents">
                        <p class="note">Consider the declarations:</p><pre class="programlisting">
abstract class C&lt;T&gt; {
    abstract T id(T x);
}
class D extends C&lt;String&gt; {
    String id(String x) { return x; }
}
</pre><p class="note">Now, given an invocation:</p><pre class="screen">
C c = new D();
c.id(new Object());  // fails with a ClassCastException
</pre><p class="note">The erasure of the actual method being
                           invoked, <code class="literal">D.id()</code>, differs in its signature from that
                           of the compile-time method declaration, <code class="literal">C.id()</code>. The
                           former takes an argument of type <code class="literal">String</code> while the latter takes an
                           argument of type <code class="literal">Object</code>. The invocation fails with a <code class="literal">ClassCastException</code> before
                           the body of the method is executed.
                        </p>
                        <p class="note">Such situations can only arise if the program gives
                           rise to a compile-time unchecked warning (<a class="xref" href="jls-4.html#jls-4.8" title="4.8.&nbsp;Raw Types">&sect;4.8</a>,
                           <a class="xref" href="jls-5.html#jls-5.1.9" title="5.1.9.&nbsp;Unchecked Conversion">&sect;5.1.9</a>, <a class="xref" href="jls-5.html#jls-5.5.2" title="5.5.2.&nbsp;Checked Casts and Unchecked Casts">&sect;5.5.2</a>,
                           <a class="xref" href="jls-8.html#jls-8.4.1" title="8.4.1.&nbsp;Formal Parameters">&sect;8.4.1</a>, <a class="xref" href="jls-8.html#jls-8.4.8.3" title="8.4.8.3.&nbsp;Requirements in Overriding and Hiding">&sect;8.4.8.3</a>,
                           <a class="xref" href="jls-8.html#jls-8.4.8.4" title="8.4.8.4.&nbsp;Inheriting Methods with Override-Equivalent Signatures">&sect;8.4.8.4</a>, <a class="xref" href="jls-9.html#jls-9.4.1.2" title="9.4.1.2.&nbsp;Requirements in Overriding">&sect;9.4.1.2</a>,
                           <a class="xref" href="jls-15.html#jls-15.12.4.2" title="15.12.4.2.&nbsp;Evaluate Arguments">&sect;15.12.4.2</a>).
                        </p>
                        <p class="note">Implementations can enforce these semantics by
                           creating <span class="emphasis"><em>bridge methods</em></span>. In the above example,
                           the following bridge method would be created in
                           class <code class="literal">D</code>:
                        </p><pre class="screen">
Object id(Object x) { return id((String) x); }
</pre><p class="note">This is the method that would actually be invoked by
                           the Java Virtual Machine in response to the call <code class="literal">c.id(new
                              Object())</code> shown above, and it will execute the cast and
                           fail, as required.
                        </p>
                     </div>
                  </div><br class="example-break"></div>
            </div>
         </div>
         <div class="section" title="15.13.&nbsp;Method Reference Expressions">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.13"></a>15.13.&nbsp;Method Reference Expressions
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-15.13-100"></a>A method reference expression
               is used to refer to the invocation of a method without actually
               performing the invocation. Certain forms of method reference
               expression also allow class instance creation
               (<a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>) or array creation
               (<a class="xref" href="jls-15.html#jls-15.10" title="15.10.&nbsp;Array Creation and Access Expressions">&sect;15.10</a>) to be treated as if it were a method
               invocation.
            </p>
            <div id="jls-15.13-110" class="productionset"><a name="jls-15.13-110"></a>
                 
               <div class="production"><a name="jls-MethodReference"></a>
                      
                  <div class="lhs">MethodReference:</div>
                      
                  <div class="rhs">
                           
                           <a href="jls-6.html#jls-ExpressionName" title="ExpressionName">ExpressionName</a> <code class="literal">::</code>
                           [<a href="jls-4.html#jls-TypeArguments" title="TypeArguments">TypeArguments</a>] <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a> <br>
                     
                           
                           <a href="jls-4.html#jls-ReferenceType" title="ReferenceType">ReferenceType</a> <code class="literal">::</code>
                           [<a href="jls-4.html#jls-TypeArguments" title="TypeArguments">TypeArguments</a>] <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a> <br>
                     
                           
                           <a href="jls-15.html#jls-Primary" title="Primary">Primary</a> <code class="literal">::</code>
                           [<a href="jls-4.html#jls-TypeArguments" title="TypeArguments">TypeArguments</a>] <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a> <br>
                     
                           
                           <code class="literal">super</code> <code class="literal">::</code>
                           [<a href="jls-4.html#jls-TypeArguments" title="TypeArguments">TypeArguments</a>] <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a> <br>
                     
                           
                           <a href="jls-6.html#jls-TypeName" title="TypeName">TypeName</a> <code class="literal">.</code> <code class="literal">super</code> <code class="literal">::</code>
                           [<a href="jls-4.html#jls-TypeArguments" title="TypeArguments">TypeArguments</a>] <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a> <br>
                     
                           
                           <a href="jls-4.html#jls-ClassType" title="ClassType">ClassType</a> <code class="literal">::</code>
                           [<a href="jls-4.html#jls-TypeArguments" title="TypeArguments">TypeArguments</a>] <code class="literal">new</code> <br>
                     
                           
                           <a href="jls-4.html#jls-ArrayType" title="ArrayType">ArrayType</a> <code class="literal">::</code> <code class="literal">new</code>
                         
                  </div>
                    
               </div>
               
            </div>
            <p class="norm-error"><a name="jls-15.13-200"></a>If
               <span class="emphasis"><em>TypeArguments</em></span> is present to the right of <code class="literal">::</code>, then it is a
               compile-time error if any of the type arguments are wildcards
               (<a class="xref" href="jls-4.html#jls-4.5.1" title="4.5.1.&nbsp;Type Arguments of Parameterized Types">&sect;4.5.1</a>).
            </p>
            <p class="norm-error"><a name="jls-15.13-210"></a>If a method
               reference expression has the form <span class="emphasis"><em>ExpressionName</em></span> <code class="literal">::</code>
               <span class="emphasis"><em>[TypeArguments]</em></span> <span class="emphasis"><em>Identifier</em></span> or <span class="emphasis"><em>Primary</em></span> <code class="literal">::</code>
               <span class="emphasis"><em>[TypeArguments]</em></span> <span class="emphasis"><em>Identifier</em></span>, it is a compile-time error if the
               type of the <span class="emphasis"><em>ExpressionName</em></span> or <span class="emphasis"><em>Primary</em></span> is not a reference
               type.
            </p>
            <p class="norm-error"><a name="jls-15.13-220"></a>If a method
               reference expression has the form <code class="literal">super</code> <code class="literal">::</code>
               <span class="emphasis"><em>[TypeArguments]</em></span> <span class="emphasis"><em>Identifier</em></span>, let <span class="type">T</span> be the type declaration
               immediately enclosing the method reference expression. It is a
               compile-time error if <span class="type">T</span> is the class <code class="literal">Object</code> or <span class="type">T</span> is an
               interface.
            </p>
            <p class="norm-error"><a name="jls-15.13-230"></a>If a method
               reference expression has the form <span class="emphasis"><em>TypeName</em></span> <code class="literal">.</code> <code class="literal">super</code>
               <code class="literal">::</code> <span class="emphasis"><em>[TypeArguments]</em></span> <span class="emphasis"><em>Identifier</em></span>, then:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-error"><a name="jls-15.13-230-A"></a>
                              If <span class="emphasis"><em>TypeName</em></span> denotes a class, <span class="type">C</span>, then it is a compile-time
                              error if <span class="type">C</span> is not a lexically enclosing class of the current
                              class, or if <span class="type">C</span> is the class <code class="literal">Object</code>.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-error"><a name="jls-15.13-230-B"></a>
                              If <span class="emphasis"><em>TypeName</em></span> denotes an interface, <span class="type">I</span>, then let <span class="type">T</span> be the
                              type declaration immediately enclosing the method reference
                              expression. It is a compile-time error if <span class="type">I</span> is not a direct
                              superinterface of <span class="type">T</span>, or if there exists some other direct
                              superclass or direct superinterface of <span class="type">T</span>, <span class="type">J</span>, such that <span class="type">J</span>
                              is a subtype of <span class="type">I</span>.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-error"><a name="jls-15.13-230-C"></a>
                              If <span class="emphasis"><em>TypeName</em></span> denotes a type variable, then a compile-time error
                              occurs.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm-error"><a name="jls-15.13-240"></a>If a method
               reference expression has the form <code class="literal">super</code> <code class="literal">::</code>
               <span class="emphasis"><em>[TypeArguments]</em></span> <span class="emphasis"><em>Identifier</em></span> or <span class="emphasis"><em>TypeName</em></span> <code class="literal">.</code> <code class="literal">super</code>
               <code class="literal">::</code> <span class="emphasis"><em>[TypeArguments]</em></span> <span class="emphasis"><em>Identifier</em></span>, it is a compile-time
               error if the expression occurs in a static context.
            </p>
            <p class="norm-error"><a name="jls-15.13-250"></a>If a method
               reference expression has the form <span class="emphasis"><em>ClassType</em></span> <code class="literal">::</code>
               <span class="emphasis"><em>[TypeArguments]</em></span> <code class="literal">new</code>, then:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-error"><a name="jls-15.13-250-A"></a>
                              <span class="emphasis"><em>ClassType</em></span> must denote a class that is accessible,
                              non-<code class="literal">abstract</code>, and not an enum type, or a compile-time error
                              occurs.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-error"><a name="jls-15.13-250-B"></a>
                              If <span class="emphasis"><em>ClassType</em></span> denotes a parameterized type
                              (<a class="xref" href="jls-4.html#jls-4.5" title="4.5.&nbsp;Parameterized Types">&sect;4.5</a>), then it is a compile-time error if
                              any of its type arguments are wildcards.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-error"><a name="jls-15.13-250-C"></a>
                              If <span class="emphasis"><em>ClassType</em></span> denotes a raw type (<a class="xref" href="jls-4.html#jls-4.8" title="4.8.&nbsp;Raw Types">&sect;4.8</a>),
                              then it is a compile-time error if <span class="emphasis"><em>TypeArguments</em></span> is present
                              after the <code class="literal">::</code>.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm-error"><a name="jls-15.13-260"></a>If a method
               reference expression has the form <span class="emphasis"><em>ArrayType</em></span> <code class="literal">::</code> <code class="literal">new</code>, then
               <span class="emphasis"><em>ArrayType</em></span> must denote a type that is reifiable
               (<a class="xref" href="jls-4.html#jls-4.7" title="4.7.&nbsp;Reifiable Types">&sect;4.7</a>), or a compile-time error occurs.
            </p>
            <p class="norm"><a name="jls-15.13-300"></a>The target reference of an
               instance method (<a class="xref" href="jls-15.html#jls-15.12.4.1" title="15.12.4.1.&nbsp;Compute Target Reference (If Necessary)">&sect;15.12.4.1</a>) may be provided by
               the method reference expression using an <span class="emphasis"><em>ExpressionName</em></span>, a
               <span class="emphasis"><em>Primary</em></span>, or <code class="literal">super</code>, or it may be provided later when the method is
               invoked. The immediately enclosing instance of a new inner class
               instance (<a class="xref" href="jls-15.html#jls-15.9.2" title="15.9.2.&nbsp;Determining Enclosing Instances">&sect;15.9.2</a>) must be provided by a
               lexically enclosing instance of <code class="literal">this</code>
               (<a class="xref" href="jls-8.html#jls-8.1.3" title="8.1.3.&nbsp;Inner Classes and Enclosing Instances">&sect;8.1.3</a>).
            </p>
            <p class="norm"><a name="jls-15.13-310"></a>When more than one member
               method of a type has the same name, or when a class has more than one
               constructor, the appropriate method or constructor is selected based
               on the functional interface type targeted by the expression, as
               specified in <a class="xref" href="jls-15.html#jls-15.13.1" title="15.13.1.&nbsp;Compile-Time Declaration of a Method Reference">&sect;15.13.1</a>.
            </p>
            <p class="norm"><a name="jls-15.13-320"></a>If a method or constructor is
               generic, the appropriate type arguments may either be inferred or
               provided explicitly. Similarly, the type arguments of a generic type
               mentioned by the method reference expression may be provided
               explicitly or inferred.
            </p>
            <p class="norm-static"><a name="jls-15.13-400"></a>Method
               reference expressions are always poly expressions
               (<a class="xref" href="jls-15.html#jls-15.2" title="15.2.&nbsp;Forms of Expressions">&sect;15.2</a>).
            </p>
            <p class="norm-error"><a name="jls-15.13-410"></a>It is a
               compile-time error if a method reference expression occurs in a
               program in someplace other than an assignment context
               (<a class="xref" href="jls-5.html#jls-5.2" title="5.2.&nbsp;Assignment Contexts">&sect;5.2</a>), an invocation context
               (<a class="xref" href="jls-5.html#jls-5.3" title="5.3.&nbsp;Invocation Contexts">&sect;5.3</a>), or a casting context
               (<a class="xref" href="jls-5.html#jls-5.5" title="5.5.&nbsp;Casting Contexts">&sect;5.5</a>).
            </p>
            <p class="norm-dynamic"><a name="jls-15.13-500"></a>
               Evaluation of a method reference expression produces an instance of a
               functional interface type (<a class="xref" href="jls-9.html#jls-9.8" title="9.8.&nbsp;Functional Interfaces">&sect;9.8</a>). Method
               reference evaluation does <span class="emphasis"><em>not</em></span> cause the execution
               of the corresponding method; instead, this may occur at a later time
               when an appropriate method of the functional interface is
               invoked.
            </p>
            <div class="informalexample">
               <p class="note">Here are some method reference expressions, first
                  with no target reference and then with a target reference:
               </p><pre class="screen">
String::length             // instance method
System::currentTimeMillis  // static method
List&lt;String&gt;::size  // explicit type arguments for generic type
List::size          // inferred type arguments for generic type
int[]::clone
T::tvarMember

System.out::println
"abc"::length
foo[x]::bar
(test ? list.replaceAll(String::trim) : list) :: iterator
super::toString
</pre><p class="note">Here are some more method reference expressions:</p><pre class="screen">
String::valueOf       // overload resolution needed     
Arrays::sort          // type arguments inferred from context
Arrays::&lt;String&gt;sort  // explicit type arguments
</pre><p class="note">Here are some method reference expressions that
                  represent a deferred creation of an object or an array:
               </p><pre class="screen">
ArrayList&lt;String&gt;::new     // constructor for parameterized type
ArrayList::new             // inferred type arguments
                           // for generic class
Foo::&lt;Integer&gt;new          // explicit type arguments
                           // for generic constructor
Bar&lt;String&gt;::&lt;Integer&gt;new  // generic class, generic constructor
Outer.Inner::new           // inner class constructor
int[]::new                 // array creation
</pre></div>
            <p class="note">It is not possible to specify a particular signature
               to be matched, for example, <code class="literal">Arrays::sort(int[])</code>.
               Instead, the functional interface provides argument types that are
               used as input to the overload resolution algorithm
               (<a class="xref" href="jls-15.html#jls-15.12.2" title="15.12.2.&nbsp;Compile-Time Step 2: Determine Method Signature">&sect;15.12.2</a>). This should satisfy the vast majority
               of use cases; when the rare need arises for more precise control, a
               lambda expression can be used.
            </p>
            <p class="note">The use of type argument syntax in the class name
               before a delimiter (<code class="literal">List&lt;String&gt;::size</code>)
               raises the parsing problem of distinguishing between <code class="literal">&lt;</code> as a
               type argument bracket and <code class="literal">&lt;</code> as a less-than operator. In theory,
               this is no worse than allowing type arguments in cast expressions;
               however, the difference is that the cast case only comes up when a
               <code class="literal">(</code> token is encountered; with the addition of method reference
               expressions, the start of <span class="emphasis"><em>every</em></span> expression is
               potentially a parameterized type.
            </p>
            <div class="section" title="15.13.1.&nbsp;Compile-Time Declaration of a Method Reference">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.13.1"></a>15.13.1.&nbsp;Compile-Time Declaration of a Method Reference
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.13.1-100"></a>The 
                  <span class="emphasis"><em>compile-time declaration</em></span> of a method reference is
                  the method to which the expression refers. In special cases, the
                  compile-time declaration does not actually exist, but is a notional
                  method that represents a class instance creation or an array
                  creation. The choice of compile-time declaration depends on a function
                  type targeted by the expression, just as the compile-time declaration
                  of a method invocation depends on the invocation's arguments
                  (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>).
               </p>
               <p class="norm-static"><a name="jls-15.13.1-200"></a>The
                  search for a compile-time declaration mirrors the process for method
                  invocations in <a class="xref" href="jls-15.html#jls-15.12.1" title="15.12.1.&nbsp;Compile-Time Step 1: Determine Class or Interface to Search">&sect;15.12.1</a> and
                  <a class="xref" href="jls-15.html#jls-15.12.2" title="15.12.2.&nbsp;Compile-Time Step 2: Determine Method Signature">&sect;15.12.2</a>, as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.13.1-200-A"></a>
                                 First, a type to search is determined:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.13.1-200-A-A"></a>
                                    	  If the method reference expression has the form
                                              <span class="emphasis"><em>ExpressionName</em></span> <code class="literal">::</code> <span class="emphasis"><em>[TypeArguments]</em></span>
                                              <span class="emphasis"><em>Identifier</em></span> or <span class="emphasis"><em>Primary</em></span> <code class="literal">::</code> <span class="emphasis"><em>[TypeArguments]</em></span>
                                              <span class="emphasis"><em>Identifier</em></span>, the type to search is the type of the
                                              expression preceding the <code class="literal">::</code> token.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.13.1-200-A-B"></a>
                                    	  If the method reference expression has the form
                                              <span class="emphasis"><em>ReferenceType</em></span> <code class="literal">::</code> <span class="emphasis"><em>[TypeArguments]</em></span>
                                              <span class="emphasis"><em>Identifier</em></span>, the type to search is the result of capture
                                              conversion (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>) applied to
                                              <span class="emphasis"><em>ReferenceType</em></span>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.13.1-200-A-C"></a>
                                    	  If the method reference expression has the form <code class="literal">super</code>
                                    	  <code class="literal">::</code> <span class="emphasis"><em>[TypeArguments]</em></span> <span class="emphasis"><em>Identifier</em></span>, the type to
                                    	  search is the superclass type of the class whose declaration
                                    	  contains the method reference.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.13.1-200-A-D"></a>
                                    	  If the method reference expression has the form <span class="emphasis"><em>TypeName</em></span>
                                    	  <code class="literal">.</code> <code class="literal">super</code> <code class="literal">::</code> <span class="emphasis"><em>[TypeArguments]</em></span> <span class="emphasis"><em>Identifier</em></span>,
                                    	  then if <span class="emphasis"><em>TypeName</em></span> denotes a class, the type to search is
                                    	  the superclass type of the named class; otherwise,
                                    	  <span class="emphasis"><em>TypeName</em></span> denotes an interface, and the corresponding
                                    	  superinterface type of the class or interface whose
                                    	  declaration contains the method reference is the type to
                                    	  search.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.13.1-200-A-E"></a>
                                    	  For the two other forms (involving <code class="literal">::</code> <code class="literal">new</code>), the
                                    	  referenced method is notional and there is no type to
                                    	  search.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.13.1-200-B"></a>
                                 Second, given a targeted function type with <span class="emphasis"><em>n</em></span> parameters, a
                                 set of potentially applicable methods is identified:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.13.1-200-B-A"></a>
                                    	  If the method reference expression has the form
                                    	  <span class="emphasis"><em>ReferenceType</em></span> <code class="literal">::</code> <span class="emphasis"><em>[TypeArguments]</em></span>
                                    	  <span class="emphasis"><em>Identifier</em></span>, the potentially applicable methods are the
                                    	  member methods of the type to search that have an
                                    	  appropriate name (given by <span class="emphasis"><em>Identifier</em></span>), accessibility,
                                    	  arity (<span class="emphasis"><em>n</em></span> or <span class="emphasis"><em>n-1</em></span>), and type
                                    	  argument arity (derived from <span class="emphasis"><em>[TypeArguments]</em></span>), as
                                    	  specified in <a class="xref" href="jls-15.html#jls-15.12.2.1" title="15.12.2.1.&nbsp;Identify Potentially Applicable Methods">&sect;15.12.2.1</a>.
                                 </p>
                                 <p class="note">Two different arities, <span class="emphasis"><em>n</em></span>
                                    	  and <span class="emphasis"><em>n-1</em></span>, are considered, to account for
                                    	  the possibility that this form refers to either a <code class="literal">static</code>
                                    	  method or an instance method.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.13.1-200-B-B"></a>
                                    	  If the method reference expression has the form <span class="emphasis"><em>ClassType</em></span>
                                    	  <code class="literal">::</code> <span class="emphasis"><em>[TypeArguments]</em></span> <code class="literal">new</code>, the potentially
                                    	  applicable methods are a set of notional methods
                                    	  corresponding to the constructors of <span class="emphasis"><em>ClassType</em></span>.
                                 </p>
                                 <p class="norm-static"><a name="jls-15.13.1-200-B-B.1"></a>
                                    	  If <span class="emphasis"><em>ClassType</em></span> is a raw type, but is not a non-<code class="literal">static</code>
                                    	  member type of a raw type, the candidate notional member
                                    	  methods are those specified in <a class="xref" href="jls-15.html#jls-15.9.3" title="15.9.3.&nbsp;Choosing the Constructor and its Arguments">&sect;15.9.3</a>
                                    	  for a class instance creation expression that uses <code class="literal">&lt;&gt;</code>
                                    	  to elide the type arguments to a class.
                                 </p>
                                 <p class="norm-static"><a name="jls-15.13.1-200-B-B.2"></a>
                                    	  Otherwise, the candidate notional member methods are the
                                    	  constructors of <span class="emphasis"><em>ClassType</em></span>, treated as if they were methods
                                    	  with return type <span class="emphasis"><em>ClassType</em></span>. Among these candidates, the
                                    	  methods with appropriate accessibility, arity (<span class="emphasis"><em>n</em></span>), and
                                    	  type argument arity (derived from <span class="emphasis"><em>[TypeArguments]</em></span>) are
                                    	  selected, as specified in
                                    	  <a class="xref" href="jls-15.html#jls-15.12.2.1" title="15.12.2.1.&nbsp;Identify Potentially Applicable Methods">&sect;15.12.2.1</a>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.13.1-200-B-C"></a>
                                    	  If the method reference expression has the form <span class="emphasis"><em>ArrayType</em></span>
                                    	  <code class="literal">::</code> <code class="literal">new</code>, a single notional method is
                                    	  considered. The method has a single parameter of type <code class="literal">int</code>,
                                    	  returns the <span class="emphasis"><em>ArrayType</em></span>, and has no <code class="literal">throws</code>
                                    	  clause. If <span class="emphasis"><em>n = 1</em></span>, this is the only
                                    	  potentially applicable method; otherwise, there are no
                                    	  potentially applicable methods.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.13.1-200-B-D"></a>
                                    	  For all other forms, the potentially applicable methods are
                                    	  the member methods of the type to search that have an
                                    	  appropriate name (given by <span class="emphasis"><em>Identifier</em></span>), accessibility,
                                    	  arity (<span class="emphasis"><em>n</em></span>), and type argument arity (derived from
                                    	  <span class="emphasis"><em>[TypeArguments]</em></span>), as specified in
                                    	  <a class="xref" href="jls-15.html#jls-15.12.2.1" title="15.12.2.1.&nbsp;Identify Potentially Applicable Methods">&sect;15.12.2.1</a>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.13.1-200-C"></a>
                                 Finally, if there are no potentially applicable methods, then
                                 there is no compile-time declaration.
                        </p>
                        <p class="norm-static"><a name="jls-15.13.1-200-C.1"></a>
                                 Otherwise, given a targeted function type with parameter types
                                 <span class="type">P<sub>1</sub></span>, ..., <span class="type">P<sub>n</sub></span> and a set of potentially applicable methods, the
                                 compile-time declaration is selected as follows:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.13.1-200-C.1-A"></a>
                                    	  If the method reference expression has the form
                                    	  <span class="emphasis"><em>ReferenceType</em></span> <code class="literal">::</code> <span class="emphasis"><em>[TypeArguments]</em></span>
                                    	  <span class="emphasis"><em>Identifier</em></span>, then two searches for a most specific
                                    	  applicable method are performed. Each search is as specified
                                    	  in <a class="xref" href="jls-15.html#jls-15.12.2.2" title="15.12.2.2.&nbsp;Phase 1: Identify Matching Arity Methods Applicable by Strict Invocation">&sect;15.12.2.2</a> through
                                    	  <a class="xref" href="jls-15.html#jls-15.12.2.5" title="15.12.2.5.&nbsp;Choosing the Most Specific Method">&sect;15.12.2.5</a>, with the clarifications
                                    	  below. Each search may produce a method or, in the case of
                                    	  an error as specified in <a class="xref" href="jls-15.html#jls-15.12.2.2" title="15.12.2.2.&nbsp;Phase 1: Identify Matching Arity Methods Applicable by Strict Invocation">&sect;15.12.2.2</a>
                                    	  through <a class="xref" href="jls-15.html#jls-15.12.2.5" title="15.12.2.5.&nbsp;Choosing the Most Specific Method">&sect;15.12.2.5</a>, no result.
                                 </p>
                                 <p class="norm-static"><a name="jls-15.13.1-200-C.1-A.1"></a>
                                    	  In the first search, the method reference is treated as if
                                    	  it were an invocation with argument expressions of types
                                    	  <span class="type">P<sub>1</sub></span>, ..., <span class="type">P<sub>n</sub></span>; the type arguments, if any, are given by
                                    	  the method reference expression.
                                 </p>
                                 <p class="norm-static"><a name="jls-15.13.1-200-C.1-A.2"></a>
                                    	  In the second search, if <span class="type">P<sub>1</sub></span>, ..., <span class="type">P<sub>n</sub></span> is not empty and
                                    	  <span class="type">P<sub>1</sub></span> is a subtype of <span class="emphasis"><em>ReferenceType</em></span>, then the method
                                    	  reference expression is treated as if it were a method
                                    	  invocation expression with argument expressions of types
                                    	  <span class="type">P<sub>2</sub></span>, ..., <span class="type">P<sub>n</sub></span>. If <span class="emphasis"><em>ReferenceType</em></span> is a raw type, and there
                                    	  exists a parameterization of this type,
                                    	  <span class="type">G</span><code class="literal">&lt;</code>...<code class="literal">&gt;</code>, that is a supertype of <span class="type">P<sub>1</sub></span>, the
                                    	  type to search is the result of capture conversion
                                    	  (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>) applied to
                                    	  <span class="type">G</span><code class="literal">&lt;</code>...<code class="literal">&gt;</code>; otherwise, the type to search is the
                                    	  same as the type of the first search. Again, the type
                                    	  arguments, if any, are given by the method reference
                                    	  expression.
                                 </p>
                                 <p class="norm-static"><a name="jls-15.13.1-200-C.1-A.3"></a>
                                    	  If the first search produces a <code class="literal">static</code> method, and no
                                    	  non-<code class="literal">static</code> method is applicable by
                                    	  <a class="xref" href="jls-15.html#jls-15.12.2.2" title="15.12.2.2.&nbsp;Phase 1: Identify Matching Arity Methods Applicable by Strict Invocation">&sect;15.12.2.2</a>,
                                    	  <a class="xref" href="jls-15.html#jls-15.12.2.3" title="15.12.2.3.&nbsp;Phase 2: Identify Matching Arity Methods Applicable by Loose Invocation">&sect;15.12.2.3</a>, or
                                    	  <a class="xref" href="jls-15.html#jls-15.12.2.4" title="15.12.2.4.&nbsp;Phase 3: Identify Methods Applicable by Variable Arity Invocation">&sect;15.12.2.4</a> during the second search,
                                    	  then the compile-time declaration is the result of the first
                                    	  search.
                                 </p>
                                 <p class="norm-static"><a name="jls-15.13.1-200-C.1-A.4"></a>
                                    	  Otherwise, if no <code class="literal">static</code> method is applicable by
                                    	  <a class="xref" href="jls-15.html#jls-15.12.2.2" title="15.12.2.2.&nbsp;Phase 1: Identify Matching Arity Methods Applicable by Strict Invocation">&sect;15.12.2.2</a>,
                                    	  <a class="xref" href="jls-15.html#jls-15.12.2.3" title="15.12.2.3.&nbsp;Phase 2: Identify Matching Arity Methods Applicable by Loose Invocation">&sect;15.12.2.3</a>, or
                                    	  <a class="xref" href="jls-15.html#jls-15.12.2.4" title="15.12.2.4.&nbsp;Phase 3: Identify Methods Applicable by Variable Arity Invocation">&sect;15.12.2.4</a> during the first search, and
                                    	  the second search produces a non-<code class="literal">static</code> method, then the
                                    	  compile-time declaration is the result of the second
                                    	  search.
                                 </p>
                                 <p class="norm-static"><a name="jls-15.13.1-200-C.1-A.5"></a>
                                    	  Otherwise, there is no compile-time declaration.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.13.1-200-C.1-B"></a>
                                    	  For all other forms of method reference expression, one
                                    	  search for a most specific applicable method is
                                    	  performed. The search is as specified in
                                    	  <a class="xref" href="jls-15.html#jls-15.12.2.2" title="15.12.2.2.&nbsp;Phase 1: Identify Matching Arity Methods Applicable by Strict Invocation">&sect;15.12.2.2</a> through
                                    	  <a class="xref" href="jls-15.html#jls-15.12.2.5" title="15.12.2.5.&nbsp;Choosing the Most Specific Method">&sect;15.12.2.5</a>, with the clarifications
                                    	  below.
                                 </p>
                                 <p class="norm-static"><a name="jls-15.13.1-200-C.1-B.1"></a>
                                    	  The method reference is treated as if it were an invocation
                                    	  with argument expressions of types <span class="type">P<sub>1</sub></span>, ..., <span class="type">P<sub>n</sub></span>; the type
                                    	  arguments, if any, are given by the method reference
                                    	  expression.
                                 </p>
                                 <p class="norm-static"><a name="jls-15.13.1-200-C.1-B.2"></a>
                                    	  If the search results in an error as specified in
                                    	  <a class="xref" href="jls-15.html#jls-15.12.2.2" title="15.12.2.2.&nbsp;Phase 1: Identify Matching Arity Methods Applicable by Strict Invocation">&sect;15.12.2.2</a> through
                                    	  <a class="xref" href="jls-15.html#jls-15.12.2.5" title="15.12.2.5.&nbsp;Choosing the Most Specific Method">&sect;15.12.2.5</a>, or if the most specific
                                    	  applicable method is <code class="literal">static</code>, there is no compile-time
                                    	  declaration.
                                 </p>
                                 <p class="norm-static"><a name="jls-15.13.1-200-C.1-B.3"></a>
                                    	  Otherwise, the compile-time declaration is the most specific
                                    	  applicable method.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
               <p class="norm-error"><a name="jls-15.13.1-300"></a>It is a
                  compile-time error if a method reference expression has the form
                  <span class="emphasis"><em>ReferenceType</em></span> <code class="literal">::</code> <span class="emphasis"><em>[TypeArguments]</em></span> <span class="emphasis"><em>Identifier</em></span>, and the
                  compile-time declaration is <code class="literal">static</code>, and <span class="emphasis"><em>ReferenceType</em></span> is not a
                  simple or qualified name (<a class="xref" href="jls-6.html#jls-6.2" title="6.2.&nbsp;Names and Identifiers">&sect;6.2</a>).
               </p>
               <p class="norm-error"><a name="jls-15.13.1-310"></a>It is a
                  compile-time error if the method reference expression has the form
                  <code class="literal">super</code> <code class="literal">::</code> <span class="emphasis"><em>[TypeArguments]</em></span> <span class="emphasis"><em>Identifier</em></span> or <span class="emphasis"><em>TypeName</em></span>
                  <code class="literal">.</code> <code class="literal">super</code> <code class="literal">::</code> <span class="emphasis"><em>[TypeArguments]</em></span> <span class="emphasis"><em>Identifier</em></span>, and the
                  compile-time declaration is <code class="literal">abstract</code>.
               </p>
               <p class="norm-error"><a name="jls-15.13.1-320"></a>It is a
                  compile-time error if the method reference expression has the form
                  <span class="emphasis"><em>TypeName</em></span> <code class="literal">.</code> <code class="literal">super</code> <code class="literal">::</code> <span class="emphasis"><em>[TypeArguments]</em></span>
                  <span class="emphasis"><em>Identifier</em></span>, and <span class="emphasis"><em>TypeName</em></span> denotes an interface, and there exists a
                  method, distinct from the compile-time declaration, that overrides
                  (<a class="xref" href="jls-8.html#jls-8.4.8" title="8.4.8.&nbsp;Inheritance, Overriding, and Hiding">&sect;8.4.8</a>, <a class="xref" href="jls-9.html#jls-9.4.1" title="9.4.1.&nbsp;Inheritance and Overriding">&sect;9.4.1</a>) the
                  compile-time declaration from a direct superclass or direct
                  superinterface of the type whose declaration immediately encloses the
                  method reference expression.
               </p>
               <p class="norm-error"><a name="jls-15.13.1-330"></a>It is a
                  compile-time error if the method reference expression is of the form
                  <span class="emphasis"><em>ClassType</em></span> <code class="literal">::</code> <span class="emphasis"><em>[TypeArguments]</em></span> <code class="literal">new</code> and a compile-time
                  error would occur when determining an enclosing instance for
                  <span class="emphasis"><em>ClassType</em></span> as specified in <a class="xref" href="jls-15.html#jls-15.9.2" title="15.9.2.&nbsp;Determining Enclosing Instances">&sect;15.9.2</a> (treating the
                  method reference expression as if it were a class instance creation
                  expression).
               </p>
               <p class="note">A method reference expression of the form
                  <span class="emphasis"><em>ReferenceType</em></span> <code class="literal">::</code> <span class="emphasis"><em>[TypeArguments]</em></span> <span class="emphasis"><em>Identifier</em></span> can be
                  interpreted in different ways. If <span class="emphasis"><em>Identifier</em></span> refers to an instance
                  method, then the implicit lambda expression has an extra parameter
                  compared to if <span class="emphasis"><em>Identifier</em></span> refers to a <code class="literal">static</code> method. It is
                  possible for <span class="emphasis"><em>ReferenceType</em></span> to have both kinds of applicable methods,
                  so the search algorithm described above identifies them separately,
                  since there are different parameter types for each case.
               </p>
               <p class="note">An example of ambiguity is:</p><pre class="programlisting">
interface Fun&lt;T,R&gt; { R apply(T arg); }

class C {
    int size() { return 0; }
    static int size(Object arg) { return 0; }

    void test() {
        Fun&lt;C, Integer&gt; f1 = C::size;
          // Error: instance method size()
          // or static method size(Object)?
    }
}
</pre><p class="note">This ambiguity cannot be resolved by providing an
                  applicable instance method which is more specific than an applicable
                  <code class="literal">static</code> method:
               </p><pre class="programlisting">
interface Fun&lt;T,R&gt; { R apply(T arg); }

class C {
    int size() { return 0; }
    static int size(Object arg) { return 0; }
    int size(C arg) { return 0; }

    void test() {
        Fun&lt;C, Integer&gt; f1 = C::size;
          // Error: instance method size()
          // or static method size(Object)?
    }
}
</pre><p class="note">The search is smart enough to ignore ambiguities in
                  which all the applicable methods (from both searches) are instance
                  methods:
               </p><pre class="programlisting">
interface Fun&lt;T,R&gt; { R apply(T arg); }

class C {
    int size() { return 0; }
    int size(Object arg) { return 0; }
    int size(C arg) { return 0; }

    void test() {
        Fun&lt;C, Integer&gt; f1 = C::size;
          // OK: reference is to instance method size()
    }
}
</pre><p class="note">For convenience, when the name of a generic type is
                  used to refer to an instance method (where the receiver becomes the
                  first parameter), the target type is used to determine the type
                  arguments. This facilitates usage like <code class="literal">Pair::first</code>
                  in place of <code class="literal">Pair&lt;String,Integer&gt;::first</code>.
                  Similarly, a method reference like <code class="literal">Pair::new</code> is
                  treated like a "diamond" instance creation (<code class="literal">new
                     Pair&lt;&gt;()</code>). Because the "diamond" is implicit, this
                  form does <span class="emphasis"><em>not</em></span> instantiate a raw type; in fact,
                  there is no way to express a reference to the constructor of a raw
                  type.
               </p>
               <p class="norm-static"><a name="jls-15.13.1-400"></a>For some
                  method reference expressions, there is only one possible compile-time
                  declaration with only one possible invocation type
                  (<a class="xref" href="jls-15.html#jls-15.12.2.6" title="15.12.2.6.&nbsp;Method Invocation Type">&sect;15.12.2.6</a>), regardless of the targeted function
                  type. Such method reference expressions are said to
                  be <span class="emphasis"><em>exact</em></span>. A method reference expression that is
                  not exact is said to be <span class="emphasis"><em>inexact</em></span>.
               </p>
               <p class="norm-static"><a name="jls-15.13.1-410"></a>A method
                  reference expression ending with <span class="emphasis"><em>Identifier</em></span> is exact if it satisfies
                  all of the following:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.13.1-410-A"></a>
                                 If the method reference expression has the form <span class="emphasis"><em>ReferenceType</em></span>
                                 <code class="literal">::</code> <span class="emphasis"><em>[TypeArguments]</em></span> <span class="emphasis"><em>Identifier</em></span>, then
                                 <span class="emphasis"><em>ReferenceType</em></span> does not denote a raw type.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.13.1-410-B"></a>
                                 The type to search has exactly one member method with the name
                                 <span class="emphasis"><em>Identifier</em></span> that is accessible to the class or interface in
                                 which the method reference expression appears.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.13.1-410-C"></a>
                                 This method is not variable arity (<a class="xref" href="jls-8.html#jls-8.4.1" title="8.4.1.&nbsp;Formal Parameters">&sect;8.4.1</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.13.1-410-D"></a>
                                 If this method is generic (<a class="xref" href="jls-8.html#jls-8.4.4" title="8.4.4.&nbsp;Generic Methods">&sect;8.4.4</a>), then
                                 the method reference expression provides <span class="emphasis"><em>TypeArguments</em></span>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-15.13.1-420"></a>A method
                  reference expression of the form <span class="emphasis"><em>ClassType</em></span> <code class="literal">::</code>
                  <span class="emphasis"><em>[TypeArguments]</em></span> <code class="literal">new</code> is exact if it satisfies all of the
                  following:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.13.1-420-A"></a>
                                 The type denoted by <span class="emphasis"><em>ClassType</em></span> is not raw, or is a non-<code class="literal">static</code>
                                 member type of a raw type.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.13.1-420-B"></a>
                                 The type denoted by <span class="emphasis"><em>ClassType</em></span> has exactly one constructor that
                                 is accessible to the class or interface in which the method
                                 reference expression appears.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.13.1-420-C"></a>
                                 This constructor is not variable arity.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.13.1-420-D"></a>
                                 If this constructor is generic, then the method reference
                                 expression provides <span class="emphasis"><em>TypeArguments</em></span>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-15.13.1-430"></a>A method
                  reference expression of the form <span class="emphasis"><em>ArrayType</em></span> <code class="literal">::</code> <code class="literal">new</code> is
                  always exact.
               </p>
            </div>
            <div class="section" title="15.13.2.&nbsp;Type of a Method Reference">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.13.2"></a>15.13.2.&nbsp;Type of a Method Reference
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.13.2-100"></a>A method
                  reference expression is compatible in an assignment context,
                  invocation context, or casting context with a target type <span class="type">T</span> if <span class="type">T</span>
                  is a functional interface type (<a class="xref" href="jls-9.html#jls-9.8" title="9.8.&nbsp;Functional Interfaces">&sect;9.8</a>) and the
                  expression is <span class="emphasis"><em>congruent</em></span> with the function type of
                  the <span class="emphasis"><em>ground target type</em></span> derived from <span class="type">T</span>.
               </p>
               <p class="norm-static"><a name="jls-15.13.2-200"></a>
                  The <span class="emphasis"><em>ground target type</em></span> is derived from <span class="type">T</span> as
                  follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.13.2-200-A"></a>
                                 If <span class="type">T</span> is a wildcard-parameterized functional interface type,
                                 then the ground target type is the non-wildcard parameterization
                                 (<a class="xref" href="jls-9.html#jls-9.9" title="9.9.&nbsp;Function Types">&sect;9.9</a>) of <span class="type">T</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.13.2-200-B"></a>
                                 Otherwise, the ground target type is <span class="type">T</span>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-15.13.2-300"></a>A method
                  reference expression is <span class="emphasis"><em>congruent</em></span> with a function
                  type if both of the following are true:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.13.2-300-A"></a>
                                 The function type identifies a single compile-time declaration
                                 corresponding to the reference.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.13.2-300-B"></a>
                                 One of the following is true:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.13.2-300-B-A"></a>
                                    	  The result of the function type is <code class="literal">void</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.13.2-300-B-B"></a>
                                    	  The result of the function type is <span class="type">R</span>, and the result of
                                              applying capture conversion (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>)
                                              to the return type of the invocation type
                                              (<a class="xref" href="jls-15.html#jls-15.12.2.6" title="15.12.2.6.&nbsp;Method Invocation Type">&sect;15.12.2.6</a>) of the chosen compile-time
                                              declaration is <span class="type">R</span>' (where <span class="type">R</span> is the target type that may
                                              be used to infer <span class="type">R</span>'), and neither <span class="type">R</span> nor <span class="type">R</span>' is <code class="literal">void</code>,
                                              and <span class="type">R</span>' is compatible with <span class="type">R</span> in an assignment
                                              context.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
               <p class="norm-warning"><a name="jls-15.13.2-310"></a>A
                  compile-time unchecked warning occurs if unchecked conversion was
                  necessary for the compile-time declaration to be applicable, and this
                  conversion would cause an unchecked warning in an invocation
                  context.
               </p>
               <p class="norm-warning"><a name="jls-15.13.2-320"></a>A
                  compile-time unchecked warning occurs if unchecked conversion was
                  necessary for the return type <span class="type">R</span>', described above, to be compatible
                  with the function type's return type, <span class="type">R</span>, and this conversion would
                  cause an unchecked warning in an assignment context.
               </p>
               <p class="norm-static"><a name="jls-15.13.2-400"></a>If a
                  method reference expression is compatible with a target type <span class="type">T</span>, then
                  the type of the expression, <span class="type">U</span>, is the ground target type derived
                  from <span class="type">T</span>.
               </p>
               <p class="norm-error"><a name="jls-15.13.2-410"></a>It is a
                  compile-time error if any class or interface mentioned by either <span class="type">U</span>
                  or the function type of <span class="type">U</span> is not accessible from the class or
                  interface in which the method reference expression appears.
               </p>
               <p class="norm-error"><a name="jls-15.13.2-420"></a>
                  For each non-<code class="literal">static</code> member method <code class="varname">m</code> of <span class="type">U</span>, if the function type
                  of <span class="type">U</span> has a subsignature of the signature of <code class="varname">m</code>, then a notional
                  method whose method type is the function type of <span class="type">U</span> is said to
                  override <code class="varname">m</code>, and any compile-time error or unchecked warning
                  specified in <a class="xref" href="jls-8.html#jls-8.4.8.3" title="8.4.8.3.&nbsp;Requirements in Overriding and Hiding">&sect;8.4.8.3</a> may occur.
               </p>
               <p class="norm-error"><a name="jls-15.13.2-430"></a>
                  For each checked exception type <span class="type">X</span> listed in the <code class="literal">throws</code> clause of
                  the invocation type of the compile-time declaration, <span class="type">X</span> or a
                  superclass of <span class="type">X</span> must be mentioned in the <code class="literal">throws</code> clause of the
                  function type of <span class="type">U</span>, or a compile-time error occurs.
               </p>
               <p class="note">The key idea driving the compatibility definition
                  is that a method reference is compatible if and only if the equivalent
                  lambda expression <code class="literal">(x, y, z) <code class="literal">-&gt;</code> exp.&lt;T1,
                     T2&gt;method(x, y, z)</code> is compatible. (This is informal, and
                  there are issues that make it difficult or impossible to formally
                  define the semantics in terms of such a rewrite.)
               </p>
               <p class="note">These compatibility rules provide a convenient
                  facility for converting from one functional interface to
                  another:
               </p><pre class="screen">
Task t = () <code class="literal">-&gt;</code> System.out.println("hi");
Runnable r = t::invoke;
</pre><p class="note">The implementation may be optimized so that when a
                  lambda-derived object is passed around and converted to various types,
                  this does not result in many levels of adaptation logic around the
                  core lambda body.
               </p>
               <p class="note">Unlike a lambda expression, a method reference can
                  be congruent with a generic function type (that is, a function type
                  that has type parameters). This is because the lambda expression would
                  need to be able to declare type parameters, and no syntax supports
                  this; while for a method reference, no such declaration is
                  necessary. For example, the following program is legal:
               </p><pre class="programlisting">

interface ListFactory {
    &lt;T&gt; List&lt;T&gt; make();
}

ListFactory lf  = ArrayList::new;
List&lt;String&gt; ls = lf.make();
List&lt;Number&gt; ln = lf.make();

</pre></div>
            <div class="section" title="15.13.3.&nbsp;Run-time Evaluation of Method References">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.13.3"></a>15.13.3.&nbsp;Run-time Evaluation of Method References
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-dynamic"><a name="jls-15.13.3-100"></a>At run
                  time, evaluation of a method reference expression is similar to
                  evaluation of a class instance creation expression, insofar as normal
                  completion produces a reference to an object. Evaluation of a method
                  reference expression is distinct from invocation of the method
                  itself.
               </p>
               <p class="norm-dynamic"><a name="jls-15.13.3-200"></a>
                  First, if the method reference expression begins with an
                  <span class="emphasis"><em>ExpressionName</em></span> or a <span class="emphasis"><em>Primary</em></span>, this subexpression is evaluated. If
                  the subexpression evaluates to <code class="literal">null</code>, a <code class="literal">NullPointerException</code> is raised, and the
                  method reference expression completes abruptly. If the subexpression
                  completes abruptly, the method reference expression completes abruptly
                  for the same reason.
               </p>
               <p class="norm-dynamic"><a name="jls-15.13.3-210"></a>
                  Next, either a new instance of a class with the properties below is
                  allocated and initialized, or an existing instance of a class with the
                  properties below is referenced. If a new instance is to be created,
                  but there is insufficient space to allocate the object, evaluation of
                  the method reference expression completes abruptly by throwing an
                  <code class="literal">OutOfMemoryError</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-15.13.3-300"></a>The
                  value of a method reference expression is a reference to an instance
                  of a class with the following properties:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.13.3-300-A"></a>
                                 The class implements the targeted functional interface type and,
                                 if the target type is an intersection type, every other
                                 interface type mentioned in the intersection.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.13.3-300-B"></a>
                                 Where the method reference expression has type <span class="type">U</span>, for each
                                 non-<code class="literal">static</code> member method <code class="varname">m</code> of <span class="type">U</span>:
                        </p>
                        <p class="norm-dynamic"><a name="jls-15.13.3-300-B.1"></a>
                                 If the function type of <span class="type">U</span> has a subsignature of the signature
                                 of <code class="varname">m</code>, then the class declares an <span class="emphasis"><em>invocation
                                       method</em></span> that overrides <code class="varname">m</code>. The invocation method's
                                 body invokes the referenced method, creates a class instance, or
                                 creates an array, as described below. If the invocation method's
                                 result is not <code class="literal">void</code>, then the body returns the result of the
                                 method invocation or object creation, after any necessary
                                 assignment conversions (<a class="xref" href="jls-5.html#jls-5.2" title="5.2.&nbsp;Assignment Contexts">&sect;5.2</a>).
                        </p>
                        <p class="norm-dynamic"><a name="jls-15.13.3-300-B.2"></a>
                                 If the erasure of the type of a method being overridden differs
                                 in its signature from the erasure of the function type of <span class="type">U</span>,
                                 then before the method invocation or object creation, an
                                 invocation method's body checks that each argument value is an
                                 instance of a subclass or subinterface of the erasure of the
                                 corresponding parameter type in the function type of <span class="type">U</span>; if
                                 not, a <code class="literal">ClassCastException</code> is thrown.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.13.3-300-C"></a>
                                 The class overrides no other methods of the functional interface
                                 type or other interface types mentioned above, although it may
                                 override methods of the <code class="literal">Object</code> class.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-15.13.3-400"></a>
                  The body of an invocation method depends on the form of the method
                  reference expression, as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.13.3-400-A"></a>
                                 If the form is <span class="emphasis"><em>ExpressionName</em></span> <code class="literal">::</code> <span class="emphasis"><em>[TypeArguments]</em></span>
                                 <span class="emphasis"><em>Identifier</em></span> or <span class="emphasis"><em>Primary</em></span> <code class="literal">::</code> <span class="emphasis"><em>[TypeArguments]</em></span>
                                 <span class="emphasis"><em>Identifier</em></span>, then the body of the invocation method has the
                                 effect of a method invocation expression for a compile-time
                                 declaration which is the compile-time declaration of the method
                                 reference expression. Run-time evaluation of the method
                                 invocation expression is as specified in
                                 <a class="xref" href="jls-15.html#jls-15.12.4.3" title="15.12.4.3.&nbsp;Check Accessibility of Type and Method">&sect;15.12.4.3</a>,
                                 <a class="xref" href="jls-15.html#jls-15.12.4.4" title="15.12.4.4.&nbsp;Locate Method to Invoke">&sect;15.12.4.4</a>, and
                                 <a class="xref" href="jls-15.html#jls-15.12.4.5" title="15.12.4.5.&nbsp;Create Frame, Synchronize, Transfer Control">&sect;15.12.4.5</a>, where:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.13.3-400-A-A"></a>
                                    	  The invocation mode is derived from the compile-time declaration
                                    	  as specified in <a class="xref" href="jls-15.html#jls-15.12.3" title="15.12.3.&nbsp;Compile-Time Step 3: Is the Chosen Method Appropriate?">&sect;15.12.3</a>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.13.3-400-A-B"></a>
                                    	  The target reference is the value of <span class="emphasis"><em>ExpressionName</em></span> or
                                    	  <span class="emphasis"><em>Primary</em></span>, as determined when the method reference
                                    	  expression was evaluated.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.13.3-400-A-C"></a>
                                    	  The arguments to the method invocation expression are the
                                    	  formal parameters of the invocation method.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.13.3-400-B"></a>
                                 If the form is <span class="emphasis"><em>ReferenceType</em></span> <code class="literal">::</code> <span class="emphasis"><em>[TypeArguments]</em></span>
                                 <span class="emphasis"><em>Identifier</em></span>, the body of the invocation method similarly has
                                 the effect of a method invocation expression for a compile-time
                                 declaration which is the compile-time declaration of the method
                                 reference expression. Run-time evaluation of the method
                                 invocation expression is as specified in
                                 <a class="xref" href="jls-15.html#jls-15.12.4.3" title="15.12.4.3.&nbsp;Check Accessibility of Type and Method">&sect;15.12.4.3</a>,
                                 <a class="xref" href="jls-15.html#jls-15.12.4.4" title="15.12.4.4.&nbsp;Locate Method to Invoke">&sect;15.12.4.4</a>, and
                                 <a class="xref" href="jls-15.html#jls-15.12.4.5" title="15.12.4.5.&nbsp;Create Frame, Synchronize, Transfer Control">&sect;15.12.4.5</a>, where:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.13.3-400-B-A"></a>
                                    	  The invocation mode is derived from the compile-time declaration
                                    	  as specified in <a class="xref" href="jls-15.html#jls-15.12.3" title="15.12.3.&nbsp;Compile-Time Step 3: Is the Chosen Method Appropriate?">&sect;15.12.3</a>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.13.3-400-B-B"></a>
                                    	  If the compile-time declaration is an instance method, then
                                    	  the target reference is the first formal parameter of the
                                    	  invocation method. Otherwise, there is no target
                                    	  reference.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.13.3-400-B-C"></a>
                                    	  If the compile-time declaration is an instance method, then
                                    	  the arguments to the method invocation expression (if any)
                                    	  are the second and subsequent formal parameters of the
                                    	  invocation method. Otherwise, the arguments to the method
                                    	  invocation expression are the formal parameters of the
                                    	  invocation method.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.13.3-400-C"></a>
                                 If the form is <code class="literal">super</code> <code class="literal">::</code> <span class="emphasis"><em>[TypeArguments]</em></span>
                                 <span class="emphasis"><em>Identifier</em></span> or <span class="emphasis"><em>TypeName</em></span> <code class="literal">.</code> <code class="literal">super</code> <code class="literal">::</code>
                                 <span class="emphasis"><em>[TypeArguments]</em></span> <span class="emphasis"><em>Identifier</em></span>, the body of the invocation
                                 method has the effect of a method invocation expression for a
                                 compile-time declaration which is the compile-time declaration
                                 of the method reference expression. Run-time evaluation of the
                                 method invocation expression is as specified in
                                 <a class="xref" href="jls-15.html#jls-15.12.4.3" title="15.12.4.3.&nbsp;Check Accessibility of Type and Method">&sect;15.12.4.3</a>,
                                 <a class="xref" href="jls-15.html#jls-15.12.4.4" title="15.12.4.4.&nbsp;Locate Method to Invoke">&sect;15.12.4.4</a>, and
                                 <a class="xref" href="jls-15.html#jls-15.12.4.5" title="15.12.4.5.&nbsp;Create Frame, Synchronize, Transfer Control">&sect;15.12.4.5</a>, where:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.13.3-400-C-A"></a>
                                    	  The invocation mode is <code class="literal">super</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.13.3-400-C-B"></a>
                                    	  If the method reference expression begins with a <span class="emphasis"><em>TypeName</em></span>
                                    	  that names a class, the target reference is the value of
                                    	  <span class="emphasis"><em>TypeName</em></span> <code class="literal">.</code> <code class="literal">this</code> at the point at which the method
                                    	  reference is evaluated. Otherwise, the target reference is
                                    	  the value of <code class="literal">this</code> at the point at which the method
                                    	  reference is evaluated.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.13.3-400-C-C"></a>
                                    	  The arguments to the method invocation expression are the
                                    	  formal parameters of the invocation method.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.13.3-400-D"></a>
                                 If the form is <span class="emphasis"><em>ClassType</em></span> <code class="literal">::</code> <span class="emphasis"><em>[TypeArguments]</em></span>
                                 <code class="literal">new</code>, the body of the invocation method has the effect of a
                                 class instance creation expression of the form <code class="literal">new</code>
                                 <span class="emphasis"><em>[TypeArguments]</em></span> <span class="emphasis"><em>ClassType</em></span>(<span class="type">A<sub>1</sub></span>, ..., <span class="type">A<sub>n</sub></span>), where the
                                 arguments <span class="type">A<sub>1</sub></span>, ..., <span class="type">A<sub>n</sub></span> are the formal parameters of the
                                 invocation method, and where:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.13.3-400-D-A"></a>
                                    	  The enclosing instance for the new object, if any, is
                                    	  derived from the site of the method reference expression, as
                                    	  specified in <a class="xref" href="jls-15.html#jls-15.9.2" title="15.9.2.&nbsp;Determining Enclosing Instances">&sect;15.9.2</a>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.13.3-400-D-B"></a>
                                    	  The constructor to invoke is the constructor that corresponds to
                                    	  the compile-time declaration of the method reference
                                    	  (<a class="xref" href="jls-15.html#jls-15.13.1" title="15.13.1.&nbsp;Compile-Time Declaration of a Method Reference">&sect;15.13.1</a>).
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.13.3-400-E"></a>
                                 If the form
                                 is <span class="emphasis"><em>Type<code class="literal">[]</code><sup>k</sup></em></span>
                                 <code class="literal">::</code> <code class="literal">new</code> (<span class="emphasis"><em>k</em></span> <span class="symbol">&#8805;</span> 1), then the body of the
                                 invocation method has the same effect as an array creation
                                 expression of the form <code class="literal">new</code> <span class="emphasis"><em>Type <code class="literal">[</code> size
                                       <code class="literal">]</code> <code class="literal">[]</code><sup>k-1</sup></em></span>,
                                 where <span class="emphasis"><em>size</em></span> is the invocation method's
                                 single parameter. (The notation
                                 <span class="emphasis"><em><code class="literal">[]</code><sup>k</sup></em></span>
                                 indicates a sequence of <span class="emphasis"><em>k</em></span> bracket pairs.)
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-15.13.3-410"></a>
                  If the body of the invocation method has the effect of a method
                  invocation expression, then the compile-time parameter types and the
                  compile-time result of the method invocation are determined as
                  specified in <a class="xref" href="jls-15.html#jls-15.12.3" title="15.12.3.&nbsp;Compile-Time Step 3: Is the Chosen Method Appropriate?">&sect;15.12.3</a>. For the purpose of
                  determining the compile-time result, the method invocation expression
                  is an expression statement if the invocation method's result is
                  <code class="literal">void</code>, and the <span class="emphasis"><em>Expression</em></span> of a <code class="literal">return</code> statement if the invocation
                  method's result is non-<code class="literal">void</code>.
               </p>
               <p class="note">The effect of this determination when the
                  compile-time declaration of the method reference is signature
                  polymorphic is that:
               </p>
               <div class="note">
                  <ul class="note" type="disc">
                     <li class="listitem">
                        <p class="note">The types of the parameters for the method
                                 invocation are the types of the corresponding arguments.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="note">The method invocation is either <code class="literal">void</code> or has a
                                 return type of <code class="literal">Object</code>, depending on whether the invocation
                                 method which encloses the method invocation is <code class="literal">void</code> or has a
                                 return type.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="note">The timing of method reference expression evaluation
                  is more complex than that of lambda expressions
                  (<a class="xref" href="jls-15.html#jls-15.27.4" title="15.27.4.&nbsp;Run-time Evaluation of Lambda Expressions">&sect;15.27.4</a>). When a method reference expression
                  has an expression (rather than a type) preceding the <code class="literal">::</code>
                  separator, that subexpression is evaluated immediately. The result of
                  evaluation is stored until the method of the corresponding functional
                  interface type is invoked; at that point, the result is used as the
                  target reference for the invocation. This means the expression
                  preceding the <code class="literal">::</code> separator is evaluated only when the
                  program encounters the method reference expression, and is not
                  re-evaluated on subsequent invocations on the functional interface
                  type.
               </p>
               <p class="note">It is interesting to contrast the treatment of
                  <code class="literal">null</code> here with its treatment during method invocation. When a method
                  invocation expression is evaluated, it is possible for the <span class="emphasis"><em>Primary</em></span>
                  that qualifies the invocation to evaluate to <code class="literal">null</code> but for no <code class="literal">NullPointerException</code>
                  to be raised. This occurs when the invoked method is <code class="literal">static</code> (despite
                  the syntax of the invocation suggesting an instance method). Since the
                  applicable method for a method reference expression qualified by a
                  <span class="emphasis"><em>Primary</em></span> is prohibited from being <code class="literal">static</code>
                  (<a class="xref" href="jls-15.html#jls-15.13.1" title="15.13.1.&nbsp;Compile-Time Declaration of a Method Reference">&sect;15.13.1</a>), the evaluation of the method
                  reference expression is simpler - a <code class="literal">null</code> <span class="emphasis"><em>Primary</em></span> always raises a
                  <code class="literal">NullPointerException</code>.
               </p>
            </div>
         </div>
         <div class="section" title="15.14.&nbsp;Postfix Expressions">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.14"></a>15.14.&nbsp;Postfix Expressions
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-15.14-100"></a>Postfix expressions include
               uses of the postfix <code class="literal">++</code> and <code class="literal">--</code> operators. Names are
               not considered to be primary expressions (<a class="xref" href="jls-15.html#jls-15.8" title="15.8.&nbsp;Primary Expressions">&sect;15.8</a>),
               but are handled separately in the grammar to avoid certain
               ambiguities. They become interchangeable only here, at the level of
               precedence of postfix expressions.
            </p>
            <div id="jls-15.14-110" class="productionset"><a name="jls-15.14-110"></a>
                 
               <div class="production"><a name="jls-PostfixExpression"></a>
                      
                  <div class="lhs">PostfixExpression:</div>
                      
                  <div class="rhs">
                           <a href="jls-15.html#jls-Primary" title="Primary">Primary</a> <br>
                           <a href="jls-6.html#jls-ExpressionName" title="ExpressionName">ExpressionName</a> <br>
                           <a href="jls-15.html#jls-PostIncrementExpression" title="PostIncrementExpression">PostIncrementExpression</a> <br>
                           <a href="jls-15.html#jls-PostDecrementExpression" title="PostDecrementExpression">PostDecrementExpression</a>
                         
                  </div>
                    
               </div>
               
            </div>
            <div class="section" title="15.14.1.&nbsp;Expression Names">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.14.1"></a>15.14.1.&nbsp;Expression Names
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-15.14.1-100"></a>The rules for evaluating
                  expression names are given in <a class="xref" href="jls-6.html#jls-6.5.6" title="6.5.6.&nbsp;Meaning of Expression Names">&sect;6.5.6</a>.
               </p>
            </div>
            <div class="section" title="15.14.2.&nbsp;Postfix Increment Operator ++">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.14.2"></a>15.14.2.&nbsp;Postfix Increment Operator <code class="literal">++</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-15.14.2-100"></a>A postfix expression
                  followed by a <code class="literal">++</code> operator is a postfix increment
                  expression.
               </p>
               <div id="jls-15.14.2-110" class="productionset"><a name="jls-15.14.2-110"></a>
                    
                  <div class="production"><a name="jls-PostIncrementExpression"></a>
                         
                     <div class="lhs">PostIncrementExpression:</div>
                         
                     <div class="rhs">
                              <a href="jls-15.html#jls-PostfixExpression" title="PostfixExpression">PostfixExpression</a> <code class="literal">++</code>
                            
                     </div>
                       
                  </div>
                  
               </div>
               <p class="norm-error"><a name="jls-15.14.2-120"></a>The
                  result of the postfix expression must be a variable of a type that is
                  convertible (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) to a numeric type, or a
                  compile-time error occurs.
               </p>
               <p class="norm-static"><a name="jls-15.14.2-130"></a>The type
                  of the postfix increment expression is the type of the variable. The
                  result of the postfix increment expression is not a variable, but a
                  value.
               </p>
               <p class="norm-dynamic"><a name="jls-15.14.2-200"></a>At run
                  time, if evaluation of the operand expression completes abruptly, then
                  the postfix increment expression completes abruptly for the same
                  reason and no incrementation occurs. Otherwise, the
                  value <code class="literal">1</code> is added to the value of the variable and
                  the sum is stored back into the variable. Before the addition, binary
                  numeric promotion (<a class="xref" href="jls-5.html#jls-5.6.2" title="5.6.2.&nbsp;Binary Numeric Promotion">&sect;5.6.2</a>) is performed on the
                  value <code class="literal">1</code> and the value of the variable. If
                  necessary, the sum is narrowed by a narrowing primitive conversion
                  (<a class="xref" href="jls-5.html#jls-5.1.3" title="5.1.3.&nbsp;Narrowing Primitive Conversion">&sect;5.1.3</a>) and/or subjected to boxing conversion
                  (<a class="xref" href="jls-5.html#jls-5.1.7" title="5.1.7.&nbsp;Boxing Conversion">&sect;5.1.7</a>) to the type of the variable before it is
                  stored. The value of the postfix increment expression is the value of
                  the variable <span class="emphasis"><em>before</em></span> the new value is
                  stored.
               </p>
               <p class="note">Note that the binary numeric promotion mentioned
                  above may include unboxing conversion (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>)
                  and value set conversion (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>). If necessary,
                  value set conversion is applied to the sum prior to its being stored
                  in the variable.
               </p>
               <p class="norm-static"><a name="jls-15.14.2-210"></a>A variable
                  that is declared <code class="literal">final</code> cannot be incremented  because when an access of
                  such a <code class="literal">final</code> variable is used as an expression, the result is a
                  value, not a variable. Thus, it cannot be used as the operand of a
                  postfix increment operator.
               </p>
            </div>
            <div class="section" title="15.14.3.&nbsp;Postfix Decrement Operator --">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.14.3"></a>15.14.3.&nbsp;Postfix Decrement Operator <code class="literal">--</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-15.14.3-100"></a>A postfix expression
                  followed by a <code class="literal">--</code> operator is a postfix decrement
                  expression.
               </p>
               <div id="jls-15.14.3-110" class="productionset"><a name="jls-15.14.3-110"></a>
                    
                  <div class="production"><a name="jls-PostDecrementExpression"></a>
                         
                     <div class="lhs">PostDecrementExpression:</div>
                         
                     <div class="rhs">
                              <a href="jls-15.html#jls-PostfixExpression" title="PostfixExpression">PostfixExpression</a> <code class="literal">--</code>
                            
                     </div>
                       
                  </div>
                  
               </div>
               <p class="norm-error"><a name="jls-15.14.3-120"></a>The
                  result of the postfix expression must be a variable of a type that is
                  convertible (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) to a numeric type, or a
                  compile-time error occurs.
               </p>
               <p class="norm-static"><a name="jls-15.14.3-130"></a>The type
                  of the postfix decrement expression is the type of the variable. The
                  result of the postfix decrement expression is not a variable, but a
                  value.
               </p>
               <p class="norm-dynamic"><a name="jls-15.14.3-200"></a>At run
                  time, if evaluation of the operand expression completes abruptly, then
                  the postfix decrement expression completes abruptly for the same
                  reason and no decrementation occurs. Otherwise, the
                  value <code class="literal">1</code> is subtracted from the value of the
                  variable and the difference is stored back into the variable. Before
                  the subtraction, binary numeric promotion
                  (<a class="xref" href="jls-5.html#jls-5.6.2" title="5.6.2.&nbsp;Binary Numeric Promotion">&sect;5.6.2</a>) is performed on the
                  value <code class="literal">1</code> and the value of the variable. If
                  necessary, the difference is narrowed by a narrowing primitive
                  conversion (<a class="xref" href="jls-5.html#jls-5.1.3" title="5.1.3.&nbsp;Narrowing Primitive Conversion">&sect;5.1.3</a>) and/or subjected to boxing
                  conversion (<a class="xref" href="jls-5.html#jls-5.1.7" title="5.1.7.&nbsp;Boxing Conversion">&sect;5.1.7</a>) to the type of the variable
                  before it is stored. The value of the postfix decrement expression is
                  the value of the variable <span class="emphasis"><em>before</em></span> the new value is
                  stored.
               </p>
               <p class="note">Note that the binary numeric promotion mentioned
                  above may include unboxing conversion (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>)
                  and value set conversion (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>). If necessary,
                  value set conversion is applied to the difference prior to its being
                  stored in the variable.
               </p>
               <p class="norm-static"><a name="jls-15.14.3-210"></a>A variable
                  that is declared <code class="literal">final</code> cannot be decremented  because when an access of
                  such a <code class="literal">final</code> variable is used as an expression, the result is a
                  value, not a variable. Thus, it cannot be used as the operand of a
                  postfix decrement operator.
               </p>
            </div>
         </div>
         <div class="section" title="15.15.&nbsp;Unary Operators">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.15"></a>15.15.&nbsp;Unary Operators
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-15.15-100"></a>The operators <code class="literal">+</code>,
               <code class="literal">-</code>, <code class="literal">++</code>, <code class="literal">--</code>, <code class="literal">~</code>, <code class="literal">!</code>, and the cast
               operator (<a class="xref" href="jls-15.html#jls-15.16" title="15.16.&nbsp;Cast Expressions">&sect;15.16</a>) are called the <span class="emphasis"><em>unary
                     operators</em></span>.
            </p>
            <div id="jls-15.15-110" class="productionset"><a name="jls-15.15-110"></a>
                 
               <div class="production"><a name="jls-UnaryExpression"></a>
                      
                  <div class="lhs">UnaryExpression:</div>
                      
                  <div class="rhs">
                           <a href="jls-15.html#jls-PreIncrementExpression" title="PreIncrementExpression">PreIncrementExpression</a> <br>
                           <a href="jls-15.html#jls-PreDecrementExpression" title="PreDecrementExpression">PreDecrementExpression</a> <br>
                           <code class="literal">+</code> <a href="jls-15.html#jls-UnaryExpression" title="UnaryExpression">UnaryExpression</a> <br>
                           <code class="literal">-</code> <a href="jls-15.html#jls-UnaryExpression" title="UnaryExpression">UnaryExpression</a> <br>
                           <a href="jls-15.html#jls-UnaryExpressionNotPlusMinus" title="UnaryExpressionNotPlusMinus">UnaryExpressionNotPlusMinus</a>
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-PreIncrementExpression"></a>
                      
                  <div class="lhs">PreIncrementExpression:</div>
                      
                  <div class="rhs">
                           <code class="literal">++</code> <a href="jls-15.html#jls-UnaryExpression" title="UnaryExpression">UnaryExpression</a>
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-PreDecrementExpression"></a>
                      
                  <div class="lhs">PreDecrementExpression:</div>
                      
                  <div class="rhs">
                           <code class="literal">--</code> <a href="jls-15.html#jls-UnaryExpression" title="UnaryExpression">UnaryExpression</a>
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-UnaryExpressionNotPlusMinus"></a>
                      
                  <div class="lhs">UnaryExpressionNotPlusMinus:</div>
                      
                  <div class="rhs">
                           <a href="jls-15.html#jls-PostfixExpression" title="PostfixExpression">PostfixExpression</a> <br>
                           <code class="literal">~</code> <a href="jls-15.html#jls-UnaryExpression" title="UnaryExpression">UnaryExpression</a> <br>
                           <code class="literal">!</code> <a href="jls-15.html#jls-UnaryExpression" title="UnaryExpression">UnaryExpression</a> <br>
                           <a href="jls-15.html#jls-CastExpression" title="CastExpression">CastExpression</a>
                         
                  </div>
                    
               </div>
               
            </div>
            <p class="note">The following production from
               <a class="xref" href="jls-15.html#jls-15.16" title="15.16.&nbsp;Cast Expressions">&sect;15.16</a> is shown here for convenience:
            </p>
            <div id="d5e27230" class="productionset"><a name="d5e27230"></a>
                 
               <div class="productionrecap-note">
                  <div class="production">
                         
                     <div class="lhs">CastExpression:</div>
                         
                     <div class="rhs">
                              <code class="literal">(</code> <a href="jls-4.html#jls-PrimitiveType" title="PrimitiveType">PrimitiveType</a> <code class="literal">)</code>
                              <a href="jls-15.html#jls-UnaryExpression" title="UnaryExpression">UnaryExpression</a> <br>
                        
                              <code class="literal">(</code> <a href="jls-4.html#jls-ReferenceType" title="ReferenceType">ReferenceType</a> {<a href="jls-4.html#jls-AdditionalBound" title="AdditionalBound">AdditionalBound</a>} <code class="literal">)</code>
                              <a href="jls-15.html#jls-UnaryExpressionNotPlusMinus" title="UnaryExpressionNotPlusMinus">UnaryExpressionNotPlusMinus</a> <br>
                        
                              <code class="literal">(</code> <a href="jls-4.html#jls-ReferenceType" title="ReferenceType">ReferenceType</a> {<a href="jls-4.html#jls-AdditionalBound" title="AdditionalBound">AdditionalBound</a>} <code class="literal">)</code>
                              <a href="jls-15.html#jls-LambdaExpression" title="LambdaExpression">LambdaExpression</a> <br>
                            
                     </div>
                       
                  </div>
               </div>
               
            </div>
            <p class="norm-static"><a name="jls-15.15-120"></a>
               Expressions with unary operators group right-to-left, so
               that <code class="literal">-~x</code> means the same
               as <code class="literal">-(~x)</code>.
            </p>
            <p class="note">This portion of the grammar contains some tricks to
               avoid two potential syntactic ambiguities.
            </p>
            <p class="note">The first potential ambiguity would arise in
               expressions such as <code class="literal">(p)+q</code>, which looks, to a C or
               C++ programmer, as though it could be either a cast to
               type <code class="literal">p</code> of a unary <code class="literal">+</code> operating
               on <code class="literal">q</code>, or a binary addition of two
               quantities <code class="literal">p</code> and <code class="literal">q</code>. In C and
               C++, the parser handles this problem by performing a limited amount of
               semantic analysis as it parses, so that it knows
               whether <code class="literal">p</code> is the name of a type or the name of a
               variable.
            </p>
            <p class="note">Java takes a different approach. The result of the
               <code class="literal">+</code> operator must be numeric, and all type names involved in casts
               on numeric values are known keywords. Thus, if <code class="literal">p</code> is
               a keyword naming a primitive type, then <code class="literal">(p)+q</code> can
               make sense only as a cast of a unary expression. However,
               if <code class="literal">p</code> is not a keyword naming a primitive type, then
               <code class="literal">(p)+q</code> can make sense only as a binary arithmetic
               operation. Similar remarks apply to the <code class="literal">-</code> operator. The grammar
               shown above splits <span class="emphasis"><em>CastExpression</em></span> into two cases
               to make this distinction. The
               nonterminal <span class="emphasis"><em>UnaryExpression</em></span> includes all unary
               operators, but the
               nonterminal <span class="emphasis"><em>UnaryExpressionNotPlusMinus</em></span> excludes
               uses of all unary operators that could also be binary operators, which
               in Java are <code class="literal">+</code> and <code class="literal">-</code>.
            </p>
            <p class="note">The second potential ambiguity is that the
               expression <code class="literal">(p)++</code> could, to a C or C++ programmer,
               appear to be either a postfix increment of a parenthesized expression
               or the beginning of a cast, for example,
               in <code class="literal">(p)++q</code>. As before, parsers for C and C++ know
               whether <code class="literal">p</code> is the name of a type or the name of a
               variable. But a parser using only one-token lookahead and no semantic
               analysis during the parse would not be able to tell, when <code class="literal">++</code>
               is the lookahead token, whether <code class="literal">(p)</code> should be
               considered a <span class="emphasis"><em>Primary</em></span> expression or left alone for later
               consideration as part of a <span class="emphasis"><em>CastExpression</em></span>.
            </p>
            <p class="note">In Java, the result of the <code class="literal">++</code> operator must
               be numeric, and all type names involved in casts on numeric values are
               known keywords. Thus, if <code class="literal">p</code> is a keyword naming a
               primitive type, then <code class="literal">(p)++</code> can make sense only as a
               cast of a prefix increment expression, and there had better be an
               operand such as <code class="literal">q</code> following the
               <code class="literal">++</code>. However, if <code class="literal">p</code> is not a keyword naming a
               primitive type, then <code class="literal">(p)++</code> can make sense only as a
               postfix increment of <code class="literal">p</code>. Similar remarks apply to
               the <code class="literal">--</code> operator. The
               nonterminal <span class="emphasis"><em>UnaryExpressionNotPlusMinus</em></span> therefore
               also excludes uses of the prefix operators <code class="literal">++</code> and
               <code class="literal">--</code>.
            </p>
            <div class="section" title="15.15.1.&nbsp;Prefix Increment Operator ++">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.15.1"></a>15.15.1.&nbsp;Prefix Increment Operator <code class="literal">++</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-15.15.1-100"></a>A unary expression preceded
                  by a <code class="literal">++</code> operator is a prefix increment expression.
               </p>
               <p class="norm-error"><a name="jls-15.15.1-110"></a>The
                  result of the unary expression must be a variable of a type that is
                  convertible (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) to a numeric type, or a
                  compile-time error occurs.
               </p>
               <p class="norm-static"><a name="jls-15.15.1-120"></a>The type
                  of the prefix increment expression is the type of the variable. The
                  result of the prefix increment expression is not a variable, but a
                  value.
               </p>
               <p class="norm-dynamic"><a name="jls-15.15.1-200"></a>At run
                  time, if evaluation of the operand expression completes abruptly, then
                  the prefix increment expression completes abruptly for the same reason
                  and no incrementation occurs. Otherwise, the
                  value <code class="literal">1</code> is added to the value of the variable and
                  the sum is stored back into the variable. Before the addition, binary
                  numeric promotion (<a class="xref" href="jls-5.html#jls-5.6.2" title="5.6.2.&nbsp;Binary Numeric Promotion">&sect;5.6.2</a>) is performed on the
                  value <code class="literal">1</code> and the value of the variable. If
                  necessary, the sum is narrowed by a narrowing primitive conversion
                  (<a class="xref" href="jls-5.html#jls-5.1.3" title="5.1.3.&nbsp;Narrowing Primitive Conversion">&sect;5.1.3</a>) and/or subjected to boxing conversion
                  (<a class="xref" href="jls-5.html#jls-5.1.7" title="5.1.7.&nbsp;Boxing Conversion">&sect;5.1.7</a>) to the type of the variable before it is
                  stored. The value of the prefix increment expression is the value of
                  the variable <span class="emphasis"><em>after</em></span> the new value is
                  stored.
               </p>
               <p class="note">Note that the binary numeric promotion mentioned
                  above may include unboxing conversion (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>)
                  and value set conversion (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>). If necessary,
                  value set conversion is applied to the sum prior to its being stored
                  in the variable.
               </p>
               <p class="norm-static"><a name="jls-15.15.1-210"></a>A variable
                  that is declared <code class="literal">final</code> cannot be incremented  because when an access of
                  such a <code class="literal">final</code> variable is used as an expression, the result is a
                  value, not a variable. Thus, it cannot be used as the operand of a
                  prefix increment operator.
               </p>
            </div>
            <div class="section" title="15.15.2.&nbsp;Prefix Decrement Operator --">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.15.2"></a>15.15.2.&nbsp;Prefix Decrement Operator <code class="literal">--</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-15.15.2-100"></a>A unary expression preceded
                  by a <code class="literal">--</code> operator is a prefix decrement expression.
               </p>
               <p class="norm-error"><a name="jls-15.15.2-110"></a>The
                  result of the unary expression must be a variable of a type that is
                  convertible (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) to a numeric type, or a
                  compile-time error occurs.
               </p>
               <p class="norm-static"><a name="jls-15.15.2-120"></a>The type
                  of the prefix decrement expression is the type of the variable. The
                  result of the prefix decrement expression is not a variable, but a
                  value.
               </p>
               <p class="norm"><a name="jls-15.15.2-200"></a>At run time, if evaluation
                  of the operand expression completes abruptly, then the prefix
                  decrement expression completes abruptly for the same reason and no
                  decrementation occurs. Otherwise, the value <code class="literal">1</code> is
                  subtracted from the value of the variable and the difference is stored
                  back into the variable. Before the subtraction, binary numeric
                  promotion (<a class="xref" href="jls-5.html#jls-5.6.2" title="5.6.2.&nbsp;Binary Numeric Promotion">&sect;5.6.2</a>) is performed on the
                  value <code class="literal">1</code> and the value of the variable. If
                  necessary, the difference is narrowed by a narrowing primitive
                  conversion (<a class="xref" href="jls-5.html#jls-5.1.3" title="5.1.3.&nbsp;Narrowing Primitive Conversion">&sect;5.1.3</a>) and/or subjected to boxing
                  conversion (<a class="xref" href="jls-5.html#jls-5.1.7" title="5.1.7.&nbsp;Boxing Conversion">&sect;5.1.7</a>) to the type of the variable
                  before it is stored. The value of the prefix decrement expression is
                  the value of the variable <span class="emphasis"><em>after</em></span> the new value is
                  stored.
               </p>
               <p class="note">Note that the binary numeric promotion mentioned
                  above may include unboxing conversion (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>)
                  and value set conversion (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>). If necessary,
                  format conversion is applied to the difference prior to its being
                  stored in the variable.
               </p>
               <p class="norm-static"><a name="jls-15.15.2-210"></a>A variable
                  that is declared <code class="literal">final</code> cannot be decremented  because when an access of
                  such a <code class="literal">final</code> variable is used as an expression, the result is a
                  value, not a variable. Thus, it cannot be used as the operand of a
                  prefix decrement operator.
               </p>
            </div>
            <div class="section" title="15.15.3.&nbsp;Unary Plus Operator +">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.15.3"></a>15.15.3.&nbsp;Unary Plus Operator <code class="literal">+</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-error"><a name="jls-15.15.3-100"></a>The type
                  of the operand expression of the unary <code class="literal">+</code> operator
                  must be a type that is convertible (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) to a
                  primitive numeric type, or a compile-time error occurs.
               </p>
               <p class="norm-static"><a name="jls-15.15.3-110"></a>Unary
                  numeric promotion (<a class="xref" href="jls-5.html#jls-5.6.1" title="5.6.1.&nbsp;Unary Numeric Promotion">&sect;5.6.1</a>) is performed on the
                  operand. The type of the unary plus expression is the promoted type of
                  the operand. The result of the unary plus expression is not a
                  variable, but a value, even if the result of the operand expression is
                  a variable.
               </p>
               <p class="norm-dynamic"><a name="jls-15.15.3-200"></a>At run
                  time, the value of the unary plus expression is the promoted value of
                  the operand.
               </p>
            </div>
            <div class="section" title="15.15.4.&nbsp;Unary Minus Operator -">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.15.4"></a>15.15.4.&nbsp;Unary Minus Operator <code class="literal">-</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-error"><a name="jls-15.15.4-100"></a>The type
                  of the operand expression of the unary <code class="literal">-</code> operator
                  must be a type that is convertible (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) to a
                  primitive numeric type, or a compile-time error occurs.
               </p>
               <p class="norm-static"><a name="jls-15.15.4-110"></a>Unary
                  numeric promotion (<a class="xref" href="jls-5.html#jls-5.6.1" title="5.6.1.&nbsp;Unary Numeric Promotion">&sect;5.6.1</a>) is performed on the
                  operand.
               </p>
               <p class="norm-static"><a name="jls-15.15.4-120"></a>The type
                  of the unary minus expression is the promoted type of the
                  operand.
               </p>
               <p class="norm-static"><a name="jls-15.15.4-130"></a>Note
                  that unary numeric promotion performs value set conversion
                  (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>). Whatever value set the promoted
                  operand value is drawn from, the unary negation operation is carried
                  out and the result is drawn from that same value set. That result is
                  then subject to further value set conversion.
               </p>
               <p class="norm-dynamic"><a name="jls-15.15.4-200"></a>At run
                  time, the value of the unary minus expression is the arithmetic
                  negation of the promoted value of the operand.
               </p>
               <p class="norm-dynamic"><a name="jls-15.15.4-210"></a>For
                  integer values, negation is the same as subtraction from zero. The
                  Java programming language uses two's-complement representation for integers, and the
                  range of two's-complement values is not symmetric, so negation of the
                  maximum negative <code class="literal">int</code> or <code class="literal">long</code> results in that same maximum negative
                  number. Overflow occurs in this case, but no exception is thrown. For
                  all integer values <code class="literal">x</code>, <code class="literal">-x</code>
                  equals <code class="literal">(~x)+1</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-15.15.4-220"></a>For
                  floating-point values, negation is <span class="emphasis"><em>not</em></span> the same
                  as subtraction from zero, because if <code class="literal">x</code>
                  is <code class="literal">+0.0</code>, then <code class="literal">0.0-x</code>
                  is <code class="literal">+0.0</code>, but <code class="literal">-x</code>
                  is <code class="literal">-0.0</code>. Unary minus merely inverts the sign of a
                  floating-point number. Special cases of interest:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.15.4-220-A"></a>If the operand is NaN, the result is
                               NaN. (Recall that NaN has no sign
                               (<a class="xref" href="jls-4.html#jls-4.2.3" title="4.2.3.&nbsp;Floating-Point Types, Formats, and Values">&sect;4.2.3</a>).)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.15.4-220-B"></a>If the operand is an infinity, the
                               result is the infinity of opposite sign.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.15.4-220-C"></a>If the operand is a zero, the result is
                               the zero of opposite sign.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="15.15.5.&nbsp;Bitwise Complement Operator ~">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.15.5"></a>15.15.5.&nbsp;Bitwise Complement Operator <code class="literal">~</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-error"><a name="jls-15.15.5-100"></a>The type
                  of the operand expression of the unary <code class="literal">~</code> operator
                  must be a type that is convertible (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) to a
                  primitive integral type, or a compile-time error occurs.
               </p>
               <p class="norm-static"><a name="jls-15.15.5-110"></a>Unary
                  numeric promotion (<a class="xref" href="jls-5.html#jls-5.6.1" title="5.6.1.&nbsp;Unary Numeric Promotion">&sect;5.6.1</a>) is performed on the
                  operand. The type of the unary bitwise complement expression is the
                  promoted type of the operand.
               </p>
               <p class="norm-dynamic"><a name="jls-15.15.5-200"></a>At run
                  time, the value of the unary bitwise complement expression is the
                  bitwise complement of the promoted value of the operand. In all
                  cases, <code class="literal">~x</code> equals <code class="literal">(-x)-1</code>.
               </p>
            </div>
            <div class="section" title="15.15.6.&nbsp;Logical Complement Operator !">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.15.6"></a>15.15.6.&nbsp;Logical Complement Operator <code class="literal">!</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-error"><a name="jls-15.15.6-100"></a>The type
                  of the operand expression of the unary <code class="literal">!</code> operator
                  must be <code class="literal">boolean</code> or <code class="literal">Boolean</code>, or a compile-time error occurs.
               </p>
               <p class="norm-static"><a name="jls-15.15.6-110"></a>The type
                  of the unary logical complement expression is <code class="literal">boolean</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-15.15.6-200"></a>At run
                  time, the operand is subject to unboxing conversion
                  (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) if necessary. The value of the unary
                  logical complement expression is <code class="literal">true</code> if the (possibly converted)
                  operand value is <code class="literal">false</code>, and <code class="literal">false</code> if the (possibly converted)
                  operand value is <code class="literal">true</code>.
               </p>
            </div>
         </div>
         <div class="section" title="15.16.&nbsp;Cast Expressions">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.16"></a>15.16.&nbsp;Cast Expressions
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-15.16-100"></a>A cast
               expression converts, at run time, a value of one numeric type to a
               similar value of another numeric type; or confirms, at compile time,
               that the type of an expression is <code class="literal">boolean</code>; or checks, at run time,
               that a reference value refers to an object whose class is compatible
               with a specified reference type or list of reference
               types.
            </p>
            <p class="norm"><a name="jls-15.16-110"></a>The parentheses and the
               type or list of types they contain are sometimes
               called the <span class="emphasis"><em>cast operator</em></span>.
            </p>
            <div id="jls-15.16-120" class="productionset"><a name="jls-15.16-120"></a>
                 
               <div class="production"><a name="jls-CastExpression"></a>
                      
                  <div class="lhs">CastExpression:</div>
                      
                  <div class="rhs">
                           <code class="literal">(</code> <a href="jls-4.html#jls-PrimitiveType" title="PrimitiveType">PrimitiveType</a> <code class="literal">)</code>
                           <a href="jls-15.html#jls-UnaryExpression" title="UnaryExpression">UnaryExpression</a> <br>
                     
                           <code class="literal">(</code> <a href="jls-4.html#jls-ReferenceType" title="ReferenceType">ReferenceType</a> {<a href="jls-4.html#jls-AdditionalBound" title="AdditionalBound">AdditionalBound</a>} <code class="literal">)</code>
                           <a href="jls-15.html#jls-UnaryExpressionNotPlusMinus" title="UnaryExpressionNotPlusMinus">UnaryExpressionNotPlusMinus</a> <br>
                     
                           <code class="literal">(</code> <a href="jls-4.html#jls-ReferenceType" title="ReferenceType">ReferenceType</a> {<a href="jls-4.html#jls-AdditionalBound" title="AdditionalBound">AdditionalBound</a>} <code class="literal">)</code>
                           <a href="jls-15.html#jls-LambdaExpression" title="LambdaExpression">LambdaExpression</a> <br>
                         
                  </div>
                    
               </div>
               
            </div>
            <p class="note">The following production from
               <a class="xref" href="jls-4.html#jls-4.4" title="4.4.&nbsp;Type Variables">&sect;4.4</a> is shown here for convenience:
            </p>
            <div id="d5e27414" class="productionset"><a name="d5e27414"></a>
                 
               <div class="productionrecap-note">
                  <div class="production">
                         
                     <div class="lhs">AdditionalBound:</div>
                         
                     <div class="rhs">
                              <code class="literal">&amp;</code> <a href="jls-4.html#jls-InterfaceType" title="InterfaceType">InterfaceType</a>
                            
                     </div>
                       
                  </div>
               </div>
               
            </div>
            <p class="norm-error"><a name="jls-15.16-200"></a>If the cast
               operator contains a list of types - that is, a <span class="emphasis"><em>ReferenceType</em></span>
               followed by one or more <span class="emphasis"><em>AdditionalBound</em></span> terms -
               then all of the following must be true, or a compile-time error
               occurs:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-error"><a name="jls-15.16-200-A"></a>
                              <span class="emphasis"><em>ReferenceType</em></span> must denote a class or interface type.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-error"><a name="jls-15.16-200-B"></a>
                              The erasures (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>) of all the listed types
                              must be pairwise different.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-error"><a name="jls-15.16-200-C"></a>
                              No two listed types may be subtypes of different
                              parameterizations of the same generic interface.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm-static"><a name="jls-15.16-210"></a> The target type
               for the casting context (<a class="xref" href="jls-5.html#jls-5.5" title="5.5.&nbsp;Casting Contexts">&sect;5.5</a>) introduced by the
               cast expression is either the <span class="emphasis"><em>PrimitiveType</em></span> or
               the <span class="emphasis"><em>ReferenceType</em></span> (if not followed
               by <span class="emphasis"><em>AdditionalBound</em></span> terms) appearing in the cast
               operator, or the intersection type denoted by the <span class="emphasis"><em>ReferenceType</em></span> and
               <span class="emphasis"><em>AdditionalBound</em></span> terms appearing in the cast
               operator.
            </p>
            <p class="norm-static"><a name="jls-15.16-220"></a>The type of a
               cast expression is the result of applying capture conversion
               (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>) to this target type.
            </p>
            <p class="note">Casts can be used to explicitly "tag" a lambda
               expression or a method reference expression with a particular target
               type. To provide an appropriate degree of flexibility, the target type
               may be a list of types denoting an intersection type, provided the
               intersection induces a functional interface (<a class="xref" href="jls-9.html#jls-9.8" title="9.8.&nbsp;Functional Interfaces">&sect;9.8</a>).
            </p>
            <p class="norm-static"><a name="jls-15.16-300"></a>The result
               of a cast expression is not a variable, but a value, even if the
               result of the operand expression is a variable.
            </p>
            <p class="norm-dynamic"><a name="jls-15.16-310"></a>A cast
               operator has no effect on the choice of value set
               (<a class="xref" href="jls-4.html#jls-4.2.3" title="4.2.3.&nbsp;Floating-Point Types, Formats, and Values">&sect;4.2.3</a>) for a value of type <code class="literal">float</code> or type
               <code class="literal">double</code>. Consequently, a cast to type <code class="literal">float</code> within an expression
               that is not FP-strict (<a class="xref" href="jls-15.html#jls-15.4" title="15.4.&nbsp;FP-strict Expressions">&sect;15.4</a>) does not
               necessarily cause its value to be converted to an element of the float
               value set, and a cast to type <code class="literal">double</code> within an expression that is
               not FP-strict does not necessarily cause its value to be converted to
               an element of the double value set.
            </p>
            <p class="norm-error"><a name="jls-15.16-320"></a>It is a
               compile-time error if the compile-time type of the operand may never
               be cast to the type specified by the cast operator according to the
               rules of casting conversion (<a class="xref" href="jls-5.html#jls-5.5" title="5.5.&nbsp;Casting Contexts">&sect;5.5</a>).
            </p>
            <p class="norm-dynamic"><a name="jls-15.16-330"></a>Otherwise, at run time, the operand value is
               converted (if necessary) by casting conversion to the type specified
               by the cast operator.
            </p>
            <p class="norm-dynamic"><a name="jls-15.16-400"></a>A <code class="literal">ClassCastException</code>
               is thrown if a cast is found at run time to be impermissible.
            </p>
            <p class="note">Some casts result in an error at compile time. Some
               casts can be proven, at compile time, always to be correct at run
               time. For example, it is always correct to convert a value of a class
               type to the type of its superclass; such a cast should require no
               special action at run time. Finally, some casts cannot be proven to be
               either always correct or always incorrect at compile time. Such casts
               require a test at run time. See <a class="xref" href="jls-5.html#jls-5.5" title="5.5.&nbsp;Casting Contexts">&sect;5.5</a> for
               details.
            </p>
         </div>
         <div class="section" title="15.17.&nbsp;Multiplicative Operators">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.17"></a>15.17.&nbsp;Multiplicative Operators
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-15.17-100"></a>The operators <code class="literal">*</code>,
               <code class="literal">/</code>, and <code class="literal">%</code> are called the <span class="emphasis"><em>multiplicative
                     operators</em></span>.
            </p>
            <div id="jls-15.17-110" class="productionset"><a name="jls-15.17-110"></a>
                 
               <div class="production"><a name="jls-MultiplicativeExpression"></a>
                      
                  <div class="lhs">MultiplicativeExpression:</div>
                      
                  <div class="rhs">
                           <a href="jls-15.html#jls-UnaryExpression" title="UnaryExpression">UnaryExpression</a> <br>
                           <a href="jls-15.html#jls-MultiplicativeExpression" title="MultiplicativeExpression">MultiplicativeExpression</a> <code class="literal">*</code> <a href="jls-15.html#jls-UnaryExpression" title="UnaryExpression">UnaryExpression</a> <br>
                           <a href="jls-15.html#jls-MultiplicativeExpression" title="MultiplicativeExpression">MultiplicativeExpression</a> <code class="literal">/</code> <a href="jls-15.html#jls-UnaryExpression" title="UnaryExpression">UnaryExpression</a> <br>
                           <a href="jls-15.html#jls-MultiplicativeExpression" title="MultiplicativeExpression">MultiplicativeExpression</a> <code class="literal">%</code> <a href="jls-15.html#jls-UnaryExpression" title="UnaryExpression">UnaryExpression</a>
                         
                  </div>
                    
               </div>
               
            </div>
            <p class="norm-static"><a name="jls-15.17-120"></a>The
               multiplicative operators have the same precedence and are
               syntactically left-associative (they group left-to-right).
            </p>
            <p class="norm-error"><a name="jls-15.17-200"></a>The type of
               each of the operands of a multiplicative operator must be a type that
               is convertible (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) to a primitive numeric
               type, or a compile-time error occurs.
            </p>
            <p class="norm-static"><a name="jls-15.17-300"></a>Binary
               numeric promotion is performed on the operands
               (<a class="xref" href="jls-5.html#jls-5.6.2" title="5.6.2.&nbsp;Binary Numeric Promotion">&sect;5.6.2</a>).
            </p>
            <p class="note">Note that binary numeric promotion performs value
               set conversion (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>) and may perform unboxing
               conversion (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>).
            </p>
            <p class="norm-static"><a name="jls-15.17-310"></a>The type
               of a multiplicative expression is the promoted type of its
               operands.
            </p>
            <p class="norm-dynamic"><a name="jls-15.17-320"></a>If the
               promoted type is <code class="literal">int</code> or <code class="literal">long</code>, then integer arithmetic is
               performed.
            </p>
            <p class="norm-dynamic"><a name="jls-15.17-330"></a>If the
               promoted type is <code class="literal">float</code> or <code class="literal">double</code>, then floating-point arithmetic
               is performed.
            </p>
            <div class="section" title="15.17.1.&nbsp;Multiplication Operator *">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.17.1"></a>15.17.1.&nbsp;Multiplication Operator <code class="literal">*</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-dynamic"><a name="jls-15.17.1-100"></a>The
                  binary <code class="literal">*</code> operator performs multiplication,
                  producing the product of its operands.
               </p>
               <p class="norm-static"><a name="jls-15.17.1-110"></a>Multiplication is a commutative operation if
                  the operand expressions have no side effects.
               </p>
               <p class="norm-static"><a name="jls-15.17.1-120"></a>Integer
                  multiplication is associative when the operands are all of the same
                  type.
               </p>
               <p class="norm-static"><a name="jls-15.17.1-130"></a>Floating-point multiplication is not
                  associative.
               </p>
               <p class="norm-dynamic"><a name="jls-15.17.1-200"></a>If an
                  integer multiplication overflows, then the result is the low-order
                  bits of the mathematical product as represented in some sufficiently
                  large two's-complement format. As a result, if overflow occurs, then
                  the sign of the result may not be the same as the sign of the
                  mathematical product of the two operand values.
               </p>
               <p class="norm-dynamic"><a name="jls-15.17.1-300"></a>The
                  result of a floating-point multiplication is determined by the rules
                  of IEEE 754 arithmetic:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.1-300-A"></a>If either operand is NaN, the result is
                               NaN.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.1-300-B"></a>If the result is not NaN, the sign of
                               the result is positive if both operands have the same sign, and
                               negative if the operands have different signs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.1-300-C"></a>Multiplication of an infinity by a zero
                               results in NaN.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.1-300-D"></a>Multiplication of an infinity by a
                               finite value results in a signed infinity. The sign is determined
                               by the rule stated above.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.1-300-E"></a>In the remaining cases, where neither
                               an infinity nor NaN is involved, the exact mathematical product is
                               computed. A floating-point value set is then chosen:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm"><a name="jls-15.17.1-300-E-1"></a>If the
                                    	multiplication expression is FP-strict
                                    	(<a class="xref" href="jls-15.html#jls-15.4" title="15.4.&nbsp;FP-strict Expressions">&sect;15.4</a>):
                                 </p>
                                 <div class="norm">
                                    <ul class="norm" type="square">
                                       <li class="listitem">
                                          <p class="norm-dynamic"><a name="jls-15.17.1-300-E-1-1"></a>If the type of the
                                             	    multiplication expression is <code class="literal">float</code>, then the float value
                                             	    set must be chosen.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-dynamic"><a name="jls-15.17.1-300-E-1-2"></a>If the type of the
                                             	    multiplication expression is <code class="literal">double</code>, then the double
                                             	    value set must be chosen.
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-15.17.1-300-E-2"></a>If the
                                    	multiplication expression is not FP-strict:
                                 </p>
                                 <div class="norm">
                                    <ul class="norm" type="square">
                                       <li class="listitem">
                                          <p class="norm-dynamic"><a name="jls-15.17.1-300-E-2-1"></a>If the type of the
                                             	    multiplication expression is <code class="literal">float</code>, then either the
                                             	    float value set or the float-extended-exponent value set
                                             	    may be chosen, at the whim of the implementation.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-dynamic"><a name="jls-15.17.1-300-E-2-2"></a>If the type of the
                                             	    multiplication expression is <code class="literal">double</code>, then either the
                                             	    double value set or the double-extended-exponent value set
                                             	    may be chosen, at the whim of the implementation.
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                           </ul>
                        </div>
                        <p class="norm-dynamic"><a name="jls-15.17.1-300-E.1"></a>Next, a value must be chosen from the
                               chosen value set to represent the product.
                        </p>
                        <p class="norm-dynamic"><a name="jls-15.17.1-300-E.2"></a>If the magnitude of the product is
                               too large to represent, we say the operation overflows; the result
                               is then an infinity of appropriate sign.
                        </p>
                        <p class="norm-dynamic"><a name="jls-15.17.1-300-E.3"></a>Otherwise, the product is rounded to
                               the nearest value in the chosen value set using IEEE 754
                               round-to-nearest mode. The Java programming language requires support of gradual
                               underflow as defined by IEEE 754
                               (<a class="xref" href="jls-4.html#jls-4.2.4" title="4.2.4.&nbsp;Floating-Point Operations">&sect;4.2.4</a>).
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-15.17.1-400"></a>Despite
                  the fact that overflow, underflow, or loss of information may occur,
                  evaluation of a multiplication operator <code class="literal">*</code> never throws a
                  run-time exception.
               </p>
            </div>
            <div class="section" title="15.17.2.&nbsp;Division Operator /">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.17.2"></a>15.17.2.&nbsp;Division Operator <code class="literal">/</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-dynamic"><a name="jls-15.17.2-100"></a>The
                  binary <code class="literal">/</code> operator performs division, producing the
                  quotient of its operands. The left-hand operand is
                  the <span class="emphasis"><em>dividend</em></span> and the right-hand operand is
                  the <span class="emphasis"><em>divisor</em></span>.
               </p>
               <p class="norm-dynamic"><a name="jls-15.17.2-200"></a>Integer
                  division rounds toward <code class="literal">0</code>. That is, the quotient
                  produced for operands <span class="emphasis"><em>n</em></span> and <span class="emphasis"><em>d</em></span> that are integers after binary
                  numeric promotion (<a class="xref" href="jls-5.html#jls-5.6.2" title="5.6.2.&nbsp;Binary Numeric Promotion">&sect;5.6.2</a>) is an integer value
                  <span class="emphasis"><em>q</em></span> whose magnitude is as large as possible while satisfying
                  |<span class="emphasis"><em>d</em></span> <span class="symbol">&#8901;</span> <span class="emphasis"><em>q</em></span>| <span class="symbol">&#8804;</span> |<span class="emphasis"><em>n</em></span>|. Moreover, <span class="emphasis"><em>q</em></span> is positive
                  when |<span class="emphasis"><em>n</em></span>| <span class="symbol">&#8805;</span> |<span class="emphasis"><em>d</em></span>| and <span class="emphasis"><em>n</em></span> and <span class="emphasis"><em>d</em></span> have the same sign,
                  but <span class="emphasis"><em>q</em></span> is negative when |<span class="emphasis"><em>n</em></span>| <span class="symbol">&#8805;</span> |<span class="emphasis"><em>d</em></span>| and <span class="emphasis"><em>n</em></span> and
                  <span class="emphasis"><em>d</em></span> have opposite signs.
               </p>
               <p class="norm-dynamic"><a name="jls-15.17.2-210"></a>There
                  is one special case that does not satisfy this rule: if the dividend
                  is the negative integer of largest possible magnitude for its type,
                  and the divisor is <code class="literal">-1</code>, then integer overflow occurs
                  and the result is equal to the dividend. Despite the overflow, no
                  exception is thrown in this case. On the other hand, if the value of
                  the divisor in an integer division is <code class="literal">0</code>, then an
                  <code class="literal">ArithmeticException</code> is thrown.
               </p>
               <p class="norm-dynamic"><a name="jls-15.17.2-300"></a>The
                  result of a floating-point division is determined by the rules of IEEE
                  754 arithmetic:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.2-300-A"></a>If either operand is NaN, the result is
                               NaN.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.2-300-B"></a>If the result is not NaN, the sign of
                               the result is positive if both operands have the same sign, and
                               negative if the operands have different signs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.2-300-C"></a>Division of an infinity by an infinity
                               results in NaN.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.2-300-D"></a>Division of an infinity by a finite
                               value results in a signed infinity. The sign is determined by the
                               rule stated above.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.2-300-E"></a>Division of a finite value by an
                               infinity results in a signed zero. The sign is determined by the
                               rule stated above.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.2-300-F"></a>Division of a zero by a zero results in
                               NaN; division of zero by any other finite value results in a
                               signed zero. The sign is determined by the rule stated
                               above.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.2-300-G"></a>Division of a nonzero finite value by a
                               zero results in a signed infinity. The sign is determined by the
                               rule stated above.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.2-300-H"></a>In
                               the remaining cases, where neither an infinity nor NaN is
                               involved, the exact mathematical quotient is computed. A
                               floating-point value set is then chosen:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm"><a name="jls-15.17.2-300-H-1"></a>If the division
                                    	expression is FP-strict (<a class="xref" href="jls-15.html#jls-15.4" title="15.4.&nbsp;FP-strict Expressions">&sect;15.4</a>):
                                 </p>
                                 <div class="norm">
                                    <ul class="norm" type="square">
                                       <li class="listitem">
                                          <p class="norm-dynamic"><a name="jls-15.17.2-300-H-1-1"></a>If the type of the division
                                             	    expression is <code class="literal">float</code>, then the float value set must be
                                             	    chosen.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-dynamic"><a name="jls-15.17.2-300-H-1-2"></a>If the type of the division
                                             	    expression is <code class="literal">double</code>, then the double value set must be
                                             	    chosen.
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-15.17.2-300-H-2"></a>If the division
                                    	expression is not FP-strict:
                                 </p>
                                 <div class="norm">
                                    <ul class="norm" type="square">
                                       <li class="listitem">
                                          <p class="norm-dynamic"><a name="jls-15.17.2-300-H-2-1"></a>If the type of the division
                                             	    expression is <code class="literal">float</code>, then either the float value set or
                                             	    the float-extended-exponent value set may be chosen, at
                                             	    the whim of the implementation.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-dynamic"><a name="jls-15.17.2-300-H-2-2"></a>If the type of the division
                                             	    expression is <code class="literal">double</code>, then either the double value set
                                             	    or the double-extended-exponent value set may be chosen,
                                             	    at the whim of the implementation.
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                           </ul>
                        </div>
                        <p class="norm-dynamic"><a name="jls-15.17.2-300-H.1"></a>Next, a value must be chosen from the
                               chosen value set to represent the quotient.
                        </p>
                        <p class="norm-dynamic"><a name="jls-15.17.2-300-H.2"></a>If the magnitude of the quotient is
                               too large to represent, we say the operation overflows; the result
                               is then an infinity of appropriate sign.
                        </p>
                        <p class="norm-dynamic"><a name="jls-15.17.2-300-H.3"></a>Otherwise, the quotient is rounded to
                               the nearest value in the chosen value set using IEEE 754
                               round-to-nearest mode. The Java programming language requires support of gradual
                               underflow as defined by IEEE 754
                               (<a class="xref" href="jls-4.html#jls-4.2.4" title="4.2.4.&nbsp;Floating-Point Operations">&sect;4.2.4</a>).
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-15.17.2-400"></a>Despite
                  the fact that overflow, underflow, division by zero, or loss of
                  information may occur, evaluation of a floating-point division
                  operator <code class="literal">/</code> never throws a run-time exception.
               </p>
            </div>
            <div class="section" title="15.17.3.&nbsp;Remainder Operator %">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.17.3"></a>15.17.3.&nbsp;Remainder Operator <code class="literal">%</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-15.17.3-100"></a>The
                  binary <code class="literal">%</code> operator is said to yield the remainder of
                  its operands from an implied division; the left-hand operand is
                  the <span class="emphasis"><em>dividend</em></span> and the right-hand operand is
                  the <span class="emphasis"><em>divisor</em></span>.
               </p>
               <p class="norm"><a name="jls-15.17.3-110"></a>In C and C++, the remainder
                  operator accepts only integral operands, but in the Java programming language, it
                  also accepts floating-point operands.
               </p>
               <p class="norm-dynamic"><a name="jls-15.17.3-200"></a>The
                  remainder operation for operands that are integers after binary
                  numeric promotion (<a class="xref" href="jls-5.html#jls-5.6.2" title="5.6.2.&nbsp;Binary Numeric Promotion">&sect;5.6.2</a>) produces a result
                  value such that <code class="literal">(a/b)*b+(a%b)</code> is equal
                  to <code class="literal">a</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-15.17.3-210"></a>This
                  identity holds even in the special case that the dividend is the
                  negative integer of largest possible magnitude for its type and the
                  divisor is <code class="literal">-1</code> (the remainder
                  is <code class="literal">0</code>).
               </p>
               <p class="norm-dynamic"><a name="jls-15.17.3-220"></a>It
                  follows from this rule that the result of the remainder operation can
                  be negative only if the dividend is negative, and can be positive only
                  if the dividend is positive. Moreover, the magnitude of the result is
                  always less than the magnitude of the divisor.
               </p>
               <p class="norm-error"><a name="jls-15.17.3-230"></a>If the
                  value of the divisor for an integer remainder operator
                  is <code class="literal">0</code>, then an <code class="literal">ArithmeticException</code> is
                  thrown.
               </p>
               <div class="example"><a name="d5e27634"></a><p class="title"><b>Example&nbsp;15.17.3-1.&nbsp;Integer Remainder Operator</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Test1 {
    public static void main(String[] args) {
        int a = 5%3;  // 2
        int b = 5/3;  // 1
        System.out.println("5%3 produces " + a +
                           " (note that 5/3 produces " + b + ")");

        int c = 5%(-3);  // 2
        int d = 5/(-3);  // -1
        System.out.println("5%(-3) produces " + c +
                           " (note that 5/(-3) produces " + d + ")");

        int e = (-5)%3;  // -2
        int f = (-5)/3;  // -1
        System.out.println("(-5)%3 produces " + e +
                           " (note that (-5)/3 produces " + f + ")");

        int g = (-5)%(-3);  // -2
        int h = (-5)/(-3);  // 1
        System.out.println("(-5)%(-3) produces " + g +
                           " (note that (-5)/(-3) produces " + h + ")");
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
5%3 produces 2 (note that 5/3 produces 1)
5%(-3) produces 2 (note that 5/(-3) produces -1)
(-5)%3 produces -2 (note that (-5)/3 produces -1)
(-5)%(-3) produces -2 (note that (-5)/(-3) produces 1)
</pre></div>
               </div><br class="example-break"><p class="norm"><a name="jls-15.17.3-300"></a>The result of a
                  floating-point remainder operation as computed by
                  the <code class="literal">%</code> operator is <span class="emphasis"><em>not</em></span> the same
                  as that produced by the remainder operation defined by IEEE 754. The
                  IEEE 754 remainder operation computes the remainder from a rounding
                  division, not a truncating division, and so its behavior
                  is <span class="emphasis"><em>not</em></span> analogous to that of the usual integer
                  remainder operator. Instead, the Java programming language
                  defines <code class="literal">%</code> on floating-point operations to behave in
                  a manner analogous to that of the integer remainder operator; this may
                  be compared with the C library function <code class="literal">fmod</code>. The
                  IEEE 754 remainder operation may be computed by the library
                  routine <code class="literal">Math.IEEEremainder</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-15.17.3-310"></a>The
                  result of a floating-point remainder operation is determined by the
                  rules of IEEE 754 arithmetic:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.3-310-A"></a>If either operand is NaN, the result is
                               NaN.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.3-310-B"></a>If the result is not NaN, the sign of
                               the result equals the sign of the dividend.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.3-310-C"></a>If the dividend is an infinity, or the
                               divisor is a zero, or both, the result is NaN.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.3-310-D"></a>If the dividend is finite and the
                               divisor is an infinity, the result equals the dividend.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.3-310-E"></a>If the dividend is a zero and the
                               divisor is finite, the result equals the dividend.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.17.3-310-F"></a>In the remaining cases, where neither
                               an infinity, nor a zero, nor NaN is involved, the floating-point
                               remainder <span class="emphasis"><em>r</em></span> from the division of a dividend <span class="emphasis"><em>n</em></span> by a
                               divisor <span class="emphasis"><em>d</em></span> is defined by the mathematical relation <span class="emphasis"><em>r</em></span> =
                               <span class="emphasis"><em>n</em></span> - (<span class="emphasis"><em>d</em></span> <span class="symbol">&#8901;</span> <span class="emphasis"><em>q</em></span>) where <span class="emphasis"><em>q</em></span> is an integer that
                               is negative only if <span class="emphasis"><em>n</em></span>/<span class="emphasis"><em>d</em></span> is negative and positive only if
                               <span class="emphasis"><em>n</em></span>/<span class="emphasis"><em>d</em></span> is positive, and whose magnitude is as large as
                               possible without exceeding the magnitude of the true mathematical
                               quotient of <span class="emphasis"><em>n</em></span> and <span class="emphasis"><em>d</em></span>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-15.17.3-400"></a>Evaluation of a floating-point remainder
                  operator <code class="literal">%</code> never throws a run-time exception, even
                  if the right-hand operand is zero. Overflow, underflow, or loss of
                  precision cannot occur.
               </p>
               <div class="example"><a name="d5e27677"></a><p class="title"><b>Example&nbsp;15.17.3-2.&nbsp;Floating-Point Remainder Operator</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Test2 {
    public static void main(String[] args) {
        double a = 5.0%3.0;  // 2.0
        System.out.println("5.0%3.0 produces " + a);

        double b = 5.0%(-3.0);  // 2.0
        System.out.println("5.0%(-3.0) produces " + b);

        double c = (-5.0)%3.0;  // -2.0
        System.out.println("(-5.0)%3.0 produces " + c);

        double d = (-5.0)%(-3.0);  // -2.0
        System.out.println("(-5.0)%(-3.0) produces " + d);
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
5.0%3.0 produces 2.0
5.0%(-3.0) produces 2.0
(-5.0)%3.0 produces -2.0
(-5.0)%(-3.0) produces -2.0
</pre></div>
               </div><br class="example-break"></div>
         </div>
         <div class="section" title="15.18.&nbsp;Additive Operators">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.18"></a>15.18.&nbsp;Additive Operators
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-15.18-100"></a>The operators <code class="literal">+</code> and
               <code class="literal">-</code> are called the <span class="emphasis"><em>additive operators</em></span>.
            </p>
            <div id="jls-15.18-110" class="productionset"><a name="jls-15.18-110"></a>
                 
               <div class="production"><a name="jls-AdditiveExpression"></a>
                      
                  <div class="lhs">AdditiveExpression:</div>
                      
                  <div class="rhs">
                           <a href="jls-15.html#jls-MultiplicativeExpression" title="MultiplicativeExpression">MultiplicativeExpression</a> <br>
                           <a href="jls-15.html#jls-AdditiveExpression" title="AdditiveExpression">AdditiveExpression</a> <code class="literal">+</code> <a href="jls-15.html#jls-MultiplicativeExpression" title="MultiplicativeExpression">MultiplicativeExpression</a> <br>
                           <a href="jls-15.html#jls-AdditiveExpression" title="AdditiveExpression">AdditiveExpression</a> <code class="literal">-</code> <a href="jls-15.html#jls-MultiplicativeExpression" title="MultiplicativeExpression">MultiplicativeExpression</a>
                         
                  </div>
                    
               </div>
               
            </div>
            <p class="norm-static"><a name="jls-15.18-120"></a>The
               additive operators have the same precedence and are syntactically
               left-associative (they group left-to-right).
            </p>
            <p class="norm-static"><a name="jls-15.18-200"></a>If the
               type of either operand of a <code class="literal">+</code> operator is <code class="literal">String</code>,
               then the operation is string concatenation.
            </p>
            <p class="norm-error"><a name="jls-15.18-210"></a>Otherwise,
               the type of each of the operands of the <code class="literal">+</code> operator
               must be a type that is convertible (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) to a
               primitive numeric type, or a compile-time error occurs.
            </p>
            <p class="norm-error"><a name="jls-15.18-300"></a>In every
               case, the type of each of the operands of the
               binary <code class="literal">-</code> operator must be a type that is
               convertible (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) to a primitive numeric type,
               or a compile-time error occurs.
            </p>
            <div class="section" title="15.18.1.&nbsp;String Concatenation Operator +">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.18.1"></a>15.18.1.&nbsp;String Concatenation Operator <code class="literal">+</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-dynamic"><a name="jls-15.18.1-100"></a>If only
                  one operand expression is of type <code class="literal">String</code>, then string conversion
                  (<a class="xref" href="jls-5.html#jls-5.1.11" title="5.1.11.&nbsp;String Conversion">&sect;5.1.11</a>) is performed on the other operand to
                  produce a string at run time.
               </p>
               <p class="norm-dynamic"><a name="jls-15.18.1-110"></a>The
                  result of string concatenation is a reference to a
                  <code class="literal">String</code> object that is the concatenation of the two operand
                  strings. The characters of the left-hand operand precede the
                  characters of the right-hand operand in the newly created
                  string.
               </p>
               <p class="norm-dynamic"><a name="jls-15.18.1-120"></a>The
                  <code class="literal">String</code> object is newly created (<a class="xref" href="jls-12.html#jls-12.5" title="12.5.&nbsp;Creation of New Class Instances">&sect;12.5</a>) unless
                  the expression is a constant expression (<a class="xref" href="jls-15.html#jls-15.28" title="15.28.&nbsp;Constant Expressions">&sect;15.28</a>).
               </p>
               <p class="note">An implementation may choose to perform conversion
                  and concatenation in one step to avoid creating and then discarding an
                  intermediate <code class="literal">String</code> object. To increase the performance of repeated
                  string concatenation, a Java compiler may use
                  the <code class="literal">StringBuffer</code> class or a similar technique to
                  reduce the number of intermediate <code class="literal">String</code> objects that are created by
                  evaluation of an expression.
               </p>
               <p class="note">For primitive types, an implementation may also
                  optimize away the creation of a wrapper object by converting directly
                  from a primitive type to a string.
               </p>
               <div class="example"><a name="d5e27726"></a><p class="title"><b>Example&nbsp;15.18.1-1.&nbsp;String Concatenation</b></p>
                  <div class="example-contents">
                     <p class="note">The example expression:</p><pre class="screen">
"The square root of 2 is " + Math.sqrt(2)
</pre><p class="note">produces the result:</p><pre class="screen">
"The square root of 2 is 1.4142135623730952"
</pre><p class="note">The <code class="literal">+</code> operator is syntactically
                        left-associative, no matter whether it is determined by type analysis
                        to represent string concatenation or numeric addition. In some cases
                        care is required to get the desired result. For example, the
                        expression:
                     </p><pre class="screen">
a + b + c
</pre><p class="note">is always regarded as meaning:</p><pre class="screen">
(a + b) + c
</pre><p class="note">Therefore the result of the expression:</p><pre class="screen">
1 + 2 + " fiddlers"
</pre><p class="note">is:</p><pre class="screen">
"3 fiddlers"
</pre><p class="note">but the result of:</p><pre class="screen">
"fiddlers " + 1 + 2
</pre><p class="note">is:</p><pre class="screen">
"fiddlers 12"
</pre></div>
               </div><br class="example-break"><div class="example"><a name="d5e27745"></a><p class="title"><b>Example&nbsp;15.18.1-2.&nbsp;String Concatenation and Conditionals</b></p>
                  <div class="example-contents">
                     <p class="note">In this jocular little example:</p><pre class="programlisting">
class Bottles {
    static void printSong(Object stuff, int n) {
        String plural = (n == 1) ? "" : "s";
  loop: while (true) {
            System.out.println(n + " bottle" + plural
                    + " of " + stuff + " on the wall,");
            System.out.println(n + " bottle" + plural
                    + " of " + stuff + ";");
            System.out.println("You take one down "
                    + "and pass it around:");
            --n;
            plural = (n == 1) ? "" : "s";
            if (n == 0)
                break loop;
            System.out.println(n + " bottle" + plural
                    + " of " + stuff + " on the wall!");
            System.out.println();
        }
        System.out.println("No bottles of " +
                    stuff + " on the wall!");
    }

    public static void main(String[] args) {
        printSong("slime", 3);
    }
}
</pre><p class="note">the method <code class="literal">printSong</code> will print a
                        version of a children's song. Popular values
                        for <code class="literal">stuff</code> include "<code class="literal">pop</code>" and
                        "<code class="literal">beer</code>"; the most popular value
                        for <code class="literal">n</code> is <code class="literal">100</code>. Here is the output
                        that results from running the program:
                     </p><pre class="screen">
3 bottles of slime on the wall,
3 bottles of slime;
You take one down and pass it around:
2 bottles of slime on the wall!

2 bottles of slime on the wall,
2 bottles of slime;
You take one down and pass it around:
1 bottle of slime on the wall!

1 bottle of slime on the wall,
1 bottle of slime;
You take one down and pass it around:
No bottles of slime on the wall!
</pre><p class="note">In the code, note the careful conditional generation
                        of the singular "<code class="literal">bottle</code>" when appropriate rather
                        than the plural "<code class="literal">bottles</code>"; note also how the string
                        concatenation operator was used to break the long constant
                        string:
                     </p><pre class="screen">
"You take one down and pass it around:"
</pre><p class="note">into two pieces to avoid an inconveniently long line
                        in the source code.
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="15.18.2.&nbsp;Additive Operators (+ and -) for Numeric Types">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.18.2"></a>15.18.2.&nbsp;Additive Operators (<code class="literal">+</code> and <code class="literal">-</code>) for Numeric Types
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-dynamic"><a name="jls-15.18.2-100"></a>The
                  binary <code class="literal">+</code> operator performs addition when applied to
                  two operands of numeric type, producing the sum of the
                  operands.
               </p>
               <p class="norm-dynamic"><a name="jls-15.18.2-110"></a>The
                  binary <code class="literal">-</code> operator performs subtraction, producing
                  the difference of two numeric operands.
               </p>
               <p class="norm-static"><a name="jls-15.18.2-200"></a>Binary
                  numeric promotion is performed on the operands
                  (<a class="xref" href="jls-5.html#jls-5.6.2" title="5.6.2.&nbsp;Binary Numeric Promotion">&sect;5.6.2</a>).
               </p>
               <p class="note">Note that binary numeric promotion performs value
                  set conversion (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>) and may perform unboxing
                  conversion (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>).
               </p>
               <p class="norm-static"><a name="jls-15.18.2-210"></a>The type
                  of an additive expression on numeric operands is the promoted type of
                  its operands.
               </p>
               <p class="norm-dynamic"><a name="jls-15.18.2-220"></a>If this
                  promoted type is <code class="literal">int</code> or <code class="literal">long</code>, then integer arithmetic is
                  performed.
               </p>
               <p class="norm-dynamic"><a name="jls-15.18.2-230"></a>If this
                  promoted type is <code class="literal">float</code> or <code class="literal">double</code>, then floating-point arithmetic
                  is performed.
               </p>
               <p class="norm-static"><a name="jls-15.18.2-300"></a>Addition
                  is a commutative operation if the operand expressions have no side
                  effects.
               </p>
               <p class="norm-static"><a name="jls-15.18.2-310"></a>Integer
                  addition is associative when the operands are all of the same
                  type.
               </p>
               <p class="norm-static"><a name="jls-15.18.2-320"></a>Floating-point addition is not
                  associative.
               </p>
               <p class="norm-dynamic"><a name="jls-15.18.2-400"></a>If an
                  integer addition overflows, then the result is the low-order bits of
                  the mathematical sum as represented in some sufficiently large
                  two's-complement format. If overflow occurs, then the sign of the
                  result is not the same as the sign of the mathematical sum of the two
                  operand values.
               </p>
               <p class="norm-dynamic"><a name="jls-15.18.2-500"></a>The
                  result of a floating-point addition is determined using the following
                  rules of IEEE 754 arithmetic:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.18.2-500-A"></a>If either operand is NaN, the result is
                               NaN.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.18.2-500-B"></a>The sum of two infinities of opposite
                               sign is NaN.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.18.2-500-C"></a>The sum of two infinities of the same
                               sign is the infinity of that sign.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.18.2-500-D"></a>The sum of an infinity and a finite
                               value is equal to the infinite operand.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.18.2-500-E"></a>The sum of two zeros of opposite sign
                               is positive zero.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.18.2-500-F"></a>The sum of two zeros of the same sign
                               is the zero of that sign.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.18.2-500-G"></a>The sum of a zero and a nonzero finite
                               value is equal to the nonzero operand.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.18.2-500-H"></a>The sum of two nonzero finite values of
                               the same magnitude and opposite sign is positive zero.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.18.2-500-I"></a>In the remaining cases, where neither
                               an infinity, nor a zero, nor NaN is involved, and the operands
                               have the same sign or have different magnitudes, the exact
                               mathematical sum is computed. A floating-point value set is then
                               chosen:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm"><a name="jls-15.18.2-500-I-1"></a>If the addition
                                    	expression is FP-strict (<a class="xref" href="jls-15.html#jls-15.4" title="15.4.&nbsp;FP-strict Expressions">&sect;15.4</a>):
                                 </p>
                                 <div class="norm">
                                    <ul class="norm" type="square">
                                       <li class="listitem">
                                          <p class="norm-dynamic"><a name="jls-15.18.2-500-I-1-1"></a>If the type of the addition
                                             	    expression is <code class="literal">float</code>, then the float value set must be
                                             	    chosen.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-dynamic"><a name="jls-15.18.2-500-I-1-2"></a>If the type of the addition
                                             	    expression is <code class="literal">double</code>, then the double value set must be
                                             	    chosen.
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-15.18.2-500-I-2"></a>If the addition
                                    	expression is not FP-strict:
                                 </p>
                                 <div class="norm">
                                    <ul class="norm" type="square">
                                       <li class="listitem">
                                          <p class="norm-dynamic"><a name="jls-15.18.2-500-I-2-1"></a>If the type of the addition
                                             	    expression is <code class="literal">float</code>, then either the float value set or
                                             	    the float-extended-exponent value set may be chosen, at
                                             	    the whim of the implementation.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-dynamic"><a name="jls-15.18.2-500-I-2-2"></a>If the type of the addition
                                             	    expression is <code class="literal">double</code>, then either the double value set
                                             	    or the double-extended-exponent value set may be chosen,
                                             	    at the whim of the implementation.
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                           </ul>
                        </div>
                        <p class="norm-dynamic"><a name="jls-15.18.2-500-I.1"></a>Next, a value must be chosen from the
                               chosen value set to represent the sum.
                        </p>
                        <p class="norm-dynamic"><a name="jls-15.18.2-500-I.2"></a>If the magnitude of the sum is too
                               large to represent, we say the operation overflows; the result is
                               then an infinity of appropriate sign.
                        </p>
                        <p class="norm-dynamic"><a name="jls-15.18.2-500-I.3"></a>Otherwise, the sum is rounded to the
                               nearest value in the chosen value set using IEEE 754
                               round-to-nearest mode. The Java programming language requires support of gradual
                               underflow as defined by IEEE 754
                               (<a class="xref" href="jls-4.html#jls-4.2.4" title="4.2.4.&nbsp;Floating-Point Operations">&sect;4.2.4</a>).
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-15.18.2-600"></a>The
                  binary <code class="literal">-</code> operator performs subtraction when applied
                  to two operands of numeric type, producing the difference of its
                  operands; the left-hand operand is the <span class="emphasis"><em>minuend</em></span>
                  and the right-hand operand is
                  the <span class="emphasis"><em>subtrahend</em></span>.
               </p>
               <p class="norm-dynamic"><a name="jls-15.18.2-610"></a>For
                  both integer and floating-point subtraction, it is always the case
                  that <code class="literal">a-b</code> produces the same result
                  as <code class="literal">a+(-b)</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-15.18.2-620"></a>Note
                  that, for integer values, subtraction from zero is the same as
                  negation. However, for floating-point operands, subtraction from zero
                  is <span class="emphasis"><em>not</em></span> the same as negation, because if x
                  is <code class="literal">+0.0</code>, then <code class="literal">0.0-x</code>
                  is <code class="literal">+0.0</code>, but <code class="literal">-x</code>
                  is <code class="literal">-0.0</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-15.18.2-700"></a>Despite
                  the fact that overflow, underflow, or loss of information may occur,
                  evaluation of a numeric additive operator never throws a run-time
                  exception.
               </p>
            </div>
         </div>
         <div class="section" title="15.19.&nbsp;Shift Operators">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.19"></a>15.19.&nbsp;Shift Operators
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-15.19-100"></a>The operators <code class="literal">&lt;&lt;</code> (left
               shift), <code class="literal">&gt;&gt;</code> (signed right shift), and <code class="literal">&gt;&gt;&gt;</code> (unsigned right
               shift) are called the <span class="emphasis"><em>shift operators</em></span>. The
               left-hand operand of a shift operator is the value to be shifted; the
               right-hand operand specifies the shift distance.
            </p>
            <div id="jls-15.19-110" class="productionset"><a name="jls-15.19-110"></a>
                 
               <div class="production"><a name="jls-ShiftExpression"></a>
                      
                  <div class="lhs">ShiftExpression:</div>
                      
                  <div class="rhs">
                           <a href="jls-15.html#jls-AdditiveExpression" title="AdditiveExpression">AdditiveExpression</a> <br>
                           <a href="jls-15.html#jls-ShiftExpression" title="ShiftExpression">ShiftExpression</a> <code class="literal">&lt;&lt;</code> <a href="jls-15.html#jls-AdditiveExpression" title="AdditiveExpression">AdditiveExpression</a> <br>
                           <a href="jls-15.html#jls-ShiftExpression" title="ShiftExpression">ShiftExpression</a> <code class="literal">&gt;&gt;</code> <a href="jls-15.html#jls-AdditiveExpression" title="AdditiveExpression">AdditiveExpression</a> <br>
                           <a href="jls-15.html#jls-ShiftExpression" title="ShiftExpression">ShiftExpression</a> <code class="literal">&gt;&gt;&gt;</code> <a href="jls-15.html#jls-AdditiveExpression" title="AdditiveExpression">AdditiveExpression</a>
                         
                  </div>
                    
               </div>
               
            </div>
            <p class="norm-static"><a name="jls-15.19-120"></a>The shift
               operators are syntactically left-associative (they group
               left-to-right).
            </p>
            <p class="norm-static"><a name="jls-15.19-200"></a>Unary
               numeric promotion (<a class="xref" href="jls-5.html#jls-5.6.1" title="5.6.1.&nbsp;Unary Numeric Promotion">&sect;5.6.1</a>) is performed on each
               operand separately. (Binary numeric promotion
               (<a class="xref" href="jls-5.html#jls-5.6.2" title="5.6.2.&nbsp;Binary Numeric Promotion">&sect;5.6.2</a>) is <span class="emphasis"><em>not</em></span> performed on
               the operands.)
            </p>
            <p class="norm-error"><a name="jls-15.19-210"></a>It is a
               compile-time error if the type of each of the operands of a shift
               operator, after unary numeric promotion, is not a primitive integral
               type.
            </p>
            <p class="norm-static"><a name="jls-15.19-220"></a>The type
               of the shift expression is the promoted type of the left-hand
               operand.
            </p>
            <p class="norm-static"><a name="jls-15.19-300"></a>If the
               promoted type of the left-hand operand is <code class="literal">int</code>, only the five
               lowest-order bits of the right-hand operand are used as the shift
               distance. It is as if the right-hand operand were subjected to a
               bitwise logical AND operator <code class="literal">&amp;</code> (<a class="xref" href="jls-15.html#jls-15.22.1" title="15.22.1.&nbsp;Integer Bitwise Operators &amp;, ^, and |">&sect;15.22.1</a>)
               with the mask value <code class="literal">0x1f</code>
               (<code class="literal">0b11111</code>). The shift distance actually used is
               therefore always in the range <code class="literal">0</code> to <code class="literal">31</code>,
               inclusive.
            </p>
            <p class="norm-static"><a name="jls-15.19-310"></a>If the
               promoted type of the left-hand operand is <code class="literal">long</code>, then only the six
               lowest-order bits of the right-hand operand are used as the shift
               distance. It is as if the right-hand operand were subjected to a
               bitwise logical AND operator <code class="literal">&amp;</code> (<a class="xref" href="jls-15.html#jls-15.22.1" title="15.22.1.&nbsp;Integer Bitwise Operators &amp;, ^, and |">&sect;15.22.1</a>)
               with the mask value <code class="literal">0x3f</code>
               (<code class="literal">0b111111</code>). The shift distance actually used is
               therefore always in the range <code class="literal">0</code> to <code class="literal">63</code>,
               inclusive.
            </p>
            <p class="norm-dynamic"><a name="jls-15.19-400"></a>At run
               time, shift operations are performed on the two's-complement integer
               representation of the value of the left operand.
            </p>
            <p class="norm-dynamic"><a name="jls-15.19-410"></a>The value
               of <span class="emphasis"><em>n</em></span> <code class="literal">&lt;&lt;</code> <span class="emphasis"><em>s</em></span> is <span class="emphasis"><em>n</em></span> left-shifted <span class="emphasis"><em>s</em></span> bit positions;
               this is equivalent (even if overflow occurs) to multiplication by two
               to the power <span class="emphasis"><em>s</em></span>.
            </p>
            <p class="norm-dynamic"><a name="jls-15.19-420"></a>The value
               of <span class="emphasis"><em>n</em></span> <code class="literal">&gt;&gt;</code> <span class="emphasis"><em>s</em></span> is <span class="emphasis"><em>n</em></span> right-shifted <span class="emphasis"><em>s</em></span> bit positions
               with sign-extension. The resulting value is <span class="symbol">&#63728;</span> <span class="emphasis"><em>n</em></span> <code class="literal">/
                  2</code><sup><span class="emphasis"><em>s</em></span></sup> <span class="symbol">&#63739;</span>. For
               non-negative values of <span class="emphasis"><em>n</em></span>, this is equivalent to truncating
               integer division, as computed by the integer division
               operator <code class="literal">/</code>, by two to the power <span class="emphasis"><em>s</em></span>.
            </p>
            <p class="norm-dynamic"><a name="jls-15.19-430"></a>The value
               of <span class="emphasis"><em>n</em></span> <code class="literal">&gt;&gt;&gt;</code> <span class="emphasis"><em>s</em></span> is <span class="emphasis"><em>n</em></span> right-shifted <span class="emphasis"><em>s</em></span> bit
               positions with zero-extension, where:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-dynamic"><a name="jls-15.19-430-A"></a>If
                            <span class="emphasis"><em>n</em></span> is positive, then the result is the same as that of <span class="emphasis"><em>n</em></span>
                            <code class="literal">&gt;&gt;</code> <span class="emphasis"><em>s</em></span>.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-dynamic"><a name="jls-15.19-430-B"></a>If
                            <span class="emphasis"><em>n</em></span> is negative and the type of the left-hand operand is <code class="literal">int</code>,
                            then the result is equal to that of the expression <code class="literal">(</code><span class="emphasis"><em>n</em></span>
                            <code class="literal">&gt;&gt;</code> <span class="emphasis"><em>s</em></span><code class="literal">)</code> <code class="literal">+</code> <code class="literal">(</code><code class="literal">2</code> <code class="literal">&lt;&lt;</code>
                            <code class="literal">~</code><span class="emphasis"><em>s</em></span><code class="literal">)</code>.
                            
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-dynamic"><a name="jls-15.19-430-C"></a>If
                            <span class="emphasis"><em>n</em></span> is negative and the type of the left-hand operand is
                            <code class="literal">long</code>, then the result is equal to that of the
                            expression 
                              <code class="literal">(</code><span class="emphasis"><em>n</em></span> <code class="literal">&gt;&gt;</code> <span class="emphasis"><em>s</em></span><code class="literal">)</code> <code class="literal">+</code>
                              <code class="literal">(</code><code class="literal">2L</code> <code class="literal">&lt;&lt;</code> <code class="literal">~</code><span class="emphasis"><em>s</em></span><code class="literal">)</code>.
                            
                     </p>
                  </li>
               </ul>
            </div>
            <p class="note">The added term <code class="literal">(</code><code class="literal">2</code> <code class="literal">&lt;&lt;</code>
               <code class="literal">~</code><span class="emphasis"><em>s</em></span><code class="literal">)</code> or <code class="literal">(</code><code class="literal">2L</code> <code class="literal">&lt;&lt;</code>
               <code class="literal">~</code><span class="emphasis"><em>s</em></span><code class="literal">)</code> cancels out the propagated sign bit.
            </p>
            <p class="note">Note that, because of the implicit masking of the
               right-hand operand of a shift operator, <code class="literal">~</code><span class="emphasis"><em>s</em></span> as
               a shift distance is equivalent to <code class="literal">31-</code><span class="emphasis"><em>s</em></span> when
               shifting an <code class="literal">int</code> value and to <code class="literal">63-</code><span class="emphasis"><em>s</em></span> when
               shifting a <code class="literal">long</code> value.
            </p>
         </div>
         <div class="section" title="15.20.&nbsp;Relational Operators">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.20"></a>15.20.&nbsp;Relational Operators
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-15.20-100"></a>The numerical comparison
               operators <code class="literal">&lt;</code>, <code class="literal">&gt;</code>, <code class="literal">&lt;=</code>, and
               <code class="literal">&gt;=</code>, and the <code class="literal">instanceof</code> operator, are called
               the <span class="emphasis"><em>relational operators</em></span>.
            </p>
            <div id="jls-15.20-110" class="productionset"><a name="jls-15.20-110"></a>
                 
               <div class="production"><a name="jls-RelationalExpression"></a>
                      
                  <div class="lhs">RelationalExpression:</div>
                      
                  <div class="rhs">
                           <a href="jls-15.html#jls-ShiftExpression" title="ShiftExpression">ShiftExpression</a> <br>
                           <a href="jls-15.html#jls-RelationalExpression" title="RelationalExpression">RelationalExpression</a> <code class="literal">&lt;</code> <a href="jls-15.html#jls-ShiftExpression" title="ShiftExpression">ShiftExpression</a> <br>
                           <a href="jls-15.html#jls-RelationalExpression" title="RelationalExpression">RelationalExpression</a> <code class="literal">&gt;</code> <a href="jls-15.html#jls-ShiftExpression" title="ShiftExpression">ShiftExpression</a> <br>
                           <a href="jls-15.html#jls-RelationalExpression" title="RelationalExpression">RelationalExpression</a> <code class="literal">&lt;=</code> <a href="jls-15.html#jls-ShiftExpression" title="ShiftExpression">ShiftExpression</a> <br>
                           <a href="jls-15.html#jls-RelationalExpression" title="RelationalExpression">RelationalExpression</a> <code class="literal">&gt;=</code> <a href="jls-15.html#jls-ShiftExpression" title="ShiftExpression">ShiftExpression</a> <br>
                           <a href="jls-15.html#jls-RelationalExpression" title="RelationalExpression">RelationalExpression</a> <code class="literal">instanceof</code> <a href="jls-4.html#jls-ReferenceType" title="ReferenceType">ReferenceType</a>
                         
                  </div>
                    
               </div>
               
            </div>
            <p class="norm-static"><a name="jls-15.20-120"></a>The
               relational operators are syntactically left-associative (they group
               left-to-right).
            </p>
            <p class="note">However, this fact is not useful. For
               example, <code class="literal">a&lt;b&lt;c</code> parses
               as <code class="literal">(a&lt;b)&lt;c</code>, which is always a compile-time
               error, because the type of <code class="literal">a&lt;b</code> is always
               <code class="literal">boolean</code> and &lt; is not an operator on <code class="literal">boolean</code> values.
            </p>
            <p class="norm-static"><a name="jls-15.20-200"></a>The type
               of a relational expression is always <code class="literal">boolean</code>.
            </p>
            <div class="section" title="15.20.1.&nbsp;Numerical Comparison Operators <, <=, &gt;, and &gt;=">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.20.1"></a>15.20.1.&nbsp;Numerical Comparison Operators <code class="literal">&lt;</code>,
                           <code class="literal">&lt;=</code>, <code class="literal">&gt;</code>, and <code class="literal">&gt;=</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-error"><a name="jls-15.20.1-100"></a>The type
                  of each of the operands of a numerical comparison operator must be a
                  type that is convertible (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) to a primitive
                  numeric type, or a compile-time error occurs.
               </p>
               <p class="norm-static"><a name="jls-15.20.1-110"></a>Binary
                  numeric promotion is performed on the operands
                  (<a class="xref" href="jls-5.html#jls-5.6.2" title="5.6.2.&nbsp;Binary Numeric Promotion">&sect;5.6.2</a>).
               </p>
               <p class="note">Note that binary numeric promotion performs value
                  set conversion (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>) and may perform unboxing
                  conversion (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>).
               </p>
               <p class="norm-dynamic"><a name="jls-15.20.1-120"></a>If the
                  promoted type of the operands is <code class="literal">int</code> or <code class="literal">long</code>, then signed integer
                  comparison is performed.
               </p>
               <p class="norm-dynamic"><a name="jls-15.20.1-130"></a>If the
                  promoted type is <code class="literal">float</code> or <code class="literal">double</code>, then floating-point comparison
                  is performed.
               </p>
               <p class="norm-dynamic"><a name="jls-15.20.1-200"></a>Comparison is carried out accurately on
                  floating-point values, no matter what value sets their representing
                  values were drawn from.
               </p>
               <p class="norm-dynamic"><a name="jls-15.20.1-210"></a>The
                  result of a floating-point comparison, as determined by the
                  specification of the IEEE 754 standard, is:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.20.1-210-A"></a>If either operand is NaN, then the
                               result is false.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.20.1-210-B"></a>All values other than NaN are ordered,
                               with negative infinity less than all finite values, and positive
                               infinity greater than all finite values.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.20.1-210-C"></a>Positive zero and negative zero are
                               considered equal.
                        </p>
                        <p class="note">For example, <code class="literal">-0.0&lt;0.0</code> is
                               <code class="literal">false</code>, but <code class="literal">-0.0&lt;=0.0</code> is <code class="literal">true</code>.
                        </p>
                        <p class="note">Note, however, that the
                               methods <code class="literal">Math.min</code>
                               and <code class="literal">Math.max</code> treat negative zero as being
                               strictly smaller than positive zero.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-15.20.1-220"></a>Subject to these
                  considerations for floating-point numbers, the following rules then
                  hold for integer operands or for floating-point operands other than
                  NaN:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.20.1-220-A"></a>The value produced by the <code class="literal">&lt;</code>
                               operator is <code class="literal">true</code> if the value of the left-hand operand is less
                               than the value of the right-hand operand, and otherwise is
                               <code class="literal">false</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.20.1-220-B"></a>The value produced by the
                               <code class="literal">&lt;=</code> operator is <code class="literal">true</code> if the value of the
                               left-hand operand is less than or equal to the value of the
                               right-hand operand, and otherwise is <code class="literal">false</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.20.1-220-C"></a>The value produced by the
                               <code class="literal">&gt;</code> operator is <code class="literal">true</code> if the value of the left-hand
                               operand is greater than the value of the right-hand operand, and
                               otherwise is <code class="literal">false</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.20.1-220-D"></a>The value produced by the
                               <code class="literal">&gt;=</code> operator is <code class="literal">true</code> if the value of the
                               left-hand operand is greater than or equal to the value of the
                               right-hand operand, and otherwise is <code class="literal">false</code>.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="15.20.2.&nbsp;Type Comparison Operator instanceof">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.20.2"></a>15.20.2.&nbsp;Type Comparison Operator <code class="literal">instanceof</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-error"><a name="jls-15.20.2-100"></a>The type
                  of the <span class="emphasis"><em>RelationalExpression</em></span> operand of the
                  <code class="literal">instanceof</code> operator must be a reference type or the null type;
                  otherwise, a compile-time error occurs.
               </p>
               <p class="norm-error"><a name="jls-15.20.2-110"></a>It is a
                  compile-time error if the <span class="emphasis"><em>ReferenceType</em></span> mentioned
                  after the <code class="literal">instanceof</code> operator does not denote a reference type that
                  is reifiable (<a class="xref" href="jls-4.html#jls-4.7" title="4.7.&nbsp;Reifiable Types">&sect;4.7</a>).
               </p>
               <p class="norm-error"><a name="jls-15.20.2-120"></a>If a cast
                  (<a class="xref" href="jls-15.html#jls-15.16" title="15.16.&nbsp;Cast Expressions">&sect;15.16</a>) of
                  the <span class="emphasis"><em>RelationalExpression</em></span> to
                  the <span class="emphasis"><em>ReferenceType</em></span> would be rejected as a
                  compile-time error, then the <code class="literal">instanceof</code> relational expression
                  likewise produces a compile-time error. In such a situation, the
                  result of the <code class="literal">instanceof</code> expression could never be true.
               </p>
               <p class="norm-dynamic"><a name="jls-15.20.2-200"></a>At run
                  time, the result of the <code class="literal">instanceof</code> operator is <code class="literal">true</code> if the value
                  of the <span class="emphasis"><em>RelationalExpression</em></span> is not <code class="literal">null</code> and the
                  reference could be cast to the <span class="emphasis"><em>ReferenceType</em></span>
                  without raising a <code class="literal">ClassCastException</code>. Otherwise the result is <code class="literal">false</code>.
               </p>
               <div class="example"><a name="d5e28099"></a><p class="title"><b>Example&nbsp;15.20.2-1.&nbsp;The <code class="literal">instanceof</code> Operator</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Point   { int x, y; }
class Element { int atomicNumber; }
class Test {
    public static void main(String[] args) {
        Point   p = new Point();
        Element e = new Element();
        if (e instanceof Point) {  // compile-time error
            System.out.println("I get your point!");
            p = (Point)e;  // compile-time error
        }
    }
}
</pre><p class="note">This program results in two compile-time errors. The
                        cast <code class="literal">(Point)e</code> is incorrect because no instance
                        of <code class="literal">Element</code> or any of its possible subclasses (none
                        are shown here) could possibly be an instance of any subclass
                        of <code class="literal">Point</code>. The <code class="literal">instanceof</code> expression is incorrect
                        for exactly the same reason. If, on the other hand, the
                        class <code class="literal">Point</code> were a subclass
                        of <code class="literal">Element</code> (an admittedly strange notion in this
                        example):
                     </p><pre class="programlisting">

class Point extends Element { int x, y; }

</pre><p class="note">then the cast would be possible, though it would
                        require a run-time check, and the <code class="literal">instanceof</code> expression would then
                        be sensible and valid. The cast <code class="literal">(Point)e</code> would
                        never raise an exception because it would not be executed if the value
                        of <code class="literal">e</code> could not correctly be cast to
                        type <code class="literal">Point</code>.
                     </p>
                  </div>
               </div><br class="example-break"></div>
         </div>
         <div class="section" title="15.21.&nbsp;Equality Operators">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.21"></a>15.21.&nbsp;Equality Operators
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-15.21-100"></a>The
               operators <code class="literal">==</code> (equal to) and <code class="literal">!=</code>
               (not equal to) are called the <span class="emphasis"><em>equality
                     operators</em></span>.
            </p>
            <div id="jls-15.21-110" class="productionset"><a name="jls-15.21-110"></a>
                 
               <div class="production"><a name="jls-EqualityExpression"></a>
                      
                  <div class="lhs">EqualityExpression:</div>
                      
                  <div class="rhs">
                           <a href="jls-15.html#jls-RelationalExpression" title="RelationalExpression">RelationalExpression</a> <br>
                           <a href="jls-15.html#jls-EqualityExpression" title="EqualityExpression">EqualityExpression</a> <code class="literal">==</code> <a href="jls-15.html#jls-RelationalExpression" title="RelationalExpression">RelationalExpression</a> <br>
                           <a href="jls-15.html#jls-EqualityExpression" title="EqualityExpression">EqualityExpression</a> <code class="literal">!=</code> <a href="jls-15.html#jls-RelationalExpression" title="RelationalExpression">RelationalExpression</a>
                         
                  </div>
                    
               </div>
               
            </div>
            <p class="norm-static"><a name="jls-15.21-120"></a>The
               equality operators are syntactically left-associative (they group
               left-to-right).
            </p>
            <p class="note">However, this fact is essentially never useful. For
               example, <code class="literal">a==b==c</code> parses
               as <code class="literal">(a==b)==c</code>. The result type
               of <code class="literal">a==b</code> is always <code class="literal">boolean</code>,
               and <code class="literal">c</code> must therefore be of type <code class="literal">boolean</code> or a
               compile-time error occurs. Thus, <code class="literal">a==b==c</code> does not
               test to see whether <code class="literal">a</code>, <code class="literal">b</code>,
               and <code class="literal">c</code> are all equal.
            </p>
            <p class="norm-static"><a name="jls-15.21-130"></a>The
               equality operators are commutative if the operand expressions have no
               side effects.
            </p>
            <p class="norm-static"><a name="jls-15.21-140"></a>The
               equality operators are analogous to the relational operators except
               for their lower precedence. Thus, <code class="literal">a&lt;b==c&lt;d</code> is
               <code class="literal">true</code> whenever <code class="literal">a&lt;b</code> and 
               <code class="literal">c&lt;d</code> have the same truth value.
            </p>
            <p class="norm-error"><a name="jls-15.21-200"></a>The
               equality operators may be used to compare two operands that are
               convertible (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) to numeric type, or two
               operands of type <code class="literal">boolean</code> or <code class="literal">Boolean</code>, or two operands that are each
               of either reference type or the null type. All other cases result in a
               compile-time error.
            </p>
            <p class="norm-static"><a name="jls-15.21-210"></a>The type
               of an equality expression is always <code class="literal">boolean</code>.
            </p>
            <p class="norm-dynamic"><a name="jls-15.21-300"></a>In all
               cases, <code class="literal">a!=b</code> produces the same result
               as <code class="literal">!(a==b)</code>.
            </p>
            <div class="section" title="15.21.1.&nbsp;Numerical Equality Operators == and !=">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.21.1"></a>15.21.1.&nbsp;Numerical Equality Operators <code class="literal">==</code> and <code class="literal">!=</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.21.1-100"></a>If the
                  operands of an equality operator are both of numeric type, or one is
                  of numeric type and the other is convertible
                  (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) to numeric type, binary numeric
                  promotion is performed on the operands
                  (<a class="xref" href="jls-5.html#jls-5.6.2" title="5.6.2.&nbsp;Binary Numeric Promotion">&sect;5.6.2</a>).
               </p>
               <p class="note">Note that binary numeric promotion performs value
                  set conversion (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>) and may perform unboxing
                  conversion (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>).
               </p>
               <p class="norm-dynamic"><a name="jls-15.21.1-110"></a>If the
                  promoted type of the operands is <code class="literal">int</code> or <code class="literal">long</code>, then an integer
                  equality test is performed.
               </p>
               <p class="norm-dynamic"><a name="jls-15.21.1-120"></a>If the
                  promoted type is <code class="literal">float</code> or <code class="literal">double</code>, then a floating-point equality
                  test is performed.
               </p>
               <p class="norm-dynamic"><a name="jls-15.21.1-200"></a>Comparison is carried out accurately on
                  floating-point values, no matter what value sets their representing
                  values were drawn from.
               </p>
               <p class="norm-dynamic"><a name="jls-15.21.1-210"></a>Floating-point equality testing is performed
                  in accordance with the rules of the IEEE 754 standard:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.21.1-210-A"></a>If either operand is NaN, then the
                               result of <code class="literal">==</code> is <code class="literal">false</code> but the result
                               of <code class="literal">!=</code> is <code class="literal">true</code>.
                        </p>
                        <p class="norm-dynamic"><a name="jls-15.21.1-210-A.1"></a>Indeed, the
                               test <code class="literal">x!=x</code> is <code class="literal">true</code> if and only if the value
                               of <code class="literal">x</code> is NaN.
                        </p>
                        <p class="note">The methods <code class="literal">Float.isNaN</code>
                               and <code class="literal">Double.isNaN</code> may also be used to test
                               whether a value is NaN.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.21.1-210-B"></a>Positive zero and negative zero are
                               considered equal.
                        </p>
                        <p class="note">For example, <code class="literal">-0.0==0.0</code> is
                               <code class="literal">true</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.21.1-210-C"></a>Otherwise, two distinct floating-point
                               values are considered unequal by the equality operators.
                        </p>
                        <p class="norm-dynamic"><a name="jls-15.21.1-210-C.1"></a>In particular, there is one value
                               representing positive infinity and one value representing negative
                               infinity; each compares equal only to itself, and each compares
                               unequal to all other values.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-15.21.1-220"></a>Subject
                  to these considerations for floating-point numbers, the following
                  rules then hold for integer operands or for floating-point operands
                  other than NaN:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.21.1-220-A"></a>The value produced by
                               the <code class="literal">==</code> operator is <code class="literal">true</code> if the value of the
                               left-hand operand is equal to the value of the right-hand operand;
                               otherwise, the result is <code class="literal">false</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.21.1-220-B"></a>The value produced by
                               the <code class="literal">!=</code> operator is <code class="literal">true</code> if the value of the
                               left-hand operand is not equal to the value of the right-hand
                               operand; otherwise, the result is <code class="literal">false</code>.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="15.21.2.&nbsp;Boolean Equality Operators == and !=">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.21.2"></a>15.21.2.&nbsp;Boolean Equality Operators <code class="literal">==</code> and <code class="literal">!=</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.21.2-100"></a>If the
                  operands of an equality operator are both of type <code class="literal">boolean</code>, or if one
                  operand is of type <code class="literal">boolean</code> and the other is of type <code class="literal">Boolean</code>, then
                  the operation is boolean equality.
               </p>
               <p class="norm-static"><a name="jls-15.21.2-110"></a>The
                  boolean equality operators are associative.
               </p>
               <p class="norm-dynamic"><a name="jls-15.21.2-200"></a>If one
                  of the operands is of type <code class="literal">Boolean</code>, it is subjected to unboxing
                  conversion (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>).
               </p>
               <p class="norm-dynamic"><a name="jls-15.21.2-300"></a>The
                  result of <code class="literal">==</code> is <code class="literal">true</code> if the operands (after any
                  required unboxing conversion) are both <code class="literal">true</code> or both <code class="literal">false</code>;
                  otherwise, the result is <code class="literal">false</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-15.21.2-400"></a>The
                  result of <code class="literal">!=</code> is <code class="literal">false</code> if the operands are both
                  <code class="literal">true</code> or both <code class="literal">false</code>; otherwise, the result is <code class="literal">true</code>.
               </p>
               <p class="note">Thus <code class="literal">!=</code> behaves the same
                  as <code class="literal">^</code> (<a class="xref" href="jls-15.html#jls-15.22.2" title="15.22.2.&nbsp;Boolean Logical Operators &amp;, ^, and |">&sect;15.22.2</a>) when applied
                  to <code class="literal">boolean</code> operands.
               </p>
            </div>
            <div class="section" title="15.21.3.&nbsp;Reference Equality Operators == and !=">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.21.3"></a>15.21.3.&nbsp;Reference Equality Operators <code class="literal">==</code> and <code class="literal">!=</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.21.3-100"></a>If the
                  operands of an equality operator are both of either reference type or
                  the null type, then the operation is object equality.
               </p>
               <p class="norm-error"><a name="jls-15.21.3-110"></a>It is a
                  compile-time error if it is impossible to convert the type of either
                  operand to the type of the other by a casting conversion
                  (<a class="xref" href="jls-5.html#jls-5.5" title="5.5.&nbsp;Casting Contexts">&sect;5.5</a>). The run-time values of the two operands
                  would necessarily be unequal.
               </p>
               <p class="norm-dynamic"><a name="jls-15.21.3-200"></a>At
                  run time, the result of <code class="literal">==</code> is <code class="literal">true</code> if the operand
                  values are both <code class="literal">null</code> or both refer to the same object or array;
                  otherwise, the result is <code class="literal">false</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-15.21.3-300"></a>The
                  result of <code class="literal">!=</code> is <code class="literal">false</code> if the operand values are both
                  <code class="literal">null</code> or both refer to the same object or array; otherwise, the
                  result is <code class="literal">true</code>.
               </p>
               <p class="norm"><a name="jls-15.21.3-400"></a>While <code class="literal">==</code> may be
                  used to compare references of type <code class="literal">String</code>, such an equality test
                  determines whether or not the two operands refer to the same <code class="literal">String</code>
                  object. The result is <code class="literal">false</code> if the operands are distinct <code class="literal">String</code>
                  objects, even if they contain the same sequence of characters
                  (<a class="xref" href="jls-3.html#jls-3.10.5" title="3.10.5.&nbsp;String Literals">&sect;3.10.5</a>). The contents of two
                  strings <code class="literal">s</code> and <code class="literal">t</code> can be tested
                  for equality by the method
                  invocation <code class="literal">s.equals(t)</code>.
               </p>
            </div>
         </div>
         <div class="section" title="15.22.&nbsp;Bitwise and Logical Operators">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.22"></a>15.22.&nbsp;Bitwise and Logical Operators
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-15.22-100"></a>The <span class="emphasis"><em>bitwise
                     operators</em></span> and <span class="emphasis"><em>logical operators</em></span>
               include the AND operator <code class="literal">&amp;</code>, exclusive OR operator <code class="literal">^</code>, and
               inclusive OR operator <code class="literal">|</code>.
            </p>
            <div id="jls-15.22-110" class="productionset"><a name="jls-15.22-110"></a>
                 
               <div class="production"><a name="jls-AndExpression"></a>
                      
                  <div class="lhs">AndExpression:</div>
                      
                  <div class="rhs">
                           <a href="jls-15.html#jls-EqualityExpression" title="EqualityExpression">EqualityExpression</a> <br>
                           <a href="jls-15.html#jls-AndExpression" title="AndExpression">AndExpression</a> <code class="literal">&amp;</code> <a href="jls-15.html#jls-EqualityExpression" title="EqualityExpression">EqualityExpression</a>
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-ExclusiveOrExpression"></a>
                      
                  <div class="lhs">ExclusiveOrExpression:</div>
                      
                  <div class="rhs">
                           <a href="jls-15.html#jls-AndExpression" title="AndExpression">AndExpression</a> <br>
                           <a href="jls-15.html#jls-ExclusiveOrExpression" title="ExclusiveOrExpression">ExclusiveOrExpression</a> <code class="literal">^</code> <a href="jls-15.html#jls-AndExpression" title="AndExpression">AndExpression</a>
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-InclusiveOrExpression"></a>
                      
                  <div class="lhs">InclusiveOrExpression:</div>
                      
                  <div class="rhs">
                           <a href="jls-15.html#jls-ExclusiveOrExpression" title="ExclusiveOrExpression">ExclusiveOrExpression</a> <br>
                           <a href="jls-15.html#jls-InclusiveOrExpression" title="InclusiveOrExpression">InclusiveOrExpression</a> <code class="literal">|</code> <a href="jls-15.html#jls-ExclusiveOrExpression" title="ExclusiveOrExpression">ExclusiveOrExpression</a>
                         
                  </div>
                    
               </div>
               
            </div>
            <p class="norm-static"><a name="jls-15.22-120"></a>These
               operators have different precedence, with <code class="literal">&amp;</code>
               having the highest precedence and <code class="literal">|</code> the lowest
               precedence.
            </p>
            <p class="norm-static"><a name="jls-15.22-130"></a>Each of
               these operators is syntactically left-associative (each groups
               left-to-right).
            </p>
            <p class="norm-static"><a name="jls-15.22-140"></a>Each
               operator is commutative if the operand expressions have no side
               effects.
            </p>
            <p class="norm-static"><a name="jls-15.22-150"></a>Each
               operator is associative.
            </p>
            <p class="norm-error"><a name="jls-15.22-200"></a>The bitwise
               and logical operators may be used to compare two operands of numeric
               type or two operands of type <code class="literal">boolean</code>. All other cases result in a
               compile-time error.
            </p>
            <div class="section" title="15.22.1.&nbsp;Integer Bitwise Operators &amp;, ^, and |">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.22.1"></a>15.22.1.&nbsp;Integer Bitwise Operators <code class="literal">&amp;</code>, <code class="literal">^</code>, and <code class="literal">|</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.22.1-100"></a>When
                  both operands of an operator <code class="literal">&amp;</code>, 
                  <code class="literal">^</code>, or <code class="literal">|</code> are of a type that is
                  convertible (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) to a primitive integral
                  type, binary numeric promotion is first performed on the operands
                  (<a class="xref" href="jls-5.html#jls-5.6.2" title="5.6.2.&nbsp;Binary Numeric Promotion">&sect;5.6.2</a>).
               </p>
               <p class="norm-static"><a name="jls-15.22.1-110"></a>The type
                  of the bitwise operator expression is the promoted type of the
                  operands.
               </p>
               <p class="norm-dynamic"><a name="jls-15.22.1-200"></a>For <code class="literal">&amp;</code>, the result
                  value is the bitwise AND of the operand values.
               </p>
               <p class="norm-dynamic"><a name="jls-15.22.1-210"></a>For <code class="literal">^</code>, the result value is
                  the bitwise exclusive OR of the operand values.
               </p>
               <p class="norm-dynamic"><a name="jls-15.22.1-220"></a>For <code class="literal">|</code>, the result value is
                  the bitwise inclusive OR of the operand values.
               </p>
               <div class="informalexample">
                  <p class="note">For example, the result of the expression:</p><pre class="screen">0xff00 &amp; 0xf0f0</pre><p class="note">is:</p><pre class="screen">0xf000</pre><p class="note">The result of the expression:</p><pre class="screen">0xff00 ^ 0xf0f0</pre><p class="note">is:</p><pre class="screen">0x0ff0</pre><p class="note">The result of the expression:</p><pre class="screen">0xff00 | 0xf0f0</pre><p class="note">is:</p><pre class="screen">0xfff0</pre></div>
            </div>
            <div class="section" title="15.22.2.&nbsp;Boolean Logical Operators &amp;, ^, and |">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.22.2"></a>15.22.2.&nbsp;Boolean Logical Operators <code class="literal">&amp;</code>, <code class="literal">^</code>, and <code class="literal">|</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.22.2-100"></a>When
                  both operands of a <code class="literal">&amp;</code>, <code class="literal">^</code>,
                  or <code class="literal">|</code> operator are of type <code class="literal">boolean</code> or <code class="literal">Boolean</code>,
                  then the type of the bitwise operator expression is <code class="literal">boolean</code>. In all
                  cases, the operands are subject to unboxing conversion
                  (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) as necessary.
               </p>
               <p class="norm-dynamic"><a name="jls-15.22.2-200"></a>For <code class="literal">&amp;</code>, the result
                  value is <code class="literal">true</code> if both operand values are <code class="literal">true</code>; otherwise, the
                  result is <code class="literal">false</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-15.22.2-210"></a>For <code class="literal">^</code>, the result value is
                  <code class="literal">true</code> if the operand values are different; otherwise, the result is
                  <code class="literal">false</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-15.22.2-220"></a>For <code class="literal">|</code>, the result value is
                  <code class="literal">false</code> if both operand values are <code class="literal">false</code>; otherwise, the result is
                  <code class="literal">true</code>.
               </p>
            </div>
         </div>
         <div class="section" title="15.23.&nbsp;Conditional-And Operator &amp;&amp;">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.23"></a>15.23.&nbsp;Conditional-And Operator <code class="literal">&amp;&amp;</code></h2>
                  </div>
               </div>
            </div>
            <p class="norm-dynamic"><a name="jls-15.23-100"></a>The
               conditional-and operator <code class="literal">&amp;&amp;</code> is like <code class="literal">&amp;</code>
               (<a class="xref" href="jls-15.html#jls-15.22.2" title="15.22.2.&nbsp;Boolean Logical Operators &amp;, ^, and |">&sect;15.22.2</a>), but evaluates its right-hand operand
               only if the value of its left-hand operand is <code class="literal">true</code>.
            </p>
            <div id="jls-15.23-110" class="productionset"><a name="jls-15.23-110"></a>
                 
               <div class="production"><a name="jls-ConditionalAndExpression"></a>
                      
                  <div class="lhs">ConditionalAndExpression:</div>
                      
                  <div class="rhs">
                           <a href="jls-15.html#jls-InclusiveOrExpression" title="InclusiveOrExpression">InclusiveOrExpression</a> <br>
                           <a href="jls-15.html#jls-ConditionalAndExpression" title="ConditionalAndExpression">ConditionalAndExpression</a> <code class="literal">&amp;&amp;</code> <a href="jls-15.html#jls-InclusiveOrExpression" title="InclusiveOrExpression">InclusiveOrExpression</a>
                         
                  </div>
                    
               </div>
               
            </div>
            <p class="norm-static"><a name="jls-15.23-120"></a>The
               conditional-and operator is syntactically left-associative (it groups
               left-to-right).
            </p>
            <p class="norm-static"><a name="jls-15.23-130"></a>The
               conditional-and operator is fully associative with respect to both
               side effects and result value. That is, for any
               expressions <code class="varname">a</code>, <code class="varname">b</code>,
               and <code class="varname">c</code>, evaluation of the
               expression <code class="literal">((<code class="varname">a</code>) <code class="literal">&amp;&amp;</code>
                  (<code class="varname">b</code>)) <code class="literal">&amp;&amp;</code> (<code class="varname">c</code>)</code>
               produces the same result, with the same side effects occurring in the
               same order, as evaluation of the
               expression <code class="literal">(<code class="varname">a</code>) <code class="literal">&amp;&amp;</code>
                  ((<code class="varname">b</code>) <code class="literal">&amp;&amp;</code>
                  (<code class="varname">c</code>))</code>.
            </p>
            <p class="norm-error"><a name="jls-15.23-200"></a>Each
               operand of the conditional-and operator must be of type <code class="literal">boolean</code> or
               <code class="literal">Boolean</code>, or a compile-time error occurs.
            </p>
            <p class="norm-static"><a name="jls-15.23-300"></a>The type
               of a conditional-and expression is always <code class="literal">boolean</code>.
            </p>
            <p class="norm-dynamic"><a name="jls-15.23-400"></a>At run
               time, the left-hand operand expression is evaluated first; if the
               result has type <code class="literal">Boolean</code>, it is subjected to unboxing conversion
               (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>).
            </p>
            <p class="norm-dynamic"><a name="jls-15.23-410"></a>If the
               resulting value is <code class="literal">false</code>, the value of the conditional-and
               expression is <code class="literal">false</code> and the right-hand operand expression is not
               evaluated.
            </p>
            <p class="norm-dynamic"><a name="jls-15.23-420"></a>If the
               value of the left-hand operand is <code class="literal">true</code>, then the right-hand
               expression is evaluated; if the result has type <code class="literal">Boolean</code>, it is
               subjected to unboxing conversion (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>). The
               resulting value becomes the value of the conditional-and
               expression.
            </p>
            <p class="norm-dynamic"><a name="jls-15.23-430"></a>Thus,
               <code class="literal">&amp;&amp;</code> computes the same result as <code class="literal">&amp;</code> on
               <code class="literal">boolean</code> operands. It differs only in that the right-hand operand
               expression is evaluated conditionally rather than always.
            </p>
         </div>
         <div class="section" title="15.24.&nbsp;Conditional-Or Operator ||">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.24"></a>15.24.&nbsp;Conditional-Or Operator <code class="literal">||</code></h2>
                  </div>
               </div>
            </div>
            <p class="norm-dynamic"><a name="jls-15.24-100"></a>The
               conditional-or operator <code class="literal">||</code> operator is like <code class="literal">|</code>
               (<a class="xref" href="jls-15.html#jls-15.22.2" title="15.22.2.&nbsp;Boolean Logical Operators &amp;, ^, and |">&sect;15.22.2</a>), but evaluates its right-hand operand
               only if the value of its left-hand operand is <code class="literal">false</code>.
            </p>
            <div id="jls-15.24-110" class="productionset"><a name="jls-15.24-110"></a>
                 
               <div class="production"><a name="jls-ConditionalOrExpression"></a>
                      
                  <div class="lhs">ConditionalOrExpression:</div>
                      
                  <div class="rhs">
                           <a href="jls-15.html#jls-ConditionalAndExpression" title="ConditionalAndExpression">ConditionalAndExpression</a> <br>
                           <a href="jls-15.html#jls-ConditionalOrExpression" title="ConditionalOrExpression">ConditionalOrExpression</a> <code class="literal">||</code> ConditionalAndExpression
                         
                  </div>
                    
               </div>
               
            </div>
            <p class="norm-static"><a name="jls-15.24-120"></a>The
               conditional-or operator is syntactically left-associative (it groups
               left-to-right).
            </p>
            <p class="norm-static"><a name="jls-15.24-130"></a>The
               conditional-or operator is fully associative with respect to both side
               effects and result value. That is, for any
               expressions <code class="varname">a</code>, <code class="varname">b</code>,
               and <code class="varname">c</code>, evaluation of the
               expression <code class="literal">((<code class="varname">a</code>) <code class="literal">||</code>
                  (<code class="varname">b</code>)) <code class="literal">||</code> (<code class="varname">c</code>)</code>
               produces the same result, with the same side effects occurring in the
               same order, as evaluation of the
               expression <code class="literal">(<code class="varname">a</code>) <code class="literal">||</code>
                  ((<code class="varname">b</code>) <code class="literal">||</code>
                  (<code class="varname">c</code>))</code>.
            </p>
            <p class="norm-error"><a name="jls-15.24-200"></a>Each
               operand of the conditional-or operator must be of type <code class="literal">boolean</code> or
               <code class="literal">Boolean</code>, or a compile-time error occurs.
            </p>
            <p class="norm-static"><a name="jls-15.24-300"></a>The type
               of a conditional-or expression is always <code class="literal">boolean</code>.
            </p>
            <p class="norm-dynamic"><a name="jls-15.24-400"></a>At run
               time, the left-hand operand expression is evaluated first; if the
               result has type <code class="literal">Boolean</code>, it is subjected to unboxing conversion
               (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>).
            </p>
            <p class="norm-dynamic"><a name="jls-15.24-410"></a>If the
               resulting value is <code class="literal">true</code>, the value of the conditional-or expression
               is <code class="literal">true</code> and the right-hand operand expression is not
               evaluated.
            </p>
            <p class="norm-dynamic"><a name="jls-15.24-420"></a>If the
               value of the left-hand operand is <code class="literal">false</code>, then the right-hand
               expression is evaluated; if the result has type <code class="literal">Boolean</code>, it is
               subjected to unboxing conversion (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>). The
               resulting value becomes the value of the conditional-or
               expression.
            </p>
            <p class="norm-dynamic"><a name="jls-15.24-430"></a>Thus,
               <code class="literal">||</code> computes the same result as <code class="literal">|</code> on <code class="literal">boolean</code>
               or <code class="literal">Boolean</code> operands. It differs only in that the right-hand operand
               expression is evaluated conditionally rather than always.
            </p>
         </div>
         <div class="section" title="15.25.&nbsp;Conditional Operator ? :">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.25"></a>15.25.&nbsp;Conditional Operator <code class="literal">? :</code></h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-15.25-100"></a>The conditional operator
               <code class="literal">? :</code> uses the boolean value of one expression to decide which of
               two other expressions should be evaluated.
            </p>
            <div id="jls-15.25-110" class="productionset"><a name="jls-15.25-110"></a>
                 
               <div class="production"><a name="jls-ConditionalExpression"></a>
                      
                  <div class="lhs">ConditionalExpression:</div>
                      
                  <div class="rhs">
                           <a href="jls-15.html#jls-ConditionalOrExpression" title="ConditionalOrExpression">ConditionalOrExpression</a> <br>
                     
                           <a href="jls-15.html#jls-ConditionalOrExpression" title="ConditionalOrExpression">ConditionalOrExpression</a> <code class="literal">?</code> 
                           <a href="jls-15.html#jls-Expression" title="Expression">Expression</a> <code class="literal">:</code> 
                           <a href="jls-15.html#jls-ConditionalExpression" title="ConditionalExpression">ConditionalExpression</a>
                         
                  </div>
                    
               </div>
               
            </div>
            <p class="norm-static"><a name="jls-15.25-120"></a>The
               conditional operator is syntactically right-associative (it groups
               right-to-left). Thus, <code class="literal">a?b:c?d:e?f:g</code> means the same
               as <code class="literal">a?b:(c?d:(e?f:g))</code>.
            </p>
            <p class="norm"><a name="jls-15.25-200"></a>The conditional operator has
               three operand expressions. <code class="literal">?</code> appears between the first and second
               expressions, and <code class="literal">:</code> appears between the second and third
               expressions.
            </p>
            <p class="norm-error"><a name="jls-15.25-210"></a>The first
               expression must be of type <code class="literal">boolean</code> or <code class="literal">Boolean</code>, or a compile-time
               error occurs.
            </p>
            <p class="norm-error"><a name="jls-15.25-220"></a>It is a
               compile-time error for either the second or the third operand
               expression to be an invocation of a <code class="literal">void</code> method.
            </p>
            <p class="note">In fact, by the grammar of expression statements
               (<a class="xref" href="jls-14.html#jls-14.8" title="14.8.&nbsp;Expression Statements">&sect;14.8</a>), it is not permitted for a conditional
               expression to appear in any context where an invocation of a <code class="literal">void</code>
               method could appear.
            </p>
            <p class="norm-static"><a name="jls-15.25-300"></a>There are three
               kinds of conditional expressions, classified according to the second
               and third operand expressions: <span class="emphasis"><em>boolean conditional
                     expressions</em></span>, <span class="emphasis"><em>numeric conditional
                     expressions</em></span>, and <span class="emphasis"><em>reference conditional
                     expressions</em></span>. The classification rules are as
               follows:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.25-300-A"></a>
                              If both the second and the third operand expressions
                              are <span class="emphasis"><em>boolean expressions</em></span>, the conditional
                              expression is a boolean conditional expression.
                     </p>
                     <p class="norm-static"><a name="jls-15.25-300-A.1"></a>
                              For the purpose of classifying a conditional, the following
                              expressions are boolean expressions:
                     </p>
                     <div class="norm">
                        <ul class="norm" type="circle">
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-15.25-300-A.1-A"></a>
                                 	  An expression of a standalone form (<a class="xref" href="jls-15.html#jls-15.2" title="15.2.&nbsp;Forms of Expressions">&sect;15.2</a>) 
                                 	  that has type <code class="literal">boolean</code> or <code class="literal">Boolean</code>.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-15.25-300-A.1-B"></a>
                                 	  A parenthesized <code class="literal">boolean</code> expression
                                           (<a class="xref" href="jls-15.html#jls-15.8.5" title="15.8.5.&nbsp;Parenthesized Expressions">&sect;15.8.5</a>).
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-15.25-300-A.1-C"></a>
                                 	  A class instance creation expression
                                           (<a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>) for class <code class="literal">Boolean</code>.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-15.25-300-A.1-D"></a>
                                 	  A method invocation expression (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>)
                                           for which the chosen most specific method
                                           (<a class="xref" href="jls-15.html#jls-15.12.2.5" title="15.12.2.5.&nbsp;Choosing the Most Specific Method">&sect;15.12.2.5</a>) has return type <code class="literal">boolean</code>
                                           or <code class="literal">Boolean</code>.
                              </p>
                              <p class="note">Note that, for a generic method, this is the
                                 	  type <span class="emphasis"><em>before</em></span> instantiating the method's
                                 	  type arguments.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-15.25-300-A.1-E"></a>
                                 	  A <code class="literal">boolean</code> conditional expression.
                              </p>
                           </li>
                        </ul>
                     </div>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.25-300-B"></a>
                              If both the second and the third operand expressions
                              are <span class="emphasis"><em>numeric expressions</em></span>, the conditional
                              expression is a numeric conditional expression.
                     </p>
                     <p class="norm-static"><a name="jls-15.25-300-B.1"></a>
                              For the purpose of classifying a conditional, the following
                              expressions are numeric expressions:
                     </p>
                     <div class="norm">
                        <ul class="norm" type="circle">
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-15.25-300-B.1-A"></a>
                                 	  An expression of a standalone form
                                 	  (<a class="xref" href="jls-15.html#jls-15.2" title="15.2.&nbsp;Forms of Expressions">&sect;15.2</a>) with a type that is convertible
                                 	  to a numeric type (<a class="xref" href="jls-4.html#jls-4.2" title="4.2.&nbsp;Primitive Types and Values">&sect;4.2</a>,
                                 	  <a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>).
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-15.25-300-B.1-B"></a>
                                 	  A parenthesized numeric expression
                                 	  (<a class="xref" href="jls-15.html#jls-15.8.5" title="15.8.5.&nbsp;Parenthesized Expressions">&sect;15.8.5</a>).
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-15.25-300-B.1-C"></a>
                                 	  A class instance creation expression
                                 	  (<a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>) for a class that is convertible
                                 	  to a numeric type.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-15.25-300-B.1-D"></a>
                                 	  A method invocation expression (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>)
                                 	  for which the chosen most specific method
                                 	  (<a class="xref" href="jls-15.html#jls-15.12.2.5" title="15.12.2.5.&nbsp;Choosing the Most Specific Method">&sect;15.12.2.5</a>) has a return type that is
                                 	  convertible to a numeric type.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-15.25-300-B.1-E"></a>
                                 	  A numeric conditional expression.
                              </p>
                           </li>
                        </ul>
                     </div>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.25-300-C"></a>
                              Otherwise, the conditional expression is a reference conditional
                              expression.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm-static"><a name="jls-15.25-310"></a>The process for
               determining the type of a conditional expression depends on the kind
               of conditional expression, as outlined in the following
               sections.
            </p>
            <p class="norm"><a name="jls-15.25-400"></a>The following tables summarize the rules above by giving
               the type of a conditional expression for all possible types of its
               second and third operands. bnp(..) means to apply binary numeric
               promotion. The form "<span class="type">T</span> | bnp(..)" is used where one operand is a
               constant expression of type <code class="literal">int</code> and may be representable in type
               <span class="type">T</span>, where binary numeric promotion is used if the operand is not
               representable in type <span class="type">T</span>. The operand type <code class="literal">Object</code> means any
               reference type other than the <code class="literal">null</code> type and the eight wrapper
               classes <code class="literal">Boolean</code>, <code class="literal">Byte</code>, <code class="literal">Short</code>, <code class="literal">Character</code>, <code class="literal">Integer</code>, <code class="literal">Long</code>,
               <code class="literal">Float</code>, <code class="literal">Double</code>.
            </p>
            <div class="table"><a name="jls-15.25-400-A"></a><p class="title"><b>Table&nbsp;15.1.&nbsp;Conditional expression type (Primitive 3rd operand, Part I)</b></p>
               <div class="table-contents">
                  <table summary="Conditional expression type (Primitive 3rd operand, Part I)" border="1">
                     <colgroup>
                        <col align="left">
                        <col>
                        <col>
                        <col>
                        <col align="center">
                     </colgroup>
                     <thead>
                        <tr>
                           <th align="left">3rd <span class="symbol">&#8594;</span></th>
                           <th align="center"><code class="literal">byte</code></th>
                           <th align="center"><code class="literal">short</code></th>
                           <th align="center"><code class="literal">char</code></th>
                           <th align="center"><code class="literal">int</code></th>
                        </tr>
                        <tr>
                           <th align="left">2nd <span class="symbol">&#8595;</span></th>
                           <td class="auto-generated">&nbsp;</td>
                           <td class="auto-generated">&nbsp;</td>
                           <td class="auto-generated">&nbsp;</td>
                           <td class="auto-generated">&nbsp;</td>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td align="left"><code class="literal">byte</code></td>
                           <td align="center"><code class="literal">byte</code></td>
                           <td align="center"><code class="literal">short</code></td>
                           <td align="center">bnp(<code class="literal">byte</code>,<code class="literal">char</code>)
                           </td>
                           <td align="center"><code class="literal">byte</code> | bnp(<code class="literal">byte</code>,<code class="literal">int</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Byte</code></td>
                           <td align="center"><code class="literal">byte</code></td>
                           <td align="center"><code class="literal">short</code></td>
                           <td align="center">bnp(<code class="literal">Byte</code>,<code class="literal">char</code>)
                           </td>
                           <td align="center"><code class="literal">byte</code> | bnp(<code class="literal">Byte</code>,<code class="literal">int</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">short</code></td>
                           <td align="center"><code class="literal">short</code></td>
                           <td align="center"><code class="literal">short</code></td>
                           <td align="center">bnp(<code class="literal">short</code>,<code class="literal">char</code>)
                           </td>
                           <td align="center"><code class="literal">short</code> | bnp(<code class="literal">short</code>,<code class="literal">int</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Short</code></td>
                           <td align="center"><code class="literal">short</code></td>
                           <td align="center"><code class="literal">short</code></td>
                           <td align="center">bnp(<code class="literal">Short</code>,<code class="literal">char</code>)
                           </td>
                           <td align="center"><code class="literal">short</code> | bnp(<code class="literal">Short</code>,<code class="literal">int</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">char</code></td>
                           <td align="center">bnp(<code class="literal">char</code>,<code class="literal">byte</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">char</code>,<code class="literal">short</code>)
                           </td>
                           <td align="center"><code class="literal">char</code></td>
                           <td align="center"><code class="literal">char</code> | bnp(<code class="literal">char</code>,<code class="literal">int</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Character</code></td>
                           <td align="center">bnp(<code class="literal">Character</code>,<code class="literal">byte</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Character</code>,<code class="literal">short</code>)
                           </td>
                           <td align="center"><code class="literal">char</code></td>
                           <td align="center"><code class="literal">char</code> | bnp(<code class="literal">Character</code>,<code class="literal">int</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">int</code></td>
                           <td align="center"><code class="literal">byte</code> | bnp(<code class="literal">int</code>,<code class="literal">byte</code>)
                           </td>
                           <td align="center"><code class="literal">short</code> | bnp(<code class="literal">int</code>,<code class="literal">short</code>)
                           </td>
                           <td align="center"><code class="literal">char</code> | bnp(<code class="literal">int</code>,<code class="literal">char</code>)
                           </td>
                           <td align="center"><code class="literal">int</code></td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Integer</code></td>
                           <td align="center">bnp(<code class="literal">Integer</code>,<code class="literal">byte</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Integer</code>,<code class="literal">short</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Integer</code>,<code class="literal">char</code>)
                           </td>
                           <td align="center"><code class="literal">int</code></td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">long</code></td>
                           <td align="center">bnp(<code class="literal">long</code>,<code class="literal">byte</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">long</code>,<code class="literal">short</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">long</code>,<code class="literal">char</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">long</code>,<code class="literal">int</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Long</code></td>
                           <td align="center">bnp(<code class="literal">Long</code>,<code class="literal">byte</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Long</code>,<code class="literal">short</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Long</code>,<code class="literal">char</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Long</code>,<code class="literal">int</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">float</code></td>
                           <td align="center">bnp(<code class="literal">float</code>,<code class="literal">byte</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">float</code>,<code class="literal">short</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">float</code>,<code class="literal">char</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">float</code>,<code class="literal">int</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Float</code></td>
                           <td align="center">bnp(<code class="literal">Float</code>,<code class="literal">byte</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Float</code>,<code class="literal">short</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Float</code>,<code class="literal">char</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Float</code>,<code class="literal">int</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">double</code></td>
                           <td align="center">bnp(<code class="literal">double</code>,<code class="literal">byte</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">double</code>,<code class="literal">short</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">double</code>,<code class="literal">char</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">double</code>,<code class="literal">int</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Double</code></td>
                           <td align="center">bnp(<code class="literal">Double</code>,<code class="literal">byte</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Double</code>,<code class="literal">short</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Double</code>,<code class="literal">char</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Double</code>,<code class="literal">int</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">boolean</code></td>
                           <td align="center">lub(<code class="literal">Boolean</code>,<code class="literal">Byte</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Boolean</code>,<code class="literal">Short</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Boolean</code>,<code class="literal">Character</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Boolean</code>,<code class="literal">Integer</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Boolean</code></td>
                           <td align="center">lub(<code class="literal">Boolean</code>,<code class="literal">Byte</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Boolean</code>,<code class="literal">Short</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Boolean</code>,<code class="literal">Character</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Boolean</code>,<code class="literal">Integer</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">null</code></td>
                           <td align="center">lub(<code class="literal">null</code>,<code class="literal">Byte</code>)
                           </td>
                           <td align="center">lub(<code class="literal">null</code>,<code class="literal">Short</code>)
                           </td>
                           <td align="center">lub(<code class="literal">null</code>,<code class="literal">Character</code>)
                           </td>
                           <td align="center">lub(<code class="literal">null</code>,<code class="literal">Integer</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Object</code></td>
                           <td align="center">lub(<code class="literal">Object</code>,<code class="literal">Byte</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Object</code>,<code class="literal">Short</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Object</code>,<code class="literal">Character</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Object</code>,<code class="literal">Integer</code>)
                           </td>
                        </tr>
                     </tbody>
                  </table>
               </div>
            </div><br class="table-break"><div class="table"><a name="jls-15.25-400-B"></a><p class="title"><b>Table&nbsp;15.2.&nbsp;Conditional expression type (Primitive 3rd operand, Part II)</b></p>
               <div class="table-contents">
                  <table summary="Conditional expression type (Primitive 3rd operand, Part II)" border="1">
                     <colgroup>
                        <col align="left">
                        <col>
                        <col>
                        <col>
                        <col>
                     </colgroup>
                     <thead>
                        <tr>
                           <th align="left">3rd <span class="symbol">&#8594;</span></th>
                           <th align="center"><code class="literal">long</code></th>
                           <th align="center"><code class="literal">float</code></th>
                           <th align="center"><code class="literal">double</code></th>
                           <th align="center"><code class="literal">boolean</code></th>
                        </tr>
                        <tr>
                           <th align="left">2nd <span class="symbol">&#8595;</span></th>
                           <td class="auto-generated">&nbsp;</td>
                           <td class="auto-generated">&nbsp;</td>
                           <td class="auto-generated">&nbsp;</td>
                           <td class="auto-generated">&nbsp;</td>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td align="left"><code class="literal">byte</code></td>
                           <td align="center">bnp(<code class="literal">byte</code>,<code class="literal">long</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">byte</code>,<code class="literal">float</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">byte</code>,<code class="literal">double</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Byte</code>,<code class="literal">Boolean</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Byte</code></td>
                           <td align="center">bnp(<code class="literal">Byte</code>,<code class="literal">long</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Byte</code>,<code class="literal">float</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Byte</code>,<code class="literal">double</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Byte</code>,<code class="literal">Boolean</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">short</code></td>
                           <td align="center">bnp(<code class="literal">short</code>,<code class="literal">long</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">short</code>,<code class="literal">float</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">short</code>,<code class="literal">double</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Short</code>,<code class="literal">Boolean</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Short</code></td>
                           <td align="center">bnp(<code class="literal">Short</code>,<code class="literal">long</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Short</code>,<code class="literal">float</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Short</code>,<code class="literal">double</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Short</code>,<code class="literal">Boolean</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">char</code></td>
                           <td align="center">bnp(<code class="literal">char</code>,<code class="literal">long</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">char</code>,<code class="literal">float</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">char</code>,<code class="literal">double</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Character</code>,<code class="literal">Boolean</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Character</code></td>
                           <td align="center">bnp(<code class="literal">Character</code>,<code class="literal">long</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Character</code>,<code class="literal">float</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Character</code>,<code class="literal">double</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Character</code>,<code class="literal">Boolean</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">int</code></td>
                           <td align="center">bnp(<code class="literal">int</code>,<code class="literal">long</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">int</code>,<code class="literal">float</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">int</code>,<code class="literal">double</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Integer</code>,<code class="literal">Boolean</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Integer</code></td>
                           <td align="center">bnp(<code class="literal">Integer</code>,<code class="literal">long</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Integer</code>,<code class="literal">float</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Integer</code>,<code class="literal">double</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Integer</code>,<code class="literal">Boolean</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">long</code></td>
                           <td align="center"><code class="literal">long</code></td>
                           <td align="center">bnp(<code class="literal">long</code>,<code class="literal">float</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">long</code>,<code class="literal">double</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Long</code>,<code class="literal">Boolean</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Long</code></td>
                           <td align="center"><code class="literal">long</code></td>
                           <td align="center">bnp(<code class="literal">Long</code>,<code class="literal">float</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Long</code>,<code class="literal">double</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Long</code>,<code class="literal">Boolean</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">float</code></td>
                           <td align="center">bnp(<code class="literal">float</code>,<code class="literal">long</code>)
                           </td>
                           <td align="center"><code class="literal">float</code></td>
                           <td align="center">bnp(<code class="literal">float</code>,<code class="literal">double</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Float</code>,<code class="literal">Boolean</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Float</code></td>
                           <td align="center">bnp(<code class="literal">Float</code>,<code class="literal">long</code>)
                           </td>
                           <td align="center"><code class="literal">float</code></td>
                           <td align="center">bnp(<code class="literal">Float</code>,<code class="literal">double</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Float</code>,<code class="literal">Boolean</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">double</code></td>
                           <td align="center">bnp(<code class="literal">double</code>,<code class="literal">long</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">double</code>,<code class="literal">float</code>)
                           </td>
                           <td align="center"><code class="literal">double</code></td>
                           <td align="center">lub(<code class="literal">Double</code>,<code class="literal">Boolean</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Double</code></td>
                           <td align="center">bnp(<code class="literal">Double</code>,<code class="literal">long</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Double</code>,<code class="literal">float</code>)
                           </td>
                           <td align="center"><code class="literal">double</code></td>
                           <td align="center">lub(<code class="literal">Double</code>,<code class="literal">Boolean</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">boolean</code></td>
                           <td align="center">lub(<code class="literal">Boolean</code>,<code class="literal">Long</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Boolean</code>,<code class="literal">Float</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Boolean</code>,<code class="literal">Double</code>)
                           </td>
                           <td align="center"><code class="literal">boolean</code></td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Boolean</code></td>
                           <td align="center">lub(<code class="literal">Boolean</code>,<code class="literal">Long</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Boolean</code>,<code class="literal">Float</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Boolean</code>,<code class="literal">Double</code>)
                           </td>
                           <td align="center"><code class="literal">boolean</code></td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">null</code></td>
                           <td align="center">lub(<code class="literal">null</code>,<code class="literal">Long</code>)
                           </td>
                           <td align="center">lub(<code class="literal">null</code>,<code class="literal">Float</code>)
                           </td>
                           <td align="center">lub(<code class="literal">null</code>,<code class="literal">Double</code>)
                           </td>
                           <td align="center">lub(<code class="literal">null</code>,<code class="literal">Boolean</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Object</code></td>
                           <td align="center">lub(<code class="literal">Object</code>,<code class="literal">Long</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Object</code>,<code class="literal">Float</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Object</code>,<code class="literal">Double</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Object</code>,<code class="literal">Boolean</code>)
                           </td>
                        </tr>
                     </tbody>
                  </table>
               </div>
            </div><br class="table-break"><div class="table"><a name="jls-15.25-400-C"></a><p class="title"><b>Table&nbsp;15.3.&nbsp;Conditional expression type (Reference 3rd operand, Part I)</b></p>
               <div class="table-contents">
                  <table summary="Conditional expression type (Reference 3rd operand, Part I)" border="1">
                     <colgroup>
                        <col align="left">
                        <col>
                        <col>
                        <col align="center">
                        <col align="center">
                     </colgroup>
                     <thead>
                        <tr>
                           <th align="left">3rd <span class="symbol">&#8594;</span></th>
                           <th align="center"><code class="literal">Byte</code></th>
                           <th align="center"><code class="literal">Short</code></th>
                           <th align="center"><code class="literal">Character</code></th>
                           <th align="center"><code class="literal">Integer</code></th>
                        </tr>
                        <tr>
                           <th align="left">2nd <span class="symbol">&#8595;</span></th>
                           <td class="auto-generated">&nbsp;</td>
                           <td class="auto-generated">&nbsp;</td>
                           <td class="auto-generated">&nbsp;</td>
                           <td class="auto-generated">&nbsp;</td>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td align="left"><code class="literal">byte</code></td>
                           <td align="center"><code class="literal">byte</code></td>
                           <td align="center"><code class="literal">short</code></td>
                           <td align="center">bnp(<code class="literal">byte</code>,<code class="literal">Character</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">byte</code>,<code class="literal">Integer</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Byte</code></td>
                           <td align="center"><code class="literal">Byte</code></td>
                           <td align="center"><code class="literal">short</code></td>
                           <td align="center">bnp(<code class="literal">Byte</code>,<code class="literal">Character</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Byte</code>,<code class="literal">Integer</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">short</code></td>
                           <td align="center"><code class="literal">short</code></td>
                           <td align="center"><code class="literal">short</code></td>
                           <td align="center">bnp(<code class="literal">short</code>,<code class="literal">Character</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">short</code>,<code class="literal">Integer</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Short</code></td>
                           <td align="center"><code class="literal">short</code></td>
                           <td align="center"><code class="literal">Short</code></td>
                           <td align="center">bnp(<code class="literal">Short</code>,<code class="literal">Character</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Short</code>,<code class="literal">Integer</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">char</code></td>
                           <td align="center">bnp(<code class="literal">char</code>,<code class="literal">Byte</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">char</code>,<code class="literal">Short</code>)
                           </td>
                           <td align="center"><code class="literal">char</code></td>
                           <td align="center">bnp(<code class="literal">char</code>,<code class="literal">Integer</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Character</code></td>
                           <td align="center">bnp(<code class="literal">Character</code>,<code class="literal">Byte</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Character</code>,<code class="literal">Short</code>)
                           </td>
                           <td align="center"><code class="literal">Character</code></td>
                           <td align="center">bnp(<code class="literal">Character</code>,<code class="literal">Integer</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">int</code></td>
                           <td align="center"><code class="literal">byte</code> | bnp(<code class="literal">int</code>,<code class="literal">Byte</code>)
                           </td>
                           <td align="center"><code class="literal">short</code> | bnp(<code class="literal">int</code>,<code class="literal">Short</code>)
                           </td>
                           <td align="center"><code class="literal">char</code> | bnp(<code class="literal">int</code>,<code class="literal">Character</code>)
                           </td>
                           <td align="center"><code class="literal">int</code></td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Integer</code></td>
                           <td align="center">bnp(<code class="literal">Integer</code>,<code class="literal">Byte</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Integer</code>,<code class="literal">Short</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Integer</code>,<code class="literal">Character</code>)
                           </td>
                           <td align="center"><code class="literal">Integer</code></td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">long</code></td>
                           <td align="center">bnp(<code class="literal">long</code>,<code class="literal">Byte</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">long</code>,<code class="literal">Short</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">long</code>,<code class="literal">Character</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">long</code>,<code class="literal">Integer</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Long</code></td>
                           <td align="center">bnp(<code class="literal">Long</code>,<code class="literal">Byte</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Long</code>,<code class="literal">Short</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Long</code>,<code class="literal">Character</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Long</code>,<code class="literal">Integer</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">float</code></td>
                           <td align="center">bnp(<code class="literal">float</code>,<code class="literal">Byte</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">float</code>,<code class="literal">Short</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">float</code>,<code class="literal">Character</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">float</code>,<code class="literal">Integer</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Float</code></td>
                           <td align="center">bnp(<code class="literal">Float</code>,<code class="literal">Byte</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Float</code>,<code class="literal">Short</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Float</code>,<code class="literal">Character</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Float</code>,<code class="literal">Integer</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">double</code></td>
                           <td align="center">bnp(<code class="literal">double</code>,<code class="literal">Byte</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">double</code>,<code class="literal">Short</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">double</code>,<code class="literal">Character</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">double</code>,<code class="literal">Integer</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Double</code></td>
                           <td align="center">bnp(<code class="literal">Double</code>,<code class="literal">Byte</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Double</code>,<code class="literal">Short</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Double</code>,<code class="literal">Character</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Double</code>,<code class="literal">Integer</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">boolean</code></td>
                           <td align="center">lub(<code class="literal">Boolean</code>,<code class="literal">Byte</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Boolean</code>,<code class="literal">Short</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Boolean</code>,<code class="literal">Character</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Boolean</code>,<code class="literal">Integer</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Boolean</code></td>
                           <td align="center">lub(<code class="literal">Boolean</code>,<code class="literal">Byte</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Boolean</code>,<code class="literal">Short</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Boolean</code>,<code class="literal">Character</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Boolean</code>,<code class="literal">Integer</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">null</code></td>
                           <td align="center"><code class="literal">Byte</code></td>
                           <td align="center"><code class="literal">Short</code></td>
                           <td align="center"><code class="literal">Character</code></td>
                           <td align="center"><code class="literal">Integer</code></td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Object</code></td>
                           <td align="center">lub(<code class="literal">Object</code>,<code class="literal">Byte</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Object</code>,<code class="literal">Short</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Object</code>,<code class="literal">Character</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Object</code>,<code class="literal">Integer</code>)
                           </td>
                        </tr>
                     </tbody>
                  </table>
               </div>
            </div><br class="table-break"><div class="table"><a name="jls-15.25-400-D"></a><p class="title"><b>Table&nbsp;15.4.&nbsp;Conditional expression type (Reference 3rd operand, Part II)</b></p>
               <div class="table-contents">
                  <table summary="Conditional expression type (Reference 3rd operand, Part II)" border="1">
                     <colgroup>
                        <col align="left">
                        <col>
                        <col>
                        <col>
                        <col>
                     </colgroup>
                     <thead>
                        <tr>
                           <th align="left">3rd <span class="symbol">&#8594;</span></th>
                           <th align="center"><code class="literal">Long</code></th>
                           <th align="center"><code class="literal">Float</code></th>
                           <th align="center"><code class="literal">Double</code></th>
                           <th align="center"><code class="literal">Boolean</code></th>
                        </tr>
                        <tr>
                           <th align="left">2nd <span class="symbol">&#8595;</span></th>
                           <td class="auto-generated">&nbsp;</td>
                           <td class="auto-generated">&nbsp;</td>
                           <td class="auto-generated">&nbsp;</td>
                           <td class="auto-generated">&nbsp;</td>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td align="left"><code class="literal">byte</code></td>
                           <td align="center">bnp(<code class="literal">byte</code>,<code class="literal">Long</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">byte</code>,<code class="literal">Float</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">byte</code>,<code class="literal">Double</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Byte</code>,<code class="literal">Boolean</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Byte</code></td>
                           <td align="center">bnp(<code class="literal">Byte</code>,<code class="literal">Long</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Byte</code>,<code class="literal">Float</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Byte</code>,<code class="literal">Double</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Byte</code>,<code class="literal">Boolean</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">short</code></td>
                           <td align="center">bnp(<code class="literal">short</code>,<code class="literal">Long</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">short</code>,<code class="literal">Float</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">short</code>,<code class="literal">Double</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Short</code>,<code class="literal">Boolean</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Short</code></td>
                           <td align="center">bnp(<code class="literal">Short</code>,<code class="literal">Long</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Short</code>,<code class="literal">Float</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Short</code>,<code class="literal">Double</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Short</code>,<code class="literal">Boolean</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">char</code></td>
                           <td align="center">bnp(<code class="literal">char</code>,<code class="literal">Long</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">char</code>,<code class="literal">Float</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">char</code>,<code class="literal">Double</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Character</code>,<code class="literal">Boolean</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Character</code></td>
                           <td align="center">bnp(<code class="literal">Character</code>,<code class="literal">Long</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Character</code>,<code class="literal">Float</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Character</code>,<code class="literal">Double</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Character</code>,<code class="literal">Boolean</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">int</code></td>
                           <td align="center">bnp(<code class="literal">int</code>,<code class="literal">Long</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">int</code>,<code class="literal">Float</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">int</code>,<code class="literal">Double</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Integer</code>,<code class="literal">Boolean</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Integer</code></td>
                           <td align="center">bnp(<code class="literal">Integer</code>,<code class="literal">Long</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Integer</code>,<code class="literal">Float</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Integer</code>,<code class="literal">Double</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Integer</code>,<code class="literal">Boolean</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">long</code></td>
                           <td align="center"><code class="literal">long</code></td>
                           <td align="center">bnp(<code class="literal">long</code>,<code class="literal">Float</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">long</code>,<code class="literal">Double</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Long</code>,<code class="literal">Boolean</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Long</code></td>
                           <td align="center"><code class="literal">Long</code></td>
                           <td align="center">bnp(<code class="literal">Long</code>,<code class="literal">Float</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Long</code>,<code class="literal">Double</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Long</code>,<code class="literal">Boolean</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">float</code></td>
                           <td align="center">bnp(<code class="literal">float</code>,<code class="literal">Long</code>)
                           </td>
                           <td align="center"><code class="literal">float</code></td>
                           <td align="center">bnp(<code class="literal">float</code>,<code class="literal">Double</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Float</code>,<code class="literal">Boolean</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Float</code></td>
                           <td align="center">bnp(<code class="literal">Float</code>,<code class="literal">Long</code>)
                           </td>
                           <td align="center"><code class="literal">Float</code></td>
                           <td align="center">bnp(<code class="literal">Float</code>,<code class="literal">Double</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Float</code>,<code class="literal">Boolean</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">double</code></td>
                           <td align="center">bnp(<code class="literal">double</code>,<code class="literal">Long</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">double</code>,<code class="literal">Float</code>)
                           </td>
                           <td align="center"><code class="literal">double</code></td>
                           <td align="center">lub(<code class="literal">Double</code>,<code class="literal">Boolean</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Double</code></td>
                           <td align="center">bnp(<code class="literal">Double</code>,<code class="literal">Long</code>)
                           </td>
                           <td align="center">bnp(<code class="literal">Double</code>,<code class="literal">Float</code>)
                           </td>
                           <td align="center"><code class="literal">Double</code></td>
                           <td align="center">lub(<code class="literal">Double</code>,<code class="literal">Boolean</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">boolean</code></td>
                           <td align="center">lub(<code class="literal">Boolean</code>,<code class="literal">Long</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Boolean</code>,<code class="literal">Float</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Boolean</code>,<code class="literal">Double</code>)
                           </td>
                           <td align="center"><code class="literal">boolean</code></td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Boolean</code></td>
                           <td align="center">lub(<code class="literal">Boolean</code>,<code class="literal">Long</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Boolean</code>,<code class="literal">Float</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Boolean</code>,<code class="literal">Double</code>)
                           </td>
                           <td align="center"><code class="literal">Boolean</code></td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">null</code></td>
                           <td align="center"><code class="literal">Long</code></td>
                           <td align="center"><code class="literal">Float</code></td>
                           <td align="center"><code class="literal">Double</code></td>
                           <td align="center"><code class="literal">Boolean</code></td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Object</code></td>
                           <td align="center">lub(<code class="literal">Object</code>,<code class="literal">Long</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Object</code>,<code class="literal">Float</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Object</code>,<code class="literal">Double</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Object</code>,<code class="literal">Boolean</code>)
                           </td>
                        </tr>
                     </tbody>
                  </table>
               </div>
            </div><br class="table-break"><div class="table"><a name="jls-15.25-400-E"></a><p class="title"><b>Table&nbsp;15.5.&nbsp;Conditional expression type (Reference 3rd operand, Part III)</b></p>
               <div class="table-contents">
                  <table summary="Conditional expression type (Reference 3rd operand, Part III)" border="1">
                     <colgroup>
                        <col align="left">
                        <col>
                        <col>
                     </colgroup>
                     <thead>
                        <tr>
                           <th align="left">3rd <span class="symbol">&#8594;</span></th>
                           <th align="center"><code class="literal">null</code></th>
                           <th align="center"><code class="literal">Object</code></th>
                        </tr>
                        <tr>
                           <th align="left">2nd <span class="symbol">&#8595;</span></th>
                           <td class="auto-generated">&nbsp;</td>
                           <td class="auto-generated">&nbsp;</td>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td align="left"><code class="literal">byte</code></td>
                           <td align="center">lub(<code class="literal">Byte</code>,<code class="literal">null</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Byte</code>,<code class="literal">Object</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Byte</code></td>
                           <td align="center"><code class="literal">Byte</code></td>
                           <td align="center">lub(<code class="literal">Byte</code>,<code class="literal">Object</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">short</code></td>
                           <td align="center">lub(<code class="literal">Short</code>,<code class="literal">null</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Short</code>,<code class="literal">Object</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Short</code></td>
                           <td align="center"><code class="literal">Short</code></td>
                           <td align="center">lub(<code class="literal">Short</code>,<code class="literal">Object</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">char</code></td>
                           <td align="center">lub(<code class="literal">Character</code>,<code class="literal">null</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Character</code>,<code class="literal">Object</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Character</code></td>
                           <td align="center"><code class="literal">Character</code></td>
                           <td align="center">lub(<code class="literal">Character</code>,<code class="literal">Object</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">int</code></td>
                           <td align="center">lub(<code class="literal">Integer</code>,<code class="literal">null</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Integer</code>,<code class="literal">Object</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Integer</code></td>
                           <td align="center"><code class="literal">Integer</code></td>
                           <td align="center">lub(<code class="literal">Integer</code>,<code class="literal">Object</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">long</code></td>
                           <td align="center">lub(<code class="literal">Long</code>,<code class="literal">null</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Long</code>,<code class="literal">Object</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Long</code></td>
                           <td align="center"><code class="literal">Long</code></td>
                           <td align="center">lub(<code class="literal">Long</code>,<code class="literal">Object</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">float</code></td>
                           <td align="center">lub(<code class="literal">Float</code>,<code class="literal">null</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Float</code>,<code class="literal">Object</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Float</code></td>
                           <td align="center"><code class="literal">Float</code></td>
                           <td align="center">lub(<code class="literal">Float</code>,<code class="literal">Object</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">double</code></td>
                           <td align="center">lub(<code class="literal">Double</code>,<code class="literal">null</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Double</code>,<code class="literal">Object</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Double</code></td>
                           <td align="center"><code class="literal">Double</code></td>
                           <td align="center">lub(<code class="literal">Double</code>,<code class="literal">Object</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">boolean</code></td>
                           <td align="center">lub(<code class="literal">Boolean</code>,<code class="literal">null</code>)
                           </td>
                           <td align="center">lub(<code class="literal">Boolean</code>,<code class="literal">Object</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Boolean</code></td>
                           <td align="center"><code class="literal">Boolean</code></td>
                           <td align="center">lub(<code class="literal">Boolean</code>,<code class="literal">Object</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">null</code></td>
                           <td align="center"><code class="literal">null</code></td>
                           <td align="center">lub(<code class="literal">null</code>,<code class="literal">Object</code>)
                           </td>
                        </tr>
                        <tr>
                           <td align="left"><code class="literal">Object</code></td>
                           <td align="center"><code class="literal">Object</code></td>
                           <td align="center"><code class="literal">Object</code></td>
                        </tr>
                     </tbody>
                  </table>
               </div>
            </div><br class="table-break"><p class="norm-dynamic"><a name="jls-15.25-500"></a>At run
               time, the first operand expression of the conditional expression is
               evaluated first. If necessary, unboxing conversion is performed on the
               result.
            </p>
            <p class="norm-dynamic"><a name="jls-15.25-510"></a>The
               resulting <code class="literal">boolean</code> value is then used to choose either the second or
               the third operand expression:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-dynamic"><a name="jls-15.25-510-A"></a>If
                              the value of the first operand is <code class="literal">true</code>, then the second
                              operand expression is chosen.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-dynamic"><a name="jls-15.25-510-B"></a>If
                              the value of the first operand is <code class="literal">false</code>, then the third
                              operand expression is chosen.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm-dynamic"><a name="jls-15.25-520"></a>The
               chosen operand expression is then evaluated and the resulting value is
               converted to the type of the conditional expression as determined by
               the rules stated below.
            </p>
            <p class="norm-dynamic"><a name="jls-15.25-530"></a>This
               conversion may include boxing or unboxing conversion
               (<a class="xref" href="jls-5.html#jls-5.1.7" title="5.1.7.&nbsp;Boxing Conversion">&sect;5.1.7</a>, <a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>).
            </p>
            <p class="norm-dynamic"><a name="jls-15.25-540"></a>The
               operand expression not chosen is not evaluated for that particular
               evaluation of the conditional expression.
            </p>
            <div class="section" title="15.25.1.&nbsp;Boolean Conditional Expressions">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.25.1"></a>15.25.1.&nbsp;Boolean Conditional Expressions
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.25.1-100"></a>Boolean
                  conditional expressions are standalone expressions
                  (<a class="xref" href="jls-15.html#jls-15.2" title="15.2.&nbsp;Forms of Expressions">&sect;15.2</a>).
               </p>
               <p class="norm-static"><a name="jls-15.25.1-200"></a>The type
                  of a boolean conditional expression is determined as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.25.1-200-A"></a>If
                                 the second and third operands are both of type <code class="literal">Boolean</code>, the
                                 conditional expression has type <code class="literal">Boolean</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.25.1-200-B"></a>Otherwise, the conditional expression
                                 has type <code class="literal">boolean</code>.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="15.25.2.&nbsp;Numeric Conditional Expressions">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.25.2"></a>15.25.2.&nbsp;Numeric Conditional Expressions
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.25.2-100"></a>Numeric
                  conditional expressions are standalone expressions
                  (<a class="xref" href="jls-15.html#jls-15.2" title="15.2.&nbsp;Forms of Expressions">&sect;15.2</a>).
               </p>
               <p class="norm-static"><a name="jls-15.25.2-200"></a>The type
                  of a numeric conditional expression is determined as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.25.2-200-A"></a>If
                                 the second and third operands have the same type, then that is
                                 the type of the conditional expression.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.25.2-200-B"></a>If one
                                 of the second and third operands is of primitive type <span class="type">T</span>, and
                                 the type of the other is the result of applying boxing
                                 conversion (<a class="xref" href="jls-5.html#jls-5.1.7" title="5.1.7.&nbsp;Boxing Conversion">&sect;5.1.7</a>) to <span class="type">T</span>, then the type
                                 of the conditional expression is <span class="type">T</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.25.2-200-C"></a>If
                                 one of the operands is of type <code class="literal">byte</code> or <code class="literal">Byte</code> and the other is
                                 of type <code class="literal">short</code> or <code class="literal">Short</code>, then the type of the conditional
                                 expression is <code class="literal">short</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.25.2-200-D"></a>If
                                 one of the operands is of type <span class="type">T</span> where <span class="type">T</span> is <code class="literal">byte</code>, <code class="literal">short</code>,
                                 or <code class="literal">char</code>, and the other operand is a constant expression
                                 (<a class="xref" href="jls-15.html#jls-15.28" title="15.28.&nbsp;Constant Expressions">&sect;15.28</a>) of type <code class="literal">int</code> whose value is
                                 representable in type <span class="type">T</span>, then the type of the conditional
                                 expression is <span class="type">T</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.25.2-200-E"></a>If one of the operands is of
                                 type <span class="type">T</span>, where <span class="type">T</span> is <code class="literal">Byte</code>, <code class="literal">Short</code>, or <code class="literal">Character</code>, and the
                                 other operand is a constant expression of type <code class="literal">int</code> whose value
                                 is representable in the type <span class="type">U</span> which is the result of applying
                                 unboxing conversion to <span class="type">T</span>, then the type of the conditional
                                 expression is <span class="type">U</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.25.2-200-F"></a>Otherwise, binary numeric promotion
                                 (<a class="xref" href="jls-5.html#jls-5.6.2" title="5.6.2.&nbsp;Binary Numeric Promotion">&sect;5.6.2</a>) is applied to the operand types,
                                 and the type of the conditional expression is the promoted type
                                 of the second and third operands.
                        </p>
                        <p class="note">Note that binary numeric promotion performs
                                 value set conversion (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>) and may
                                 perform unboxing conversion (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>).
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="15.25.3.&nbsp;Reference Conditional Expressions">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.25.3"></a>15.25.3.&nbsp;Reference Conditional Expressions
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.25.3-100"></a>A
                  reference conditional expression is a poly expression if it appears in
                  an assignment context or an invocation context
                  (<a class="xref" href="jls-5.html#jls-5.2" title="5.2.&nbsp;Assignment Contexts">&sect;5.2</a>. <a class="xref" href="jls-5.html#jls-5.3" title="5.3.&nbsp;Invocation Contexts">&sect;5.3</a>). Otherwise, it
                  is a standalone expression.
               </p>
               <p class="norm-static"><a name="jls-15.25.3-110"></a>Where a
                  poly reference conditional expression appears in a context of a
                  particular kind with target type <span class="type">T</span>, its second and third operand
                  expressions similarly appear in a context of the same kind with target
                  type <span class="type">T</span>.
               </p>
               <p class="norm-static"><a name="jls-15.25.3-200"></a>The type
                  of a poly reference conditional expression is the same as its target
                  type.
               </p>
               <p class="norm-static"><a name="jls-15.25.3-210"></a>The type
                  of a standalone reference conditional expression is determined as
                  follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.25.3-210-A"></a>If
                                 the second and third operands have the same type (which may be
                                 the null type), then that is the type of the conditional
                                 expression.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.25.3-210-B"></a>If
                                 the type of one of the second and third operands is the null
                                 type, and the type of the other operand is a reference type,
                                 then the type of the conditional expression is that reference
                                 type.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.25.3-210-C"></a>Otherwise, the second and third
                                 operands are of types <span class="type">S<sub>1</sub></span> and <span class="type">S<sub>2</sub></span> respectively. Let <span class="type">T<sub>1</sub></span> be
                                 the type that results from applying boxing conversion to <span class="type">S<sub>1</sub></span>,
                                 and let <span class="type">T<sub>2</sub></span> be the type that results from applying boxing
                                 conversion to <span class="type">S<sub>2</sub></span>. The type of the conditional expression is
                                 the result of applying capture conversion
                                 (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>) to lub(<span class="type">T<sub>1</sub></span>, <span class="type">T<sub>2</sub></span>).
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="note">Because reference conditional expressions can be
                  poly expressions, they can "pass down" context to their operands. This
                  allows lambda expressions and method reference expressions to appear
                  as operands:
               </p><pre class="screen">
return ... ? (x <code class="literal">-&gt;</code> x) : (x <code class="literal">-&gt;</code> -x);
</pre><p class="note">It also allows use of extra information to improve
                  type checking of generic method invocations. Prior to Java SE 8, this
                  assignment was well-typed:
               </p><pre class="screen">
List&lt;String&gt; ls = Arrays.asList();
</pre><p class="note">but this was not:</p><pre class="screen">
List&lt;String&gt; ls = ... ? Arrays.asList() : Arrays.asList("a","b");
</pre><p class="note">The rules above allow both assignments to be
                  considered well-typed.
               </p>
               <p class="note">Note that a reference conditional expression does
                  not have to <span class="emphasis"><em>contain</em></span> a poly expression as an
                  operand in order to <span class="emphasis"><em>be</em></span> a poly expression. It is a
                  poly expression simply by virtue of the context in which it
                  appears. For example, in the following code, the conditional
                  expression is a poly expression, and each operand is considered to be
                  in an assignment context targeting <code class="literal">Class<code class="literal">&lt;</code>? super
                     Integer<code class="literal">&gt;</code></code>:
               </p><pre class="programlisting">

Class&lt;? super Integer&gt; choose(boolean b,
                              Class&lt;Integer&gt; c1,
                              Class&lt;Number&gt; c2) {
    return b ? c1 : c2;
}

</pre><p class="note">If the conditional expression was not a poly
                  expression, then a compile-time error would occur, as its type would
                  be lub(<code class="literal">Class<code class="literal">&lt;</code>Integer<code class="literal">&gt;</code></code>, 
                  <code class="literal">Class<code class="literal">&lt;</code>Number<code class="literal">&gt;</code></code>)
                  = <code class="literal">Class<code class="literal">&lt;</code>? extends Number<code class="literal">&gt;</code></code> which is
                  incompatible with the return type of <code class="literal">choose</code>.
               </p>
            </div>
         </div>
         <div class="section" title="15.26.&nbsp;Assignment Operators">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.26"></a>15.26.&nbsp;Assignment Operators
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-15.26-100"></a>There are
               12 <span class="emphasis"><em>assignment operators</em></span>; all are syntactically
               right-associative (they group right-to-left). Thus, 
               <code class="literal">a=b=c</code> means <code class="literal">a=(b=c)</code>, which
               assigns the value of <code class="literal">c</code> to <code class="literal">b</code> and
               then assigns the value of <code class="literal">b</code>
               to <code class="literal">a</code>.
            </p>
            <div id="jls-15.26-110" class="productionset"><a name="jls-15.26-110"></a>
                 
               <div class="production"><a name="jls-AssignmentExpression"></a>
                      
                  <div class="lhs">AssignmentExpression:</div>
                      
                  <div class="rhs">
                           <a href="jls-15.html#jls-ConditionalExpression" title="ConditionalExpression">ConditionalExpression</a> <br>
                           <a href="jls-15.html#jls-Assignment" title="Assignment">Assignment</a>
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-Assignment"></a>
                      
                  <div class="lhs">Assignment:</div>
                      
                  <div class="rhs">
                           <a href="jls-15.html#jls-LeftHandSide" title="LeftHandSide">LeftHandSide</a> <a href="jls-15.html#jls-AssignmentOperator" title="AssignmentOperator">AssignmentOperator</a> <a href="jls-15.html#jls-Expression" title="Expression">Expression</a>
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-LeftHandSide"></a>
                      
                  <div class="lhs">LeftHandSide:</div>
                      
                  <div class="rhs">
                           <a href="jls-6.html#jls-ExpressionName" title="ExpressionName">ExpressionName</a> <br>
                           <a href="jls-15.html#jls-FieldAccess" title="FieldAccess">FieldAccess</a> <br>
                           <a href="jls-15.html#jls-ArrayAccess" title="ArrayAccess">ArrayAccess</a>
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-AssignmentOperator"></a>
                      
                  <div class="lhs">AssignmentOperator:</div>
                      
                  <div class="rhs">
                     <pre class="screen"><code class="literal">=</code>  <code class="literal">*=</code>  <code class="literal">/=</code>  <code class="literal">%=</code>  <code class="literal">+=</code>  <code class="literal">-=</code>  <code class="literal">&lt;&lt;=</code>  <code class="literal">&gt;&gt;=</code>  <code class="literal">&gt;&gt;&gt;=</code>  <code class="literal">&amp;=</code>  <code class="literal">^=</code>  <code class="literal">|=</code></pre>
                         </div>
                    
               </div>
               
            </div>
            <p class="norm-error"><a name="jls-15.26-200"></a>The result
               of the first operand of an assignment operator must be a variable, or
               a compile-time error occurs.
            </p>
            <p class="norm-static"><a name="jls-15.26-210"></a>This
               operand may be a named variable, such as a local variable or a field
               of the current object or class, or it may be a computed variable, as
               can result from a field access (<a class="xref" href="jls-15.html#jls-15.11" title="15.11.&nbsp;Field Access Expressions">&sect;15.11</a>) or an
               array access (<a class="xref" href="jls-15.html#jls-15.10.3" title="15.10.3.&nbsp;Array Access Expressions">&sect;15.10.3</a>).
            </p>
            <p class="norm-static"><a name="jls-15.26-300"></a>The type
               of the assignment expression is the type of the variable after capture
               conversion (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>).
            </p>
            <p class="norm-dynamic"><a name="jls-15.26-400"></a>At run
               time, the result of the assignment expression is the value of the
               variable after the assignment has occurred. The result of an
               assignment expression is not itself a variable.
            </p>
            <p class="norm-static"><a name="jls-15.26-410"></a>A variable
               that is declared <code class="literal">final</code> cannot be assigned to (unless it is
               definitely unassigned (<a class="xref" href="jls-16.html" title="Chapter&nbsp;16.&nbsp;Definite Assignment">&sect;16 (<i>Definite Assignment</i>)</a>)), because when an
               access of such a <code class="literal">final</code> variable is used as an expression, the result
               is a value, not a variable, and so it cannot be used as the first
               operand of an assignment operator. 
            </p>
            <div class="section" title="15.26.1.&nbsp;Simple Assignment Operator =">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.26.1"></a>15.26.1.&nbsp;Simple Assignment Operator <code class="literal">=</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-error"><a name="jls-15.26.1-100"></a>A
                  compile-time error occurs if the type of the right-hand operand cannot
                  be converted to the type of the variable by assignment conversion
                  (<a class="xref" href="jls-5.html#jls-5.2" title="5.2.&nbsp;Assignment Contexts">&sect;5.2</a>).
               </p>
               <p class="norm-dynamic"><a name="jls-15.26.1-200"></a>At run
                  time, the expression is evaluated in one of three ways.
               </p>
               <p class="norm-dynamic"><a name="jls-15.26.1-300"></a>If the
                  left-hand operand expression is a field access expression <code class="varname">e</code><code class="literal">.</code><code class="varname">f</code>
                  (<a class="xref" href="jls-15.html#jls-15.11" title="15.11.&nbsp;Field Access Expressions">&sect;15.11</a>), possibly enclosed in one or more pairs
                  of parentheses, then:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.1-300-A"></a>
                                 First, the expression <code class="varname">e</code> is evaluated. If evaluation of <code class="varname">e</code>
                                 completes abruptly, the assignment expression completes abruptly
                                 for the same reason.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.1-300-B"></a>
                                 Next, the right hand operand is evaluated. If evaluation of the
                                 right hand expression completes abruptly, the assignment
                                 expression completes abruptly for the same reason.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.1-300-C"></a>
                                 Then, if the field denoted by <code class="varname">e</code><code class="literal">.</code><code class="varname">f</code> is not <code class="literal">static</code> and
                                 the result of the evaluation of <code class="varname">e</code> above is <code class="literal">null</code>, then a
                                 <code class="literal">NullPointerException</code> is thrown.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.1-300-D"></a>
                                 Otherwise, the variable denoted by <code class="varname">e</code><code class="literal">.</code><code class="varname">f</code> is assigned the
                                 value of the right hand operand as computed above.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-15.26.1-400"></a>If the
                  left-hand operand is an array access expression
                  (<a class="xref" href="jls-15.html#jls-15.10.3" title="15.10.3.&nbsp;Array Access Expressions">&sect;15.10.3</a>), possibly enclosed in one or more
                  pairs of parentheses, then:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.1-400-A"></a>
                                 First, the array reference subexpression of the left-hand
                                 operand array access expression is evaluated. If this evaluation
                                 completes abruptly, then the assignment expression completes
                                 abruptly for the same reason; the index subexpression (of the
                                 left-hand operand array access expression) and the right-hand
                                 operand are not evaluated and no assignment occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.1-400-B"></a>
                                 Otherwise, the index subexpression of the left-hand operand
                                 array access expression is evaluated. If this evaluation
                                 completes abruptly, then the assignment expression completes
                                 abruptly for the same reason and the right-hand operand is not
                                 evaluated and no assignment occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.1-400-C"></a>
                                 Otherwise, the right-hand operand is evaluated. If this
                                 evaluation completes abruptly, then the assignment expression
                                 completes abruptly for the same reason and no assignment
                                 occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.1-400-D"></a>
                                 Otherwise, if the value of the array reference subexpression is
                                 <code class="literal">null</code>, then no assignment occurs and a <code class="literal">NullPointerException</code> is thrown.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.1-400-E"></a>
                                 Otherwise, the value of the array reference subexpression indeed
                                 refers to an array. If the value of the index subexpression is
                                 less than zero, or greater than or equal to the <code class="literal">length</code> of the
                                 array, then no assignment occurs and an <code class="literal">ArrayIndexOutOfBoundsException</code> is
                                 thrown.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.1-400-F"></a>
                                 Otherwise, the value of the index subexpression is used to
                                 select a component of the array referred to by the value of the
                                 array reference subexpression.
                        </p>
                        <p class="norm-dynamic"><a name="jls-15.26.1-400-F.1"></a>
                                 This component is a variable; call its type <span class="type">SC</span>. Also, let <span class="type">TC</span>
                                 be the type of the left-hand operand of the assignment operator
                                 as determined at compile time. Then there are two
                                 possibilities:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.26.1-400-F.1-A"></a>
                                    	  If <span class="type">TC</span> is a primitive type, then <span class="type">SC</span> is necessarily the
                                    	  same as <span class="type">TC</span>.
                                 </p>
                                 <p class="norm-dynamic"><a name="jls-15.26.1-400-F.1-A.1"></a>
                                    	  The value of the right-hand operand is converted to the type
                                    	  of the selected array component, is subjected to value set
                                    	  conversion (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>) to the appropriate
                                    	  standard value set (not an extended-exponent value set), and
                                    	  the result of the conversion is stored into the array
                                    	  component.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-15.26.1-400-F.1-B"></a>
                                    	  If <span class="type">TC</span> is a reference type, then <span class="type">SC</span> may not be the same
                                              as <span class="type">TC</span>, but rather a type that extends or implements
                                              <span class="type">TC</span>.
                                 </p>
                                 <p class="norm"><a name="jls-15.26.1-400-F.1-B.1"></a>
                                    	  Let <span class="type">RC</span> be the class of the object referred to by the value
                                     	  of the right-hand operand at run time.
                                 </p>
                                 <p class="norm-dynamic"><a name="jls-15.26.1-400-F.1-B.2"></a>
                                    	  A Java compiler may be able to prove at compile time that
                                    	  the array component will be of type <span class="type">TC</span> exactly (for
                                    	  example, <span class="type">TC</span> might be <code class="literal">final</code>). But if a Java compiler
                                    	  cannot prove at compile time that the array component will
                                    	  be of type <span class="type">TC</span> exactly, then a check must be performed at
                                    	  run time to ensure that the class <span class="type">RC</span> is assignment
                                    	  compatible (<a class="xref" href="jls-5.html#jls-5.2" title="5.2.&nbsp;Assignment Contexts">&sect;5.2</a>) with the actual type
                                    	  <span class="type">SC</span> of the array component.
                                 </p>
                                 <p class="note">This check is similar to a narrowing cast
                                    	  (<a class="xref" href="jls-5.html#jls-5.5" title="5.5.&nbsp;Casting Contexts">&sect;5.5</a>, <a class="xref" href="jls-15.html#jls-15.16" title="15.16.&nbsp;Cast Expressions">&sect;15.16</a>),
                                    	  except that if the check fails, an <code class="literal">ArrayStoreException</code> is thrown rather
                                    	  than a <code class="literal">ClassCastException</code>.
                                 </p>
                                 <p class="norm-dynamic"><a name="jls-15.26.1-400-F.1-B.3"></a>
                                    	  If class <span class="type">RC</span> is not assignable to type <span class="type">SC</span>, then no
                                    	  assignment occurs and an <code class="literal">ArrayStoreException</code> is thrown.
                                 </p>
                                 <p class="norm-dynamic"><a name="jls-15.26.1-400-F.1-B.4"></a>
                                    	  Otherwise, the reference value of the right-hand operand is
                                    	  stored into the selected array component.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-15.26.1-500"></a>Otherwise, three steps are required:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.1-500-A"></a>
                                 First, the left-hand operand is evaluated to produce a
                                 variable. If this evaluation completes abruptly, then the
                                 assignment expression completes abruptly for the same reason;
                                 the right-hand operand is not evaluated and no assignment
                                 occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.1-500-B"></a>
                                 Otherwise, the right-hand operand is evaluated. If this
                                 evaluation completes abruptly, then the assignment expression
                                 completes abruptly for the same reason and no assignment
                                 occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.1-500-C"></a>
                                 Otherwise, the value of the right-hand operand is converted to
                                 the type of the left-hand variable, is subjected to value set
                                 conversion (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>) to the appropriate
                                 standard value set (not an extended-exponent value set), and the
                                 result of the conversion is stored into the variable.
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="example"><a name="d5e30155"></a><p class="title"><b>Example&nbsp;15.26.1-1.&nbsp;Simple Assignment To An Array Component</b></p>
                  <div class="example-contents"><pre class="programlisting">
class ArrayReferenceThrow extends RuntimeException { }
class IndexThrow          extends RuntimeException { }
class RightHandSideThrow  extends RuntimeException { }

class IllustrateSimpleArrayAssignment {
    static Object[] objects = { new Object(), new Object() };
    static Thread[] threads = { new Thread(), new Thread() };

    static Object[] arrayThrow() {
        throw new ArrayReferenceThrow();
    }
    static int indexThrow() {
        throw new IndexThrow();
    }
    static Thread rightThrow() {
        throw new RightHandSideThrow();
    }
    static String name(Object q) {
        String sq = q.getClass().getName();
        int k = sq.lastIndexOf('.');
        return (k &lt; 0) ? sq : sq.substring(k+1);
    }

    static void testFour(Object[] x, int j, Object y) {
        String sx = x == null ? "null" : name(x[0]) + "s";
        String sy = name(y);
        System.out.println();
        try {
            System.out.print(sx + "[throw]=throw =&gt; ");
            x[indexThrow()] = rightThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print(sx + "[throw]=" + sy + " =&gt; ");
            x[indexThrow()] = y;
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print(sx + "[" + j + "]=throw =&gt; ");
            x[j] = rightThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print(sx + "[" + j + "]=" + sy + " =&gt; ");
            x[j] = y;
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
    }

    public static void main(String[] args) {
        try {
            System.out.print("throw[throw]=throw =&gt; ");
            arrayThrow()[indexThrow()] = rightThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print("throw[throw]=Thread =&gt; ");
            arrayThrow()[indexThrow()] = new Thread();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print("throw[1]=throw =&gt; ");
            arrayThrow()[1] = rightThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print("throw[1]=Thread =&gt; ");
            arrayThrow()[1] = new Thread();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }

        testFour(null, 1, new StringBuffer());
        testFour(null, 9, new Thread());
        testFour(objects, 1, new StringBuffer());
        testFour(objects, 1, new Thread());
        testFour(objects, 9, new StringBuffer());
        testFour(objects, 9, new Thread());
        testFour(threads, 1, new StringBuffer());
        testFour(threads, 1, new Thread());
        testFour(threads, 9, new StringBuffer());
        testFour(threads, 9, new Thread());
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
throw[throw]=throw =&gt; ArrayReferenceThrow
throw[throw]=Thread =&gt; ArrayReferenceThrow
throw[1]=throw =&gt; ArrayReferenceThrow
throw[1]=Thread =&gt; ArrayReferenceThrow

null[throw]=throw =&gt; IndexThrow
null[throw]=StringBuffer =&gt; IndexThrow
null[1]=throw =&gt; RightHandSideThrow
null[1]=StringBuffer =&gt; NullPointerException

null[throw]=throw =&gt; IndexThrow
null[throw]=Thread =&gt; IndexThrow
null[9]=throw =&gt; RightHandSideThrow
null[9]=Thread =&gt; NullPointerException

Objects[throw]=throw =&gt; IndexThrow
Objects[throw]=StringBuffer =&gt; IndexThrow
Objects[1]=throw =&gt; RightHandSideThrow
Objects[1]=StringBuffer =&gt; Okay!

Objects[throw]=throw =&gt; IndexThrow
Objects[throw]=Thread =&gt; IndexThrow
Objects[1]=throw =&gt; RightHandSideThrow
Objects[1]=Thread =&gt; Okay!

Objects[throw]=throw =&gt; IndexThrow
Objects[throw]=StringBuffer =&gt; IndexThrow
Objects[9]=throw =&gt; RightHandSideThrow
Objects[9]=StringBuffer =&gt; ArrayIndexOutOfBoundsException

Objects[throw]=throw =&gt; IndexThrow
Objects[throw]=Thread =&gt; IndexThrow
Objects[9]=throw =&gt; RightHandSideThrow
Objects[9]=Thread =&gt; ArrayIndexOutOfBoundsException

Threads[throw]=throw =&gt; IndexThrow
Threads[throw]=StringBuffer =&gt; IndexThrow
Threads[1]=throw =&gt; RightHandSideThrow
Threads[1]=StringBuffer =&gt; ArrayStoreException

Threads[throw]=throw =&gt; IndexThrow
Threads[throw]=Thread =&gt; IndexThrow
Threads[1]=throw =&gt; RightHandSideThrow
Threads[1]=Thread =&gt; Okay!

Threads[throw]=throw =&gt; IndexThrow
Threads[throw]=StringBuffer =&gt; IndexThrow
Threads[9]=throw =&gt; RightHandSideThrow
Threads[9]=StringBuffer =&gt; ArrayIndexOutOfBoundsException

Threads[throw]=throw =&gt; IndexThrow
Threads[throw]=Thread =&gt; IndexThrow
Threads[9]=throw =&gt; RightHandSideThrow
Threads[9]=Thread =&gt; ArrayIndexOutOfBoundsException
</pre><p class="note">The most interesting case of the lot is thirteenth
                        from the end:
                     </p><pre class="screen">
Threads[1]=StringBuffer =&gt; ArrayStoreException
</pre><p class="note">which indicates that the attempt to store a
                        reference to a <code class="literal">StringBuffer</code> into an array whose
                        components are of type <code class="literal">Thread</code> throws an <code class="literal">ArrayStoreException</code>. The code is
                        type-correct at compile time: the assignment has a left-hand side of
                        type <code class="literal">Object[]</code> and a right-hand side of type
                        <code class="literal">Object</code>. At run time, the first actual argument to
                        method <code class="literal">testFour</code> is a reference to an instance of
                        "array of <code class="literal">Thread</code>" and the third actual argument is a reference to an
                        instance of class <code class="literal">StringBuffer</code>.
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="15.26.2.&nbsp;Compound Assignment Operators">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.26.2"></a>15.26.2.&nbsp;Compound Assignment Operators
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.26.2-100"></a>A
                  compound assignment expression of the form <code class="varname">E1 op=
                     E2</code> is equivalent to <code class="varname">E1 = (T) ((E1) op
                     (E2))</code>, where <span class="type">T</span> is the type of <code class="varname">E1</code>,
                  except that <code class="varname">E1</code> is evaluated only once.
               </p>
               <div class="informalexample">
                  <p class="note">For example, the following code is correct:</p><pre class="screen">
short x = 3;
x += 4.6;
</pre><p class="note">and results in <code class="literal">x</code> having the
                     value <code class="literal">7</code> because it is equivalent to:
                  </p><pre class="screen">
short x = 3;
x = (short)(x + 4.6);
</pre></div>
               <p class="norm-dynamic"><a name="jls-15.26.2-200"></a>At run
                  time, the expression is evaluated in one of two ways.
               </p>
               <p class="norm-dynamic"><a name="jls-15.26.2-300"></a>If the
                  left-hand operand expression is not an array access expression,
                  then:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.2-300-A"></a>
                                 First, the left-hand operand is evaluated to produce a
                                 variable. If this evaluation completes abruptly, then the
                                 assignment expression completes abruptly for the same reason;
                                 the right-hand operand is not evaluated and no assignment
                                 occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.2-300-B"></a>
                                 Otherwise, the value of the left-hand operand is saved and then
                                 the right-hand operand is evaluated. If this evaluation
                                 completes abruptly, then the assignment expression completes
                                 abruptly for the same reason and no assignment occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.2-300-C"></a>
                                 Otherwise, the saved value of the left-hand variable and the
                                 value of the right-hand operand are used to perform the binary
                                 operation indicated by the compound assignment operator. If this
                                 operation completes abruptly, then the assignment expression
                                 completes abruptly for the same reason and no assignment
                                 occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.2-300-D"></a>
                                 Otherwise, the result of the binary operation is converted to
                                 the type of the left-hand variable, subjected to value set
                                 conversion (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>) to the appropriate
                                 standard value set (not an extended-exponent value set), and the
                                 result of the conversion is stored into the variable.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-15.26.2-400"></a>If the
                  left-hand operand expression is an array access expression
                  (<a class="xref" href="jls-15.html#jls-15.10.3" title="15.10.3.&nbsp;Array Access Expressions">&sect;15.10.3</a>), then:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.2-400-A"></a>
                                 First, the array reference subexpression of the left-hand
                                 operand array access expression is evaluated. If this evaluation
                                 completes abruptly, then the assignment expression completes
                                 abruptly for the same reason; the index subexpression (of the
                                 left-hand operand array access expression) and the right-hand
                                 operand are not evaluated and no assignment occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.2-400-B"></a>
                                 Otherwise, the index subexpression of the left-hand operand
                                 array access expression is evaluated. If this evaluation
                                 completes abruptly, then the assignment expression completes
                                 abruptly for the same reason and the right-hand operand is not
                                 evaluated and no assignment occurs.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.2-400-C"></a>
                                 Otherwise, if the value of the array reference subexpression is
                                 <code class="literal">null</code>, then no assignment occurs and a <code class="literal">NullPointerException</code> is thrown.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.2-400-D"></a>
                                 Otherwise, the value of the array reference subexpression indeed
                                 refers to an array. If the value of the index subexpression is
                                 less than zero, or greater than or equal to the <code class="literal">length</code> of the
                                 array, then no assignment occurs and an <code class="literal">ArrayIndexOutOfBoundsException</code> is
                                 thrown.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.2-400-E"></a>
                                 Otherwise, the value of the index subexpression is used to
                                 select a component of the array referred to by the value of the
                                 array reference subexpression. The value of this component is
                                 saved and then the right-hand operand is evaluated. If this
                                 evaluation completes abruptly, then the assignment expression
                                 completes abruptly for the same reason and no assignment
                                 occurs.
                        </p>
                        <p class="note">For a simple assignment operator, the evaluation
                                 of the right-hand operand occurs before the checks of the array
                                 reference subexpression and the index subexpression, but for a
                                 compound assignment operator, the evaluation of the right-hand
                                 operand occurs after these checks.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.26.2-400-F"></a>
                                 Otherwise, consider the array component selected in the previous
                                 step, whose value was saved. This component is a variable; call
                                 its type <span class="type">S</span>. Also, let <span class="type">T</span> be the type of the left-hand operand
                                 of the assignment operator as determined at compile time.
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.26.2-400-F-A"></a>
                                    	  If <span class="type">T</span> is a primitive type, then <span class="type">S</span> is necessarily the same
                                    	  as <span class="type">T</span>.
                                 </p>
                                 <p class="norm-dynamic"><a name="jls-15.26.2-400-F-A.1"></a>
                                    	  The saved value of the array component and the value of the
                                    	  right-hand operand are used to perform the binary operation
                                    	  indicated by the compound assignment operator.
                                 </p>
                                 <p class="norm-dynamic"><a name="jls-15.26.2-400-F-A.2"></a>
                                    	  If this operation completes abruptly (the only possibility
                                    	  is an integer division by zero - see
                                    	  <a class="xref" href="jls-15.html#jls-15.17.2" title="15.17.2.&nbsp;Division Operator /">&sect;15.17.2</a>), then the assignment
                                    	  expression completes abruptly for the same reason and no
                                    	  assignment occurs.
                                 </p>
                                 <p class="norm-dynamic"><a name="jls-15.26.2-400-F-A.3"></a>
                                    	  Otherwise, the result of the binary operation is converted
                                    	  to the type of the selected array component, subjected to
                                    	  value set conversion (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>) to the
                                    	  appropriate standard value set (not an extended-exponent
                                    	  value set), and the result of the conversion is stored into
                                    	  the array component.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-15.26.2-400-F-B"></a>
                                    	  If <span class="type">T</span> is a reference type, then it must be
                                    	  <code class="literal">String</code>. Because class <code class="literal">String</code> is a <code class="literal">final</code> class, <span class="type">S</span>
                                    	  must also be <code class="literal">String</code>.
                                 </p>
                                 <p class="note">Therefore the run-time check that is
                                    	  sometimes required for the simple assignment operator is
                                    	  never required for a compound assignment operator.
                                 </p>
                                 <p class="norm-dynamic"><a name="jls-15.26.2-400-F-B.1"></a>
                                    	  The saved value of the array component and the value of the
                                    	  right-hand operand are used to perform the binary operation
                                    	  (string concatenation) indicated by the compound assignment
                                    	  operator (which is necessarily <code class="literal">+=</code>). If this
                                    	  operation completes abruptly, then the assignment expression
                                    	  completes abruptly for the same reason and no assignment
                                    	  occurs.
                                 </p>
                                 <p class="norm-dynamic"><a name="jls-15.26.2-400-F-B.2"></a>
                                    	  Otherwise, the <code class="literal">String</code> result of the binary operation is
                                    	  stored into the array component.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
               <div class="example"><a name="d5e30244"></a><p class="title"><b>Example&nbsp;15.26.2-1.&nbsp;Compound Assignment To An Array Component</b></p>
                  <div class="example-contents"><pre class="programlisting">
class ArrayReferenceThrow extends RuntimeException { }
class IndexThrow          extends RuntimeException { }
class RightHandSideThrow  extends RuntimeException { }

class IllustrateCompoundArrayAssignment {
    static String[] strings = { "Simon", "Garfunkel" };
    static double[] doubles = { Math.E, Math.PI };

    static String[] stringsThrow() {
        throw new ArrayReferenceThrow();
    }
    static double[] doublesThrow() {
        throw new ArrayReferenceThrow();
    }
    static int indexThrow() {
        throw new IndexThrow();
    }
    static String stringThrow() {
        throw new RightHandSideThrow();
    }
    static double doubleThrow() {
        throw new RightHandSideThrow();
    }
    static String name(Object q) {
        String sq = q.getClass().getName();
        int k = sq.lastIndexOf('.');
        return (k &lt; 0) ? sq : sq.substring(k+1);
    }

    static void testEight(String[] x, double[] z, int j) {
        String sx = (x == null) ? "null" : "Strings";
        String sz = (z == null) ? "null" : "doubles";
        System.out.println();
        try {
            System.out.print(sx + "[throw]+=throw =&gt; ");
            x[indexThrow()] += stringThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print(sz + "[throw]+=throw =&gt; ");
            z[indexThrow()] += doubleThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print(sx + "[throw]+=\"heh\" =&gt; ");
            x[indexThrow()] += "heh";
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print(sz + "[throw]+=12345 =&gt; ");
            z[indexThrow()] += 12345;
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print(sx + "[" + j + "]+=throw =&gt; ");
            x[j] += stringThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print(sz + "[" + j + "]+=throw =&gt; ");
            z[j] += doubleThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print(sx + "[" + j + "]+=\"heh\" =&gt; ");
            x[j] += "heh";
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print(sz + "[" + j + "]+=12345 =&gt; ");
            z[j] += 12345;
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
    }

    public static void main(String[] args) {
        try {
            System.out.print("throw[throw]+=throw =&gt; ");
            stringsThrow()[indexThrow()] += stringThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print("throw[throw]+=throw =&gt; ");
            doublesThrow()[indexThrow()] += doubleThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print("throw[throw]+=\"heh\" =&gt; ");
            stringsThrow()[indexThrow()] += "heh";
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print("throw[throw]+=12345 =&gt; ");
            doublesThrow()[indexThrow()] += 12345;
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print("throw[1]+=throw =&gt; ");
            stringsThrow()[1] += stringThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print("throw[1]+=throw =&gt; ");
            doublesThrow()[1] += doubleThrow();
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print("throw[1]+=\"heh\" =&gt; ");
            stringsThrow()[1] += "heh";
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        try {
            System.out.print("throw[1]+=12345 =&gt; ");
            doublesThrow()[1] += 12345;
            System.out.println("Okay!");
        } catch (Throwable e) { System.out.println(name(e)); }
        testEight(null, null, 1);
        testEight(null, null, 9);
        testEight(strings, doubles, 1);
        testEight(strings, doubles, 9);
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
throw[throw]+=throw =&gt; ArrayReferenceThrow
throw[throw]+=throw =&gt; ArrayReferenceThrow
throw[throw]+="heh" =&gt; ArrayReferenceThrow
throw[throw]+=12345 =&gt; ArrayReferenceThrow
throw[1]+=throw =&gt; ArrayReferenceThrow
throw[1]+=throw =&gt; ArrayReferenceThrow
throw[1]+="heh" =&gt; ArrayReferenceThrow
throw[1]+=12345 =&gt; ArrayReferenceThrow

null[throw]+=throw =&gt; IndexThrow
null[throw]+=throw =&gt; IndexThrow
null[throw]+="heh" =&gt; IndexThrow
null[throw]+=12345 =&gt; IndexThrow
null[1]+=throw =&gt; NullPointerException
null[1]+=throw =&gt; NullPointerException
null[1]+="heh" =&gt; NullPointerException
null[1]+=12345 =&gt; NullPointerException

null[throw]+=throw =&gt; IndexThrow
null[throw]+=throw =&gt; IndexThrow
null[throw]+="heh" =&gt; IndexThrow
null[throw]+=12345 =&gt; IndexThrow
null[9]+=throw =&gt; NullPointerException
null[9]+=throw =&gt; NullPointerException
null[9]+="heh" =&gt; NullPointerException
null[9]+=12345 =&gt; NullPointerException

Strings[throw]+=throw =&gt; IndexThrow
doubles[throw]+=throw =&gt; IndexThrow
Strings[throw]+="heh" =&gt; IndexThrow
doubles[throw]+=12345 =&gt; IndexThrow
Strings[1]+=throw =&gt; RightHandSideThrow
doubles[1]+=throw =&gt; RightHandSideThrow
Strings[1]+="heh" =&gt; Okay!
doubles[1]+=12345 =&gt; Okay!

Strings[throw]+=throw =&gt; IndexThrow
doubles[throw]+=throw =&gt; IndexThrow
Strings[throw]+="heh" =&gt; IndexThrow
doubles[throw]+=12345 =&gt; IndexThrow
Strings[9]+=throw =&gt; ArrayIndexOutOfBoundsException
doubles[9]+=throw =&gt; ArrayIndexOutOfBoundsException
Strings[9]+="heh" =&gt; ArrayIndexOutOfBoundsException
doubles[9]+=12345 =&gt; ArrayIndexOutOfBoundsException
</pre><p class="note">The most interesting cases of the lot are eleventh
                        and twelfth from the end:
                     </p><pre class="screen">
Strings[1]+=throw =&gt; RightHandSideThrow
doubles[1]+=throw =&gt; RightHandSideThrow
</pre><p class="note">They are the cases where a right-hand side that
                        throws an exception actually gets to throw the exception; moreover,
                        they are the only such cases in the lot. This demonstrates that the
                        evaluation of the right-hand operand indeed occurs after the checks
                        for a null array reference value and an out-of-bounds index
                        value.
                     </p>
                  </div>
               </div><br class="example-break"><div class="example"><a name="d5e30252"></a><p class="title"><b>Example&nbsp;15.26.2-2.&nbsp;Value Of Left-Hand Side Of Compound Assignment Is Saved Before Evaluation Of Right-Hand Side</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Test {
    public static void main(String[] args) {
        int k = 1;
        int[] a = { 1 };
        k += (k = 4) * (k + 2);
        a[0] += (a[0] = 4) * (a[0] + 2);
        System.out.println("k==" + k + " and a[0]==" + a[0]);
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
k==25 and a[0]==25
</pre><p class="note">The value <code class="literal">1</code> of <code class="literal">k</code> is saved by
                        the compound assignment operator <code class="literal">+=</code> before its
                        right-hand operand <code class="literal">(k = 4) * (k + 2)</code> is
                        evaluated. Evaluation of this right-hand operand then
                        assigns <code class="literal">4</code> to <code class="literal">k</code>, calculates the
                        value <code class="literal">6</code> for <code class="literal">k + 2</code>, and then
                        multiplies <code class="literal">4</code> by <code class="literal">6</code> to
                        get <code class="literal">24</code>. This is added to the saved value <code class="literal">1</code> to
                        get <code class="literal">25</code>, which is then stored
                        into <code class="literal">k</code> by the <code class="literal">+=</code> operator. An
                        identical analysis applies to the case that
                        uses <code class="literal">a[0]</code>.
                     </p>
                     <p class="note">In short, the statements:</p><pre class="screen">
k += (k = 4) * (k + 2);
a[0] += (a[0] = 4) * (a[0] + 2);
</pre><p class="note">behave in exactly the same manner as the
                        statements:
                     </p><pre class="screen">
k = k + (k = 4) * (k + 2);
a[0] = a[0] + (a[0] = 4) * (a[0] + 2);
</pre></div>
               </div><br class="example-break"></div>
         </div>
         <div class="section" title="15.27.&nbsp;Lambda Expressions">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.27"></a>15.27.&nbsp;Lambda Expressions
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-15.27-100"></a>A lambda expression is like a
               method: it provides a list of formal parameters and a body - an
               expression or block - expressed in terms of those parameters.
            </p>
            <div id="jls-15.27-110" class="productionset"><a name="jls-15.27-110"></a>
                 
               <div class="production"><a name="jls-LambdaExpression"></a>
                      
                  <div class="lhs">LambdaExpression:</div>
                      
                  <div class="rhs">
                           <a href="jls-15.html#jls-LambdaParameters" title="LambdaParameters">LambdaParameters</a> <code class="literal">-&gt;</code> <a href="jls-15.html#jls-LambdaBody" title="LambdaBody">LambdaBody</a>
                         
                  </div>
                    
               </div>
               
            </div>
            <p class="norm-static"><a name="jls-15.27-200"></a>Lambda
               expressions are always poly expressions (<a class="xref" href="jls-15.html#jls-15.2" title="15.2.&nbsp;Forms of Expressions">&sect;15.2</a>).
            </p>
            <p class="norm-error"><a name="jls-15.27-210"></a>It is a
               compile-time error if a lambda expression occurs in a program in
               someplace other than an assignment context
               (<a class="xref" href="jls-5.html#jls-5.2" title="5.2.&nbsp;Assignment Contexts">&sect;5.2</a>), an invocation context
               (<a class="xref" href="jls-5.html#jls-5.3" title="5.3.&nbsp;Invocation Contexts">&sect;5.3</a>), or a casting context
               (<a class="xref" href="jls-5.html#jls-5.5" title="5.5.&nbsp;Casting Contexts">&sect;5.5</a>).
            </p>
            <p class="norm-dynamic"><a name="jls-15.27-300"></a>
               Evaluation of a lambda expression produces an instance of a functional
               interface (<a class="xref" href="jls-9.html#jls-9.8" title="9.8.&nbsp;Functional Interfaces">&sect;9.8</a>).  Lambda expression evaluation
               does <span class="emphasis"><em>not</em></span> cause the execution of the expression's
               body; instead, this may occur at a later time when an appropriate
               method of the functional interface is invoked.
            </p>
            <div class="informalexample">
               <p class="note">Here are some examples of lambda expressions:</p><pre class="programlisting">

() -&gt; {}                // No parameters; result is void
() -&gt; 42                // No parameters, expression body
() -&gt; null              // No parameters, expression body
() -&gt; { return 42; }    // No parameters, block body with return
() -&gt; { System.gc(); }  // No parameters, void block body

() -&gt; {                 // Complex block body with returns
  if (true) return 12;
  else {
    int result = 15;
    for (int i = 1; i &lt; 10; i++)
      result *= i;
    return result;
  }
}                          

(int x) -&gt; x+1              // Single declared-type parameter
(int x) -&gt; { return x+1; }  // Single declared-type parameter
(x) -&gt; x+1                  // Single inferred-type parameter
x -&gt; x+1                    // Parentheses optional for
                            // single inferred-type parameter

(String s) -&gt; s.length()      // Single declared-type parameter
(Thread t) -&gt; { t.start(); }  // Single declared-type parameter
s -&gt; s.length()               // Single inferred-type parameter
t -&gt; { t.start(); }           // Single inferred-type parameter

(int x, int y) -&gt; x+y  // Multiple declared-type parameters
(x, y) -&gt; x+y          // Multiple inferred-type parameters
(x, int y) -&gt; x+y    // Illegal: can't mix inferred and declared types
(x, final y) -&gt; x+y  // Illegal: no modifiers with inferred types

</pre></div>
            <p class="note">This syntax has the advantage of minimizing bracket
               noise around simple lambda expressions, which is especially beneficial
               when a lambda expression is an argument to a method, or when the body
               is another lambda expression. It also clearly distinguishes between
               its expression and statement forms, which avoids ambiguities or
               over-reliance on '<code class="literal">;</code>' tokens. When some extra bracketing is needed
               to visually distinguish either the full lambda expression or its body
               expression, parentheses are naturally supported (just as in other
               cases in which operator precedence is unclear).
            </p>
            <p class="note">The syntax has some parsing challenges. The
               Java programming language has always had an ambiguity between types and expressions
               after a '<code class="literal">(</code>' token: what follows may be a cast or a
               parenthesized expression. This was made worse when generics reused the
               binary operators '<code class="literal">&lt;</code>' and '<code class="literal">&gt;</code>' in types. Lambda
               expressions introduce a new possibility: the tokens following
               '<code class="literal">(</code>' may describe a type, an expression, or a lambda parameter
               list. Some tokens (annotations, <code class="literal">final</code>) are unique to parameter
               lists, while in other cases there are certain patterns that must be
               interpreted as parameter lists (two names in a row, a '<code class="literal">,</code>' not
               nested inside of '<code class="literal">&lt;</code>' and '<code class="literal">&gt;</code>'). And sometimes, the
               ambiguity cannot be resolved until a '<code class="literal">-&gt;</code>' is encountered, after a
               '<code class="literal">)</code>'. The simplest way to think of how this might be efficiently
               parsed is with a state machine: each state represents a subset of
               possible interpretations (type, expression, or parameters), and when
               the machine transitions to a state in which the set is a singleton,
               the parser knows which case it is. This does not map very elegantly to
               a fixed-lookahead grammar, however.
            </p>
            <p class="note">There is no special nullary form: a lambda
               expression with zero arguments is expressed as <code class="literal">() <code class="literal">-&gt;</code>
                  ...</code>. The obvious special-case syntax, <code class="literal"><code class="literal">-&gt;</code>
                  ...</code>, does not work because it introduces an ambiguity
               between argument lists and casts: <code class="literal">(x) <code class="literal">-&gt;</code>
                  ...</code>.
            </p>
            <p class="note">Lambda expressions cannot declare type parameters.
               While it would make sense semantically to do so, the natural syntax
               (preceding the parameter list with a type parameter list) introduces
               messy ambiguities. For example, consider:
            </p><pre class="screen">foo( (x) &lt; y , z &gt; (w) <code class="literal">-&gt;</code> v )</pre><p class="note">This could be an invocation
               of <code class="literal">foo</code> with one argument (a generic lambda cast to
               type <code class="literal">x</code>), or it could be an invocation
               of <code class="literal">foo</code> with two arguments, both the results of
               comparisons, the second comparing <code class="literal">z</code> with a lambda
               expression. (Strictly speaking, a lambda expression is meaningless as
               an operand to the relational operator <code class="literal">&gt;</code>, but that is a
               tenuous assumption on which to build the grammar.)
            </p>
            <p class="note">There is a precedent for ambiguity resolution
               involving casts, which essentially prohibits the use of <code class="literal">-</code> and
               <code class="literal">+</code> following a non-primitive cast (<a class="xref" href="jls-15.html#jls-15.15" title="15.15.&nbsp;Unary Operators">&sect;15.15</a>),
               but to extend that approach to generic lambdas would involve invasive
               changes to the grammar.
            </p>
            <div class="section" title="15.27.1.&nbsp;Lambda Parameters">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.27.1"></a>15.27.1.&nbsp;Lambda Parameters
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.27.1-100"></a>The
                  formal parameters of a lambda expression may have either declared
                  types or inferred types. These styles cannot be mixed: it is not
                  possible for a lambda expression to declare the types of some of its
                  parameters but leave others to be inferred. Only parameters with
                  declared types can have modifiers.
               </p>
               <div id="jls-15.27.1-110" class="productionset"><a name="jls-15.27.1-110"></a>
                    
                  <div class="production"><a name="jls-LambdaParameters"></a>
                         
                     <div class="lhs">LambdaParameters:</div>
                         
                     <div class="rhs">
                              <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a> <br>
                              <code class="literal">(</code> [<a href="jls-8.html#jls-FormalParameterList" title="FormalParameterList">FormalParameterList</a>] <code class="literal">)</code> <br>
                              <code class="literal">(</code> <a href="jls-15.html#jls-InferredFormalParameterList" title="InferredFormalParameterList">InferredFormalParameterList</a> <code class="literal">)</code>
                            
                     </div>
                       
                  </div>
                  
                    
                  <div class="production"><a name="jls-InferredFormalParameterList"></a>
                         
                     <div class="lhs">InferredFormalParameterList:</div>
                         
                     <div class="rhs">
                              <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a> {<code class="literal">,</code> <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a>}
                            
                     </div>
                       
                  </div>
                  
               </div>
               <p class="note">The following productions from
                  <a class="xref" href="jls-4.html#jls-4.3" title="4.3.&nbsp;Reference Types and Values">&sect;4.3</a>, <a class="xref" href="jls-8.html#jls-8.3" title="8.3.&nbsp;Field Declarations">&sect;8.3</a>, and
                  <a class="xref" href="jls-8.html#jls-8.4.1" title="8.4.1.&nbsp;Formal Parameters">&sect;8.4.1</a> are shown here for convenience:
               </p>
               <div id="d5e30357" class="productionset"><a name="d5e30357"></a>
                    
                  <div class="productionrecap-note">
                     <div class="production">
                            
                        <div class="lhs">FormalParameterList:</div>
                            
                        <div class="rhs">
                                 <a href="jls-8.html#jls-FormalParameters" title="FormalParameters">FormalParameters</a> <code class="literal">,</code> <a href="jls-8.html#jls-LastFormalParameter" title="LastFormalParameter">LastFormalParameter</a> <br>
                                 <a href="jls-8.html#jls-LastFormalParameter" title="LastFormalParameter">LastFormalParameter</a>
                               
                        </div>
                          
                     </div>
                  </div>
                    
                  <div class="productionrecap-note">
                     <div class="production">
                            
                        <div class="lhs">FormalParameters:</div>
                            
                        <div class="rhs">
                                 <a href="jls-8.html#jls-FormalParameter" title="FormalParameter">FormalParameter</a> {<code class="literal">,</code> <a href="jls-8.html#jls-FormalParameter" title="FormalParameter">FormalParameter</a>} <br>
                                 <a href="jls-8.html#jls-ReceiverParameter" title="ReceiverParameter">ReceiverParameter</a> {<code class="literal">,</code> <a href="jls-8.html#jls-FormalParameter" title="FormalParameter">FormalParameter</a>}
                               
                        </div>
                          
                     </div>
                  </div>
                    
                  <div class="productionrecap-note">
                     <div class="production">
                            
                        <div class="lhs">FormalParameter:</div>
                            
                        <div class="rhs">
                                 {<a href="jls-8.html#jls-VariableModifier" title="VariableModifier">VariableModifier</a>}
                                 <a href="jls-8.html#jls-UnannType" title="UnannType">UnannType</a>
                                 <a href="jls-8.html#jls-VariableDeclaratorId" title="VariableDeclaratorId">VariableDeclaratorId</a>
                               
                        </div>
                          
                     </div>
                  </div>
                    
                  <div class="productionrecap-note">
                     <div class="production">
                            
                        <div class="lhs">LastFormalParameter:</div>
                            
                        <div class="rhs">
                                 {<a href="jls-8.html#jls-VariableModifier" title="VariableModifier">VariableModifier</a>}
                                 <a href="jls-8.html#jls-UnannType" title="UnannType">UnannType</a> {<a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>} <code class="literal">...</code>
                                 <a href="jls-8.html#jls-VariableDeclaratorId" title="VariableDeclaratorId">VariableDeclaratorId</a> <br>
                           
                                 <a href="jls-8.html#jls-FormalParameter" title="FormalParameter">FormalParameter</a>
                               
                        </div>
                          
                     </div>
                  </div>
                    
                  <div class="productionrecap-note">
                     <div class="production">
                            
                        <div class="lhs">VariableModifier:</div>
                            
                        <div class="rhs">
                                 <a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a> <code class="literal">final</code>
                               
                        </div>
                          
                     </div>
                  </div>
                    
                  <div class="productionrecap-note">
                     <div class="production">
                            
                        <div class="lhs">VariableDeclaratorId:</div>
                            
                        <div class="rhs">
                                 <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a> [<a href="jls-4.html#jls-Dims" title="Dims">Dims</a>]
                               
                        </div>
                          
                     </div>
                  </div>
                    
                  <div class="productionrecap-note">
                     <div class="production">
                            
                        <div class="lhs">Dims:</div>
                            
                        <div class="rhs">
                                 {<a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>} <code class="literal">[</code> <code class="literal">]</code> {{<a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>} <code class="literal">[</code> <code class="literal">]</code>}
                               
                        </div>
                          
                     </div>
                  </div>
                  
               </div>
               <p class="note">Receiver parameters are not permitted in
                  the <span class="emphasis"><em>FormalParameters</em></span> of a lambda expression, as
                  specified in <a class="xref" href="jls-8.html#jls-8.4.1" title="8.4.1.&nbsp;Formal Parameters">&sect;8.4.1</a>.
               </p>
               <p class="norm-static"><a name="jls-15.27.1-120"></a>A lambda
                  expression whose formal parameters have declared types is said to
                  be <span class="emphasis"><em>explicitly typed</em></span>, while a lambda expression
                  whose formal parameters have inferred types is said to
                  be <span class="emphasis"><em>implicitly typed</em></span>. A lambda expression with
                  zero parameters is explicitly typed.
               </p>
               <p class="norm-static"><a name="jls-15.27.1-130"></a>If the
                  formal parameters have inferred types, then these types are derived
                  (<a class="xref" href="jls-15.html#jls-15.27.3" title="15.27.3.&nbsp;Type of a Lambda Expression">&sect;15.27.3</a>) from the functional interface type
                  targeted by the lambda expression.
               </p>
               <p class="norm-static"><a name="jls-15.27.1-200"></a>The
                  syntax for formal parameters with declared types is the same as the
                  syntax for the parameters of a method declaration
                  (<a class="xref" href="jls-8.html#jls-8.4.1" title="8.4.1.&nbsp;Formal Parameters">&sect;8.4.1</a>).
               </p>
               <p class="norm-static"><a name="jls-15.27.1-210"></a>The
                  declared type of a formal parameter is denoted by
                  the <span class="emphasis"><em>UnannType</em></span> that appears in its parameter
                  specifier, followed by any bracket pairs that follow the <span class="emphasis"><em>Identifier</em></span>
                  in the declarator, except for a variable arity parameter, whose
                  declared type is an array type whose component type is
                  the <span class="emphasis"><em>UnannType</em></span> that appears in its parameter
                  specifier.
               </p>
               <p class="note">No distinction is made between the following lambda
                  parameter lists:
               </p><pre class="screen">
(int... x) <code class="literal">-&gt;</code> ..
(int[] x) <code class="literal">-&gt;</code> ..
</pre><p class="note">Consistent with the rules for overriding, either can
                  be used, whether the functional interface's abstract method is fixed
                  arity or variable arity. Since lambda expressions are never directly
                  invoked, introducing <code class="literal">int...</code> where the functional
                  interface uses <code class="literal">int[]</code> can have no impact on the
                  surrounding program. In a lambda body, a variable arity parameter is
                  treated just like an array-typed parameter.
               </p>
               <p class="norm-error"><a name="jls-15.27.1-300"></a>The rules
                  for annotation modifiers on a formal parameter declaration are
                  specified in <a class="xref" href="jls-9.html#jls-9.7.4" title="9.7.4.&nbsp;Where Annotations May Appear">&sect;9.7.4</a> and
                  <a class="xref" href="jls-9.html#jls-9.7.5" title="9.7.5.&nbsp;Multiple Annotations Of The Same Type">&sect;9.7.5</a>.
               </p>
               <p class="norm-error"><a name="jls-15.27.1-310"></a>It is a
                  compile-time error if <code class="literal">final</code> appears more than once as a modifier for
                  a formal parameter declaration.
               </p>
               <p class="norm-error"><a name="jls-15.27.1-320"></a>It is a
                  compile-time error to use mixed array notation
                  (<a class="xref" href="jls-10.html#jls-10.2" title="10.2.&nbsp;Array Variables">&sect;10.2</a>) for a variable arity parameter.
               </p>
               <p class="norm-static"><a name="jls-15.27.1-330"></a>The
                  scope and shadowing of a formal parameter declaration is specified in
                  <a class="xref" href="jls-6.html#jls-6.3" title="6.3.&nbsp;Scope of a Declaration">&sect;6.3</a> and <a class="xref" href="jls-6.html#jls-6.4" title="6.4.&nbsp;Shadowing and Obscuring">&sect;6.4</a>.
               </p>
               <p class="norm-error"><a name="jls-15.27.1-340"></a>It is a
                  compile-time error for a lambda expression to declare two formal
                  parameters with the same name. (That is, their declarations mention
                  the same <span class="emphasis"><em>Identifier</em></span>.)
               </p>
               <p class="norm-error"><a name="jls-15.27.1-350"></a>It is a
                  compile-time error if a lambda parameter has the name <code class="literal">_</code>
                  (that is, a single underscore character).
               </p>
               <p class="note">The use of the variable name <code class="literal">_</code> in any
                  context is discouraged. Future versions of the Java programming language may reserve
                  this name as a keyword and/or give it special semantics.
               </p>
               <p class="norm-error"><a name="jls-15.27.1-360"></a>It is a
                  compile-time error if a receiver parameter
                  (<a class="xref" href="jls-8.html#jls-8.4.1" title="8.4.1.&nbsp;Formal Parameters">&sect;8.4.1</a>) appears in
                  the <span class="emphasis"><em>FormalParameters</em></span> of a lambda
                  expression.
               </p>
               <p class="norm-error"><a name="jls-15.27.1-370"></a>It is a
                  compile-time error if a formal parameter that is declared <code class="literal">final</code> is
                  assigned to within the body of the lambda expression.
               </p>
               <p class="norm-dynamic"><a name="jls-15.27.1-400"></a>When
                  the lambda expression is invoked (via a method invocation expression
                  (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>)), the values of the actual argument
                  expressions initialize newly created parameter variables, each of the
                  declared or inferred type, before execution of the lambda body. The
                  <span class="emphasis"><em>Identifier</em></span> that appears in
                  the <span class="emphasis"><em>VariableDeclaratorId</em></span> or
                  the <span class="emphasis"><em>InferredFormalParameterList</em></span> may be used as a
                  simple name in the lambda body to refer to the formal
                  parameter.
               </p>
               <p class="norm-dynamic"><a name="jls-15.27.1-410"></a>A
                  lambda parameter of type <code class="literal">float</code> always contains an element of the
                  float value set (<a class="xref" href="jls-4.html#jls-4.2.3" title="4.2.3.&nbsp;Floating-Point Types, Formats, and Values">&sect;4.2.3</a>); similarly, a lambda
                  parameter of type <code class="literal">double</code> always contains an element of the double
                  value set. It is not permitted for a lambda parameter of type <code class="literal">float</code>
                  to contain an element of the float-extended-exponent value set that is
                  not also an element of the float value set, nor for a lambda parameter
                  of type <code class="literal">double</code> to contain an element of the double-extended-exponent
                  value set that is not also an element of the double value set.
               </p>
               <p class="note">When the parameter types of a lambda expression are
                  inferred, the same lambda body can be interpreted in different ways,
                  depending on the context in which it appears. Specifically, the types
                  of expressions in the body, the checked exceptions thrown by the body,
                  and the type correctness of code in the body all depend on the
                  parameters' inferred types. This implies that inference of parameter
                  types must occur "before" attempting to type-check the body of the
                  lambda expression.
               </p>
            </div>
            <div class="section" title="15.27.2.&nbsp;Lambda Body">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.27.2"></a>15.27.2.&nbsp;Lambda Body
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.27.2-100"></a>A lambda
                  body is either a single expression or a block
                  (<a class="xref" href="jls-14.html#jls-14.2" title="14.2.&nbsp;Blocks">&sect;14.2</a>). Like a method body, a lambda body
                  describes code that will be executed whenever an invocation
                  occurs.
               </p>
               <div id="jls-15.27.2-110" class="productionset"><a name="jls-15.27.2-110"></a>
                    
                  <div class="production"><a name="jls-LambdaBody"></a>
                         
                     <div class="lhs">LambdaBody:</div>
                         
                     <div class="rhs">
                              <a href="jls-15.html#jls-Expression" title="Expression">Expression</a> <br>
                              <a href="jls-14.html#jls-Block" title="Block">Block</a>
                            
                     </div>
                       
                  </div>
                  
               </div>
               <p class="norm-static"><a name="jls-15.27.2-120"></a>Unlike
                  code appearing in anonymous class declarations, the meaning of names
                  and the <code class="literal">this</code> and <code class="literal">super</code> keywords appearing in a lambda body, along
                  with the accessibility of referenced declarations, are the same as in
                  the surrounding context (except that lambda parameters introduce new
                  names).
               </p>
               <p class="note">The transparency of <code class="literal">this</code> (both explicit and
                  implicit) in the body of a lambda expression - that is, treating it
                  the same as in the surrounding context - allows more flexibility for
                  implementations, and prevents the meaning of unqualified names in the
                  body from being dependent on overload resolution.
               </p>
               <p class="note">Practically speaking, it is unusual for a lambda
                  expression to need to talk about itself (either to call itself
                  recursively or to invoke its other methods), while it is more common
                  to want to use names to refer to things in the enclosing class that
                  would otherwise be shadowed (<code class="literal">this</code>, <code class="literal">toString()</code>).
                  If it is necessary for a lambda expression to refer to itself (as if
                  via <code class="literal">this</code>), a method reference or an anonymous inner class should be
                  used instead.
               </p>
               <p class="norm-static"><a name="jls-15.27.2-200"></a>A block
                  lambda body is <span class="emphasis"><em>void-compatible</em></span> if every return
                  statement in the block has the form <code class="literal">return</code><code class="literal">;</code>.
               </p>
               <p class="norm-static"><a name="jls-15.27.2-210"></a>A block
                  lambda body is <span class="emphasis"><em>value-compatible</em></span> if it cannot
                  complete normally (<a class="xref" href="jls-14.html#jls-14.21" title="14.21.&nbsp;Unreachable Statements">&sect;14.21</a>) and every return
                  statement in the block has the form <code class="literal">return</code>
                  <span class="emphasis"><em>Expression</em></span><code class="literal">;</code>.
               </p>
               <p class="norm-error"><a name="jls-15.27.2-220"></a>It is a
                  compile-time error if a block lambda body is neither void-compatible
                  nor value-compatible.
               </p>
               <p class="norm-static"><a name="jls-15.27.2-230"></a>In a
                  value-compatible block lambda body, the <span class="emphasis"><em>result
                        expressions</em></span> are any expressions that may produce an
                  invocation's value. Specifically, for each statement of the form
                  <code class="literal">return</code> <span class="emphasis"><em>Expression</em></span> <code class="literal">;</code> contained by the body, the <span class="emphasis"><em>Expression</em></span>
                  is a result expression.
               </p>
               <div class="informalexample">
                  <p class="note">The following lambda bodies are
                     void-compatible:
                  </p><pre class="screen">
() <code class="literal">-&gt;</code> {}
() <code class="literal">-&gt;</code> { System.out.println("done"); }
</pre><p class="note">These are value-compatible:</p><pre class="screen">
() <code class="literal">-&gt;</code> { return "done"; }
() <code class="literal">-&gt;</code> { if (...) return 1; else return 0; }
</pre><p class="note">These are both:</p><pre class="screen">
() <code class="literal">-&gt;</code> { throw new RuntimeException(); }
() <code class="literal">-&gt;</code> { while (true); }
</pre><p class="note">This is neither:</p><pre class="screen">
() <code class="literal">-&gt;</code> { if (...) return "done"; System.out.println("done"); }
</pre></div>
               <p class="note">The handling of void/value-compatible and the
                  meaning of names in the body jointly serve to minimize the dependency
                  on a particular target type in the given context, which is useful both
                  for implementations and for programmer comprehension. While
                  expressions can be assigned different types during overload resolution
                  depending on the target type, the meaning of unqualified names and the
                  basic structure of the lambda body do not change.
               </p>
               <p class="note">Note that the void/value-compatible definition is
                  not a strictly structural property: "can complete normally" depends on
                  the values of constant expressions, and these may include names that
                  reference constant variables.
               </p>
               <p class="norm-error"><a name="jls-15.27.2-300"></a>Any local
                  variable, formal parameter, or exception parameter used but not
                  declared in a lambda expression must either be declared <code class="literal">final</code> or be
                  effectively final (<a class="xref" href="jls-4.html#jls-4.12.4" title="4.12.4.&nbsp;final Variables">&sect;4.12.4</a>), or a compile-time
                  error occurs where the use is attempted.
               </p>
               <p class="norm-error"><a name="jls-15.27.2-310"></a>Any local
                  variable used but not declared in a lambda body must be definitely
                  assigned (<a class="xref" href="jls-16.html" title="Chapter&nbsp;16.&nbsp;Definite Assignment">&sect;16 (<i>Definite Assignment</i>)</a>) before the lambda body, or a
                  compile-time error occurs.
               </p>
               <p class="note">Similar rules on variable use apply in the body of
                  an inner class (<a class="xref" href="jls-8.html#jls-8.1.3" title="8.1.3.&nbsp;Inner Classes and Enclosing Instances">&sect;8.1.3</a>). The restriction to
                  effectively final variables prohibits access to dynamically-changing
                  local variables, whose capture would likely introduce concurrency
                  problems. Compared to the <code class="literal">final</code> restriction, it reduces the clerical
                  burden on programmers.
               </p>
               <p class="note">The restriction to effectively final variables
                  includes standard loop variables, but not enhanced-<code class="literal">for</code> loop
                  variables, which are treated as distinct for each iteration of the
                  loop (<a class="xref" href="jls-14.html#jls-14.14.2" title="14.14.2.&nbsp;The enhanced for statement">&sect;14.14.2</a>).
               </p>
               <div class="informalexample">
                  <p class="note">The following lambda bodies demonstrate use of
                     effectively final variables.
                  </p><pre class="programlisting">

void m1(int x) {
    int y = 1;
    foo(() -&gt; x+y);
    // Legal: x and y are both effectively final.
}

void m2(int x) {
    int y;
    y = 1;
    foo(() -&gt; x+y);
    // Legal: x and y are both effectively final.
}

void m3(int x) {
    int y;
    if (...) y = 1;
    foo(() -&gt; x+y);
    // Illegal: y is effectively final, but not definitely assigned.
}

void m4(int x) {
    int y;
    if (...) y = 1; else y = 2;
    foo(() -&gt;; x+y);
    // Legal: x and y are both effectively final.
}

</pre><pre class="programlisting">

void m5(int x) {
    int y;
    if (...) y = 1;
    y = 2;
    foo(() -&gt; x+y);
    // Illegal: y is not effectively final.
}

void m6(int x) {
    foo(() -&gt; x+1);
    x++;
    // Illegal: x is not effectively final.
}

void m7(int x) {
    foo(() -&gt; x=1);
    // Illegal: x is not effectively final.
}

void m8() {
    int y;
    foo(() -&gt; y=1);
    // Illegal: y is not definitely assigned before the lambda.
}

void m9(String[] arr) {
    for (String s : arr) {
        foo(() -&gt; s);
        // Legal: s is effectively final
        // (it is a new variable on each iteration)
    }
}

void m10(String[] arr) {
    for (int i = 0; i &lt; arr.length; i++) {
        foo(() -&gt; arr[i]);
        // Illegal: i is not effectively final
        // (it is not final, and is incremented)
    }
}

</pre></div>
            </div>
            <div class="section" title="15.27.3.&nbsp;Type of a Lambda Expression">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.27.3"></a>15.27.3.&nbsp;Type of a Lambda Expression
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-15.27.3-100"></a>A lambda
                  expression is compatible in an assignment context, invocation context,
                  or casting context with a target type <span class="type">T</span> if <span class="type">T</span> is a functional
                  interface type (<a class="xref" href="jls-9.html#jls-9.8" title="9.8.&nbsp;Functional Interfaces">&sect;9.8</a>) and the expression
                  is <span class="emphasis"><em>congruent</em></span> with the function type of
                  the <span class="emphasis"><em>ground target type</em></span> derived from <span class="type">T</span>.
               </p>
               <p class="norm-static"><a name="jls-15.27.3-200"></a>
                  The <span class="emphasis"><em>ground target type</em></span> is derived from <span class="type">T</span> as
                  follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.27.3-200-A"></a>
                                 If <span class="type">T</span> is a wildcard-parameterized functional interface type and
                                 the lambda expression is explicitly typed, then the ground
                                 target type is inferred as described in
                                 <a class="xref" href="jls-18.html#jls-18.5.3" title="18.5.3.&nbsp;Functional Interface Parameterization Inference">&sect;18.5.3</a>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.27.3-200-B"></a>
                                 If <span class="type">T</span> is a wildcard-parameterized functional interface type and
                                 the lambda expression is implicitly typed, then the ground
                                 target type is the non-wildcard parameterization
                                 (<a class="xref" href="jls-9.html#jls-9.9" title="9.9.&nbsp;Function Types">&sect;9.9</a>) of <span class="type">T</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.27.3-200-C"></a>
                                 Otherwise, the ground target type is <span class="type">T</span>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-15.27.3-300"></a>A lambda
                  expression is <span class="emphasis"><em>congruent</em></span> with a function type if
                  all of the following are true:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.27.3-300-A"></a>
                                 The function type has no type parameters.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.27.3-300-B"></a>
                                 The number of lambda parameters is the same as the number of
                                 parameter types of the function type.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.27.3-300-C"></a>
                                 If the lambda expression is explicitly typed, its formal
                                 parameter types are the same as the parameter types of the
                                 function type.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-15.27.3-300-D"></a>
                                 If the lambda parameters are assumed to have the same types as
                                 the function type's parameter types, then:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.27.3-300-D-A"></a>
                                    	  If the function type's result is <code class="literal">void</code>, the lambda body is
                                              either a statement expression or a <code class="literal">void</code>-compatible
                                              block.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-15.27.3-300-D-B"></a>
                                    	  If the function type's result is a (non-<code class="literal">void</code>) type <span class="type">R</span>,
                                              then either i) the lambda body is an expression that is
                                              compatible with <span class="type">R</span> in an assignment context, or ii) the
                                              lambda body is a value-compatible block, and each result
                                              expression (<a class="xref" href="jls-15.html#jls-15.27.2" title="15.27.2.&nbsp;Lambda Body">&sect;15.27.2</a>) is compatible
                                              with <span class="type">R</span> in an assignment context.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-15.27.3-400"></a>If a
                  lambda expression is compatible with a target type <span class="type">T</span>, then the type
                  of the expression, <span class="type">U</span>, is the ground target type derived from
                  <span class="type">T</span>.
               </p>
               <p class="norm-error"><a name="jls-15.27.3-410"></a>It is a
                  compile-time error if any class or interface mentioned by either <span class="type">U</span>
                  or the function type of <span class="type">U</span> is not accessible from the class or
                  interface in which the lambda expression appears.
               </p>
               <p class="norm-error"><a name="jls-15.27.3-420"></a>
                  For each non-<code class="literal">static</code> member method <code class="varname">m</code> of <span class="type">U</span>, if the function type
                  of <span class="type">U</span> has a subsignature of the signature of <code class="varname">m</code>, then a notional
                  method whose method type is the function type of <span class="type">U</span> is deemed to
                  override <code class="varname">m</code>, and any compile-time error or unchecked warning
                  specified in <a class="xref" href="jls-8.html#jls-8.4.8.3" title="8.4.8.3.&nbsp;Requirements in Overriding and Hiding">&sect;8.4.8.3</a> may occur.
               </p>
               <p class="norm-error"><a name="jls-15.27.3-430"></a>A checked
                  exception that can be thrown in the body of the lambda expression may
                  cause a compile-time error, as specified in
                  <a class="xref" href="jls-11.html#jls-11.2.3" title="11.2.3.&nbsp;Exception Checking">&sect;11.2.3</a>.
               </p>
               <p class="note">The parameter types of explicitly typed lambdas are
                  required to exactly match those of the function type.  While it would
                  be possible to be more flexible - allow boxing or contravariance, for
                  example - this kind of generality seems unnecessary, and is
                  inconsistent with the way overriding works in class declarations.  A
                  programmer ought to know exactly what function type is being targeted
                  when writing a lambda expression, so he should thus know exactly what
                  signature must be overridden.  (In contrast, this is not the case for
                  method references, and so more flexibility is allowed when they are
                  used.)  In addition, more flexibility with parameter types would add
                  to the complexity of type inference and overload resolution.
               </p>
               <p class="note">Note that while boxing is not allowed in a strict
                  invocation context, boxing of lambda result expressions
                  is <span class="emphasis"><em>always</em></span> allowed - that is, the result
                  expression appears in an assignment context, regardless of the context
                  enclosing the lambda expression. However, if an explicitly typed
                  lambda expression is an argument to an overloaded method, a method
                  signature that avoids boxing or unboxing the lambda result is
                  preferred by the most specific check
                  (<a class="xref" href="jls-15.html#jls-15.12.2.5" title="15.12.2.5.&nbsp;Choosing the Most Specific Method">&sect;15.12.2.5</a>).
               </p>
               <p class="note">If the body of a lambda is a statement expression
                  (that is, an expression that would be allowed to stand alone as a
                  statement), it is compatible with a <code class="literal">void</code>-producing function type;
                  any result is simply discarded. So, for example, both of the following
                  are legal:
               </p><pre class="screen">
// Predicate has a <code class="literal">boolean</code> result
java.util.function.Predicate&lt;String&gt; p = s <code class="literal">-&gt;</code> list.add(s);
// Consumer has a <code class="literal">void</code> result
java.util.function.Consumer&lt;String&gt; c = s <code class="literal">-&gt;</code> list.add(s);
</pre><p class="note">Generally speaking, a lambda of the form
                  <code class="literal">(</code><code class="literal">)</code> <code class="literal">-&gt;</code> <span class="emphasis"><em>expr</em></span>,
                  where <span class="emphasis"><em>expr</em></span> is a statement expression, is
                  interpreted as either <code class="literal">(</code><code class="literal">)</code> <code class="literal">-&gt;</code> <code class="literal">{</code>
                  <code class="literal">return</code> <span class="emphasis"><em>expr</em></span><code class="literal">;</code> <code class="literal">}</code> or <code class="literal">(</code><code class="literal">)</code>
                  <code class="literal">-&gt;</code> <code class="literal">{</code> <span class="emphasis"><em>expr</em></span><code class="literal">;</code> <code class="literal">}</code>, depending
                  on the target type.
               </p>
            </div>
            <div class="section" title="15.27.4.&nbsp;Run-time Evaluation of Lambda Expressions">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-15.27.4"></a>15.27.4.&nbsp;Run-time Evaluation of Lambda Expressions
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-dynamic"><a name="jls-15.27.4-100"></a>At run
                  time, evaluation of a lambda expression is similar to evaluation of a
                  class instance creation expression, insofar as normal completion
                  produces a reference to an object. Evaluation of a lambda expression
                  is distinct from execution of the lambda body.
               </p>
               <p class="norm-dynamic"><a name="jls-15.27.4-200"></a>Either
                  a new instance of a class with the properties below is allocated and
                  initialized, or an existing instance of a class with the properties
                  below is referenced. If a new instance is to be created, but there is
                  insufficient space to allocate the object, evaluation of the lambda
                  expression completes abruptly by throwing an <code class="literal">OutOfMemoryError</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-15.27.4-300"></a>The
                  value of a lambda expression is a reference to an instance of a class
                  with the following properties:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.27.4-300-A"></a>
                                 The class implements the targeted functional interface type and,
                                 if the target type is an intersection type, every other
                                 interface type mentioned in the intersection.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.27.4-300-B"></a>
                                 Where the lambda expression has type <span class="type">U</span>, for each non-<code class="literal">static</code>
                                 member method <code class="varname">m</code> of <span class="type">U</span>:
                        </p>
                        <p class="norm-dynamic"><a name="jls-15.27.4-300-B.1"></a>
                                 If the function type of <span class="type">U</span> has a subsignature of the signature
                                 of <code class="varname">m</code>, then the class declares a method that overrides <code class="varname">m</code>. The
                                 method's body has the effect of evaluating the lambda body, if
                                 it is an expression, or of executing the lambda body, if it is a
                                 block; if a result is expected, it is returned from the
                                 method.
                        </p>
                        <p class="norm-dynamic"><a name="jls-15.27.4-300-B.2"></a>
                                 If the erasure of the type of a method being overridden differs
                                 in its signature from the erasure of the function type of <span class="type">U</span>,
                                 then before evaluating or executing the lambda body, the
                                 method's body checks that each argument value is an instance of
                                 a subclass or subinterface of the erasure of the corresponding
                                 parameter type in the function type of <span class="type">U</span>; if not, a <code class="literal">ClassCastException</code> is
                                 thrown.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-15.27.4-300-C"></a>
                                 The class overrides no other methods of the targeted functional
                                 interface type or other interface types mentioned above,
                                 although it may override methods of the <code class="literal">Object</code> class.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="note">These rules are meant to offer flexibility to
                  implementations of the Java programming language, in that:
               </p>
               <div class="note">
                  <ul class="note" type="disc">
                     <li class="listitem">
                        <p class="note">A new object need not be allocated on every
                                 evaluation.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="note">Objects produced by different lambda expressions
                                 need not belong to different classes (if the bodies are
                                 identical, for example).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="note">Every object produced by evaluation need not
                                 belong to the same class (captured local variables might be
                                 inlined, for example).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="note">If an "existing instance" is available, it need
                                 not have been created at a previous lambda evaluation (it might
                                 have been allocated during the enclosing class's initialization,
                                 for example).
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="note">If the targeted functional interface type is a
                  subtype of <code class="literal">java.io.Serializable</code>, the resulting object will automatically be
                  an instance of a serializable class. Making an object derived from a
                  lambda expression serializable can have extra run time overhead and
                  security implications, so lambda-derived objects are not required to
                  be serializable "by default".
               </p>
            </div>
         </div>
         <div class="section" title="15.28.&nbsp;Constant Expressions">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-15.28"></a>15.28.&nbsp;Constant Expressions
                     </h2>
                  </div>
               </div>
            </div>
            <div id="jls-15.28-100" class="productionset"><a name="jls-15.28-100"></a>
                 
               <div class="production"><a name="jls-ConstantExpression"></a>
                      
                  <div class="lhs">ConstantExpression:</div>
                      
                  <div class="rhs">
                           <a href="jls-15.html#jls-Expression" title="Expression">Expression</a>
                         
                  </div>
                    
               </div>
               
            </div>
            <p class="norm-static"><a name="jls-15.28-110"></a>A 
               <span class="emphasis"><em>constant expression</em></span> is an expression denoting a
               value of primitive type or a <code class="literal">String</code> that does not complete abruptly
               and is composed using only the following:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.28-110-A"></a>
                              Literals of primitive type and literals of type <code class="literal">String</code>
                              (<a class="xref" href="jls-3.html#jls-3.10.1" title="3.10.1.&nbsp;Integer Literals">&sect;3.10.1</a>, <a class="xref" href="jls-3.html#jls-3.10.2" title="3.10.2.&nbsp;Floating-Point Literals">&sect;3.10.2</a>,
                              <a class="xref" href="jls-3.html#jls-3.10.3" title="3.10.3.&nbsp;Boolean Literals">&sect;3.10.3</a>, <a class="xref" href="jls-3.html#jls-3.10.4" title="3.10.4.&nbsp;Character Literals">&sect;3.10.4</a>,
                              <a class="xref" href="jls-3.html#jls-3.10.5" title="3.10.5.&nbsp;String Literals">&sect;3.10.5</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.28-110-B"></a>
                              Casts to primitive types and casts to type <code class="literal">String</code>
                              (<a class="xref" href="jls-15.html#jls-15.16" title="15.16.&nbsp;Cast Expressions">&sect;15.16</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.28-110-C"></a>
                              The unary operators <code class="literal">+</code>, <code class="literal">-</code>, <code class="literal">~</code>, and <code class="literal">!</code> (but
                              not <code class="literal">++</code> or <code class="literal">--</code>) (<a class="xref" href="jls-15.html#jls-15.15.3" title="15.15.3.&nbsp;Unary Plus Operator +">&sect;15.15.3</a>,
                              <a class="xref" href="jls-15.html#jls-15.15.4" title="15.15.4.&nbsp;Unary Minus Operator -">&sect;15.15.4</a>, <a class="xref" href="jls-15.html#jls-15.15.5" title="15.15.5.&nbsp;Bitwise Complement Operator ~">&sect;15.15.5</a>,
                              <a class="xref" href="jls-15.html#jls-15.15.6" title="15.15.6.&nbsp;Logical Complement Operator !">&sect;15.15.6</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.28-110-D"></a>
                              The multiplicative operators <code class="literal">*</code>, <code class="literal">/</code>, and
                              <code class="literal">%</code> (<a class="xref" href="jls-15.html#jls-15.17" title="15.17.&nbsp;Multiplicative Operators">&sect;15.17</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.28-110-E"></a>
                              The additive operators <code class="literal">+</code> and <code class="literal">-</code>
                              (<a class="xref" href="jls-15.html#jls-15.18" title="15.18.&nbsp;Additive Operators">&sect;15.18</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.28-110-F"></a>
                              The shift operators <code class="literal">&lt;&lt;</code>, <code class="literal">&gt;&gt;</code>, and <code class="literal">&gt;&gt;&gt;</code>
                              (<a class="xref" href="jls-15.html#jls-15.19" title="15.19.&nbsp;Shift Operators">&sect;15.19</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.28-110-G"></a>
                              The relational operators <code class="literal">&lt;</code>, <code class="literal">&lt;=</code>,
                              <code class="literal">&gt;</code>, and <code class="literal">&gt;=</code> (but not
                              <code class="literal">instanceof</code>) (<a class="xref" href="jls-15.html#jls-15.20" title="15.20.&nbsp;Relational Operators">&sect;15.20</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.28-110-H"></a>
                              The equality operators <code class="literal">==</code> and <code class="literal">!=</code>
                              (<a class="xref" href="jls-15.html#jls-15.21" title="15.21.&nbsp;Equality Operators">&sect;15.21</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.28-110-I"></a>
                              The bitwise and logical operators <code class="literal">&amp;</code>, <code class="literal">^</code>, and <code class="literal">|</code>
                              (<a class="xref" href="jls-15.html#jls-15.22" title="15.22.&nbsp;Bitwise and Logical Operators">&sect;15.22</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.28-110-J"></a>
                              The conditional-and operator <code class="literal">&amp;&amp;</code> and the conditional-or
                              operator <code class="literal">||</code> (<a class="xref" href="jls-15.html#jls-15.23" title="15.23.&nbsp;Conditional-And Operator &amp;&amp;">&sect;15.23</a>,
                              <a class="xref" href="jls-15.html#jls-15.24" title="15.24.&nbsp;Conditional-Or Operator ||">&sect;15.24</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.28-110-K"></a>
                              The ternary conditional operator <code class="literal">? :</code>
                              (<a class="xref" href="jls-15.html#jls-15.25" title="15.25.&nbsp;Conditional Operator ? :">&sect;15.25</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.28-110-L"></a>
                              Parenthesized expressions (<a class="xref" href="jls-15.html#jls-15.8.5" title="15.8.5.&nbsp;Parenthesized Expressions">&sect;15.8.5</a>) whose
                              contained expression is a constant expression.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.28-110-M"></a>
                              Simple names (<a class="xref" href="jls-6.html#jls-6.5.6.1" title="6.5.6.1.&nbsp;Simple Expression Names">&sect;6.5.6.1</a>) that refer to
                              constant variables (<a class="xref" href="jls-4.html#jls-4.12.4" title="4.12.4.&nbsp;final Variables">&sect;4.12.4</a>).
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-15.28-110-N"></a>
                              Qualified names (<a class="xref" href="jls-6.html#jls-6.5.6.2" title="6.5.6.2.&nbsp;Qualified Expression Names">&sect;6.5.6.2</a>) of the form
                              <span class="emphasis"><em>TypeName</em></span> <code class="literal">.</code> <span class="emphasis"><em>Identifier</em></span> that refer to constant variables
                              (<a class="xref" href="jls-4.html#jls-4.12.4" title="4.12.4.&nbsp;final Variables">&sect;4.12.4</a>).
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm-dynamic"><a name="jls-15.28-200"></a>Constant
               expressions of type <code class="literal">String</code> are always "interned" so as to share
               unique instances, using the method <code class="literal">String.intern</code>.
            </p>
            <p class="norm-dynamic"><a name="jls-15.28-210"></a>A
               constant expression is always treated as FP-strict
               (<a class="xref" href="jls-15.html#jls-15.4" title="15.4.&nbsp;FP-strict Expressions">&sect;15.4</a>), even if it occurs in a context where a
               non-constant expression would not be considered to be
               FP-strict.
            </p>
            <p class="note">Constant expressions are used as <code class="literal">case</code> labels
               in <code class="literal">switch</code> statements (<a class="xref" href="jls-14.html#jls-14.11" title="14.11.&nbsp;The switch Statement">&sect;14.11</a>) and have a
               special significance for assignment conversion
               (<a class="xref" href="jls-5.html#jls-5.2" title="5.2.&nbsp;Assignment Contexts">&sect;5.2</a>) and initialization of a class or interface
               (<a class="xref" href="jls-12.html#jls-12.4.2" title="12.4.2.&nbsp;Detailed Initialization Procedure">&sect;12.4.2</a>). They may also govern the ability of a
               <code class="literal">while</code>, <code class="literal">do</code>, or <code class="literal">for</code> statement to complete normally
               (<a class="xref" href="jls-14.html#jls-14.21" title="14.21.&nbsp;Unreachable Statements">&sect;14.21</a>), and the type of a conditional operator
               <code class="literal">? :</code> with numeric operands.
            </p>
            <div class="example"><a name="d5e30735"></a><p class="title"><b>Example&nbsp;15.28-1.&nbsp;Constant Expressions</b></p>
               <div class="example-contents"><pre class="screen">
true
(short)(1*2*3*4*5*6)
Integer.MAX_VALUE / 2
2.0 * Math.PI
"The integer " + Long.MAX_VALUE + " is mighty big."
</pre></div>
            </div><br class="example-break"></div>
      </div>
      <div class="navfooter">
         <hr>
         <table width="100%" summary="Navigation footer">
            <tr>
               <td width="40%" align="left"><a accesskey="p" href="jls-14.html">Prev</a>&nbsp;
               </td>
               <td width="20%" align="center">&nbsp;</td>
               <td width="40%" align="right">&nbsp;<a accesskey="n" href="jls-16.html">Next</a></td>
            </tr>
            <tr>
               <td width="40%" align="left" valign="top">Chapter&nbsp;14.&nbsp;Blocks and Statements&nbsp;</td>
               <td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
               <td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;16.&nbsp;Definite Assignment</td>
            </tr>
         </table>
      </div>
      <div xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:rx="http://www.renderx.com/XSL/Extensions" class="navfooter">
         <hr><a href="jls-0-front.html">
                Legal Notice
              </a></div>
   </body>
</html>