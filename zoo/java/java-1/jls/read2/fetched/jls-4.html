
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   
      <title>Chapter&nbsp;4.&nbsp;Types, Values, and Variables</title>
      <link rel="stylesheet" type="text/css" href="../../../javaspec.css">
      <meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1">
      <link rel="home" href="index.html" title="The Java&reg; Language Specification">
      <link rel="up" href="index.html" title="The Java&reg; Language Specification">
      <link rel="prev" href="jls-3.html" title="Chapter&nbsp;3.&nbsp;Lexical Structure">
      <link rel="next" href="jls-5.html" title="Chapter&nbsp;5.&nbsp;Conversions and Contexts">
      <link rel="copyright" href="jls-0-front.html" title="Legal Notice">
   </head>
   <body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
      <div xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:rx="http://www.renderx.com/XSL/Extensions" id="logo"><img src="http://www.oracleimg.com/us/assets/oralogo-small.gif" alt="Oracle Logo"><br><p><a target="_blank" href="http://www.oracle.com/us/technologies/java/">Oracle
                   Technology Network</a> &gt; <a target="_blank" href="http://docs.oracle.com/javase/">Java SE</a>
                &gt; <a href="index.html">Java Language Specification</a></p>
      </div>
      <div class="navheader">
         <table width="100%" summary="Navigation header">
            <tr>
               <th colspan="3" align="center">Chapter&nbsp;4.&nbsp;Types, Values, and Variables</th>
            </tr>
            <tr>
               <td width="20%" align="left"><a accesskey="p" href="jls-3.html">Prev</a>&nbsp;
               </td>
               <th width="60%" align="center">&nbsp;</th>
               <td width="20%" align="right">&nbsp;<a accesskey="n" href="jls-5.html">Next</a></td>
            </tr>
         </table>
         <hr>
      </div>
      <div lang="en" class="chapter" title="Chapter&nbsp;4.&nbsp;Types, Values, and Variables">
         <div class="titlepage">
            <div>
               <div>
                  <h2 class="title"><a name="jls-4"></a>Chapter&nbsp;4.&nbsp;Types, Values, and Variables
                  </h2>
               </div>
            </div>
         </div>
         <div class="toc">
            <p><b>Table of Contents</b></p>
            <dl>
               <dt><span class="section"><a href="jls-4.html#jls-4.1">4.1. The Kinds of Types and Values</a></span></dt>
               <dt><span class="section"><a href="jls-4.html#jls-4.2">4.2. Primitive Types and Values</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-4.html#jls-4.2.1">4.2.1. Integral Types and Values</a></span></dt>
                     <dt><span class="section"><a href="jls-4.html#jls-4.2.2">4.2.2. Integer Operations</a></span></dt>
                     <dt><span class="section"><a href="jls-4.html#jls-4.2.3">4.2.3. Floating-Point Types, Formats, and Values</a></span></dt>
                     <dt><span class="section"><a href="jls-4.html#jls-4.2.4">4.2.4. Floating-Point Operations</a></span></dt>
                     <dt><span class="section"><a href="jls-4.html#jls-4.2.5">4.2.5. The <code class="literal">boolean</code> Type and boolean Values</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-4.html#jls-4.3">4.3. Reference Types and Values</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-4.html#jls-4.3.1">4.3.1. Objects</a></span></dt>
                     <dt><span class="section"><a href="jls-4.html#jls-4.3.2">4.3.2. The Class <code class="literal">Object</code></a></span></dt>
                     <dt><span class="section"><a href="jls-4.html#jls-4.3.3">4.3.3. The Class <code class="literal">String</code></a></span></dt>
                     <dt><span class="section"><a href="jls-4.html#jls-4.3.4">4.3.4. When Reference Types Are the Same</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-4.html#jls-4.4">4.4. Type Variables</a></span></dt>
               <dt><span class="section"><a href="jls-4.html#jls-4.5">4.5. Parameterized Types</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-4.html#jls-4.5.1">4.5.1. Type Arguments of Parameterized Types</a></span></dt>
                     <dt><span class="section"><a href="jls-4.html#jls-4.5.2">4.5.2. Members and Constructors of Parameterized Types</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-4.html#jls-4.6">4.6. Type Erasure</a></span></dt>
               <dt><span class="section"><a href="jls-4.html#jls-4.7">4.7. Reifiable Types</a></span></dt>
               <dt><span class="section"><a href="jls-4.html#jls-4.8">4.8. Raw Types</a></span></dt>
               <dt><span class="section"><a href="jls-4.html#jls-4.9">4.9. Intersection Types</a></span></dt>
               <dt><span class="section"><a href="jls-4.html#jls-4.10">4.10. Subtyping</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-4.html#jls-4.10.1">4.10.1. Subtyping among Primitive Types</a></span></dt>
                     <dt><span class="section"><a href="jls-4.html#jls-4.10.2">4.10.2. Subtyping among Class and Interface Types</a></span></dt>
                     <dt><span class="section"><a href="jls-4.html#jls-4.10.3">4.10.3. Subtyping among Array Types</a></span></dt>
                     <dt><span class="section"><a href="jls-4.html#jls-4.10.4">4.10.4. Least Upper Bound</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-4.html#jls-4.11">4.11. Where Types Are Used</a></span></dt>
               <dt><span class="section"><a href="jls-4.html#jls-4.12">4.12. Variables</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-4.html#jls-4.12.1">4.12.1. Variables of Primitive Type</a></span></dt>
                     <dt><span class="section"><a href="jls-4.html#jls-4.12.2">4.12.2. Variables of Reference Type</a></span></dt>
                     <dt><span class="section"><a href="jls-4.html#jls-4.12.3">4.12.3. Kinds of Variables</a></span></dt>
                     <dt><span class="section"><a href="jls-4.html#jls-4.12.4">4.12.4. <code class="literal">final</code> Variables</a></span></dt>
                     <dt><span class="section"><a href="jls-4.html#jls-4.12.5">4.12.5. Initial Values of Variables</a></span></dt>
                     <dt><span class="section"><a href="jls-4.html#jls-4.12.6">4.12.6. Types, Classes, and Interfaces</a></span></dt>
                  </dl>
               </dd>
            </dl>
         </div>
         <p class="norm"><a name="jls-4-100"></a>The Java programming language is
            a <span class="emphasis"><em>statically typed</em></span> language, which means that
            every variable and every expression has a type that is known at
            compile time.
         </p>
         <p class="norm"><a name="jls-4-110"></a>The Java programming language is also
            a <span class="emphasis"><em>strongly typed</em></span> language, because types limit
            the values that a variable (<a class="xref" href="jls-4.html#jls-4.12" title="4.12.&nbsp;Variables">&sect;4.12</a>) can hold or
            that an expression can produce, limit the operations supported on
            those values, and determine the meaning of the operations. Strong
            static typing helps detect errors at compile time.
         </p>
         <p class="norm"><a name="jls-4-120"></a>The types of the Java programming language are
            divided into two categories: primitive types and reference types. The
            primitive types (<a class="xref" href="jls-4.html#jls-4.2" title="4.2.&nbsp;Primitive Types and Values">&sect;4.2</a>) are the <code class="literal">boolean</code> type and
            the numeric types. The numeric types are the integral types <code class="literal">byte</code>,
            <code class="literal">short</code>, <code class="literal">int</code>, <code class="literal">long</code>, and <code class="literal">char</code>, and the floating-point types
            <code class="literal">float</code> and <code class="literal">double</code>. The reference types (<a class="xref" href="jls-4.html#jls-4.3" title="4.3.&nbsp;Reference Types and Values">&sect;4.3</a>)
            are class types, interface types, and array types. There is also a
            special null type. An object (<a class="xref" href="jls-4.html#jls-4.3.1" title="4.3.1.&nbsp;Objects">&sect;4.3.1</a>) is a
            dynamically created instance of a class type or a dynamically created
            array. The values of a reference type are references to objects. All
            objects, including arrays, support the methods of class <code class="literal">Object</code>
            (<a class="xref" href="jls-4.html#jls-4.3.2" title="4.3.2.&nbsp;The Class Object">&sect;4.3.2</a>). String literals are represented by
            <code class="literal">String</code> objects (<a class="xref" href="jls-4.html#jls-4.3.3" title="4.3.3.&nbsp;The Class String">&sect;4.3.3</a>).
         </p>
         <div class="section" title="4.1.&nbsp;The Kinds of Types and Values">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-4.1"></a>4.1.&nbsp;The Kinds of Types and Values
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-4.1-100"></a>There are
               two kinds of types in the Java programming language: primitive types
               (<a class="xref" href="jls-4.html#jls-4.2" title="4.2.&nbsp;Primitive Types and Values">&sect;4.2</a>) and reference types
               (<a class="xref" href="jls-4.html#jls-4.3" title="4.3.&nbsp;Reference Types and Values">&sect;4.3</a>). There are, correspondingly, two kinds of
               data values that can be stored in variables, passed as arguments,
               returned by methods, and operated on: primitive values
               (<a class="xref" href="jls-4.html#jls-4.2" title="4.2.&nbsp;Primitive Types and Values">&sect;4.2</a>) and reference values
               (<a class="xref" href="jls-4.html#jls-4.3" title="4.3.&nbsp;Reference Types and Values">&sect;4.3</a>).
            </p>
            <div id="jls-4.1-110" class="productionset"><a name="jls-4.1-110"></a>
                 
               <div class="production"><a name="jls-Type"></a>
                      
                  <div class="lhs">Type:</div>
                      
                  <div class="rhs">
                           <a href="jls-4.html#jls-PrimitiveType" title="PrimitiveType">PrimitiveType</a> <br>
                           <a href="jls-4.html#jls-ReferenceType" title="ReferenceType">ReferenceType</a>
                         
                  </div>
                    
               </div>
               
            </div>
            <p class="norm-static"><a name="jls-4.1-200"></a>There is
               also a special <span class="emphasis"><em>null type</em></span>, the type of the
               expression <code class="literal">null</code> (<a class="xref" href="jls-3.html#jls-3.10.7" title="3.10.7.&nbsp;The Null Literal">&sect;3.10.7</a>,
               <a class="xref" href="jls-15.html#jls-15.8.1" title="15.8.1.&nbsp;Lexical Literals">&sect;15.8.1</a>), which has no name.
            </p>
            <p class="norm-static"><a name="jls-4.1-210"></a>Because the
               null type has no name, it is impossible to declare a variable of the
               null type or to cast to the null type.
            </p>
            <p class="norm-dynamic"><a name="jls-4.1-220"></a>The null
               reference is the only possible value of an expression of null
               type.
            </p>
            <p class="norm-dynamic"><a name="jls-4.1-230"></a>The null
               reference can always be assigned or cast to any reference type
               (<a class="xref" href="jls-5.html#jls-5.2" title="5.2.&nbsp;Assignment Contexts">&sect;5.2</a>, <a class="xref" href="jls-5.html#jls-5.3" title="5.3.&nbsp;Invocation Contexts">&sect;5.3</a>,
               <a class="xref" href="jls-5.html#jls-5.5" title="5.5.&nbsp;Casting Contexts">&sect;5.5</a>).
            </p>
            <p class="note">In practice, the programmer can ignore the null type
               and just pretend that <code class="literal">null</code> is merely a special literal that can be
               of any reference type.
            </p>
         </div>
         <div class="section" title="4.2.&nbsp;Primitive Types and Values">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-4.2"></a>4.2.&nbsp;Primitive Types and Values
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-4.2-100"></a>A primitive
               type is predefined by the Java programming language and named by its reserved keyword
               (<a class="xref" href="jls-3.html#jls-3.9" title="3.9.&nbsp;Keywords">&sect;3.9</a>):
            </p>
            <div id="jls-4.2-110" class="productionset"><a name="jls-4.2-110"></a>
                 
               <div class="production"><a name="jls-PrimitiveType"></a>
                      
                  <div class="lhs">PrimitiveType:</div>
                      
                  <div class="rhs">
                           {<a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>} <a href="jls-4.html#jls-NumericType" title="NumericType">NumericType</a> <br>
                           {<a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>} <code class="literal">boolean</code>
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-NumericType"></a>
                      
                  <div class="lhs">NumericType:</div>
                      
                  <div class="rhs">
                           <a href="jls-4.html#jls-IntegralType" title="IntegralType">IntegralType</a> <br>
                           <a href="jls-4.html#jls-FloatingPointType" title="FloatingPointType">FloatingPointType</a>
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-IntegralType"></a>
                      
                  <div class="lhs">IntegralType:</div>
                      
                  <div class="rhs">
                           <code class="literal">byte</code> <code class="literal">short</code> <code class="literal">int</code> <code class="literal">long</code> <code class="literal">char</code>
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-FloatingPointType"></a>
                      
                  <div class="lhs">FloatingPointType:</div>
                      
                  <div class="rhs">
                           <code class="literal">float</code> <code class="literal">double</code>
                         
                  </div>
                    
               </div>
               
            </div>
            <p class="norm-dynamic"><a name="jls-4.2-120"></a>Primitive
               values do not share state with other primitive values.
            </p>
            <p class="norm-static"><a name="jls-4.2-200"></a>The <span class="emphasis"><em>numeric types</em></span> are the
               integral types and the floating-point types.
            </p>
            <p class="norm-static"><a name="jls-4.2-210"></a>The <span class="emphasis"><em>integral types</em></span> are
               <code class="literal">byte</code>, <code class="literal">short</code>, <code class="literal">int</code>, and <code class="literal">long</code>, whose values are 8-bit, 16-bit,
               32-bit and 64-bit signed two's-complement integers, respectively, and
               <code class="literal">char</code>, whose values are 16-bit unsigned integers representing UTF-16
               code units (<a class="xref" href="jls-3.html#jls-3.1" title="3.1.&nbsp;Unicode">&sect;3.1</a>).
            </p>
            <p class="norm-static"><a name="jls-4.2-220"></a>The <span class="emphasis"><em>floating-point types</em></span> are
               <code class="literal">float</code>, whose values include the 32-bit IEEE 754 floating-point
               numbers, and <code class="literal">double</code>, whose values include the 64-bit IEEE 754
               floating-point numbers.
            </p>
            <p class="norm-dynamic"><a name="jls-4.2-300"></a>The
               <code class="literal">boolean</code> type has exactly two values: <code class="literal">true</code> and <code class="literal">false</code>.
            </p>
            <div class="section" title="4.2.1.&nbsp;Integral Types and Values">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.2.1"></a>4.2.1.&nbsp;Integral Types and Values
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-dynamic"><a name="jls-4.2.1-100"></a>The
                  values of the integral types are integers in the following
                  ranges:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-4.2.1-100-A"></a>For
                                <code class="literal">byte</code>, from -128 to 127, inclusive
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-4.2.1-100-B"></a>For
                                <code class="literal">short</code>, from -32768 to 32767, inclusive
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-4.2.1-100-C"></a>For
                                <code class="literal">int</code>, from -2147483648 to 2147483647, inclusive
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-4.2.1-100-D"></a>For
                                <code class="literal">long</code>, from -9223372036854775808 to 9223372036854775807,
                                inclusive
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-4.2.1-100-E"></a>For
                                <code class="literal">char</code>, from <code class="literal">'\u0000'</code>
                                to <code class="literal">'\uffff'</code> inclusive, that is, from 0 to
                                65535
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="4.2.2.&nbsp;Integer Operations">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.2.2"></a>4.2.2.&nbsp;Integer Operations
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-4.2.2-100"></a>The Java programming language provides a
                  number of operators that act on integral values:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.2-100-A"></a>The comparison
                               operators, which result in a value of type <code class="literal">boolean</code>:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm"><a name="jls-4.2.2-100-A-A"></a>The numerical
                                    	comparison operators <code class="literal">&lt;</code>, <code class="literal">&lt;=</code>,
                                    	<code class="literal">&gt;</code>, and <code class="literal">&gt;=</code>
                                    	(<a class="xref" href="jls-15.html#jls-15.20.1" title="15.20.1.&nbsp;Numerical Comparison Operators <, <=, &gt;, and &gt;=">&sect;15.20.1</a>)
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-4.2.2-100-A-B"></a>The numerical
                                    	equality operators <code class="literal">==</code> and <code class="literal">!=</code>
                                    	(<a class="xref" href="jls-15.html#jls-15.21.1" title="15.21.1.&nbsp;Numerical Equality Operators == and !=">&sect;15.21.1</a>)
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.2-100-B"></a>The numerical
                               operators, which result in a value of type <code class="literal">int</code> or <code class="literal">long</code>:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm"><a name="jls-4.2.2-100-B-A"></a>The unary plus
                                    	and minus operators <code class="literal">+</code> and <code class="literal">-</code>
                                    	(<a class="xref" href="jls-15.html#jls-15.15.3" title="15.15.3.&nbsp;Unary Plus Operator +">&sect;15.15.3</a>,
                                    	<a class="xref" href="jls-15.html#jls-15.15.4" title="15.15.4.&nbsp;Unary Minus Operator -">&sect;15.15.4</a>)
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-4.2.2-100-B-B"></a>The
                                    	multiplicative operators <code class="literal">*</code>, <code class="literal">/</code>, and <code class="literal">%</code>
                                    	(<a class="xref" href="jls-15.html#jls-15.17" title="15.17.&nbsp;Multiplicative Operators">&sect;15.17</a>)
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-4.2.2-100-B-C"></a>The additive
                                    	operators <code class="literal">+</code> and <code class="literal">-</code>
                                    	(<a class="xref" href="jls-15.html#jls-15.18" title="15.18.&nbsp;Additive Operators">&sect;15.18</a>)
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-4.2.2-100-B-D"></a>The increment
                                    	operator <code class="literal">++</code>, both prefix
                                    	(<a class="xref" href="jls-15.html#jls-15.15.1" title="15.15.1.&nbsp;Prefix Increment Operator ++">&sect;15.15.1</a>) and postfix
                                    	(<a class="xref" href="jls-15.html#jls-15.14.2" title="15.14.2.&nbsp;Postfix Increment Operator ++">&sect;15.14.2</a>)
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-4.2.2-100-B-E"></a>The decrement
                                    	operator <code class="literal">--</code>, both prefix
                                    	(<a class="xref" href="jls-15.html#jls-15.15.2" title="15.15.2.&nbsp;Prefix Decrement Operator --">&sect;15.15.2</a>) and postfix
                                    	(<a class="xref" href="jls-15.html#jls-15.14.3" title="15.14.3.&nbsp;Postfix Decrement Operator --">&sect;15.14.3</a>)
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-4.2.2-100-B-F"></a>The signed and
                                    	unsigned shift operators <code class="literal">&lt;&lt;</code>, <code class="literal">&gt;&gt;</code>, and <code class="literal">&gt;&gt;&gt;</code>
                                    	(<a class="xref" href="jls-15.html#jls-15.19" title="15.19.&nbsp;Shift Operators">&sect;15.19</a>)
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-4.2.2-100-B-G"></a>The bitwise
                                    	complement operator <code class="literal">~</code>
                                    	(<a class="xref" href="jls-15.html#jls-15.15.5" title="15.15.5.&nbsp;Bitwise Complement Operator ~">&sect;15.15.5</a>)
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-4.2.2-100-B-H"></a>The integer
                                    	bitwise operators <code class="literal">&amp;</code>, <code class="literal">^</code>, and <code class="literal">|</code>
                                    	(<a class="xref" href="jls-15.html#jls-15.22.1" title="15.22.1.&nbsp;Integer Bitwise Operators &amp;, ^, and |">&sect;15.22.1</a>)
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.2-100-C"></a>The conditional
                               operator <code class="literal">? :</code> (<a class="xref" href="jls-15.html#jls-15.25" title="15.25.&nbsp;Conditional Operator ? :">&sect;15.25</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.2-100-D"></a>The cast operator
                               (<a class="xref" href="jls-15.html#jls-15.16" title="15.16.&nbsp;Cast Expressions">&sect;15.16</a>), which can convert from an integral
                               value to a value of any specified numeric type
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.2-100-E"></a>The string
                               concatenation operator <code class="literal">+</code> (<a class="xref" href="jls-15.html#jls-15.18.1" title="15.18.1.&nbsp;String Concatenation Operator +">&sect;15.18.1</a>),
                               which, when given a <code class="literal">String</code> operand and an integral operand, will
                               convert the integral operand to a <code class="literal">String</code> representing its value
                               in decimal form, and then produce a newly created <code class="literal">String</code> that is
                               the concatenation of the two strings
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-4.2.2-110"></a>Other useful constructors,
                  methods, and constants are predefined in the classes <code class="literal">Byte</code>, <code class="literal">Short</code>,
                  <code class="literal">Integer</code>, <code class="literal">Long</code>, and <code class="literal">Character</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.2-200"></a>If an
                  integer operator other than a shift operator has at least one operand
                  of type <code class="literal">long</code>, then the operation is carried out using 64-bit
                  precision, and the result of the numerical operator is of type
                  <code class="literal">long</code>. If the other operand is not <code class="literal">long</code>, it is first widened
                  (<a class="xref" href="jls-5.html#jls-5.1.5" title="5.1.5.&nbsp;Widening Reference Conversion">&sect;5.1.5</a>) to type <code class="literal">long</code> by numeric promotion
                  (<a class="xref" href="jls-5.html#jls-5.6" title="5.6.&nbsp;Numeric Contexts">&sect;5.6</a>).
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.2-210"></a>Otherwise, the operation is carried out using
                  32-bit precision, and the result of the numerical operator is of type
                  <code class="literal">int</code>. If either operand is not an <code class="literal">int</code>, it is first widened to type
                  <code class="literal">int</code> by numeric promotion.
               </p>
               <p class="norm"><a name="jls-4.2.2-220"></a>Any value of any integral
                  type may be cast to or from any numeric type. There are no casts
                  between integral types and the type <code class="literal">boolean</code>.
               </p>
               <p class="note">See <a class="xref" href="jls-4.html#jls-4.2.5" title="4.2.5.&nbsp;The boolean Type and boolean Values">&sect;4.2.5</a> for an idiom to
                  convert integer expressions to <code class="literal">boolean</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.2-300"></a>The
                   integer operators do not indicate overflow or
                  underflow in any way.
               </p>
               <p class="norm"><a name="jls-4.2.2-310"></a>An integer operator can throw
                  an exception (<a class="xref" href="jls-11.html" title="Chapter&nbsp;11.&nbsp;Exceptions">&sect;11 (<i>Exceptions</i>)</a>) for the following
                  reasons:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.2-310-A"></a>Any integer operator
                                 can throw a <code class="literal">NullPointerException</code> if unboxing conversion
                                 (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) of a null reference is
                                 required.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.2-310-B"></a>The integer divide
                                 operator <code class="literal">/</code> (<a class="xref" href="jls-15.html#jls-15.17.2" title="15.17.2.&nbsp;Division Operator /">&sect;15.17.2</a>) and the
                                 integer remainder operator <code class="literal">%</code>
                                 (<a class="xref" href="jls-15.html#jls-15.17.3" title="15.17.3.&nbsp;Remainder Operator %">&sect;15.17.3</a>) can throw an
                                 <code class="literal">ArithmeticException</code> if the right-hand operand is zero.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.2-310-C"></a>The increment and
                                 decrement operators <code class="literal">++</code> (<a class="xref" href="jls-15.html#jls-15.14.2" title="15.14.2.&nbsp;Postfix Increment Operator ++">&sect;15.14.2</a>,
                                 <a class="xref" href="jls-15.html#jls-15.15.1" title="15.15.1.&nbsp;Prefix Increment Operator ++">&sect;15.15.1</a>) and <code class="literal">--</code>
                                 (<a class="xref" href="jls-15.html#jls-15.14.3" title="15.14.3.&nbsp;Postfix Decrement Operator --">&sect;15.14.3</a>, <a class="xref" href="jls-15.html#jls-15.15.2" title="15.15.2.&nbsp;Prefix Decrement Operator --">&sect;15.15.2</a>)
                                 can throw an <code class="literal">OutOfMemoryError</code> if boxing conversion
                                 (<a class="xref" href="jls-5.html#jls-5.1.7" title="5.1.7.&nbsp;Boxing Conversion">&sect;5.1.7</a>) is required and there is not
                                 sufficient memory available to perform the conversion.
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="example"><a name="d5e2024"></a><p class="title"><b>Example&nbsp;4.2.2-1.&nbsp;Integer Operations</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Test {
    public static void main(String[] args) {
        int i = 1000000;
        System.out.println(i * i);
        long l = i;
        System.out.println(l * l);
        System.out.println(20296 / (l - i));
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
-727379968
1000000000000
</pre><p class="note">and then encounters an <code class="literal">ArithmeticException</code> in the
                        division by <code class="literal">l - i</code>, because <code class="literal">l - i</code>
                        is zero. The first multiplication is performed in 32-bit precision,
                        whereas the second multiplication is a <code class="literal">long</code> multiplication. The
                        value <code class="literal">-727379968</code> is the decimal value of the low 32
                        bits of the mathematical result, <code class="literal">1000000000000</code>,
                        which is a value too large for type <code class="literal">int</code>.
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="4.2.3.&nbsp;Floating-Point Types, Formats, and Values">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.2.3"></a>4.2.3.&nbsp;Floating-Point Types, Formats, and Values
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-dynamic"><a name="jls-4.2.3-100"></a>The
                  floating-point types are <code class="literal">float</code> and <code class="literal">double</code>, which are conceptually
                  associated with the single-precision 32-bit and double-precision
                  64-bit format IEEE 754 values and operations as specified
                  in <em class="citetitle">IEEE Standard for Binary Floating-Point
                     Arithmetic</em>, ANSI/IEEE Standard 754-1985 (IEEE, New
                  York).
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.3-110"></a>The IEEE
                  754 standard includes not only positive and negative numbers that
                  consist of a sign and magnitude, but also positive and negative zeros,
                  positive and negative <span class="emphasis"><em>infinities</em></span>, and
                  special <span class="emphasis"><em>Not-a-Number</em></span> values (hereafter
                  abbreviated NaN). A NaN value is used to represent the result of
                  certain invalid operations such as dividing zero by zero. NaN
                  constants of both <code class="literal">float</code> and <code class="literal">double</code> type are predefined
                  as <code class="literal">Float.NaN</code>
                  and <code class="literal">Double.NaN</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.3-120"></a>Every
                  implementation of the Java programming language is required to support two standard
                  sets of floating-point values, called the <span class="emphasis"><em>float value
                        set</em></span> and the <span class="emphasis"><em>double value set</em></span>. In
                  addition, an implementation of the Java programming language may support either or
                  both of two extended-exponent floating-point value sets, called
                  the <span class="emphasis"><em>float-extended-exponent value set</em></span> and
                  the <span class="emphasis"><em>double-extended-exponent value set</em></span>. These
                  extended-exponent value sets may, under certain circumstances, be used
                  instead of the standard value sets to represent the values of
                  expressions of type <code class="literal">float</code> or <code class="literal">double</code> (<a class="xref" href="jls-5.html#jls-5.1.13" title="5.1.13.&nbsp;Value Set Conversion">&sect;5.1.13</a>,
                  <a class="xref" href="jls-15.html#jls-15.4" title="15.4.&nbsp;FP-strict Expressions">&sect;15.4</a>).
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.3-130"></a>The
                  finite nonzero values of any floating-point value set can all be
                  expressed in the form <span class="emphasis"><em>s</em></span> &middot; <span class="emphasis"><em>m</em></span>
                  &middot; 2<sup>(<span class="emphasis"><em>e</em></span> - <span class="emphasis"><em>N</em></span> +
                     1)</sup>, where <span class="emphasis"><em>s</em></span> is +1 or
                  -1, <span class="emphasis"><em>m</em></span> is a positive integer less than
                  2<sup><span class="emphasis"><em>N</em></span></sup>,
                  and <span class="emphasis"><em>e</em></span> is an integer
                  between <span class="emphasis"><em>E<sub>min</sub></em></span> =
                  -(2<sup><span class="emphasis"><em>K</em></span>-1</sup>-2)
                  and <span class="emphasis"><em>E<sub>max</sub></em></span> =
                  2<sup><span class="emphasis"><em>K</em></span>-1</sup>-1, inclusive, and
                  where <span class="emphasis"><em>N</em></span> and <span class="emphasis"><em>K</em></span> are parameters
                  that depend on the value set. Some values can be represented in this
                  form in more than one way; for example, supposing that a
                  value <span class="emphasis"><em>v</em></span> in a value set might be represented in
                  this form using certain values for
                  <span class="emphasis"><em>s</em></span>, <span class="emphasis"><em>m</em></span>,
                  and <span class="emphasis"><em>e</em></span>, then if it happened
                  that <span class="emphasis"><em>m</em></span> were even and <span class="emphasis"><em>e</em></span> were
                  less than 2<sup><span class="emphasis"><em>K</em></span>-1</sup>, one
                  could halve <span class="emphasis"><em>m</em></span> and increase <span class="emphasis"><em>e</em></span>
                  by 1 to produce a second representation for the same
                  value <span class="emphasis"><em>v</em></span>. A representation in this form is
                  called <span class="emphasis"><em>normalized</em></span> if <span class="emphasis"><em>m</em></span> <span class="symbol">&#8805;</span>
                  2<sup><span class="emphasis"><em>N</em></span>-1</sup>; otherwise the
                  representation is said to be <span class="emphasis"><em>denormalized</em></span>. If a
                  value in a value set cannot be represented in such a way
                  that <span class="emphasis"><em>m</em></span> <span class="symbol">&#8805;</span>
                  2<sup><span class="emphasis"><em>N</em></span>-1</sup>, then the value
                  is said to be a <span class="emphasis"><em>denormalized value</em></span>, because it
                  has no normalized representation.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.3-140"></a>The
                  constraints on the parameters <span class="emphasis"><em>N</em></span>
                  and <span class="emphasis"><em>K</em></span> (and on the derived
                  parameters <span class="emphasis"><em>E<sub>min</sub></em></span>
                  and <span class="emphasis"><em>E<sub>max</sub></em></span>) for the two
                  required and two optional floating-point value sets are summarized in
                  <a class="xref" href="jls-4.html#jls-4.2.3-140-A" title="Table&nbsp;4.1.&nbsp;Floating-point value set parameters">Table&nbsp;4.1</a>.
               </p>
               <div class="table"><a name="jls-4.2.3-140-A"></a><p class="title"><b>Table&nbsp;4.1.&nbsp;Floating-point value set parameters</b></p>
                  <div class="table-contents">
                     <table summary="Floating-point value set parameters" border="1">
                        <colgroup>
                           <col>
                           <col>
                           <col>
                           <col>
                           <col>
                        </colgroup>
                        <thead>
                           <tr>
                              <th>Parameter</th>
                              <th>float</th>
                              <th>float-extended-exponent</th>
                              <th>double</th>
                              <th>double-extended-exponent</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr>
                              <td><span class="emphasis"><em>N</em></span></td>
                              <td>24</td>
                              <td>24</td>
                              <td>53</td>
                              <td>53</td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>K</em></span></td>
                              <td>8</td>
                              <td><span class="symbol">&#8805;</span> 11
                              </td>
                              <td>11</td>
                              <td><span class="symbol">&#8805;</span> 15
                              </td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>E<sub>max</sub></em></span></td>
                              <td>+127</td>
                              <td><span class="symbol">&#8805;</span> +1023
                              </td>
                              <td>+1023</td>
                              <td><span class="symbol">&#8805;</span> +16383
                              </td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>E<sub>min</sub></em></span></td>
                              <td>-126</td>
                              <td><span class="symbol">&#8804;</span> -1022
                              </td>
                              <td>-1022</td>
                              <td><span class="symbol">&#8804;</span> -16382
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
               </div><br class="table-break"><p class="norm-dynamic"><a name="jls-4.2.3-150"></a>Where one
                  or both extended-exponent value sets are supported by an
                  implementation, then for each supported extended-exponent value set
                  there is a specific implementation-dependent
                  constant <span class="emphasis"><em>K</em></span>, whose value is constrained by
                  <a class="xref" href="jls-4.html#jls-4.2.3-140-A" title="Table&nbsp;4.1.&nbsp;Floating-point value set parameters">Table&nbsp;4.1</a>; this value <span class="emphasis"><em>K</em></span>
                  in turn dictates the values
                  for <span class="emphasis"><em>E<sub>min</sub></em></span>
                  and <span class="emphasis"><em>E<sub>max</sub></em></span>.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.3-160"></a>Each of
                  the four value sets includes not only the finite nonzero values that
                  are ascribed to it above, but also NaN values and the four values
                  positive zero, negative zero, positive infinity, and negative
                  infinity.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.3-170"></a>Note that
                  the constraints in <a class="xref" href="jls-4.html#jls-4.2.3-140-A" title="Table&nbsp;4.1.&nbsp;Floating-point value set parameters">Table&nbsp;4.1</a> are designed so
                  that every element of the float value set is necessarily also an
                  element of the float-extended-exponent value set, the double value
                  set, and the double-extended-exponent value set. Likewise, each
                  element of the double value set is necessarily also an element of the
                  double-extended-exponent value set. Each extended-exponent value set
                  has a larger range of exponent values than the corresponding standard
                  value set, but does not have more precision.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.3-180"></a>The
                  elements of the float value set are exactly the values that can be
                  represented using the single floating-point format defined in the IEEE
                  754 standard. The elements of the double value set are exactly the
                  values that can be represented using the double floating-point format
                  defined in the IEEE 754 standard. Note, however, that the elements of
                  the float-extended-exponent and double-extended-exponent value sets
                  defined here do <span class="emphasis"><em>not</em></span> correspond to the values that
                  can be represented using IEEE 754 single extended and double extended
                  formats, respectively.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.3-190"></a>The
                  float, float-extended-exponent, double, and double-extended-exponent
                  value sets are not types. It is always correct for an implementation
                  of the Java programming language to use an element of the float value set to
                  represent a value of type <code class="literal">float</code>; however, it may be permissible in
                  certain regions of code for an implementation to use an element of the
                  float-extended-exponent value set instead. Similarly, it is always
                  correct for an implementation to use an element of the double value
                  set to represent a value of type <code class="literal">double</code>; however, it may be
                  permissible in certain regions of code for an implementation to use an
                  element of the double-extended-exponent value set instead.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.3-200"></a>Except
                  for NaN, floating-point values are <span class="emphasis"><em>ordered</em></span>;
                  arranged from smallest to largest, they are negative infinity,
                  negative finite nonzero values, positive and negative zero, positive
                  finite nonzero values, and positive infinity.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.3-210"></a>IEEE 754
                  allows multiple distinct NaN values for each of its single and double
                  floating-point formats. While each hardware architecture returns a
                  particular bit pattern for NaN when a new NaN is generated, a
                  programmer can also create NaNs with different bit patterns to encode,
                  for example, retrospective diagnostic information.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.3-220"></a>For the
                  most part, the Java SE platform treats NaN values of a given type as though
                  collapsed into a single canonical value, and hence this specification
                  normally refers to an arbitrary NaN as though to a canonical
                  value.
               </p>
               <p class="note">However, version 1.3 of the Java SE platform introduced
                  methods enabling the programmer to distinguish between NaN values:
                  the <code class="literal">Float.floatToRawIntBits</code>
                  and <code class="literal">Double.doubleToRawLongBits</code> methods. The
                  interested reader is referred to the specifications for the <code class="literal">Float</code>
                  and <code class="literal">Double</code> classes for more information.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.3-230"></a>Positive
                  zero and negative zero compare equal; thus the result of the
                  expression <code class="literal">0.0==-0.0</code> is <code class="literal">true</code> and the result
                  of <code class="literal">0.0&gt;-0.0</code> is false. But other operations can
                  distinguish positive and negative zero; for
                  example, <code class="literal">1.0/0.0</code> has the value positive infinity,
                  while the value of <code class="literal">1.0/-0.0</code> is negative
                  infinity.
               </p>
               <p class="norm"><a name="jls-4.2.3-240"></a>NaN
                  is <span class="emphasis"><em>unordered</em></span>, so:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.3-240-A"></a>The numerical
                                 comparison
                                 operators <code class="literal">&lt;</code>, <code class="literal">&lt;=</code>,
                                 <code class="literal">&gt;</code>, and <code class="literal">&gt;=</code> return
                                 <code class="literal">false</code> if either or both operands are NaN
                                 (<a class="xref" href="jls-15.html#jls-15.20.1" title="15.20.1.&nbsp;Numerical Comparison Operators <, <=, &gt;, and &gt;=">&sect;15.20.1</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.3-240-B"></a>The equality
                                 operator <code class="literal">==</code> returns <code class="literal">false</code> if either operand
                                 is NaN.
                        </p>
                        <p class="norm"><a name="jls-4.2.3-240-B.1"></a>In
                                 particular, <code class="literal">(x&lt;y) == !(x&gt;=y)</code> will be
                                 <code class="literal">false</code> if <code class="literal">x</code> or <code class="literal">y</code> is
                                 NaN.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.3-240-C"></a>The inequality
                                 operator <code class="literal">!=</code> returns <code class="literal">true</code> if either operand
                                 is NaN (<a class="xref" href="jls-15.html#jls-15.21.1" title="15.21.1.&nbsp;Numerical Equality Operators == and !=">&sect;15.21.1</a>).
                        </p>
                        <p class="norm"><a name="jls-4.2.3-240-C.1"></a>In
                                 particular, <code class="literal">x!=x</code> is <code class="literal">true</code> if and only
                                 if <code class="literal">x</code> is NaN.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="4.2.4.&nbsp;Floating-Point Operations">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.2.4"></a>4.2.4.&nbsp;Floating-Point Operations
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-4.2.4-100"></a>The Java programming language provides a
                  number of operators that act on floating-point values:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.4-100-A"></a>The comparison
                               operators, which result in a value of type <code class="literal">boolean</code>:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm"><a name="jls-4.2.4-100-A-A"></a>The numerical
                                    	comparison operators <code class="literal">&lt;</code>, <code class="literal">&lt;=</code>,
                                    	<code class="literal">&gt;</code>, and <code class="literal">&gt;=</code>
                                    	(<a class="xref" href="jls-15.html#jls-15.20.1" title="15.20.1.&nbsp;Numerical Comparison Operators <, <=, &gt;, and &gt;=">&sect;15.20.1</a>)
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-4.2.4-100-A-B"></a>The numerical
                                    	equality operators <code class="literal">==</code> and <code class="literal">!=</code>
                                    	(<a class="xref" href="jls-15.html#jls-15.21.1" title="15.21.1.&nbsp;Numerical Equality Operators == and !=">&sect;15.21.1</a>)
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.4-100-B"></a>The numerical
                               operators, which result in a value of type <code class="literal">float</code> or
                               <code class="literal">double</code>:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm"><a name="jls-4.2.4-100-B-A"></a>The unary plus
                                    	and minus operators <code class="literal">+</code> and <code class="literal">-</code>
                                    	(<a class="xref" href="jls-15.html#jls-15.15.3" title="15.15.3.&nbsp;Unary Plus Operator +">&sect;15.15.3</a>,
                                    	<a class="xref" href="jls-15.html#jls-15.15.4" title="15.15.4.&nbsp;Unary Minus Operator -">&sect;15.15.4</a>)
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-4.2.4-100-B-B"></a>The
                                    	multiplicative operators <code class="literal">*</code>, <code class="literal">/</code>, and <code class="literal">%</code>
                                    	(<a class="xref" href="jls-15.html#jls-15.17" title="15.17.&nbsp;Multiplicative Operators">&sect;15.17</a>)
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-4.2.4-100-B-C"></a>The additive
                                    	operators <code class="literal">+</code> and <code class="literal">-</code>
                                    	(<a class="xref" href="jls-15.html#jls-15.18.2" title="15.18.2.&nbsp;Additive Operators (+ and -) for Numeric Types">&sect;15.18.2</a>)
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-4.2.4-100-B-D"></a>The increment
                                    	operator <code class="literal">++</code>, both prefix
                                    	(<a class="xref" href="jls-15.html#jls-15.15.1" title="15.15.1.&nbsp;Prefix Increment Operator ++">&sect;15.15.1</a>) and postfix
                                    	(<a class="xref" href="jls-15.html#jls-15.14.2" title="15.14.2.&nbsp;Postfix Increment Operator ++">&sect;15.14.2</a>)
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jls-4.2.4-100-B-E"></a>The decrement
                                    	operator <code class="literal">--</code>, both prefix
                                    	(<a class="xref" href="jls-15.html#jls-15.15.2" title="15.15.2.&nbsp;Prefix Decrement Operator --">&sect;15.15.2</a>) and postfix
                                    	(<a class="xref" href="jls-15.html#jls-15.14.3" title="15.14.3.&nbsp;Postfix Decrement Operator --">&sect;15.14.3</a>)
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.4-100-C"></a>The conditional
                               operator <code class="literal">? :</code> (<a class="xref" href="jls-15.html#jls-15.25" title="15.25.&nbsp;Conditional Operator ? :">&sect;15.25</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.4-100-D"></a>The cast operator
                               (<a class="xref" href="jls-15.html#jls-15.16" title="15.16.&nbsp;Cast Expressions">&sect;15.16</a>), which can convert from a
                               floating-point value to a value of any specified numeric
                               type
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.4-100-E"></a>The string
                               concatenation operator <code class="literal">+</code> (<a class="xref" href="jls-15.html#jls-15.18.1" title="15.18.1.&nbsp;String Concatenation Operator +">&sect;15.18.1</a>),
                               which, when given a <code class="literal">String</code> operand and a floating-point operand,
                               will convert the floating-point operand to a <code class="literal">String</code> representing
                               its value in decimal form (without information loss), and then
                               produce a newly created <code class="literal">String</code> by concatenating the two
                               strings
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-4.2.4-110"></a>Other useful constructors,
                  methods, and constants are predefined in the classes <code class="literal">Float</code>,
                  <code class="literal">Double</code>, and <code class="literal">Math</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.4-200"></a>If at
                  least one of the operands to a binary operator is of floating-point
                  type, then the operation is a floating-point operation, even if the
                  other is integral.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.4-210"></a>If at
                  least one of the operands to a numerical operator is of type <code class="literal">double</code>,
                  then the operation is carried out using 64-bit floating-point
                  arithmetic, and the result of the numerical operator is a value of
                  type <code class="literal">double</code>. If the other operand is not a <code class="literal">double</code>, it is first
                  widened (<a class="xref" href="jls-5.html#jls-5.1.5" title="5.1.5.&nbsp;Widening Reference Conversion">&sect;5.1.5</a>) to type <code class="literal">double</code> by numeric
                  promotion (<a class="xref" href="jls-5.html#jls-5.6" title="5.6.&nbsp;Numeric Contexts">&sect;5.6</a>).
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.4-220"></a>Otherwise, the operation is carried out using
                  32-bit floating-point arithmetic, and the result of the numerical
                  operator is a value of type <code class="literal">float</code>. (If the other operand is not a
                  <code class="literal">float</code>, it is first widened to type <code class="literal">float</code> by numeric
                  promotion.)
               </p>
               <p class="norm"><a name="jls-4.2.4-230"></a>Any value of a floating-point
                  type may be cast to or from any numeric type. There are no casts
                  between floating-point types and the type <code class="literal">boolean</code>.
               </p>
               <p class="note">See <a class="xref" href="jls-4.html#jls-4.2.5" title="4.2.5.&nbsp;The boolean Type and boolean Values">&sect;4.2.5</a> for an idiom to
                  convert floating-point expressions to <code class="literal">boolean</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.4-300"></a>Operators
                  on floating-point numbers behave as specified by IEEE 754 (with the
                  exception of the remainder operator
                  (<a class="xref" href="jls-15.html#jls-15.17.3" title="15.17.3.&nbsp;Remainder Operator %">&sect;15.17.3</a>)). In particular, the Java programming language
                  requires support of IEEE 754 <span class="emphasis"><em>denormalized</em></span>
                  floating-point numbers and <span class="emphasis"><em>gradual underflow</em></span>,
                  which make it easier to prove desirable properties of particular
                  numerical algorithms. Floating-point operations do not "flush to zero"
                  if the calculated result is a denormalized number.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.4-310"></a>The
                  Java programming language requires that floating-point arithmetic behave as if every
                  floating-point operator rounded its floating-point result to the
                  result precision. <span class="emphasis"><em>Inexact</em></span> results must be rounded
                  to the representable value nearest to the infinitely precise result;
                  if the two nearest representable values are equally near, the one with
                  its least significant bit zero is chosen. This is the IEEE 754
                  standard's default rounding mode known as <span class="emphasis"><em>round to
                        nearest</em></span>.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.4-320"></a>The
                  Java programming language uses <span class="emphasis"><em>round toward zero</em></span> when converting
                  a floating value to an integer (<a class="xref" href="jls-5.html#jls-5.1.3" title="5.1.3.&nbsp;Narrowing Primitive Conversion">&sect;5.1.3</a>), which
                  acts, in this case, as though the number were truncated, discarding
                  the mantissa bits. Rounding toward zero chooses at its result the
                  format's value closest to and no greater in magnitude than the
                  infinitely precise result.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.4-330"></a>A
                  floating-point operation that overflows produces a signed
                  infinity.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.4-340"></a>A
                  floating-point operation that underflows produces a denormalized value
                  or a signed zero.
               </p>
               <p class="norm-dynamic"><a name="jls-4.2.4-350"></a>A
                  floating-point operation that has no mathematically definite result
                  produces NaN.
               </p>
               <p class="norm"><a name="jls-4.2.4-360"></a>All numeric operations with
                  NaN as an operand produce NaN as a result.
               </p>
               <p class="norm"><a name="jls-4.2.4-370"></a>A floating-point operator can
                  throw an exception (<a class="xref" href="jls-11.html" title="Chapter&nbsp;11.&nbsp;Exceptions">&sect;11 (<i>Exceptions</i>)</a>) for the following
                  reasons:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.4-370-A"></a>Any floating-point
                                 operator can throw a <code class="literal">NullPointerException</code> if unboxing conversion
                                 (<a class="xref" href="jls-5.html#jls-5.1.8" title="5.1.8.&nbsp;Unboxing Conversion">&sect;5.1.8</a>) of a null reference is
                                 required.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.4-370-B"></a>The increment and
                                 decrement operators <code class="literal">++</code> (<a class="xref" href="jls-15.html#jls-15.14.2" title="15.14.2.&nbsp;Postfix Increment Operator ++">&sect;15.14.2</a>,
                                 <a class="xref" href="jls-15.html#jls-15.15.1" title="15.15.1.&nbsp;Prefix Increment Operator ++">&sect;15.15.1</a>) and <code class="literal">--</code>
                                 (<a class="xref" href="jls-15.html#jls-15.14.3" title="15.14.3.&nbsp;Postfix Decrement Operator --">&sect;15.14.3</a>, <a class="xref" href="jls-15.html#jls-15.15.2" title="15.15.2.&nbsp;Prefix Decrement Operator --">&sect;15.15.2</a>)
                                 can throw an <code class="literal">OutOfMemoryError</code> if boxing conversion
                                 (<a class="xref" href="jls-5.html#jls-5.1.7" title="5.1.7.&nbsp;Boxing Conversion">&sect;5.1.7</a>) is required and there is not
                                 sufficient memory available to perform the conversion.
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="example"><a name="d5e2335"></a><p class="title"><b>Example&nbsp;4.2.4-1.&nbsp;Floating-point Operations</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Test {
    public static void main(String[] args) {
        // An example of overflow:
        double d = 1e308;
        System.out.print("overflow produces infinity: ");
        System.out.println(d + "*10==" + d*10);
        // An example of gradual underflow:
        d = 1e-305 * Math.PI;
        System.out.print("gradual underflow: " + d + "\n   ");
        for (int i = 0; i &lt; 4; i++)
            System.out.print(" " + (d /= 100000));
        System.out.println();
        // An example of NaN:
        System.out.print("0.0/0.0 is Not-a-Number: ");
        d = 0.0/0.0;
        System.out.println(d);
        // An example of inexact results and rounding:
        System.out.print("inexact results with float:");
        for (int i = 0; i &lt; 100; i++) {
            float z = 1.0f / i;
            if (z * i != 1.0f)
                System.out.print(" " + i);
        }
        System.out.println();
        // Another example of inexact results and rounding:
        System.out.print("inexact results with double:");
        for (int i = 0; i &lt; 100; i++) {
            double z = 1.0 / i;
            if (z * i != 1.0)
                System.out.print(" " + i);
        }
        System.out.println();
        // An example of cast to integer rounding:
        System.out.print("cast to int rounds toward 0: ");
        d = 12345.6;
        System.out.println((int)d + " " + (int)(-d));
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
overflow produces infinity: 1.0e+308*10==Infinity
gradual underflow: 3.141592653589793E-305
3.1415926535898E-310 3.141592653E-315 3.142E-320 0.0
0.0/0.0 is Not-a-Number: NaN
inexact results with float: 0 41 47 55 61 82 83 94 97
inexact results with double: 0 49 98
cast to int rounds toward 0: 12345 -12345
</pre><p class="note">This example demonstrates, among other things, that
                        gradual underflow can result in a gradual loss of precision.
                     </p>
                     <p class="note">The results when <code class="literal">i</code> is <code class="literal">0</code>
                        involve division by zero, so that <code class="literal">z</code> becomes
                        positive infinity, and <code class="literal">z * 0</code> is NaN, which is not
                        equal to <code class="literal">1.0</code>.
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="4.2.5.&nbsp;The boolean Type and boolean Values">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.2.5"></a>4.2.5.&nbsp;The <code class="literal">boolean</code> Type and boolean Values
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-4.2.5-100"></a>The
                  <code class="literal">boolean</code> type represents a logical quantity with two possible values,
                  indicated by the literals <code class="literal">true</code> and <code class="literal">false</code>
                  (<a class="xref" href="jls-3.html#jls-3.10.3" title="3.10.3.&nbsp;Boolean Literals">&sect;3.10.3</a>).
               </p>
               <p class="norm"><a name="jls-4.2.5-110"></a>The boolean operators
                  are:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.5-110-A"></a>The relational
                               operators <code class="literal">==</code> and <code class="literal">!=</code>
                               (<a class="xref" href="jls-15.html#jls-15.21.2" title="15.21.2.&nbsp;Boolean Equality Operators == and !=">&sect;15.21.2</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.5-110-B"></a>The logical complement
                               operator <code class="literal">!</code> (<a class="xref" href="jls-15.html#jls-15.15.6" title="15.15.6.&nbsp;Logical Complement Operator !">&sect;15.15.6</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.5-110-C"></a>The logical operators
                               <code class="literal">&amp;</code>, <code class="literal">^</code>, and <code class="literal">|</code> (<a class="xref" href="jls-15.html#jls-15.22.2" title="15.22.2.&nbsp;Boolean Logical Operators &amp;, ^, and |">&sect;15.22.2</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.5-110-D"></a>The conditional-and and
                               conditional-or operators <code class="literal">&amp;&amp;</code> (<a class="xref" href="jls-15.html#jls-15.23" title="15.23.&nbsp;Conditional-And Operator &amp;&amp;">&sect;15.23</a>)
                               and <code class="literal">||</code> (<a class="xref" href="jls-15.html#jls-15.24" title="15.24.&nbsp;Conditional-Or Operator ||">&sect;15.24</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.5-110-E"></a>The conditional
                               operator <code class="literal">? :</code> (<a class="xref" href="jls-15.html#jls-15.25" title="15.25.&nbsp;Conditional Operator ? :">&sect;15.25</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.5-110-F"></a>The string
                               concatenation operator <code class="literal">+</code> (<a class="xref" href="jls-15.html#jls-15.18.1" title="15.18.1.&nbsp;String Concatenation Operator +">&sect;15.18.1</a>),
                               which, when given a <code class="literal">String</code> operand and a <code class="literal">boolean</code> operand, will
                               convert the <code class="literal">boolean</code> operand to a <code class="literal">String</code>
                               (either <code class="literal">"true"</code> or <code class="literal">"false"</code>),
                               and then produce a newly created <code class="literal">String</code> that is the
                               concatenation of the two strings
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-4.2.5-120"></a>Boolean expressions determine
                  the control flow in several kinds of statements:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.5-120-A"></a>The <code class="literal">if</code> statement
                               (<a class="xref" href="jls-14.html#jls-14.9" title="14.9.&nbsp;The if Statement">&sect;14.9</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.5-120-B"></a>The <code class="literal">while</code> statement
                               (<a class="xref" href="jls-14.html#jls-14.12" title="14.12.&nbsp;The while Statement">&sect;14.12</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.5-120-C"></a>The <code class="literal">do</code> statement
                               (<a class="xref" href="jls-14.html#jls-14.13" title="14.13.&nbsp;The do Statement">&sect;14.13</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.2.5-120-D"></a>The <code class="literal">for</code> statement
                               (<a class="xref" href="jls-14.html#jls-14.14" title="14.14.&nbsp;The for Statement">&sect;14.14</a>)
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-4.2.5-130"></a>A <code class="literal">boolean</code> expression also
                  determines which subexpression is evaluated in the conditional
                  <code class="literal">? :</code> operator (<a class="xref" href="jls-15.html#jls-15.25" title="15.25.&nbsp;Conditional Operator ? :">&sect;15.25</a>).
               </p>
               <p class="norm"><a name="jls-4.2.5-140"></a>Only <code class="literal">boolean</code> and <code class="literal">Boolean</code>
                  expressions can be used in control flow statements and as the first
                  operand of the conditional operator <code class="literal">? :</code>.
               </p>
               <p class="norm-static"><a name="jls-4.2.5-200"></a>An integer
                  or floating-point expression <code class="literal">x</code>
                  can be converted to a <code class="literal">boolean</code> value, following the C language
                  convention that any nonzero value is <code class="literal">true</code>, by the
                  expression <code class="literal">x!=0</code>.
               </p>
               <p class="norm-static"><a name="jls-4.2.5-210"></a>An object
                  reference <code class="literal">obj</code> can be converted to a <code class="literal">boolean</code>
                  value, following the C language convention that any reference other
                  than <code class="literal">null</code> is <code class="literal">true</code>, by the
                  expression <code class="literal">obj!=null</code>.
               </p>
               <p class="norm"><a name="jls-4.2.5-220"></a>A <code class="literal">boolean</code> value can be
                  converted to a <code class="literal">String</code> by string conversion
                  (<a class="xref" href="jls-5.html#jls-5.4" title="5.4.&nbsp;String Contexts">&sect;5.4</a>).
               </p>
               <p class="norm"><a name="jls-4.2.5-230"></a>A <code class="literal">boolean</code> value may be cast
                  to type <code class="literal">boolean</code>, <code class="literal">Boolean</code>, or <code class="literal">Object</code> (<a class="xref" href="jls-5.html#jls-5.5" title="5.5.&nbsp;Casting Contexts">&sect;5.5</a>).
                  No other casts on type <code class="literal">boolean</code> are allowed.
               </p>
            </div>
         </div>
         <div class="section" title="4.3.&nbsp;Reference Types and Values">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-4.3"></a>4.3.&nbsp;Reference Types and Values
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-dynamic"><a name="jls-4.3-100"></a>There are
               four kinds of <span class="emphasis"><em>reference types</em></span>: class types
               (<a class="xref" href="jls-8.html#jls-8.1" title="8.1.&nbsp;Class Declarations">&sect;8.1</a>), interface types
               (<a class="xref" href="jls-9.html#jls-9.1" title="9.1.&nbsp;Interface Declarations">&sect;9.1</a>), type variables
               (<a class="xref" href="jls-4.html#jls-4.4" title="4.4.&nbsp;Type Variables">&sect;4.4</a>), and array types
               (<a class="xref" href="jls-10.html#jls-10.1" title="10.1.&nbsp;Array Types">&sect;10.1</a>).
            </p>
            <div id="jls-4.3-110a" class="productionset"><a name="jls-4.3-110a"></a>
                 
               <div class="production"><a name="jls-ReferenceType"></a>
                      
                  <div class="lhs">ReferenceType:</div>
                      
                  <div class="rhs">
                           <a href="jls-4.html#jls-ClassOrInterfaceType" title="ClassOrInterfaceType">ClassOrInterfaceType</a> <br>
                           <a href="jls-4.html#jls-TypeVariable" title="TypeVariable">TypeVariable</a> <br>
                           <a href="jls-4.html#jls-ArrayType" title="ArrayType">ArrayType</a>
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-ClassOrInterfaceType"></a>
                      
                  <div class="lhs">ClassOrInterfaceType:</div>
                      
                  <div class="rhs">
                           <a href="jls-4.html#jls-ClassType" title="ClassType">ClassType</a> <br>
                           <a href="jls-4.html#jls-InterfaceType" title="InterfaceType">InterfaceType</a>
                         
                  </div>
                    
               </div>
               
               
               
                 
               <div class="production"><a name="jls-ClassType"></a>
                      
                  <div class="lhs">ClassType:</div>
                      
                  <div class="rhs">
                           {<a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>} 
                           <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a>
                           [<a href="jls-4.html#jls-TypeArguments" title="TypeArguments">TypeArguments</a>] <br>
                     
                           <a href="jls-4.html#jls-ClassOrInterfaceType" title="ClassOrInterfaceType">ClassOrInterfaceType</a> <code class="literal">.</code> 
                           {<a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>}
                           <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a> 
                           [<a href="jls-4.html#jls-TypeArguments" title="TypeArguments">TypeArguments</a>]
                         
                  </div>
                    
               </div>
               
               
               
                 
               <div class="production"><a name="jls-InterfaceType"></a>
                      
                  <div class="lhs">InterfaceType:</div>
                      
                  <div class="rhs">
                           <a href="jls-4.html#jls-ClassType" title="ClassType">ClassType</a>
                         
                  </div>
                    
               </div> 
               
               
               
                 
               <div class="production"><a name="jls-TypeVariable"></a>
                      
                  <div class="lhs">TypeVariable:</div>
                      
                  <div class="rhs">
                           {<a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>} <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a>
                         
                  </div>
                    
               </div>
               
               
               
                 
               <div class="production"><a name="jls-ArrayType"></a>
                      
                  <div class="lhs">ArrayType:</div>
                      
                  <div class="rhs">
                           <a href="jls-4.html#jls-PrimitiveType" title="PrimitiveType">PrimitiveType</a> <a href="jls-4.html#jls-Dims" title="Dims">Dims</a> <br>
                           <a href="jls-4.html#jls-ClassOrInterfaceType" title="ClassOrInterfaceType">ClassOrInterfaceType</a> <a href="jls-4.html#jls-Dims" title="Dims">Dims</a> <br>
                           <a href="jls-4.html#jls-TypeVariable" title="TypeVariable">TypeVariable</a> <a href="jls-4.html#jls-Dims" title="Dims">Dims</a>
                         
                  </div>
                    
               </div> 
               
                 
               <div class="production"><a name="jls-Dims"></a>
                      
                  <div class="lhs">Dims:</div>
                      
                  <div class="rhs">
                           {<a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>} <code class="literal">[</code> <code class="literal">]</code> {{<a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>} <code class="literal">[</code> <code class="literal">]</code>}
                         
                  </div>
                    
               </div>
               
            </div>
            <div class="informalexample">
               <p class="note">The sample code:</p><pre class="programlisting">
class Point { int[] metrics; }
interface Move { void move(int deltax, int deltay); }
</pre><p class="note">declares a class type
                  <code class="literal">Point</code>, an interface type <code class="literal">Move</code>,
                  and uses an array type <code class="literal">int</code><code class="literal">[]</code> (an array of <code class="literal">int</code>) to declare
                  the field <code class="literal">metrics</code> of the
                  class <code class="literal">Point</code>.
               </p>
            </div>
            <p class="norm-static"><a name="jls-4.3-200"></a>A class or
               interface type consists of an identifier or a dotted sequence of
               identifiers, where each identifier is optionally followed by type
               arguments (<a class="xref" href="jls-4.html#jls-4.5.1" title="4.5.1.&nbsp;Type Arguments of Parameterized Types">&sect;4.5.1</a>). If type arguments appear
               anywhere in a class or interface type, it is a parameterized type
               (<a class="xref" href="jls-4.html#jls-4.5" title="4.5.&nbsp;Parameterized Types">&sect;4.5</a>).
            </p>
            <p class="norm-static"><a name="jls-4.3-210"></a>Each identifier in
               a class or interface type is classified as a package name or a type
               name (<a class="xref" href="jls-6.html#jls-6.5.1" title="6.5.1.&nbsp;Syntactic Classification of a Name According to Context">&sect;6.5.1</a>). Identifiers which are classified
               as type names may be annotated. If a class or interface type has the
               form <code class="varname">T.id</code> (optionally followed by type arguments),
               then <code class="varname">id</code> must be the simple name of an accessible
               member type of <code class="varname">T</code> (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>,
               <a class="xref" href="jls-8.html#jls-8.5" title="8.5.&nbsp;Member Type Declarations">&sect;8.5</a>, <a class="xref" href="jls-9.html#jls-9.5" title="9.5.&nbsp;Member Type Declarations">&sect;9.5</a>), or a
               compile-time error occurs. The class or interface type denotes that
               member type.
            </p>
            <div class="section" title="4.3.1.&nbsp;Objects">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.3.1"></a>4.3.1.&nbsp;Objects
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-4.3.1-100"></a>An 
                  <span class="emphasis"><em>object</em></span> is a <span class="emphasis"><em>class instance</em></span>
                  or an <span class="emphasis"><em>array</em></span>.
               </p>
               <p class="norm"><a name="jls-4.3.1-110"></a>The reference values (often
                  just <span class="emphasis"><em>references</em></span>) are pointers to these objects,
                  and a special null reference, which refers to no object.
               </p>
               <p class="norm"><a name="jls-4.3.1-120"></a>A class instance is
                  explicitly created by a class instance creation expression
                  (<a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>).
               </p>
               <p class="norm"><a name="jls-4.3.1-130"></a>An array is explicitly
                  created by an array creation expression
                  (<a class="xref" href="jls-15.html#jls-15.10.1" title="15.10.1.&nbsp;Array Creation Expressions">&sect;15.10.1</a>).
               </p>
               <p class="norm"><a name="jls-4.3.1-140"></a>A new class instance is
                  implicitly created when the string concatenation operator <code class="literal">+</code>
                  (<a class="xref" href="jls-15.html#jls-15.18.1" title="15.18.1.&nbsp;String Concatenation Operator +">&sect;15.18.1</a>) is used in a non-constant expression
                  (<a class="xref" href="jls-15.html#jls-15.28" title="15.28.&nbsp;Constant Expressions">&sect;15.28</a>), resulting in a new object of type
                  <code class="literal">String</code> (<a class="xref" href="jls-4.html#jls-4.3.3" title="4.3.3.&nbsp;The Class String">&sect;4.3.3</a>).
               </p>
               <p class="norm"><a name="jls-4.3.1-150"></a>A new array object is
                  implicitly created when an array initializer expression
                  (<a class="xref" href="jls-10.html#jls-10.6" title="10.6.&nbsp;Array Initializers">&sect;10.6</a>) is evaluated; this can occur when a class
                  or interface is initialized (<a class="xref" href="jls-12.html#jls-12.4" title="12.4.&nbsp;Initialization of Classes and Interfaces">&sect;12.4</a>), when a new
                  instance of a class is created (<a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>), or when a
                  local variable declaration statement is executed
                  (<a class="xref" href="jls-14.html#jls-14.4" title="14.4.&nbsp;Local Variable Declaration Statements">&sect;14.4</a>).
               </p>
               <p class="norm"><a name="jls-4.3.1-160"></a>New objects of the types
                  <code class="literal">Boolean</code>, <code class="literal">Byte</code>, <code class="literal">Short</code>, <code class="literal">Character</code>, <code class="literal">Integer</code>, <code class="literal">Long</code>, <code class="literal">Float</code>,
                  and <code class="literal">Double</code> may be implicitly created by boxing conversion
                  (<a class="xref" href="jls-5.html#jls-5.1.7" title="5.1.7.&nbsp;Boxing Conversion">&sect;5.1.7</a>).
               </p>
               <div class="example"><a name="d5e2554"></a><p class="title"><b>Example&nbsp;4.3.1-1.&nbsp;Object Creation</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Point {
    int x, y;
    Point() { System.out.println("default"); }
    Point(int x, int y) { this.x = x; this.y = y; }

    /* A Point instance is explicitly created at 
       class initialization time: */
    static Point origin = new Point(0,0);

    /* A String can be implicitly created 
       by a + operator: */
    public String toString() { return "(" + x + "," + y + ")"; }
}

class Test {
    public static void main(String[] args) {
        /* A Point is explicitly created
           using newInstance: */
        Point p = null;
        try {
            p = (Point)Class.forName("Point").newInstance();
        } catch (Exception e) {
            System.out.println(e);
        }

        /* An array is implicitly created 
           by an array constructor: */
        Point a[] = { new Point(0,0), new Point(1,1) };

        /* Strings are implicitly created 
           by + operators: */
        System.out.println("p: " + p);
        System.out.println("a: { " + a[0] + ", " + a[1] + " }");
    
        /* An array is explicitly created
           by an array creation expression: */
        String sa[] = new String[2];
        sa[0] = "he"; sa[1] = "llo";
        System.out.println(sa[0] + sa[1]);
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
default
p: (0,0)
a: { (0,0), (1,1) }
hello
</pre></div>
               </div><br class="example-break"><p class="norm"><a name="jls-4.3.1-200"></a>The operators on references
                  to objects are:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.3.1-200-A"></a>Field access, using
                               either a qualified name (<a class="xref" href="jls-6.html#jls-6.6" title="6.6.&nbsp;Access Control">&sect;6.6</a>) or a field
                               access expression (<a class="xref" href="jls-15.html#jls-15.11" title="15.11.&nbsp;Field Access Expressions">&sect;15.11</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.3.1-200-B"></a>Method invocation
                               (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.3.1-200-C"></a>The cast operator
                               (<a class="xref" href="jls-5.html#jls-5.5" title="5.5.&nbsp;Casting Contexts">&sect;5.5</a>, <a class="xref" href="jls-15.html#jls-15.16" title="15.16.&nbsp;Cast Expressions">&sect;15.16</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.3.1-200-D"></a>The string
                               concatenation operator <code class="literal">+</code> (<a class="xref" href="jls-15.html#jls-15.18.1" title="15.18.1.&nbsp;String Concatenation Operator +">&sect;15.18.1</a>),
                               which, when given a <code class="literal">String</code> operand and a reference, will convert
                               the reference to a <code class="literal">String</code> by invoking the <code class="literal">toString</code> method of
                               the referenced object (using <code class="literal">"null"</code> if either
                               the reference or the result of <code class="literal">toString</code> is a null reference),
                               and then will produce a newly created <code class="literal">String</code> that is the
                               concatenation of the two strings
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.3.1-200-E"></a>The <code class="literal">instanceof</code>
                               operator (<a class="xref" href="jls-15.html#jls-15.20.2" title="15.20.2.&nbsp;Type Comparison Operator instanceof">&sect;15.20.2</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.3.1-200-F"></a>The reference equality
                               operators <code class="literal">==</code> and <code class="literal">!=</code>
                               (<a class="xref" href="jls-15.html#jls-15.21.3" title="15.21.3.&nbsp;Reference Equality Operators == and !=">&sect;15.21.3</a>)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.3.1-200-G"></a>The conditional
                               operator <code class="literal">? :</code> (<a class="xref" href="jls-15.html#jls-15.25" title="15.25.&nbsp;Conditional Operator ? :">&sect;15.25</a>).
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-dynamic"><a name="jls-4.3.1-300"></a>There may
                  be many references to the same object. Most objects have state, stored
                  in the fields of objects that are instances of classes or in the
                  variables that are the components of an array object. If two variables
                  contain references to the same object, the state of the object can be
                  modified using one variable's reference to the object, and then the
                  altered state can be observed through the reference in the other
                  variable.
               </p>
               <div class="example"><a name="d5e2596"></a><p class="title"><b>Example&nbsp;4.3.1-2.&nbsp;Primitive and Reference Identity</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Value { int val; }

class Test {
    public static void main(String[] args) {
        int i1 = 3;
        int i2 = i1;
        i2 = 4;
        System.out.print("i1==" + i1);
        System.out.println(" but i2==" + i2);
        Value v1 = new Value();
        v1.val = 5;
        Value v2 = v1;
        v2.val = 6;
        System.out.print("v1.val==" + v1.val);
        System.out.println(" and v2.val==" + v2.val);
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
i1==3 but i2==4
v1.val==6 and v2.val==6
</pre><p class="note">because <code class="literal">v1.val</code>
                        and <code class="literal">v2.val</code> reference the same instance variable
                        (<a class="xref" href="jls-4.html#jls-4.12.3" title="4.12.3.&nbsp;Kinds of Variables">&sect;4.12.3</a>) in the one <code class="literal">Value</code>
                        object created by the only <code class="literal">new</code> expression,
                        while <code class="literal">i1</code> and <code class="literal">i2</code> are different
                        variables.
                     </p>
                  </div>
               </div><br class="example-break"><p class="norm"><a name="jls-4.3.1-400"></a>Each object is associated
                  with a  monitor (<a class="xref" href="jls-17.html#jls-17.1" title="17.1.&nbsp;Synchronization">&sect;17.1</a>), which is used
                  by <code class="literal">synchronized</code> methods (<a class="xref" href="jls-8.html#jls-8.4.3" title="8.4.3.&nbsp;Method Modifiers">&sect;8.4.3</a>) and the
                  <code class="literal">synchronized</code> statement (<a class="xref" href="jls-14.html#jls-14.19" title="14.19.&nbsp;The synchronized Statement">&sect;14.19</a>) to provide
                  control over concurrent access to state by multiple threads
                  (<a class="xref" href="jls-17.html" title="Chapter&nbsp;17.&nbsp;Threads and Locks">&sect;17 (<i>Threads and Locks</i>)</a>).
               </p>
            </div>
            <div class="section" title="4.3.2.&nbsp;The Class Object">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.3.2"></a>4.3.2.&nbsp;The Class <code class="literal">Object</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-4.3.2-100"></a>The class
                  <code class="literal">Object</code> is a superclass (<a class="xref" href="jls-8.html#jls-8.1.4" title="8.1.4.&nbsp;Superclasses and Subclasses">&sect;8.1.4</a>) of all other
                  classes.
               </p>
               <p class="norm"><a name="jls-4.3.2-200"></a>All class and array types
                  inherit (<a class="xref" href="jls-8.html#jls-8.4.8" title="8.4.8.&nbsp;Inheritance, Overriding, and Hiding">&sect;8.4.8</a>) the methods of class <code class="literal">Object</code>,
                  which are summarized as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.3.2-200-A"></a>The
                                 method <code class="literal">clone</code> is used to make a duplicate of
                                 an object.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.3.2-200-B"></a>The
                                 method <code class="literal">equals</code> defines a notion of object
                                 equality, which is based on value, not reference,
                                 comparison.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.3.2-200-C"></a>The
                                 method <code class="literal">finalize</code> is run just before an object
                                 is destroyed (<a class="xref" href="jls-12.html#jls-12.6" title="12.6.&nbsp;Finalization of Class Instances">&sect;12.6</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.3.2-200-D"></a>The
                                 method <code class="literal">getClass</code> returns the <code class="literal">Class</code> object
                                 that represents the class of the object.
                        </p>
                        <p class="norm"><a name="jls-4.3.2-200-D.1"></a>A <code class="literal">Class</code> object
                                exists for each reference type. It can be used, for example, to
                                discover the fully qualified name of a class, its members, its
                                immediate superclass, and any interfaces that it
                                implements.
                        </p>
                        <p class="norm-static"><a name="jls-4.3.2-200-D.2"></a>The type of a method
                                 invocation expression of <code class="literal">getClass</code> is
                                 <code class="literal">Class</code><code class="literal">&lt;</code><code class="literal">?</code> <code class="literal">extends</code> |<span class="type">T</span>|<code class="literal">&gt;</code> where <span class="type">T</span> is the
                                 class or interface searched (<a class="xref" href="jls-15.html#jls-15.12.1" title="15.12.1.&nbsp;Compile-Time Step 1: Determine Class or Interface to Search">&sect;15.12.1</a>)
                                 for <code class="literal">getClass</code>.
                        </p>
                        <p class="norm"><a name="jls-4.3.2-200-D.3"></a>A class method that
                                 is declared <code class="literal">synchronized</code> (<a class="xref" href="jls-8.html#jls-8.4.3.6" title="8.4.3.6.&nbsp;synchronized Methods">&sect;8.4.3.6</a>)
                                 synchronizes on the monitor associated with the <code class="literal">Class</code> object
                                 of the class.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.3.2-200-E"></a>The
                                 method <code class="literal">hashCode</code> is very useful, together with
                                 the method <code class="literal">equals</code>, in hashtables such
                                 as <code class="literal">java.util.Hashmap</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.3.2-200-F"></a>The
                                 methods <code class="literal">wait</code>, <code class="literal">notify</code>,
                                 and <code class="literal">notifyAll</code> are used in concurrent
                                 programming using threads (<a class="xref" href="jls-17.html#jls-17.2" title="17.2.&nbsp;Wait Sets and Notification">&sect;17.2</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.3.2-200-G"></a>The method <code class="literal">toString</code>
                                 returns a <code class="literal">String</code> representation of the object.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="4.3.3.&nbsp;The Class String">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.3.3"></a>4.3.3.&nbsp;The Class <code class="literal">String</code></h3>
                     </div>
                  </div>
               </div>
               <p class="norm-dynamic"><a name="jls-4.3.3-100"></a>Instances
                  of class <code class="literal">String</code> represent sequences of Unicode 
                  code points.
               </p>
               <p class="norm-dynamic"><a name="jls-4.3.3-110"></a>A
                  <code class="literal">String</code> object has a constant (unchanging) value.
               </p>
               <p class="norm-dynamic"><a name="jls-4.3.3-120"></a>String
                  literals (<a class="xref" href="jls-3.html#jls-3.10.5" title="3.10.5.&nbsp;String Literals">&sect;3.10.5</a>) are references to instances of
                  class <code class="literal">String</code>.
               </p>
               <p class="norm"><a name="jls-4.3.3-130"></a>The string concatenation
                  operator <code class="literal">+</code> (<a class="xref" href="jls-15.html#jls-15.18.1" title="15.18.1.&nbsp;String Concatenation Operator +">&sect;15.18.1</a>) implicitly creates a
                  new <code class="literal">String</code> object when the result is not a constant expression
                  (<a class="xref" href="jls-15.html#jls-15.28" title="15.28.&nbsp;Constant Expressions">&sect;15.28</a>).
               </p>
            </div>
            <div class="section" title="4.3.4.&nbsp;When Reference Types Are the Same">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.3.4"></a>4.3.4.&nbsp;When Reference Types Are the Same
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-4.3.4-100"></a>Two
                  reference types are the <span class="emphasis"><em>same compile-time type</em></span> if
                  they have the same binary name (<a class="xref" href="jls-13.html#jls-13.1" title="13.1.&nbsp;The Form of a Binary">&sect;13.1</a>) and their
                  type  arguments, if any, are the
                  same, applying this definition recursively.
               </p>
               <p class="norm"><a name="jls-4.3.4-110"></a>When two reference types are
                  the same, they are sometimes said to be the <span class="emphasis"><em>same
                        class</em></span> or the <span class="emphasis"><em>same interface</em></span>.
               </p>
               <p class="norm-dynamic"><a name="jls-4.3.4-200"></a>At run
                  time, several reference types with the same binary name may be loaded
                  simultaneously by different class loaders. These types may or may not
                  represent the same type declaration. Even if two such types do
                  represent the same type declaration, they are considered
                  distinct.
               </p>
               <p class="norm-dynamic"><a name="jls-4.3.4-300"></a>Two
                  reference types are the <span class="emphasis"><em>same run-time type</em></span>
                  if:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-4.3.4-310"></a>They
                                 are both class or both interface types, are defined by the same
                                 class loader, and have the same binary name
                                 (<a class="xref" href="jls-13.html#jls-13.1" title="13.1.&nbsp;The Form of a Binary">&sect;13.1</a>), in which case they are sometimes
                                 said to be the <span class="emphasis"><em>same run-time class</em></span> or
                                 the <span class="emphasis"><em>same run-time interface</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-4.3.4-320"></a>They
                                 are both array types, and their component types are the same
                                 run-time type (<a class="xref" href="jls-10.html" title="Chapter&nbsp;10.&nbsp;Arrays">&sect;10 (<i>Arrays</i>)</a>).
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
         </div>
         <div class="section" title="4.4.&nbsp;Type Variables">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-4.4"></a>4.4.&nbsp;Type Variables
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-4.4-100"></a>A <span class="emphasis"><em>type
                     variable</em></span> is an unqualified identifier used as a type in
               class, interface, method, and constructor bodies.
            </p>
            <p class="norm-static"><a name="jls-4.4-110"></a>A type
               variable is introduced by the declaration of a <span class="emphasis"><em>type
                     parameter</em></span> of a generic class, interface, method, or
               constructor (<a class="xref" href="jls-8.html#jls-8.1.2" title="8.1.2.&nbsp;Generic Classes and Type Parameters">&sect;8.1.2</a>, <a class="xref" href="jls-9.html#jls-9.1.2" title="9.1.2.&nbsp;Generic Interfaces and Type Parameters">&sect;9.1.2</a>,
               <a class="xref" href="jls-8.html#jls-8.4.4" title="8.4.4.&nbsp;Generic Methods">&sect;8.4.4</a>, <a class="xref" href="jls-8.html#jls-8.8.4" title="8.8.4.&nbsp;Generic Constructors">&sect;8.8.4</a>).
            </p>
            <div id="jls-4.4-120" class="productionset"><a name="jls-4.4-120"></a>
                 
               <div class="production"><a name="jls-TypeParameter"></a>
                      
                  <div class="lhs">TypeParameter:</div>
                      
                  <div class="rhs">
                           {<a href="jls-4.html#jls-TypeParameterModifier" title="TypeParameterModifier">TypeParameterModifier</a>}
                           <a href="jls-3.html#jls-Identifier" title="Identifier">Identifier</a>
                           [<a href="jls-4.html#jls-TypeBound" title="TypeBound">TypeBound</a>]
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-TypeParameterModifier"></a>
                      
                  <div class="lhs">TypeParameterModifier:</div>
                      
                  <div class="rhs">
                           <a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-TypeBound"></a>
                      
                  <div class="lhs">TypeBound:</div>
                      
                  <div class="rhs">
                           <code class="literal">extends</code> <a href="jls-4.html#jls-TypeVariable" title="TypeVariable">TypeVariable</a> <br>
                           <code class="literal">extends</code> <a href="jls-4.html#jls-ClassOrInterfaceType" title="ClassOrInterfaceType">ClassOrInterfaceType</a> {<a href="jls-4.html#jls-AdditionalBound" title="AdditionalBound">AdditionalBound</a>}
                         
                  </div>
                    
               </div>
               
                 
               <div class="production"><a name="jls-AdditionalBound"></a>
                      
                  <div class="lhs">AdditionalBound:</div>
                      
                  <div class="rhs">
                           <code class="literal">&amp;</code> <a href="jls-4.html#jls-InterfaceType" title="InterfaceType">InterfaceType</a>
                         
                  </div>
                    
               </div>
               
            </div>
            <p class="norm-static"><a name="jls-4.4-130"></a>The scope of
               a type variable declared as a type parameter is specified in
               <a class="xref" href="jls-6.html#jls-6.3" title="6.3.&nbsp;Scope of a Declaration">&sect;6.3</a>.
            </p>
            <p class="norm-static"><a name="jls-4.4-200"></a>Every type variable declared as a
               type parameter has a <span class="emphasis"><em>bound</em></span>. If no bound is
               declared for a type variable, <code class="literal">Object</code> is assumed. If a bound is
               declared, it consists of either:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.4-200-A"></a>a
                              single type variable <span class="type">T</span>, or
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.4-200-B"></a>a
                              class or interface type <span class="type">T</span> possibly followed by interface types
                              <span class="type">I<sub>1</sub></span> <code class="literal">&amp;</code> ... <code class="literal">&amp;</code> <span class="type">I<sub>n</sub></span>.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm-error"><a name="jls-4.4-210"></a>It is a
               compile-time error if any of the types <span class="type">I<sub>1</sub></span> ... <span class="type">I<sub>n</sub></span> is a class type
               or type variable.
            </p>
            <p class="norm-error"><a name="jls-4.4-220"></a>The erasures
               (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>) of all constituent types of a bound must
               be pairwise different, or a compile-time error occurs.
            </p>
            <p class="norm-error"><a name="jls-4.4-230"></a>A type
               variable must not at the same time be a subtype of two interface types
               which are different parameterizations of the same generic interface,
               or a compile-time error occurs.
            </p>
            <p class="norm-static"><a name="jls-4.4-240"></a>The order of
               types in a bound is only significant in that the erasure of a type
               variable is determined by the first type in its bound, and that a
               class type or type variable may only appear in the first
               position.
            </p>
            <p class="norm-static"><a name="jls-4.4-300"></a>The members
               of a type variable <span class="type">X</span> with bound <span class="type">T</span> <code class="literal">&amp;</code> <span class="type">I<sub>1</sub></span> <code class="literal">&amp;</code> ... <code class="literal">&amp;</code> <span class="type">I<sub>n</sub></span>
               are the members of the intersection type (<a class="xref" href="jls-4.html#jls-4.9" title="4.9.&nbsp;Intersection Types">&sect;4.9</a>)
               <span class="type">T</span> <code class="literal">&amp;</code> <span class="type">I<sub>1</sub></span> <code class="literal">&amp;</code> ... <code class="literal">&amp;</code> <span class="type">I<sub>n</sub></span> appearing at the point where the
               type variable is declared.
            </p>
            <div class="example"><a name="d5e2787"></a><p class="title"><b>Example&nbsp;4.4-1.&nbsp;Members of a Type Variable</b></p>
               <div class="example-contents"><pre class="programlisting">
package TypeVarMembers;

class C { 
    public    void mCPublic()    {}
    protected void mCProtected() {} 
              void mCPackage()   {}
    private   void mCPrivate()   {} 
} 

interface I {
    void mI();
}

class CT extends C implements I {
    public void mI() {}
}

class Test {
    &lt;T extends C &amp; I&gt; void test(T t) { 	
        t.mI();           // OK
        t.mCPublic();     // OK 
        t.mCProtected();  // OK 
        t.mCPackage();    // OK
        t.mCPrivate();    // Compile-time error
    } 
}
</pre><p class="note">The type variable <code class="literal">T</code> has the same
                     members as the intersection type <code class="literal">C &amp; I</code>, which
                     in turn has the same members as the empty class <code class="literal">CT</code>,
                     defined in the same scope with equivalent supertypes. The members of
                     an interface are always <code class="literal">public</code>, and therefore always inherited
                     (unless overridden). Hence <code class="literal">mI</code> is a member
                     of <code class="literal">CT</code> and of <code class="literal">T</code>. Among the
                     members of <code class="literal">C</code>, all but <code class="literal">mCPrivate</code>
                     are inherited by <code class="literal">CT</code>, and are therefore members of
                     both <code class="literal">CT</code> and <code class="literal">T</code>.
                  </p>
                  <p class="note">If <code class="literal">C</code> had been declared in a
                     different package than <code class="literal">T</code>, then the call
                     to <code class="literal">mCPackage</code> would give rise to a compile-time
                     error, as that member would not be accessible at the point
                     where <code class="literal">T</code> is declared.
                  </p>
               </div>
            </div><br class="example-break"></div>
         <div class="section" title="4.5.&nbsp;Parameterized Types">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-4.5"></a>4.5.&nbsp;Parameterized Types
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-4.5-100"></a>A class or
               interface declaration that is generic (<a class="xref" href="jls-8.html#jls-8.1.2" title="8.1.2.&nbsp;Generic Classes and Type Parameters">&sect;8.1.2</a>,
               <a class="xref" href="jls-9.html#jls-9.1.2" title="9.1.2.&nbsp;Generic Interfaces and Type Parameters">&sect;9.1.2</a>) defines a set of <span class="emphasis"><em>parameterized
                     types</em></span>.
            </p>
            <p class="norm-static"><a name="jls-4.5-110"></a>A
               parameterized type is a class or interface type of the form
               <span class="type">C</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>,...,<span class="type">T<sub>n</sub></span><code class="literal">&gt;</code>, where <span class="type">C</span> is the name of a generic
               type and <code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>,...,<span class="type">T<sub>n</sub></span><code class="literal">&gt;</code> is a list of type arguments
               that denote a particular <span class="emphasis"><em>parameterization</em></span> of the
               generic type.
            </p>
            <p class="norm-static"><a name="jls-4.5-120"></a>A generic
               type has type parameters <span class="type">F<sub>1</sub></span>,...,<span class="type">F<sub>n</sub></span> with corresponding bounds
               <span class="type">B<sub>1</sub></span>,...,<span class="type">B<sub>n</sub></span>. Each type argument <span class="type">T<sub>i</sub></span> of a parameterized type ranges
               over all types that are subtypes of all types listed in the
               corresponding bound. That is, for each bound type <span class="type">S</span> in <span class="type">B<sub>i</sub></span>, <span class="type">T<sub>i</sub></span> is
               a subtype of <span class="type">S</span><code class="literal">[<span class="type">F<sub>1</sub></span>:=<span class="type">T<sub>1</sub></span>,...,<span class="type">F<sub>n</sub></span>:=<span class="type">T<sub>n</sub></span>]</code>
               (<a class="xref" href="jls-4.html#jls-4.10" title="4.10.&nbsp;Subtyping">&sect;4.10</a>).
            </p>
            <p class="norm-static"><a name="jls-4.5-200"></a>A
               parameterized type <span class="type">C</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>,...,<span class="type">T<sub>n</sub></span><code class="literal">&gt;</code>
               is <span class="emphasis"><em>well-formed</em></span> if all of the following are
               true:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.5-200-A"></a>
                              <span class="type">C</span> is the name of a generic type.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.5-200-B"></a>
                              The number of type arguments is the same as the number of type
                              parameters in the generic declaration of <span class="type">C</span>.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.5-200-C"></a>
                              When subjected to capture conversion
                              (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>) resulting in the type
                              <span class="type">C</span><code class="literal">&lt;</code><span class="type">X<sub>1</sub></span>,...,<span class="type">X<sub>n</sub></span><code class="literal">&gt;</code>, each type argument <span class="type">X<sub>i</sub></span> is a
                              subtype of <span class="type">S</span><code class="literal">[<span class="type">F<sub>1</sub></span>:=<span class="type">X<sub>1</sub></span>,...,<span class="type">F<sub>n</sub></span>:=<span class="type">X<sub>n</sub></span>]</code> for
                              each bound type <span class="type">S</span> in <span class="type">B<sub>i</sub></span>.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm-error"><a name="jls-4.5-210"></a>It is a
               compile-time error if a parameterized type is not well-formed.
            </p>
            <p class="norm"><a name="jls-4.5-220"></a>In this specification, whenever
               we speak of a class or interface type, we include the generic version
               as well, unless explicitly excluded.
            </p>
            <p class="norm-static"><a name="jls-4.5-400"></a>Two
               parameterized types are <span class="emphasis"><em>provably distinct</em></span> if
               either of the following is true:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.5-400-A"></a>
                              They are parameterizations of distinct generic type
                              declarations.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.5-400-B"></a>
                              Any of their type arguments are provably distinct.
                     </p>
                  </li>
               </ul>
            </div>
            <div class="informalexample">
               <p class="note">Given the generic types in the examples of
                  <a class="xref" href="jls-8.html#jls-8.1.2" title="8.1.2.&nbsp;Generic Classes and Type Parameters">&sect;8.1.2</a>, here are some well-formed parameterized
                  types:
               </p>
               <div class="note">
                  <ul class="note" type="disc">
                     <li class="listitem">
                        <p class="note"><code class="literal">Seq&lt;String&gt;</code></p>
                     </li>
                     <li class="listitem">
                        <p class="note"><code class="literal">Seq&lt;Seq&lt;String&gt;&gt;</code></p>
                     </li>
                     <li class="listitem">
                        <p class="note"><code class="literal">Seq&lt;String&gt;.Zipper&lt;Integer&gt;</code></p>
                     </li>
                     <li class="listitem">
                        <p class="note"><code class="literal">Pair&lt;String,Integer&gt;</code></p>
                     </li>
                  </ul>
               </div>
               <p class="note">Here are some incorrect parameterizations of those generic
                  types:
               </p>
               <div class="note">
                  <ul class="note" type="disc">
                     <li class="listitem">
                        <p class="note"><code class="literal">Seq&lt;int&gt;</code> is illegal, as
                                 primitive types cannot be type arguments.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="note"><code class="literal">Pair&lt;String&gt;</code> is
                                 illegal, as there are not enough type arguments.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="note"><code class="literal">Pair&lt;String,String,String&gt;</code>
                                 is illegal, as there are too many type arguments.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <p class="note">A parameterized type may be an parameterization of a
               generic class or interface which is nested. For example, if a
               non-generic class <span class="type">C</span> has a generic member class
               <span class="type">D</span><code class="literal">&lt;</code><span class="type">T</span><code class="literal">&gt;</code>, then <span class="type">C</span><code class="literal">.</code><span class="type">D</span><code class="literal">&lt;</code><code class="literal">Object</code><code class="literal">&gt;</code> is a
               parameterized type. And if a generic class <span class="type">C</span><code class="literal">&lt;</code><span class="type">T</span><code class="literal">&gt;</code> has
               a non-generic member class <span class="type">D</span>, then the member type
               <span class="type">C</span><code class="literal">&lt;</code><code class="literal">String</code><code class="literal">&gt;</code><code class="literal">.</code><span class="type">D</span> is a parameterized type, even
               though the class <span class="type">D</span> is not generic.
            </p>
            <div class="section" title="4.5.1.&nbsp;Type Arguments of Parameterized Types">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.5.1"></a>4.5.1.&nbsp;Type Arguments of Parameterized Types
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-4.5.1-100"></a>Type
                  arguments may be either reference types or wildcards. Wildcards are
                  useful in situations where only partial knowledge about the type
                  parameter is required.
               </p>
               <div id="jls-4.5.1-110" class="productionset"><a name="jls-4.5.1-110"></a>
                    
                  <div class="production"><a name="jls-TypeArguments"></a>
                         
                     <div class="lhs">TypeArguments:</div>
                         
                     <div class="rhs">
                              <code class="literal">&lt;</code> <a href="jls-4.html#jls-TypeArgumentList" title="TypeArgumentList">TypeArgumentList</a> <code class="literal">&gt;</code>
                            
                     </div>
                       
                  </div>
                  
                    
                  <div class="production"><a name="jls-TypeArgumentList"></a>
                         
                     <div class="lhs">TypeArgumentList:</div>
                         
                     <div class="rhs">
                              <a href="jls-4.html#jls-TypeArgument" title="TypeArgument">TypeArgument</a> {<code class="literal">,</code> <a href="jls-4.html#jls-TypeArgument" title="TypeArgument">TypeArgument</a>}
                            
                     </div>
                       
                  </div>
                  
                    
                  <div class="production"><a name="jls-TypeArgument"></a>
                         
                     <div class="lhs">TypeArgument:</div>
                         
                     <div class="rhs">
                              <a href="jls-4.html#jls-ReferenceType" title="ReferenceType">ReferenceType</a> <br>
                              <a href="jls-4.html#jls-Wildcard" title="Wildcard">Wildcard</a>
                            
                     </div>
                       
                  </div>
                  
                    
                  <div class="production"><a name="jls-Wildcard"></a>
                         
                     <div class="lhs">Wildcard:</div>
                         
                     <div class="rhs">
                              {<a href="jls-9.html#jls-Annotation" title="Annotation">Annotation</a>} <code class="literal">?</code> [<a href="jls-4.html#jls-WildcardBounds" title="WildcardBounds">WildcardBounds</a>]
                            
                     </div>
                       
                  </div>
                  
                    
                  <div class="production"><a name="jls-WildcardBounds"></a>
                         
                     <div class="lhs">WildcardBounds:</div>
                         
                     <div class="rhs">
                              <code class="literal">extends</code> <a href="jls-4.html#jls-ReferenceType" title="ReferenceType">ReferenceType</a> <br>
                              <code class="literal">super</code> <a href="jls-4.html#jls-ReferenceType" title="ReferenceType">ReferenceType</a>
                            
                     </div>
                       
                  </div>
                  
               </div>
               <p class="norm-static"><a name="jls-4.5.1-200"></a>Wildcards
                  may be given explicit bounds, just like regular type variable
                  declarations. An upper bound is signified by the following syntax,
                  where <span class="type">B</span> is the bound:
               </p><pre class="screen">? extends <span class="type">B</span></pre><p class="norm-static"><a name="jls-4.5.1-210"></a>Unlike
                  ordinary type variables declared in a method signature, no type
                  inference is required when using a wildcard. Consequently, it is
                  permissible to declare lower bounds on a wildcard, using the following
                  syntax, where <span class="type">B</span> is a lower bound:
               </p><pre class="screen">? super <span class="type">B</span></pre><p class="norm-static"><a name="jls-4.5.1-220"></a>The wildcard
                  <code class="literal">?</code> <code class="literal">extends</code> <code class="literal">Object</code> is equivalent to the unbounded wildcard
                  <code class="literal">?</code>.
               </p>
               <p class="norm-static"><a name="jls-4.5.1-300"></a>Two type
                  arguments are <span class="emphasis"><em>provably distinct</em></span> if one of the
                  following is true:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.5.1-300-A"></a>Neither argument is a type variable or
                               wildcard, and the two arguments are not the same type.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.5.1-300-B"></a>One type argument is a type
                               variable or wildcard, with an upper bound (from capture conversion
                               (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>), if necessary) of <span class="type">S</span>; and the
                               other type argument <span class="type">T</span> is not a type variable or wildcard; and
                               neither |<span class="type">S</span>| <code class="literal">&lt;:</code> |<span class="type">T</span>| nor |<span class="type">T</span>| <code class="literal">&lt;:</code> |<span class="type">S</span>|
                               (<a class="xref" href="jls-4.html#jls-4.8" title="4.8.&nbsp;Raw Types">&sect;4.8</a>, <a class="xref" href="jls-4.html#jls-4.10" title="4.10.&nbsp;Subtyping">&sect;4.10</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.5.1-300-C"></a>Each type argument is a type
                               variable or wildcard, with upper bounds (from capture conversion,
                               if necessary) of <span class="type">S</span> and <span class="type">T</span>; and neither |<span class="type">S</span>| <code class="literal">&lt;:</code> |<span class="type">T</span>|
                               nor |<span class="type">T</span>| <code class="literal">&lt;:</code> |<span class="type">S</span>|.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-4.5.1-400"></a>A type argument
                  <span class="type">T<sub>1</sub></span> is said to <span class="emphasis"><em>contain</em></span> another type argument
                  <span class="type">T<sub>2</sub></span>, written <span class="type">T<sub>2</sub></span> <code class="literal">&lt;=</code> <span class="type">T<sub>1</sub></span>, if the set of types denoted by
                  <span class="type">T<sub>2</sub></span> is provably a subset of the set of types denoted by <span class="type">T<sub>1</sub></span>
                  under the reflexive and transitive closure of the
                  following rules (where <code class="literal">&lt;:</code> denotes subtyping
                  (<a class="xref" href="jls-4.html#jls-4.10" title="4.10.&nbsp;Subtyping">&sect;4.10</a>)):
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.5.1-400-A"></a>
                                 <code class="literal">?</code> <code class="literal">extends</code> <span class="type">T</span> <code class="literal">&lt;=</code> <code class="literal">?</code> <code class="literal">extends</code> <span class="type">S</span> if <span class="type">T</span> <code class="literal">&lt;:</code> <span class="type">S</span></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.5.1-400-B"></a>
                                 <code class="literal">?</code> <code class="literal">extends</code> <span class="type">T</span> <code class="literal">&lt;=</code> <code class="literal">?</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.5.1-400-C"></a>
                                 <code class="literal">?</code> <code class="literal">super</code> <span class="type">T</span> <code class="literal">&lt;=</code> <code class="literal">?</code> <code class="literal">super</code> <span class="type">S</span> if <span class="type">S</span> <code class="literal">&lt;:</code> <span class="type">T</span></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.5.1-400-D"></a>
                                 <code class="literal">?</code> <code class="literal">super</code> <span class="type">T</span> <code class="literal">&lt;=</code> <code class="literal">?</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.5.1-400-E"></a>
                                 <code class="literal">?</code> <code class="literal">super</code> <span class="type">T</span> <code class="literal">&lt;=</code> <code class="literal">?</code> <code class="literal">extends</code> <code class="literal">Object</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.5.1-400-F"></a>
                                 <span class="type">T</span> <code class="literal">&lt;=</code> <span class="type">T</span></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.5.1-400-G"></a>
                                 <span class="type">T</span> <code class="literal">&lt;=</code> <code class="literal">?</code> <code class="literal">extends</code> <span class="type">T</span></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.5.1-400-H"></a>
                                 <span class="type">T</span> <code class="literal">&lt;=</code> <code class="literal">?</code> <code class="literal">super</code> <span class="type">T</span></p>
                     </li>
                  </ul>
               </div>
               <p class="note">The relationship of wildcards to established type
                  theory is an interesting one, which we briefly allude to
                  here. Wildcards are a restricted form of existential types. Given a
                  generic type declaration <span class="type">G</span><code class="literal">&lt;</code><span class="type">T</span> <code class="literal">extends</code> <span class="type">B</span><code class="literal">&gt;</code>,
                  <span class="type">G</span><code class="literal">&lt;</code><code class="literal">?</code><code class="literal">&gt;</code> is roughly analogous to <span class="type">Some <span class="type">X</span>
                     <code class="literal">&lt;:</code> <span class="type">B</span>. <span class="type">G</span><code class="literal">&lt;</code><span class="type">X</span><code class="literal">&gt;</code></span>.
               </p>
               <p class="note">Historically, wildcards are a direct descendant of
                  the work by Atsushi Igarashi and Mirko Viroli. Readers interested in a
                  more comprehensive discussion should refer to <em class="citetitle">On
                     Variance-Based Subtyping for Parametric Types</em> by Atsushi
                  Igarashi and Mirko Viroli, in the
                  <em class="citetitle">Proceedings of the 16th European Conference on Object
                     Oriented Programming (ECOOP 2002)</em>. This work itself builds
                  upon earlier work by Kresten Thorup and Mads Torgersen
                  (<em class="citetitle">Unifying Genericity</em>, ECOOP 99), as well as a
                  long tradition of work on declaration based variance that goes back to
                  Pierre America's work on POOL (OOPSLA 89).
               </p>
               <p class="note">Wildcards differ in certain details from the
                  constructs described in the aforementioned paper, in particular in the
                  use of capture conversion (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>) rather than
                  the <code class="literal">close</code> operation described by Igarashi and
                  Viroli. For a formal account of wildcards, see <em class="citetitle">Wild
                     FJ</em> by Mads Torgersen, Erik Ernst and Christian Plesner
                  Hansen, in the 12th workshop on Foundations of Object Oriented
                  Programming (FOOL 2005).
               </p>
               <div class="example"><a name="d5e3144"></a><p class="title"><b>Example&nbsp;4.5.1-1.&nbsp;Unbounded Wildcards</b></p>
                  <div class="example-contents"><pre class="programlisting">
import java.util.Collection;
import java.util.ArrayList;

class Test {
    static void printCollection(Collection&lt;?&gt; c) {
                                // a wildcard collection
        for (Object o : c) {
            System.out.println(o);
        }
    }

    public static void main(String[] args) {
        Collection&lt;String&gt; cs = new ArrayList&lt;String&gt;();
        cs.add("hello");
        cs.add("world");
        printCollection(cs);
    }
}
</pre><p class="note">Note that using
                        <code class="literal">Collection&lt;Object&gt;</code> as the type of the
                        incoming parameter, <code class="literal">c</code>, would not be nearly as
                        useful; the method could only be used with an argument expression that
                        had type <code class="literal">Collection&lt;Object&gt;</code>, which would be
                        quite rare. In contrast, the use of an unbounded wildcard allows any
                        kind of collection to be passed as an argument.
                     </p>
                     <p class="note">Here is an example where the element type of an
                        array is parameterized by a wildcard:
                     </p><pre class="programlisting">

public Method getMethod(Class&lt;?&gt;[] parameterTypes) { ... }

</pre></div>
               </div><br class="example-break"><div class="example"><a name="d5e3153"></a><p class="title"><b>Example&nbsp;4.5.1-2.&nbsp;Bounded Wildcards</b></p>
                  <div class="example-contents"><pre class="screen">boolean addAll(Collection&lt;? extends E&gt; c)</pre><p class="note">Here, the method is declared within the
                        interface <code class="literal">Collection&lt;E&gt;</code>, and is designed to
                        add all the elements of its incoming argument to the collection upon
                        which it is invoked. A natural tendency would be to use
                        <code class="literal">Collection&lt;E&gt;</code> as the type
                        of <code class="literal">c</code>, but this is unnecessarily restrictive. An
                        alternative would be to declare the method itself to be
                        generic:
                     </p><pre class="screen">&lt;T&gt; boolean addAll(Collection&lt;T&gt; c)</pre><p class="note">This version is sufficiently flexible, but note that
                        the type parameter is used only once in the signature. This reflects
                        the fact that the type parameter is not being used to express any kind
                        of interdependency between the type(s) of the argument(s), the return
                        type and/or throws type. In the absence of such interdependency,
                        generic methods are considered bad style, and wildcards are
                        preferred.
                     </p><pre class="screen">Reference(T referent, ReferenceQueue&lt;? super T&gt; queue)</pre><p class="note">Here, the referent can be inserted into any queue
                        whose element type is a supertype of the type <code class="literal">T</code> of
                        the referent; <code class="literal">T</code> is the lower bound for the
                        wildcard.
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="4.5.2.&nbsp;Members and Constructors of Parameterized Types">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.5.2"></a>4.5.2.&nbsp;Members and Constructors of Parameterized Types
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-4.5.2-100"></a>Let <span class="type">C</span> be
                  a generic class or interface declaration with type parameters
                  <span class="type">A<sub>1</sub></span>,...,<span class="type">A<sub>n</sub></span>, and let <span class="type">C</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>,...,<span class="type">T<sub>n</sub></span><code class="literal">&gt;</code> be a
                  parameterization of <span class="type">C</span> where, for 1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>, <span class="type">T<sub>i</sub></span>
                  is a type (rather than a wildcard). Then:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.5.2-100-A"></a>Let
                                 <code class="varname">m</code> be a member or constructor declaration in <span class="type">C</span>, whose type as
                                 declared is <span class="type">T</span> (<a class="xref" href="jls-8.html#jls-8.2" title="8.2.&nbsp;Class Members">&sect;8.2</a>,
                                 <a class="xref" href="jls-8.html#jls-8.8.6" title="8.8.6.&nbsp;The Type of a Constructor">&sect;8.8.6</a>).
                        </p>
                        <p class="norm-static"><a name="jls-4.5.2-100-A.1"></a>The type of <code class="varname">m</code> in
                                 <span class="type">C</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>,...,<span class="type">T<sub>n</sub></span><code class="literal">&gt;</code> is
                                 <span class="type">T</span><code class="literal">[<span class="type">A<sub>1</sub></span>:=<span class="type">T<sub>1</sub></span>,...,<span class="type">A<sub>n</sub></span>:=<span class="type">T<sub>n</sub></span>]</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.5.2-100-B"></a>Let <code class="varname">m</code> be a member or
                                 constructor declaration in <span class="type">D</span>, where <span class="type">D</span> is a class extended by
                                 <span class="type">C</span> or an interface implemented by <span class="type">C</span>. Let
                                 <span class="type">D</span><code class="literal">&lt;</code><span class="type">U<sub>1</sub></span>,...,<span class="type">U<sub>k</sub></span><code class="literal">&gt;</code> be the supertype of
                                 <span class="type">C</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>,...,<span class="type">T<sub>n</sub></span><code class="literal">&gt;</code> that corresponds to <span class="type">D</span>.
                        </p>
                        <p class="norm-static"><a name="jls-4.5.2-100-B.1"></a>The type of <code class="varname">m</code> in
                                 <span class="type">C</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>,...,<span class="type">T<sub>n</sub></span><code class="literal">&gt;</code> is the type of <code class="varname">m</code> in
                                 <span class="type">D</span><code class="literal">&lt;</code><span class="type">U<sub>1</sub></span>,...,<span class="type">U<sub>k</sub></span><code class="literal">&gt;</code>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-4.5.2-200"></a>If any of
                  the type arguments in the parameterization of <span class="type">C</span> are wildcards,
                  then:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.5.2-200-A"></a>The
                                 types of the fields, methods, and constructors in
                                 <span class="type">C</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>,...,<span class="type">T<sub>n</sub></span><code class="literal">&gt;</code> are  
                                 the types of the fields, methods, and constructors in the
                                 capture conversion of <span class="type">C</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>,...,<span class="type">T<sub>n</sub></span><code class="literal">&gt;</code>
                                 (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.5.2-200-B"></a>Let <span class="type">D</span> be a (possibly
                                 generic) class or interface declaration in <span class="type">C</span>. Then the type of
                                 <span class="type">D</span> in <span class="type">C</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>,...,<span class="type">T<sub>n</sub></span><code class="literal">&gt;</code> is <span class="type">D</span> where, if <span class="type">D</span> is
                                 generic, all type arguments are unbounded wildcards.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="note">This is of no consequence, as it is impossible to
                  access a member of a parameterized type without performing capture
                  conversion, and it is impossible to use a wildcard after the keyword
                  <code class="literal">new</code> in a class instance creation expression
                  (<a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>).
               </p>
               <p class="note">The sole exception
                  to the previous paragraph is when a nested parameterized type is used
                  as the expression in an <code class="literal">instanceof</code> operator
                  (<a class="xref" href="jls-15.html#jls-15.20.2" title="15.20.2.&nbsp;Type Comparison Operator instanceof">&sect;15.20.2</a>), where capture conversion is not
                  applied.
               </p>
               <p class="norm-error"><a name="jls-4.5.2-300"></a>A <code class="literal">static</code>
                  member that is declared in a generic type declaration must be referred
                  to using the non-generic type that corresponds to the generic type
                  (<a class="xref" href="jls-6.html#jls-6.1" title="6.1.&nbsp;Declarations">&sect;6.1</a>, <a class="xref" href="jls-6.html#jls-6.5.5.2" title="6.5.5.2.&nbsp;Qualified Type Names">&sect;6.5.5.2</a>,
                  <a class="xref" href="jls-6.html#jls-6.5.6.2" title="6.5.6.2.&nbsp;Qualified Expression Names">&sect;6.5.6.2</a>), or a compile-time error occurs.
               </p>
               <p class="note">In other words, it is illegal to refer to a <code class="literal">static</code>
                  member declared in a generic type declaration by using a parameterized
                  type.
               </p>
            </div>
         </div>
         <div class="section" title="4.6.&nbsp;Type Erasure">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-4.6"></a>4.6.&nbsp;Type Erasure
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-4.6-100"></a>Type erasure
               is a mapping from types (possibly including parameterized types and
               type variables) to types (that are never parameterized types or type
               variables). We write |<span class="type">T</span>| for the erasure of type <span class="type">T</span>. The erasure
               mapping is defined as follows:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.6-100-A"></a>The
                            erasure of a parameterized type (<a class="xref" href="jls-4.html#jls-4.5" title="4.5.&nbsp;Parameterized Types">&sect;4.5</a>)
                            <span class="type">G</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>,...,<span class="type">T<sub>n</sub></span><code class="literal">&gt;</code> is |<span class="type">G</span>|.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.6-100-B"></a>The
                            erasure of a nested type <span class="type">T</span><code class="literal">.</code><span class="type">C</span> is |<span class="type">T</span>|.<span class="type">C</span>.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.6-100-C"></a>The
                            erasure of an array type <span class="type">T</span><code class="literal">[]</code> is |<span class="type">T</span>|<code class="literal">[]</code>.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.6-100-D"></a>The
                            erasure of a type variable (<a class="xref" href="jls-4.html#jls-4.4" title="4.4.&nbsp;Type Variables">&sect;4.4</a>) is the
                            erasure of its leftmost bound.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.6-100-E"></a>The
                            erasure of every other type is the type itself.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm-static"><a name="jls-4.6-200"></a>Type erasure
               also maps the signature (<a class="xref" href="jls-8.html#jls-8.4.2" title="8.4.2.&nbsp;Method Signature">&sect;8.4.2</a>) of a constructor
               or method to a signature that has no parameterized types or type
               variables. The erasure of a constructor or method
               signature <span class="type">s</span> is a signature consisting of the same name
               as <span class="type">s</span> and the erasures of all the formal parameter types
               given in <span class="type">s</span>.
            </p>
            <p class="norm-static"><a name="jls-4.6-210"></a>The return
               type of a method (<a class="xref" href="jls-8.html#jls-8.4.5" title="8.4.5.&nbsp;Method Result">&sect;8.4.5</a>) and the type parameters
               of a generic method or constructor (<a class="xref" href="jls-8.html#jls-8.4.4" title="8.4.4.&nbsp;Generic Methods">&sect;8.4.4</a>,
               <a class="xref" href="jls-8.html#jls-8.8.4" title="8.8.4.&nbsp;Generic Constructors">&sect;8.8.4</a>) also undergo erasure if the method or
               constructor's signature is erased.
            </p>
            <p class="norm-static"><a name="jls-4.6-220"></a>The erasure of
               the signature of a generic method has no type parameters.
            </p>
         </div>
         <div class="section" title="4.7.&nbsp;Reifiable Types">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-4.7"></a>4.7.&nbsp;Reifiable Types
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-4.7-100"></a>Because some type information
               is erased during compilation, not all types are available at run
               time. Types that are completely available at run time are known
               as <span class="emphasis"><em>reifiable types</em></span>.
            </p>
            <p class="norm-static"><a name="jls-4.7-110"></a>A type
               is <span class="emphasis"><em>reifiable</em></span> if and only if one of the following
               holds:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.7-110-A"></a>It
                            refers to a non-generic class or interface
                            type declaration.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.7-110-B"></a>It is
                            a parameterized type in which all type arguments are unbounded
                            wildcards (<a class="xref" href="jls-4.html#jls-4.5.1" title="4.5.1.&nbsp;Type Arguments of Parameterized Types">&sect;4.5.1</a>).
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.7-110-C"></a>It is
                            a raw type (<a class="xref" href="jls-4.html#jls-4.8" title="4.8.&nbsp;Raw Types">&sect;4.8</a>).
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.7-110-D"></a>It is
                            a primitive type (<a class="xref" href="jls-4.html#jls-4.2" title="4.2.&nbsp;Primitive Types and Values">&sect;4.2</a>).
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.7-110-E"></a>It is
                            an array type (<a class="xref" href="jls-10.html#jls-10.1" title="10.1.&nbsp;Array Types">&sect;10.1</a>)
                            whose  element type is
                            reifiable.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.7-110-F"></a>It is a
                              nested type where, for each type <span class="type">T</span> separated by a "<code class="literal">.</code>", <span class="type">T</span>
                              itself is reifiable.
                     </p>
                     <p class="note">For example,
                              if a generic class <span class="type">X</span><code class="literal">&lt;</code><span class="type">T</span><code class="literal">&gt;</code> has a generic member
                              class <span class="type">Y</span><code class="literal">&lt;</code><span class="type">U</span><code class="literal">&gt;</code>, then the type
                              <span class="type">X</span><code class="literal">&lt;</code><code class="literal">?</code><code class="literal">&gt;</code><code class="literal">.</code><span class="type">Y</span><code class="literal">&lt;</code><code class="literal">?</code><code class="literal">&gt;</code> is
                              reifiable because <span class="type">X</span><code class="literal">&lt;</code><code class="literal">?</code><code class="literal">&gt;</code> is reifiable and
                              <span class="type">Y</span><code class="literal">&lt;</code><code class="literal">?</code><code class="literal">&gt;</code> is reifiable. The type
                              <span class="type">X</span><code class="literal">&lt;</code><code class="literal">?</code><code class="literal">&gt;</code><code class="literal">.</code><span class="type">Y</span><code class="literal">&lt;</code><code class="literal">Object</code><code class="literal">&gt;</code> is not
                              reifiable because <span class="type">Y</span><code class="literal">&lt;</code><code class="literal">Object</code><code class="literal">&gt;</code> is not
                              reifiable.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm-static"><a name="jls-4.7-120"></a>An intersection
               type is not reifiable.
            </p>
            <p class="note">The decision not to make all generic types reifiable
               is one of the most crucial, and controversial design decisions
               involving the type system of the Java programming language.
            </p>
            <p class="note">Ultimately, the most important motivation for this
               decision is compatibility with existing code. In a naive sense, the
               addition of new constructs such as generics has no implications for
               pre-existing code. The Java programming language, per se, is compatible with earlier
               versions as long as every program written in the previous versions
               retains its meaning in the new version. However, this notion, which
               may be termed language compatibility, is of purely theoretical
               interest. Real programs (even trivial ones, such as "Hello World") are
               composed of several compilation units, some of which are provided by
               the Java SE platform (such as elements of <code class="literal">java.lang</code> or <code class="literal">java.util</code>). In
               practice, then, the minimum requirement is platform compatibility -
               that any program written for the prior version of the Java SE platform
               continues to function unchanged in the new version.
            </p>
            <p class="note">One way to provide platform compatibility is to
               leave existing platform functionality unchanged, only adding new
               functionality. For example, rather than modify the existing
               Collections hierarchy in <code class="literal">java.util</code>, one might introduce a new library
               utilizing generics.
            </p>
            <p class="note">The disadvantages of such a scheme is that it is
               extremely difficult for pre-existing clients of the Collection library
               to migrate to the new library. Collections are used to exchange data
               between independently developed modules; if a vendor decides to switch
               to the new, generic, library, that vendor must also distribute two
               versions of their code, to be compatible with their clients. Libraries
               that are dependent on other vendors code cannot be modified to use
               generics until the supplier's library is updated. If two modules are
               mutually dependent, the changes must be made simultaneously. 
            </p>
            <p class="note">Clearly, platform compatibility, as outlined above,
               does not provide a realistic path for adoption of a pervasive new
               feature such as generics. Therefore, the design of the generic type
               system seeks to support migration compatibility. Migration
               compatibiliy allows the evolution of existing code to take advantage
               of generics without imposing dependencies between independently
               developed software modules.
            </p>
            <p class="note">The price of migration compatibility is that a full
               and sound reification of the generic type system is not possible, at
               least while the migration is taking place.
            </p>
         </div>
         <div class="section" title="4.8.&nbsp;Raw Types">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-4.8"></a>4.8.&nbsp;Raw Types
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-4.8-100"></a>To facilitate
               interfacing with non-generic legacy code, it is possible to use as a
               type the erasure (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>) of a parameterized type
               (<a class="xref" href="jls-4.html#jls-4.5" title="4.5.&nbsp;Parameterized Types">&sect;4.5</a>) or the erasure of an array type
               (<a class="xref" href="jls-10.html#jls-10.1" title="10.1.&nbsp;Array Types">&sect;10.1</a>) whose element type is a parameterized
               type. Such a type is called a <span class="emphasis"><em>raw
                     type</em></span>.
            </p>
            <p class="norm-static"><a name="jls-4.8-110"></a>More
               precisely, a raw type is defined to be one of:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.8-110-A"></a>
                              The reference type that is formed by taking the name of a
                              generic type declaration without an accompanying type argument
                              list.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.8-110-B"></a>
                              An array type whose element type is a raw type.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.8-110-C"></a>
                              A non-<code class="literal">static</code> member type of a raw type <span class="type">R</span> that is not inherited
                              from a superclass or superinterface of <span class="type">R</span>.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm-static"><a name="jls-4.8-120"></a>A non-generic class or interface
               type is not a raw type.
            </p>
            <div class="informalexample">
               <p class="note">To see why a non-<code class="literal">static</code> type member of a raw type
                  is considered raw, consider the following example:
               </p><pre class="programlisting">
class Outer&lt;T&gt;{
    T t;
    class Inner {
        T setOuterT(T t1) { t = t1; return t; }
    }
}
</pre><p class="note">The type of the member(s)
                  of <code class="literal">Inner</code> depends on the type parameter
                  of <code class="literal">Outer</code>. If <code class="literal">Outer</code> is raw,
                  <code class="literal">Inner</code> must be treated as raw as well, as there is
                  no valid binding for <code class="literal">T</code>.
               </p>
               <p class="note">This rule applies only to type members that are not
                  inherited. Inherited type members that depend on type variables will
                  be inherited as raw types as a consequence of the rule that the
                  supertypes of a raw type are erased, described later in this
                  section.
               </p>
               <p class="note">Another implication of the rules above is that a
                  generic inner class of a raw type can itself only be used as a raw
                  type:
               </p><pre class="programlisting">
class Outer&lt;T&gt;{
    class Inner&lt;S&gt; {
        S s;
    }
}
</pre><p class="note">It is not possible to access
                  <code class="literal">Inner</code> as a partially raw type (a "rare"
                  type):
               </p><pre class="screen">
Outer.Inner&lt;Double&gt; x = null;  // illegal
Double d = x.s;
</pre><p class="note">because <code class="literal">Outer</code> itself is raw,
                  hence so are all its inner classes including <code class="literal">Inner</code>,
                  and so it is not possible to pass any type arguments to Inner.
               </p>
            </div>
            <p class="norm-static"><a name="jls-4.8-200"></a>The
               superclasses (respectively, superinterfaces) of a raw type are the
               erasures of the superclasses (superinterfaces) of any of the
               parameterizations of the generic type.
            </p>
            <p class="norm-static"><a name="jls-4.8-210"></a>The type of a constructor
               (<a class="xref" href="jls-8.html#jls-8.8" title="8.8.&nbsp;Constructor Declarations">&sect;8.8</a>), instance method
               (<a class="xref" href="jls-8.html#jls-8.4" title="8.4.&nbsp;Method Declarations">&sect;8.4</a>, <a class="xref" href="jls-9.html#jls-9.4" title="9.4.&nbsp;Method Declarations">&sect;9.4</a>), or
               non-<code class="literal">static</code> field (<a class="xref" href="jls-8.html#jls-8.3" title="8.3.&nbsp;Field Declarations">&sect;8.3</a>) of a raw type <span class="type">C</span> that
               is not inherited from its superclasses or superinterfaces
               is the raw type that corresponds to the erasure of
               its type in the generic declaration corresponding to <span class="type">C</span>.
            </p>
            <p class="norm-static"><a name="jls-4.8-220"></a>The type of
               a <code class="literal">static</code> method or <code class="literal">static</code> field of a raw type <span class="type">C</span> is the same as
               its type in the generic declaration corresponding to <span class="type">C</span>.
            </p>
            <p class="norm-error"><a name="jls-4.8-300"></a>It is a
               compile-time error to pass type arguments to a non-<code class="literal">static</code> type
               member of a raw type that is not inherited from its superclasses or
               superinterfaces.
            </p>
            <p class="norm-error"><a name="jls-4.8-310"></a>It is a
               compile-time error to attempt to use a type member of a parameterized
               type as a raw type.
            </p>
            <div class="informalexample">
               <p class="note">This means that the ban on "rare" types extends to
                  the case where the qualifying type is parameterized, but we attempt to
                  use the inner class as a raw type:
               </p><pre class="screen">
Outer&lt;Integer&gt;.Inner x = null; // illegal
</pre><p class="note">This is the opposite of the case discussed
                  above. There is no practical justification for this half-baked
                  type. In legacy code, no type arguments are used. In non-legacy code,
                  we should use the generic types correctly and pass all the required
                  type arguments.
               </p>
            </div>
            <p class="norm-static"><a name="jls-4.8-400"></a>The
               supertype of a class may be a raw type. Member accesses for the class
               are treated as normal, and member accesses for the supertype are
               treated as for raw types. In the constructor of the class, calls to
               <code class="literal">super</code> are treated as method calls on a raw type.
            </p>
            <p class="norm"><a name="jls-4.8-500"></a>The use of raw types is allowed
               only as a concession to compatibility of legacy code. The use of raw
               types in code written after the introduction of generics into the
               Java programming language is strongly discouraged. It is possible that future
               versions of the Java programming language will disallow the use of raw types.
            </p>
            <p class="norm-warning"><a name="jls-4.8-510"></a>To make
               sure that potential violations of the typing rules are always flagged,
               some accesses to members of a raw type will result in compile-time
               unchecked warnings. The rules for compile-time unchecked warnings when
               accessing members or constructors of raw types are as follows:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-warning"><a name="jls-4.8-510-A"></a>At an
                              assignment to a field: if the type of
                              the  <span class="emphasis"><em>Primary</em></span> in the field access
                              expression (<a class="xref" href="jls-15.html#jls-15.11" title="15.11.&nbsp;Field Access Expressions">&sect;15.11</a>) is a raw type, then a
                              compile-time unchecked warning occurs if erasure changes the
                              field's type.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-warning"><a name="jls-4.8-510-B"></a>At an
                              invocation of a method or constructor: if the type of the class
                              or interface to search (<a class="xref" href="jls-15.html#jls-15.12.1" title="15.12.1.&nbsp;Compile-Time Step 1: Determine Class or Interface to Search">&sect;15.12.1</a>) is a raw
                              type, then a compile-time unchecked warning occurs if erasure
                              changes any of the 
                              formal parameter types of the method or constructor.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-warning"><a name="jls-4.8-510-C"></a>No
                              compile-time unchecked warning occurs for a method call when the
                              formal parameter types do not change under
                              erasure (even if the return type and/or <code class="literal">throws</code> clause
                              changes), for reading from a field, or for a class instance
                              creation of a raw type.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="note">Note that the
               unchecked warnings above are distinct from the unchecked warnings
               possible from unchecked conversion (<a class="xref" href="jls-5.html#jls-5.1.9" title="5.1.9.&nbsp;Unchecked Conversion">&sect;5.1.9</a>),
               casts (<a class="xref" href="jls-5.html#jls-5.5.2" title="5.5.2.&nbsp;Checked Casts and Unchecked Casts">&sect;5.5.2</a>), method declarations
               (<a class="xref" href="jls-8.html#jls-8.4.1" title="8.4.1.&nbsp;Formal Parameters">&sect;8.4.1</a>, <a class="xref" href="jls-8.html#jls-8.4.8.3" title="8.4.8.3.&nbsp;Requirements in Overriding and Hiding">&sect;8.4.8.3</a>,
               <a class="xref" href="jls-8.html#jls-8.4.8.4" title="8.4.8.4.&nbsp;Inheriting Methods with Override-Equivalent Signatures">&sect;8.4.8.4</a>, <a class="xref" href="jls-9.html#jls-9.4.1.2" title="9.4.1.2.&nbsp;Requirements in Overriding">&sect;9.4.1.2</a>), and
               variable arity method invocations
               (<a class="xref" href="jls-15.html#jls-15.12.4.2" title="15.12.4.2.&nbsp;Evaluate Arguments">&sect;15.12.4.2</a>).
            </p>
            <p class="note">The warnings here
               cover the case where a legacy consumer uses a generified library. For
               example, the library declares a generic class <code class="literal">Foo&lt;T
                  extends String&gt;</code> that has a field <code class="literal">f</code> of
               type <code class="literal">Vector&lt;T&gt;</code>, but the consumer assigns a
               vector of integers to <code class="varname">e</code><code class="literal">.</code><code class="literal">f</code>
               where <code class="varname">e</code> has the raw type <code class="literal">Foo</code>.
               The legacy consumer receives a warning because it may have caused heap
               pollution (<a class="xref" href="jls-4.html#jls-4.12.2" title="4.12.2.&nbsp;Variables of Reference Type">&sect;4.12.2</a>) for generified consumers of
               the generified library.
            </p>
            <p class="note">(Note that the
               legacy consumer can assign a <code class="literal">Vector&lt;String&gt;</code>
               from the library to its own <code class="literal">Vector</code> variable without
               receiving a warning. That is, the subtyping rules
               (<a class="xref" href="jls-4.html#jls-4.10.2" title="4.10.2.&nbsp;Subtyping among Class and Interface Types">&sect;4.10.2</a>) of the Java programming language make it possible for
               a variable of a raw type to be assigned a value of any of the type's
               parameterized instances.)
            </p>
            <p class="note">The warnings from
               unchecked conversion cover the dual case, where a generified consumer
               uses a legacy library. For example, a method of the library has the
               raw return type <code class="literal">Vector</code>, but the consumer assigns
               the result of the method invocation to a variable of
               type <code class="literal">Vector&lt;String&gt;</code>. This is unsafe, since
               the raw vector might have had a different element type than <code class="literal">String</code>,
               but is still permitted using unchecked conversion in order to enable
               interfacing with legacy code. The warning from unchecked conversion
               indicates that the generified consumer may experience problems from
               heap pollution at other points in the program.
            </p>
            <div class="example"><a name="d5e3521"></a><p class="title"><b>Example&nbsp;4.8-1.&nbsp;Raw Types</b></p>
               <div class="example-contents"><pre class="programlisting">
class Cell&lt;E&gt; {
    E value;

    Cell(E v)     { value = v; }
    E get()       { return value; }
    void set(E v) { value = v; }

    public static void main(String[] args) {
        Cell x = new Cell&lt;String&gt;("abc");
        System.out.println(x.value);  // OK, has type Object
        System.out.println(x.get());  // OK, has type Object
        x.set("def");                 // unchecked warning
    }
}
</pre></div>
            </div><br class="example-break"><div class="example"><a name="d5e3524"></a><p class="title"><b>Example&nbsp;4.8-2.&nbsp;Raw Types and Inheritance</b></p>
               <div class="example-contents"><pre class="programlisting">
import java.util.*;
class NonGeneric {
    Collection&lt;Number&gt; myNumbers() { return null; }
}

abstract class RawMembers&lt;T&gt; extends NonGeneric
                             implements Collection&lt;String&gt; {
    static Collection&lt;NonGeneric&gt; cng =
        new ArrayList&lt;NonGeneric&gt;();

    public static void main(String[] args) {
        RawMembers rw = null;
        Collection&lt;Number&gt; cn = rw.myNumbers();
                              // OK
        Iterator&lt;String&gt; is = rw.iterator();
                            // Unchecked warning
        Collection&lt;NonGeneric&gt; cnn = rw.cng;
                                   // OK, static member
    }
}
</pre><p class="note">In this program (which is not meant to be
                     run), <code class="literal">RawMembers&lt;T&gt;</code> inherits the
                     method:
                  </p><pre class="screen">
Iterator&lt;String&gt; iterator()
</pre><p class="note">from the <code class="literal">Collection&lt;String&gt;</code>
                     superinterface. The raw type <code class="literal">RawMembers</code>
                     inherits <code class="literal">iterator()</code>
                     from <code class="literal">Collection</code>, the erasure
                     of <code class="literal">Collection&lt;String&gt;</code>, which means that the
                     return type of <code class="literal">iterator()</code>
                     in <code class="literal">RawMembers</code> is <code class="literal">Iterator</code>. As a
                     result, the attempt to assign <code class="literal">rw.iterator()</code>
                     to <code class="literal">Iterator&lt;String&gt;</code> requires an unchecked
                     conversion, so a compile-time unchecked warning is issued.
                  </p>
                  <p class="note">In contrast, <code class="literal">RawMembers</code>
                     inherits <code class="literal">myNumbers()</code> from
                     the <code class="literal">NonGeneric</code> class whose erasure is
                     also <code class="literal">NonGeneric</code>. Thus, the return type
                     of <code class="literal">myNumbers()</code> in <code class="literal">RawMembers</code> is
                     not erased, and the attempt to assign <code class="literal">rw.myNumbers()</code>
                     to <code class="literal">Collection&lt;Number&gt;</code> requires no unchecked
                     conversion, so no compile-time unchecked warning is issued.
                  </p>
                  <p class="note">Similarly, the <code class="literal">static</code> member 
                     <code class="literal">cng</code> retains its parameterized type even when
                     accessed through a object of raw type. Note that access to a <code class="literal">static</code>
                     member through an instance is considered bad style and is
                     discouraged.
                  </p>
                  <p class="note">This example reveals that certain members of a raw
                     type are not erased, namely <code class="literal">static</code> members whose types are
                     parameterized, and members inherited from a non-generic
                     supertype.
                  </p>
               </div>
            </div><br class="example-break"><p class="note">Raw types are closely related to wildcards. Both are
               based on existential types. Raw types can be thought of as wildcards
               whose type rules are deliberately unsound, to accommodate interaction
               with legacy code. Historically, raw types preceded wildcards; they
               were first introduced in GJ, and described in the
               paper <em class="citetitle">Making the future safe for the past: Adding
                  Genericity to the Java Programming Language</em> by Gilad
               Bracha, Martin Odersky, David Stoutamire, and Philip Wadler, in
               <em class="citetitle">Proceedings of the ACM Conference on Object-Oriented
                  Programming, Systems, Languages and Applications (OOPSLA
                  98)</em>, October 1998.
            </p>
         </div>
         <div class="section" title="4.9.&nbsp;Intersection Types">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-4.9"></a>4.9.&nbsp;Intersection Types
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-4.9-100"></a>An
               intersection type takes the form <span class="type">T<sub>1</sub></span> <code class="literal">&amp;</code> ... <code class="literal">&amp;</code> <span class="type">T<sub>n</sub></span> (<span class="emphasis"><em>n</em></span>
               &gt; 0), where <span class="type">T<sub>i</sub></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>) are types.
            </p>
            <p class="norm"><a name="jls-4.9-110"></a>Intersection types can be derived from
               type parameter bounds (<a class="xref" href="jls-4.html#jls-4.4" title="4.4.&nbsp;Type Variables">&sect;4.4</a>) and cast expressions
               (<a class="xref" href="jls-15.html#jls-15.16" title="15.16.&nbsp;Cast Expressions">&sect;15.16</a>); they also arise in the processes of
               capture conversion (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>) and least upper
               bound computation (<a class="xref" href="jls-4.html#jls-4.10.4" title="4.10.4.&nbsp;Least Upper Bound">&sect;4.10.4</a>).
            </p>
            <p class="norm-dynamic"><a name="jls-4.9-200"></a>The values
               of an intersection type are those objects that are values of all of
               the types <span class="type">T<sub>i</sub></span> for 1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>.
            </p>
            <p class="norm-static"><a name="jls-4.9-300"></a>Every
               intersection type <span class="type">T<sub>1</sub></span> <code class="literal">&amp;</code> ... <code class="literal">&amp;</code> <span class="type">T<sub>n</sub></span> 
               <span class="emphasis"><em>induces</em></span> a notional class or interface for the
               purpose of identifying the members of the intersection type, as
               follows:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-error"><a name="jls-4.9-300-A"></a>For each
                              <span class="type">T<sub>i</sub></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), let <span class="type">C<sub>i</sub></span> be the most
                              specific class or array type such that <span class="type">T<sub>i</sub></span> <code class="literal">&lt;:</code> <span class="type">C<sub>i</sub></span>. Then
                              there must be some <span class="type">C<sub>k</sub></span> such that <span class="type">C<sub>k</sub></span> <code class="literal">&lt;:</code> <span class="type">C<sub>i</sub></span> for any
                              <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), or a compile-time error
                              occurs.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.9-300-B"></a>For 1
                              <span class="symbol">&#8804;</span> <span class="emphasis"><em>j</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>, if <span class="type">T<sub>j</sub></span> is a type variable, then let
                              <span class="type">T<sub>j</sub></span>' be an interface whose members are the same as the <code class="literal">public</code>
                              members of <span class="type">T<sub>j</sub></span>; otherwise, if <span class="type">T<sub>j</sub></span> is an interface, then let
                              <span class="type">T<sub>j</sub></span>' be <span class="type">T<sub>j</sub></span>.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-4.9-300-C"></a>If <span class="type">C<sub>k</sub></span> is
                              <code class="literal">Object</code>, a notional interface is induced; otherwise, a notional
                              class is induced with direct superclass <span class="type">C<sub>k</sub></span>. This class or
                              interface has direct superinterfaces <span class="type">T<sub>1</sub></span>', ..., <span class="type">T<sub>n</sub></span>' and is
                              declared in the package in which the intersection type
                              appears.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm-static"><a name="jls-4.9-310"></a>The members of
               an intersection type are the members of the class or interface it
               induces.
            </p>
            <p class="note">It is worth dwelling upon the distinction between
               intersection types and the bounds of type variables. Every type
               variable bound induces an intersection type. This intersection type is
               often trivial, consisting of a single type. The form of a bound is
               restricted (only the first element may be a class or type variable,
               and only one type variable may appear in the bound) to preclude
               certain awkward situations coming into existence. However, capture
               conversion can lead to the creation of type variables whose bounds are
               more general, such as array types).
            </p>
         </div>
         <div class="section" title="4.10.&nbsp;Subtyping">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-4.10"></a>4.10.&nbsp;Subtyping
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-4.10-100"></a>The subtype and supertype
               relations are binary relations on types.
            </p>
            <p class="norm-static"><a name="jls-4.10-110"></a>The
               <span class="emphasis"><em>supertypes</em></span> of a type are obtained by reflexive
               and transitive closure over the direct supertype relation, written <span class="type">S</span>
               <code class="literal">&gt;<sub>1</sub></code> <span class="type">T</span>, which is defined by rules given later in this
               section. We write <span class="type">S</span> <code class="literal">:&gt;</code> <span class="type">T</span> to indicate that the supertype
               relation holds between <span class="type">S</span> and <span class="type">T</span>.
            </p>
            <p class="norm-static"><a name="jls-4.10-120"></a><span class="type">S</span> is
               a <span class="emphasis"><em>proper supertype</em></span> of <span class="type">T</span>, written <span class="type">S</span>
               <code class="literal">&gt;</code> <span class="type">T</span>, if <span class="type">S</span> <code class="literal">:&gt;</code> <span class="type">T</span> and <span class="type">S</span> <span class="symbol">&#8800;</span> <span class="type">T</span>.
            </p>
            <p class="norm-static"><a name="jls-4.10-200"></a>The
               <span class="emphasis"><em>subtypes</em></span> of a type <span class="type">T</span> are all types <span class="type">U</span> such
               that <span class="type">T</span> is a supertype of <span class="type">U</span>, and the null type. We write <span class="type">T</span>
               <code class="literal">&lt;:</code> <span class="type">S</span> to indicate that that the subtype relation holds between
               types <span class="type">T</span> and <span class="type">S</span>.
            </p>
            <p class="norm-static"><a name="jls-4.10-210"></a><span class="type">T</span> is
               a <span class="emphasis"><em>proper subtype</em></span> of <span class="type">S</span>, written <span class="type">T</span>
               <code class="literal">&lt;</code> <span class="type">S</span>, if <span class="type">T</span> <code class="literal">&lt;:</code> <span class="type">S</span> and <span class="type">S</span> <span class="symbol">&#8800;</span> <span class="type">T</span>.
            </p>
            <p class="norm-static"><a name="jls-4.10-220"></a><span class="type">T</span> is
               a <span class="emphasis"><em>direct subtype</em></span> of <span class="type">S</span>, written <span class="type">T</span>
               <code class="literal">&lt;<sub>1</sub></code> <span class="type">S</span>, if <span class="type">S</span> <code class="literal">&gt;<sub>1</sub></code> <span class="type">T</span>.
            </p>
            <p class="norm-static"><a name="jls-4.10-300"></a>Subtyping
               does not extend through  parameterized types: <span class="type">T</span>
               <code class="literal">&lt;:</code> <span class="type">S</span> does not imply that <span class="type">C</span><code class="literal">&lt;</code><span class="type">T</span><code class="literal">&gt;</code> <code class="literal">&lt;:</code>
               <span class="type">C</span><code class="literal">&lt;</code><span class="type">S</span><code class="literal">&gt;</code>.
            </p>
            <div class="section" title="4.10.1.&nbsp;Subtyping among Primitive Types">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.10.1"></a>4.10.1.&nbsp;Subtyping among Primitive Types
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-4.10.1-100"></a>The
                  following rules define the direct supertype relation among the
                  primitive types:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.1-100-A"></a>
                                 <code class="literal">double</code> <code class="literal">&gt;<sub>1</sub></code> <code class="literal">float</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.1-100-B"></a>
                                 <code class="literal">float</code> <code class="literal">&gt;<sub>1</sub></code> <code class="literal">long</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.1-100-C"></a>
                                 <code class="literal">long</code> <code class="literal">&gt;<sub>1</sub></code> <code class="literal">int</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.1-100-D"></a>
                                 <code class="literal">int</code> <code class="literal">&gt;<sub>1</sub></code> <code class="literal">char</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.1-100-E"></a>
                                 <code class="literal">int</code> <code class="literal">&gt;<sub>1</sub></code> <code class="literal">short</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.1-100-F"></a>
                                 <code class="literal">short</code> <code class="literal">&gt;<sub>1</sub></code> <code class="literal">byte</code></p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="4.10.2.&nbsp;Subtyping among Class and Interface Types">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.10.2"></a>4.10.2.&nbsp;Subtyping among Class and Interface Types
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-4.10.2-100"></a>
                  Given a non-generic type declaration <span class="type">C</span>, the <span class="emphasis"><em>direct
                        supertypes</em></span> of the type <span class="type">C</span> are all of the following:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.2-100-A"></a>
                                 The direct superclass of <span class="type">C</span>
                                 (<a class="xref" href="jls-8.html#jls-8.1.4" title="8.1.4.&nbsp;Superclasses and Subclasses">&sect;8.1.4</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.2-100-B"></a>
                                 The direct superinterfaces of <span class="type">C</span>
                                 (<a class="xref" href="jls-8.html#jls-8.1.5" title="8.1.5.&nbsp;Superinterfaces">&sect;8.1.5</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.2-100-C"></a>
                                 The type <code class="literal">Object</code>, if <span class="type">C</span> is an interface type with no direct
                                 superinterfaces (<a class="xref" href="jls-9.html#jls-9.1.3" title="9.1.3.&nbsp;Superinterfaces and Subinterfaces">&sect;9.1.3</a>).
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-4.10.2-110"></a>
                  Given a generic type declaration <span class="type">C</span><code class="literal">&lt;</code><span class="type">F<sub>1</sub></span>,...,<span class="type">F<sub>n</sub></span><code class="literal">&gt;</code>
                  (<span class="emphasis"><em>n</em></span> &gt; 0), the <span class="emphasis"><em>direct supertypes</em></span> of the raw
                  type <span class="type">C</span> (<a class="xref" href="jls-4.html#jls-4.8" title="4.8.&nbsp;Raw Types">&sect;4.8</a>) are all of the following:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.2-110-A"></a>
                                 The direct superclass of the raw type <span class="type">C</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.2-110-B"></a>
                                 The direct superinterfaces of the raw type <span class="type">C</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.2-110-C"></a>
                                 The type <code class="literal">Object</code>, if <span class="type">C</span><code class="literal">&lt;</code><span class="type">F<sub>1</sub></span>,...,<span class="type">F<sub>n</sub></span><code class="literal">&gt;</code> is a
                                 generic interface type with no direct superinterfaces
                                 (<a class="xref" href="jls-9.html#jls-9.1.2" title="9.1.2.&nbsp;Generic Interfaces and Type Parameters">&sect;9.1.2</a>).
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-4.10.2-120"></a>
                  Given a generic type declaration <span class="type">C</span><code class="literal">&lt;</code><span class="type">F<sub>1</sub></span>,...,<span class="type">F<sub>n</sub></span><code class="literal">&gt;</code>
                  (<span class="emphasis"><em>n</em></span> &gt; 0), the <span class="emphasis"><em>direct supertypes</em></span> of the
                  generic type <span class="type">C</span><code class="literal">&lt;</code><span class="type">F<sub>1</sub></span>,...,<span class="type">F<sub>n</sub></span><code class="literal">&gt;</code> are all of the
                  following:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.2-120-A"></a>
                                 The direct superclass of <span class="type">C</span><code class="literal">&lt;</code><span class="type">F<sub>1</sub></span>,...,<span class="type">F<sub>n</sub></span><code class="literal">&gt;</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.2-120-B"></a>
                                 The direct superinterfaces of <span class="type">C</span><code class="literal">&lt;</code><span class="type">F<sub>1</sub></span>,...,<span class="type">F<sub>n</sub></span><code class="literal">&gt;</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.2-120-C"></a>
                                 The type <code class="literal">Object</code>, if <span class="type">C</span><code class="literal">&lt;</code><span class="type">F<sub>1</sub></span>,...,<span class="type">F<sub>n</sub></span><code class="literal">&gt;</code> is a
                                 generic interface type with no direct superinterfaces.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.2-120-D"></a>
                                 The raw type <span class="type">C</span>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-4.10.2-200"></a>
                  Given a generic type declaration <span class="type">C</span><code class="literal">&lt;</code><span class="type">F<sub>1</sub></span>,...,<span class="type">F<sub>n</sub></span><code class="literal">&gt;</code>
                  (<span class="emphasis"><em>n</em></span> &gt; 0), the <span class="emphasis"><em>direct supertypes</em></span> of the
                  parameterized type <span class="type">C</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>,...,<span class="type">T<sub>n</sub></span><code class="literal">&gt;</code>, where <span class="type">T<sub>i</sub></span> (1
                  <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>) is a type, are all of the following:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.2-200-A"></a>
                                 <span class="type">D</span><code class="literal">&lt;</code><span class="type">U<sub>1</sub></span> <span class="symbol">&#952;</span>,...,<span class="type">U<sub>k</sub></span> <span class="symbol">&#952;</span><code class="literal">&gt;</code>, 
                                 where <span class="type">D</span><code class="literal">&lt;</code><span class="type">U<sub>1</sub></span>,...,<span class="type">U<sub>k</sub></span><code class="literal">&gt;</code> is a generic type
                                 which is a direct supertype of the generic type 
                                 <span class="type">C</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>,...,<span class="type">T<sub>n</sub></span><code class="literal">&gt;</code> and <span class="symbol">&#952;</span> is the
                                 substitution <code class="literal">[<span class="type">F<sub>1</sub></span>:=<span class="type">T<sub>1</sub></span>,...,<span class="type">F<sub>n</sub></span>:=<span class="type">T<sub>n</sub></span>]</code>.
                               
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.2-200-B"></a>
                                 <span class="type">C</span><code class="literal">&lt;</code><span class="type">S<sub>1</sub></span>,...,<span class="type">S<sub>n</sub></span><code class="literal">&gt;</code>, where <span class="type">S<sub>i</sub></span> contains <span class="type">T<sub>i</sub></span> 
                                 (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>) (<a class="xref" href="jls-4.html#jls-4.5.1" title="4.5.1.&nbsp;Type Arguments of Parameterized Types">&sect;4.5.1</a>).
                               
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.2-200-C"></a>The type
                                 <code class="literal">Object</code>, if <span class="type">C</span>&lt;<span class="type">F<sub>1</sub></span>,...,<span class="type">F<sub>n</sub></span>&gt; is a generic interface
                                 type with no direct superinterfaces.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.2-200-D"></a>The raw
                                 type <span class="type">C</span>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-4.10.2-300"></a>Given a
                  generic type declaration <span class="type">C</span><code class="literal">&lt;</code><span class="type">F<sub>1</sub></span>,...,<span class="type">F<sub>n</sub></span><code class="literal">&gt;</code> (<span class="emphasis"><em>n</em></span> &gt;
                  0), the <span class="emphasis"><em>direct supertypes</em></span> of the parameterized
                  type <span class="type">C</span><code class="literal">&lt;</code><span class="type">R<sub>1</sub></span>,...,<span class="type">R<sub>n</sub></span><code class="literal">&gt;</code> where at least one of the <span class="type">R<sub>i</sub></span>
                  (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>) is a wildcard type argument, are the
                  direct supertypes of the parameterized type
                  <span class="type">C</span><code class="literal">&lt;</code><span class="type">X<sub>1</sub></span>,...,<span class="type">X<sub>n</sub></span><code class="literal">&gt;</code> which is the result of applying
                  capture conversion to <span class="type">C</span><code class="literal">&lt;</code><span class="type">R<sub>1</sub></span>,...,<span class="type">R<sub>n</sub></span><code class="literal">&gt;</code>
                  (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>).
               </p>
               <p class="norm-static"><a name="jls-4.10.2-400"></a>The
                  direct supertypes of an intersection type <span class="type">T<sub>1</sub></span> <code class="literal">&amp;</code> ... <code class="literal">&amp;</code> <span class="type">T<sub>n</sub></span>
                  are <span class="type">T<sub>i</sub></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>).
               </p>
               <p class="norm-static"><a name="jls-4.10.2-500"></a>The
                  direct supertypes of a type variable are the types listed in its
                  bound.
               </p>
               <p class="norm-static"><a name="jls-4.10.2-510"></a>A type
                  variable is a direct supertype of its lower bound.
               </p>
               <p class="norm-static"><a name="jls-4.10.2-600"></a>The
                  direct supertypes of the null type are all reference types other than
                  the null type itself.
               </p>
            </div>
            <div class="section" title="4.10.3.&nbsp;Subtyping among Array Types">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.10.3"></a>4.10.3.&nbsp;Subtyping among Array Types
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-4.10.3-100"></a>The
                  following rules define the direct supertype relation among array
                  types:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.3-100-A"></a>
                                 If <span class="type">S</span> and <span class="type">T</span> are both reference types, then <span class="type">S</span><code class="literal">[]</code>
                                 <code class="literal">&gt;<sub>1</sub></code> <span class="type">T</span><code class="literal">[]</code> iff <span class="type">S</span> <code class="literal">&gt;<sub>1</sub></code>
                                 <span class="type">T</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.3-100-B"></a>
                                 <code class="literal">Object</code> <code class="literal">&gt;<sub>1</sub></code> <code class="literal">Object</code><code class="literal">[]</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.3-100-C"></a>
                                 <code class="literal">Cloneable</code> <code class="literal">&gt;<sub>1</sub></code> <code class="literal">Object</code><code class="literal">[]</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.3-100-D"></a>
                                 <code class="literal">java.io.Serializable</code> <code class="literal">&gt;<sub>1</sub></code> <code class="literal">Object</code><code class="literal">[]</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.3-100-E"></a>
                                 If <span class="type">P</span> is a primitive type, then:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-4.10.3-100-E-A"></a>
                                    	  <code class="literal">Object</code> <code class="literal">&gt;<sub>1</sub></code> <span class="type">P</span><code class="literal">[]</code></p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-4.10.3-100-E-B"></a>
                                    	  <code class="literal">Cloneable</code> <code class="literal">&gt;<sub>1</sub></code> <span class="type">P</span><code class="literal">[]</code></p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-4.10.3-100-E-C"></a>
                                    	  <code class="literal">java.io.Serializable</code> <code class="literal">&gt;<sub>1</sub></code> <span class="type">P</span><code class="literal">[]</code></p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="4.10.4.&nbsp;Least Upper Bound">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.10.4"></a>4.10.4.&nbsp;Least Upper Bound
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-4.10.4-100"></a>
                  The <span class="emphasis"><em>least upper bound</em></span>, or "lub", of a set of
                  reference types is a shared supertype that is more specific than any
                  other shared supertype (that is, no other shared supertype is a
                  subtype of the least upper bound). This type, lub(<span class="type">U<sub>1</sub></span>, ..., <span class="type">U<sub>k</sub></span>), is
                  determined as follows.
               </p>
               <p class="norm-static"><a name="jls-4.10.4-200"></a>
                  If <span class="emphasis"><em>k</em></span> = 1, then the lub is the type itself: lub(<span class="type">U</span>) = <span class="type">U</span>.
               </p>
               <p class="norm-static"><a name="jls-4.10.4-210"></a>
                  Otherwise:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.4-210-A"></a>
                                 For each <span class="type">U<sub>i</sub></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>k</em></span>):
                        </p>
                        <p class="norm-static"><a name="jls-4.10.4-210-A.1"></a>
                                 Let ST(<span class="type">U<sub>i</sub></span>) be the set of supertypes of <span class="type">U<sub>i</sub></span>.
                        </p>
                        <p class="norm-static"><a name="jls-4.10.4-210-A.2"></a>
                                 Let EST(<span class="type">U<sub>i</sub></span>), the set of erased supertypes of <span class="type">U<sub>i</sub></span>, be:
                        </p>
                        <p class="norm-static"><a name="jls-4.10.4-210-A.3"></a>
                                 EST(<span class="type">U<sub>i</sub></span>) = { |<span class="type">W</span>| | <span class="type">W</span> in ST(<span class="type">U<sub>i</sub></span>) } where |<span class="type">W</span>| is the erasure of <span class="type">W</span>.
                        </p>
                        <p class="note">The reason for computing the set of erased
                                 supertypes is to deal with situations where the set of types
                                 includes several distinct parameterizations of a generic
                                 type.
                        </p>
                        <p class="note">For example, given 
                                 <code class="literal">List<code class="literal">&lt;</code>String<code class="literal">&gt;</code></code>
                                 and <code class="literal">List<code class="literal">&lt;</code>Object<code class="literal">&gt;</code></code>, simply
                                 intersecting the sets
                                 ST(<code class="literal">List<code class="literal">&lt;</code>String<code class="literal">&gt;</code></code>) =
                                 { <code class="literal">List<code class="literal">&lt;</code>String<code class="literal">&gt;</code></code>, <code class="literal">Collection<code class="literal">&lt;</code>String<code class="literal">&gt;</code></code>,
                                 <code class="literal">Object</code> } and ST(<code class="literal">List<code class="literal">&lt;</code>Object<code class="literal">&gt;</code></code>)
                                 =
                                 { <code class="literal">List<code class="literal">&lt;</code>Object<code class="literal">&gt;</code></code>, <code class="literal">Collection<code class="literal">&lt;</code>Object<code class="literal">&gt;</code></code>,
                                 <code class="literal">Object</code> } would yield a set { <code class="literal">Object</code> }, and we would have
                                 lost track of the fact that the upper bound can safely be
                                 assumed to be a <code class="literal">List</code>.
                        </p>
                        <p class="note">In contrast, intersecting
                                 EST(<code class="literal">List<code class="literal">&lt;</code>String<code class="literal">&gt;</code></code>) =
                                 { <code class="literal">List</code>, <code class="literal">Collection</code>,
                                 <code class="literal">Object</code> } and
                                 EST(<code class="literal">List<code class="literal">&lt;</code>Object<code class="literal">&gt;</code></code>) =
                                 { <code class="literal">List</code>, <code class="literal">Collection</code>,
                                 <code class="literal">Object</code> } yields
                                 { <code class="literal">List</code>, <code class="literal">Collection</code>,
                                 <code class="literal">Object</code> }, which will eventually enable us to
                                 produce <code class="literal">List<code class="literal">&lt;</code>?<code class="literal">&gt;</code></code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.4-210-B"></a>
                                 Let EC, the erased candidate set for <span class="type">U<sub>1</sub></span> ... <span class="type">U<sub>k</sub></span>, be the
                                 intersection of all the sets EST(<span class="type">U<sub>i</sub></span>) (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span>
                                 <span class="emphasis"><em>k</em></span>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.4-210-C"></a>
                                 Let MEC, the minimal erased candidate set for <span class="type">U<sub>1</sub></span> ... <span class="type">U<sub>k</sub></span>, be:
                        </p>
                        <p class="norm-static"><a name="jls-4.10.4-210-C.1"></a>
                                 MEC = { <span class="type">V</span> | <span class="type">V</span> in EC, and for all <span class="type">W</span> <span class="symbol">&#8800;</span> <span class="type">V</span> in EC, it is not the case that <span class="type">W</span> <code class="literal">&lt;:</code> <span class="type">V</span> }
                        </p>
                        <p class="note">Because we are seeking to infer more precise
                                 types, we wish to filter out any candidates that are supertypes
                                 of other candidates. This is what computing MEC accomplishes. In
                                 our running example, we had EC =
                                 { <code class="literal">List</code>, <code class="literal">Collection</code>,
                                 <code class="literal">Object</code> }, so MEC = { <code class="literal">List</code> }. The next step
                                 is to recover type arguments for the erased types in MEC.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.4-210-D"></a>
                                 For any element <span class="type">G</span> of MEC that is a generic type:
                        </p>
                        <p class="norm-static"><a name="jls-4.10.4-210-D.1"></a>
                                 Let the "relevant" parameterizations of <span class="type">G</span>, Relevant(G), be:
                        </p>
                        <p class="norm-static"><a name="jls-4.10.4-210-D.2"></a>
                                 Relevant(<span class="type">G</span>) = { <span class="type">V</span> | 1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>k</em></span>:
                                 <span class="type">V</span> in ST(<span class="type">U<sub>i</sub></span>) and <span class="type">V</span> = <span class="type">G</span><code class="literal">&lt;</code>...<code class="literal">&gt;</code> }
                        </p>
                        <p class="note">In our running example, the only generic element
                                 of MEC is <code class="literal">List</code>, and
                                 Inv(<code class="literal">List</code>) =
                                 { <code class="literal">List<code class="literal">&lt;</code>String<code class="literal">&gt;</code></code>, 
                                 <code class="literal">List<code class="literal">&lt;</code>Object<code class="literal">&gt;</code></code> }. We will now
                                 seek to find a type argument for <code class="literal">List</code> that
                                 contains (<a class="xref" href="jls-4.html#jls-4.5.1" title="4.5.1.&nbsp;Type Arguments of Parameterized Types">&sect;4.5.1</a>) both <code class="literal">String</code> and
                                 <code class="literal">Object</code>.
                        </p>
                        <p class="note">This is done by means of the least containing
                                 parameterization (lcp) operation defined below. The first line
                                 defines lcp() on a set, such as
                                 Relevant(<code class="literal">List</code>), as an operation on a list of
                                 the elements of the set. The next line defines the operation on
                                 such lists, as a pairwise reduction on the elements of the
                                 list. The third line is the definition of lcp() on pairs of
                                 parameterized types, which in turn relies on the notion of least
                                 containing type argument (lcta). lcta() is defined for all
                                 possible cases.
                        </p>
                        <p class="norm-static"><a name="jls-4.10.4-210-D.3"></a>
                                 Let the "candidate" parameterization of <span class="type">G</span>, Candidate(<span class="type">G</span>), be
                                 the most specific parameterization of the generic type <span class="type">G</span> that
                                 contains all the relevant parameterizations of <span class="type">G</span>:
                        </p>
                        <p class="norm-static"><a name="jls-4.10.4-210-D.4"></a>
                                 Candidate(<span class="type">G</span>) = lcp(Relevant(<span class="type">G</span>))
                        </p>
                        <p class="norm-static"><a name="jls-4.10.4-210-D.5"></a>
                                 where lcp(), the least containing invocation, is:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-4.10.4-210-D.5-A"></a>
                                    	  lcp(<span class="type">S</span>) = lcp(<code class="varname">e<sub>1</sub></code>, ..., <code class="varname">e<sub>n</sub></code>) where <code class="varname">e<sub>i</sub></code> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>) in <span class="type">S</span></p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-4.10.4-210-D.5-B"></a>
                                    	  lcp(<code class="varname">e<sub>1</sub></code>, ..., <code class="varname">e<sub>n</sub></code>) = lcp(lcp(<code class="varname">e<sub>1</sub></code>, <code class="varname">e<sub>2</sub></code>), <code class="varname">e<sub>3</sub></code>, ..., <code class="varname">e<sub>n</sub></code>)
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-4.10.4-210-D.5-C"></a>
                                    	  lcp(<span class="type">G</span><code class="literal">&lt;</code><span class="type">X<sub>1</sub></span>, ..., <span class="type">X<sub>n</sub></span><code class="literal">&gt;</code>, <span class="type">G</span><code class="literal">&lt;</code><span class="type">Y<sub>1</sub></span>, ..., <span class="type">Y<sub>n</sub></span><code class="literal">&gt;</code>) = <span class="type">G</span><code class="literal">&lt;</code>lcta(<span class="type">X<sub>1</sub></span>, <span class="type">Y<sub>1</sub></span>), ..., lcta(<span class="type">X<sub>n</sub></span>, <span class="type">Y<sub>n</sub></span>)<code class="literal">&gt;</code></p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-4.10.4-210-D.5-D"></a>
                                    	  lcp(<span class="type">G</span><code class="literal">&lt;</code><span class="type">X<sub>1</sub></span>, ..., <span class="type">X<sub>n</sub></span><code class="literal">&gt;</code>) = <span class="type">G</span><code class="literal">&lt;</code>lcta(<span class="type">X<sub>1</sub></span>), ..., lcta(<span class="type">X<sub>n</sub></span>)<code class="literal">&gt;</code></p>
                              </li>
                           </ul>
                        </div>
                        <p class="norm-static"><a name="jls-4.10.4-210-D.6"></a>
                                 and where lcta(), the least containing type argument, is:
                                 (assuming <span class="type">U</span> and <span class="type">V</span> are types)
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-4.10.4-210-D.6-A"></a>
                                    	  lcta(<span class="type">U</span>, <span class="type">V</span>) = <span class="type">U</span> if <span class="type">U</span> = <span class="type">V</span>, otherwise <code class="literal">?</code> <code class="literal">extends</code> lub(<span class="type">U</span>, <span class="type">V</span>)
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-4.10.4-210-D.6-B"></a>
                                    	  lcta(<span class="type">U</span>, <code class="literal">?</code> <code class="literal">extends</code> <span class="type">V</span>) = <code class="literal">?</code> <code class="literal">extends</code> lub(<span class="type">U</span>, <span class="type">V</span>)
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-4.10.4-210-D.6-C"></a>
                                    	  lcta(<span class="type">U</span>, <code class="literal">?</code> <code class="literal">super</code> <span class="type">V</span>) = <code class="literal">?</code> <code class="literal">super</code> glb(<span class="type">U</span>, <span class="type">V</span>)
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-4.10.4-210-D.6-D"></a>
                                    	  lcta(<code class="literal">?</code> <code class="literal">extends</code> <span class="type">U</span>, <code class="literal">?</code> <code class="literal">extends</code> <span class="type">V</span>) = <code class="literal">?</code> <code class="literal">extends</code> lub(<span class="type">U</span>, <span class="type">V</span>)
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-4.10.4-210-D.6-E"></a>
                                    	  lcta(<code class="literal">?</code> <code class="literal">extends</code> <span class="type">U</span>, <code class="literal">?</code> <code class="literal">super</code> <span class="type">V</span>) = <span class="type">U</span> if <span class="type">U</span> = <span class="type">V</span>, otherwise <code class="literal">?</code></p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-4.10.4-210-D.6-F"></a>
                                    	  lcta(<code class="literal">?</code> <code class="literal">super</code> <span class="type">U</span>, <code class="literal">?</code> <code class="literal">super</code> <span class="type">V</span>) = <code class="literal">?</code> <code class="literal">super</code> glb(<span class="type">U</span>, <span class="type">V</span>)
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-4.10.4-210-D.6-G"></a>
                                    	  lcta(<span class="type">U</span>) = <code class="literal">?</code> if <span class="type">U</span>'s upper bound is <code class="literal">Object</code>, otherwise <code class="literal">?</code> <code class="literal">extends</code> lub(<span class="type">U</span>,<code class="literal">Object</code>)
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <p class="norm-static"><a name="jls-4.10.4-210-D.7"></a>
                                 and where glb() is as defined in <a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.10.4-210-E"></a>
                                 Let lub(<span class="type">U<sub>1</sub></span> ... <span class="type">U<sub>k</sub></span>) be:
                        </p>
                        <p class="norm-static"><a name="jls-4.10.4-210-E.1"></a>
                                 Best(<span class="type">W<sub>1</sub></span>) <code class="literal">&amp;</code> ... <code class="literal">&amp;</code> Best(<span class="type">W<sub>r</sub></span>)
                        </p>
                        <p class="norm-static"><a name="jls-4.10.4-210-E.2"></a>
                                 where <span class="type">W<sub>i</sub></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>r</em></span>) are the elements of
                                 MEC, the minimal erased candidate set of <span class="type">U<sub>1</sub></span> ... <span class="type">U<sub>k</sub></span>;
                        </p>
                        <p class="norm-static"><a name="jls-4.10.4-210-E.3"></a>
                                 and where, if any of these elements are generic, we use the
                                 candidate parameterization (so as to recover type arguments):
                        </p>
                        <p class="norm-static"><a name="jls-4.10.4-210-E.4"></a>
                                 Best(<span class="type">X</span>) = Candidate(<span class="type">X</span>) if <span class="type">X</span> is generic; <span class="type">X</span> otherwise.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-4.10.4-300"></a>Strictly speaking, this
                  lub() function only approximates a least upper bound. Formally, there
                  may exist some other type <span class="type">T</span> such that all of <span class="type">U<sub>1</sub></span> ... <span class="type">U<sub>k</sub></span> are
                  subtypes of <span class="type">T</span> and <span class="type">T</span> is a subtype of lub(<span class="type">U<sub>1</sub></span>, ..., <span class="type">U<sub>k</sub></span>). However,
                  a compiler for the Java programming language must implement lub() as specified
                  above.
               </p>
               <p class="norm"><a name="jls-4.10.4-310"></a>It is possible that the
                  lub() function yields an infinite type. This is permissible, and a
                  compiler for the Java programming language must recognize such situations and
                  represent them appropriately using cyclic data structures.
               </p>
               <p class="note">The possibility of an infinite type stems from the
                  recursive calls to lub(). Readers familiar with recursive types should
                  note that an infinite type is not the same as a recursive type.
               </p>
            </div>
         </div>
         <div class="section" title="4.11.&nbsp;Where Types Are Used">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-4.11"></a>4.11.&nbsp;Where Types Are Used
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-4.11-100"></a>Types are used in most kinds of
               declaration and in certain kinds of expression. Specifically, there
               are 16 <span class="emphasis"><em>type contexts</em></span> where types are used:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm"><a name="jls-4.11-100-A"></a>In declarations:
                     </p>
                     <div class="orderedlist">
                        <ol class="orderedlist" type="1">
                           <li class="listitem">
                              <p class="norm"><a name="jls-4.11-100-A-A"></a>
                                 	  A type in the <code class="literal">extends</code> or <code class="literal">implements</code> clause of a class
                                 	  declaration (<a class="xref" href="jls-8.html#jls-8.1.4" title="8.1.4.&nbsp;Superclasses and Subclasses">&sect;8.1.4</a>,
                                 	  <a class="xref" href="jls-8.html#jls-8.1.5" title="8.1.5.&nbsp;Superinterfaces">&sect;8.1.5</a>, <a class="xref" href="jls-8.html#jls-8.5" title="8.5.&nbsp;Member Type Declarations">&sect;8.5</a>,
                                 	  <a class="xref" href="jls-9.html#jls-9.5" title="9.5.&nbsp;Member Type Declarations">&sect;9.5</a>)
                                 	
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-4.11-100-A-B"></a>
                                 	  A type in the <code class="literal">extends</code> clause of an interface declaration
                                 	  (<a class="xref" href="jls-9.html#jls-9.1.3" title="9.1.3.&nbsp;Superinterfaces and Subinterfaces">&sect;9.1.3</a>, <a class="xref" href="jls-8.html#jls-8.5" title="8.5.&nbsp;Member Type Declarations">&sect;8.5</a>,
                                 	  <a class="xref" href="jls-9.html#jls-9.5" title="9.5.&nbsp;Member Type Declarations">&sect;9.5</a>)
                                 	
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-4.11-100-A-C"></a>
                                 	  The return type of a method (including the type of an
                                 	  element of an annotation type) (<a class="xref" href="jls-8.html#jls-8.4.5" title="8.4.5.&nbsp;Method Result">&sect;8.4.5</a>,
                                 	  <a class="xref" href="jls-9.html#jls-9.4" title="9.4.&nbsp;Method Declarations">&sect;9.4</a>, <a class="xref" href="jls-9.html#jls-9.6.1" title="9.6.1.&nbsp;Annotation Type Elements">&sect;9.6.1</a>)
                                 	
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-4.11-100-A-D"></a>
                                 	   A type in the <code class="literal">throws</code> clause of a method or constructor
                                 	  (<a class="xref" href="jls-8.html#jls-8.4.6" title="8.4.6.&nbsp;Method Throws">&sect;8.4.6</a>, <a class="xref" href="jls-8.html#jls-8.8.5" title="8.8.5.&nbsp;Constructor Throws">&sect;8.8.5</a>,
                                 	  <a class="xref" href="jls-9.html#jls-9.4" title="9.4.&nbsp;Method Declarations">&sect;9.4</a>)
                                 	
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-4.11-100-A-E"></a>
                                 	  A type in the <code class="literal">extends</code> clause of a type parameter
                                 	  declaration of a generic class, interface, method, or
                                 	  constructor (<a class="xref" href="jls-8.html#jls-8.1.2" title="8.1.2.&nbsp;Generic Classes and Type Parameters">&sect;8.1.2</a>,
                                 	  <a class="xref" href="jls-9.html#jls-9.1.2" title="9.1.2.&nbsp;Generic Interfaces and Type Parameters">&sect;9.1.2</a>, <a class="xref" href="jls-8.html#jls-8.4.4" title="8.4.4.&nbsp;Generic Methods">&sect;8.4.4</a>,
                                 	  <a class="xref" href="jls-8.html#jls-8.8.4" title="8.8.4.&nbsp;Generic Constructors">&sect;8.8.4</a>)
                                 	
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-4.11-100-A-F"></a>
                                 	  The type in a field declaration of a class or interface
                                 	  (including an enum constant) (<a class="xref" href="jls-8.html#jls-8.3" title="8.3.&nbsp;Field Declarations">&sect;8.3</a>,
                                 	  <a class="xref" href="jls-9.html#jls-9.3" title="9.3.&nbsp;Field (Constant) Declarations">&sect;9.3</a>, <a class="xref" href="jls-8.html#jls-8.9.1" title="8.9.1.&nbsp;Enum Constants">&sect;8.9.1</a>)
                                 	
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-4.11-100-A-G"></a>
                                 	  The type in a formal parameter declaration of a method,
                                 	  constructor, or lambda expression
                                 	  (<a class="xref" href="jls-8.html#jls-8.4.1" title="8.4.1.&nbsp;Formal Parameters">&sect;8.4.1</a>, <a class="xref" href="jls-8.html#jls-8.8.1" title="8.8.1.&nbsp;Formal Parameters">&sect;8.8.1</a>,
                                 	  <a class="xref" href="jls-9.html#jls-9.4" title="9.4.&nbsp;Method Declarations">&sect;9.4</a>, <a class="xref" href="jls-15.html#jls-15.27.1" title="15.27.1.&nbsp;Lambda Parameters">&sect;15.27.1</a>)
                                 	
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-4.11-100-A-H"></a>
                                 	  The type of the receiver parameter of a method
                                 	  (<a class="xref" href="jls-8.html#jls-8.4.1" title="8.4.1.&nbsp;Formal Parameters">&sect;8.4.1</a>)
                                 	
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-4.11-100-A-I"></a>
                                 	  The type in a local variable declaration
                                 	  (<a class="xref" href="jls-14.html#jls-14.4" title="14.4.&nbsp;Local Variable Declaration Statements">&sect;14.4</a>, <a class="xref" href="jls-14.html#jls-14.14.1" title="14.14.1.&nbsp;The basic for Statement">&sect;14.14.1</a>,
                                 	  <a class="xref" href="jls-14.html#jls-14.14.2" title="14.14.2.&nbsp;The enhanced for statement">&sect;14.14.2</a>,
                                 	  <a class="xref" href="jls-14.html#jls-14.20.3" title="14.20.3.&nbsp;try-with-resources">&sect;14.20.3</a>)
                                 	
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-4.11-100-A-J"></a>
                                 	  The type in an exception parameter declaration
                                 	  (<a class="xref" href="jls-14.html#jls-14.20" title="14.20.&nbsp;The try statement">&sect;14.20</a>)
                                 	
                              </p>
                           </li>
                        </ol>
                     </div>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-4.11-100-B"></a>In expressions:
                     </p>
                     <div class="orderedlist">
                        <ol class="orderedlist" start="11" type="1">
                           <li class="listitem">
                              <p class="norm"><a name="jls-4.11-100-B-A"></a>
                                 	  A type in the explicit type argument list to an explicit
                                 	  constructor invocation statement or class instance creation
                                 	  expression or method invocation expression
                                 	  (<a class="xref" href="jls-8.html#jls-8.8.7.1" title="8.8.7.1.&nbsp;Explicit Constructor Invocations">&sect;8.8.7.1</a>, <a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>,
                                 	  <a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>)
                                 	
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-4.11-100-B-B"></a>
                                 	  In an unqualified class instance creation expression, as the
                                 	  class type to be instantiated (<a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>)
                                 	  or as the direct superclass or direct superinterface of an
                                 	  anonymous class to be instantiated
                                 	  (<a class="xref" href="jls-15.html#jls-15.9.5" title="15.9.5.&nbsp;Anonymous Class Declarations">&sect;15.9.5</a>)
                                 	
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-4.11-100-B-C"></a>
                                 	  The element type in an array creation expression
                                 	  (<a class="xref" href="jls-15.html#jls-15.10.1" title="15.10.1.&nbsp;Array Creation Expressions">&sect;15.10.1</a>)
                                 	
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-4.11-100-B-D"></a>
                                 	  The type in the cast operator of a cast expression
                                 	  (<a class="xref" href="jls-15.html#jls-15.16" title="15.16.&nbsp;Cast Expressions">&sect;15.16</a>)
                                 	
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-4.11-100-B-E"></a>
                                 	  The type that follows the <code class="literal">instanceof</code> relational operator
                                 	  (<a class="xref" href="jls-15.html#jls-15.20.2" title="15.20.2.&nbsp;Type Comparison Operator instanceof">&sect;15.20.2</a>)
                                 	
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-4.11-100-B-F"></a>
                                 	  In a method reference expression
                                 	  (<a class="xref" href="jls-15.html#jls-15.13" title="15.13.&nbsp;Method Reference Expressions">&sect;15.13</a>), as the reference type to
                                 	  search for a member method or as the class type or array
                                 	  type to construct.
                                 	
                              </p>
                           </li>
                        </ol>
                     </div>
                  </li>
               </ul>
            </div>
            <p class="norm"><a name="jls-4.11-110"></a>Also, types are used as:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm"><a name="jls-4.11-110-A"></a>
                              The element type of an array type in any of the above contexts; and
                            
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-4.11-110-B"></a>
                              A non-wildcard type argument, or a bound of a wildcard type
                              argument, of a parameterized type in any of the above contexts.
                            
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm"><a name="jls-4.11-120"></a>Finally, there are three
               special terms in the Java programming language which denote the use of a type:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm"><a name="jls-4.11-120-A"></a>
                              An unbounded wildcard (<a class="xref" href="jls-4.html#jls-4.5.1" title="4.5.1.&nbsp;Type Arguments of Parameterized Types">&sect;4.5.1</a>)
                            
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-4.11-120-B"></a>
                              The <code class="literal">...</code> in the type of a variable arity parameter
                              (<a class="xref" href="jls-8.html#jls-8.4.1" title="8.4.1.&nbsp;Formal Parameters">&sect;8.4.1</a>), to indicate an array type
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-4.11-120-C"></a>
                              The simple name of a type in a constructor declaration
                              (<a class="xref" href="jls-8.html#jls-8.8" title="8.8.&nbsp;Constructor Declarations">&sect;8.8</a>), to indicate the class of the
                              constructed object
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm"><a name="jls-4.11-200"></a>The meaning of types in type
               contexts is given by:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm"><a name="jls-4.11-200-A"></a>
                              <a class="xref" href="jls-4.html#jls-4.2" title="4.2.&nbsp;Primitive Types and Values">&sect;4.2</a>, for primitive types
                            
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-4.11-200-B"></a>
                              <a class="xref" href="jls-4.html#jls-4.4" title="4.4.&nbsp;Type Variables">&sect;4.4</a>, for type parameters
                            
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-4.11-200-C"></a>
                              <a class="xref" href="jls-4.html#jls-4.5" title="4.5.&nbsp;Parameterized Types">&sect;4.5</a>, for class and interface types that
                              are parameterized, or appear either as type arguments in a
                              parameterized type or as bounds of wildcard type arguments in a
                              parameterized type
                            
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-4.11-200-D"></a>
                              <a class="xref" href="jls-4.html#jls-4.8" title="4.8.&nbsp;Raw Types">&sect;4.8</a>, for class and interface types that
                              are raw
                            
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-4.11-200-E"></a>
                              <a class="xref" href="jls-4.html#jls-4.9" title="4.9.&nbsp;Intersection Types">&sect;4.9</a>, for intersection types in the bounds
                              of type parameters
                            
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-4.11-200-F"></a>
                              <a class="xref" href="jls-6.html#jls-6.5" title="6.5.&nbsp;Determining the Meaning of a Name">&sect;6.5</a>, for class and interface types in
                              contexts where genericity is unimportant
                              (<a class="xref" href="jls-6.html#jls-6.1" title="6.1.&nbsp;Declarations">&sect;6.1</a>)
                            
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-4.11-200-G"></a>
                              <a class="xref" href="jls-10.html#jls-10.1" title="10.1.&nbsp;Array Types">&sect;10.1</a>, for array types
                            
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm"><a name="jls-4.11-300"></a>Some type contexts restrict
               how a reference type may be parameterized:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm"><a name="jls-4.11-300-A"></a>
                              The following type contexts require that if a type is a
                              parameterized reference type, it has no wildcard type
                              arguments:
                     </p>
                     <div class="norm">
                        <ul class="norm" type="circle">
                           <li class="listitem">
                              <p class="norm"><a name="jls-4.11-300-A-A"></a>
                                 	  In an <code class="literal">extends</code> or <code class="literal">implements</code> clause of a class
                                 	  declaration (<a class="xref" href="jls-8.html#jls-8.1.4" title="8.1.4.&nbsp;Superclasses and Subclasses">&sect;8.1.4</a>,
                                 	  <a class="xref" href="jls-8.html#jls-8.1.5" title="8.1.5.&nbsp;Superinterfaces">&sect;8.1.5</a>)
                                 	
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-4.11-300-A-B"></a>
                                 	  In an <code class="literal">extends</code> clause of an interface declaration
                                 	  (<a class="xref" href="jls-9.html#jls-9.1.3" title="9.1.3.&nbsp;Superinterfaces and Subinterfaces">&sect;9.1.3</a>)
                                 	
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-4.11-300-A-C"></a>
                                 	  In an unqualified class instance creation expression, as the
                                 	  class type to be instantiated (<a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>)
                                 	  or as the direct superclass or direct superinterface of an
                                 	  anonymous class to be instantiated
                                 	  (<a class="xref" href="jls-15.html#jls-15.9.5" title="15.9.5.&nbsp;Anonymous Class Declarations">&sect;15.9.5</a>)
                                 	
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-4.11-300-A-D"></a>
                                 	  In a method reference expression
                                 	  (<a class="xref" href="jls-15.html#jls-15.13" title="15.13.&nbsp;Method Reference Expressions">&sect;15.13</a>), as the reference type to
                                 	  search for a member method or as the class type or array
                                 	  type to construct.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <p class="norm"><a name="jls-4.11-300-A.1"></a>
                              In addition, no wildcard type arguments are permitted in the
                              explicit type argument list to an explicit constructor
                              invocation statement or class instance creation expression or
                              method invocation expression or method reference expression
                              (<a class="xref" href="jls-8.html#jls-8.8.7.1" title="8.8.7.1.&nbsp;Explicit Constructor Invocations">&sect;8.8.7.1</a>, <a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>,
                              <a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>,
                              <a class="xref" href="jls-15.html#jls-15.13" title="15.13.&nbsp;Method Reference Expressions">&sect;15.13</a>).
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-4.11-300-B"></a>
                              The following type contexts require that if a type is a
                              parameterized reference type, it has only unbounded wildcard
                              type arguments (i.e. it is a reifiable type) :
                     </p>
                     <div class="norm">
                        <ul class="norm" type="circle">
                           <li class="listitem">
                              <p class="norm"><a name="jls-4.11-300-B-A"></a>
                                 	  As the element type in an array creation expression
                                 	  (<a class="xref" href="jls-15.html#jls-15.10.1" title="15.10.1.&nbsp;Array Creation Expressions">&sect;15.10.1</a>)
                                 	
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-4.11-300-B-B"></a>
                                 	  As the type that follows the <code class="literal">instanceof</code> relational
                                 	  operator (<a class="xref" href="jls-15.html#jls-15.20.2" title="15.20.2.&nbsp;Type Comparison Operator instanceof">&sect;15.20.2</a>)
                                 	
                              </p>
                           </li>
                        </ul>
                     </div>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-4.11-300-C"></a>
                              The following type contexts disallow a parameterized reference
                              type altogether, because they involve exceptions and the type of
                              an exception is non-generic (<a class="xref" href="jls-6.html#jls-6.1" title="6.1.&nbsp;Declarations">&sect;6.1</a>):
                     </p>
                     <div class="norm">
                        <ul class="norm" type="circle">
                           <li class="listitem">
                              <p class="norm"><a name="jls-4.11-300-C-A"></a>
                                 	  As the type of an exception that can be thrown by a method
                                 	  or constructor (<a class="xref" href="jls-8.html#jls-8.4.6" title="8.4.6.&nbsp;Method Throws">&sect;8.4.6</a>,
                                 	  <a class="xref" href="jls-8.html#jls-8.8.5" title="8.8.5.&nbsp;Constructor Throws">&sect;8.8.5</a>, <a class="xref" href="jls-9.html#jls-9.4" title="9.4.&nbsp;Method Declarations">&sect;9.4</a>)
                                 	
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-4.11-300-C-B"></a>
                                 	  In an exception parameter declaration
                                 	  (<a class="xref" href="jls-14.html#jls-14.20" title="14.20.&nbsp;The try statement">&sect;14.20</a>)
                                 	
                              </p>
                           </li>
                        </ul>
                     </div>
                  </li>
               </ul>
            </div>
            <p class="note">In any type context where a type is used, it is
               possible to annotate the keyword denoting a primitive type or the
               <span class="emphasis"><em>Identifier</em></span> denoting the simple name of a reference type. It is also
               possible to annotate an array type by writing an annotation to the
               left of the <code class="literal">[</code> at the desired level of nesting in the array
               type. Annotations in these locations are called <span class="emphasis"><em>type
                     annotations</em></span>, and are specified in
               <a class="xref" href="jls-9.html#jls-9.7.4" title="9.7.4.&nbsp;Where Annotations May Appear">&sect;9.7.4</a>. Here are some examples:
            </p>
            <div class="note">
               <ul class="note" type="disc">
                  <li class="listitem">
                     <p class="note"><code class="literal">@Foo int[] f;</code> annotates the
                              primitive type <code class="literal">int</code></p>
                  </li>
                  <li class="listitem">
                     <p class="note"><code class="literal">int @Foo [] f;</code> annotates the
                              array type <code class="literal">int</code><code class="literal">[]</code></p>
                  </li>
                  <li class="listitem">
                     <p class="note"><code class="literal">int @Foo [][] f;</code> annotates
                              the array type <code class="literal">int</code><code class="literal">[]</code><code class="literal">[]</code></p>
                  </li>
                  <li class="listitem">
                     <p class="note"><code class="literal">int[] @Foo [] f;</code> annotates
                              the array type <code class="literal">int</code><code class="literal">[]</code> which is the component type of
                              the array type <code class="literal">int</code><code class="literal">[]</code><code class="literal">[]</code></p>
                  </li>
               </ul>
            </div>
            <p class="note">Five of the <span class="emphasis"><em>type contexts</em></span> which
               appear in declarations occupy the same syntactic real estate as a
               number of <span class="emphasis"><em>declaration contexts</em></span>
               (<a class="xref" href="jls-9.html#jls-9.6.4.1" title="9.6.4.1.&nbsp;@Target">&sect;9.6.4.1</a>):
            </p>
            <div class="note">
               <ul class="note" type="disc">
                  <li class="listitem">
                     <p class="note">The return type of a method (including the type
                              of an element of an annotation type)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="note">The type in a field declaration of a class or
                              interface (including an enum constant)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="note">The type in a formal parameter declaration of a
                              method, constructor, or lambda expression
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="note">The type in a local variable declaration</p>
                  </li>
                  <li class="listitem">
                     <p class="note">The type in an exception parameter declaration</p>
                  </li>
               </ul>
            </div>
            <p class="note">The fact that the same syntactic location in a
               program can be both a type context and a declaration context arises
               because the modifiers for a declaration immediately precede the type
               of the declared entity. <a class="xref" href="jls-9.html#jls-9.7.4" title="9.7.4.&nbsp;Where Annotations May Appear">&sect;9.7.4</a> explains how an
               annotation in such a location is deemed to appear in a type context or
               a declaration context or both.
            </p>
            <div class="example"><a name="d5e4665"></a><p class="title"><b>Example&nbsp;4.11-1.&nbsp;Usage of a Type</b></p>
               <div class="example-contents"><pre class="programlisting">
import java.util.Random;
import java.util.Collection;
import java.util.ArrayList;

class MiscMath&lt;T extends Number&gt; {
    int divisor;
    MiscMath(int divisor) { this.divisor = divisor; }
    float ratio(long l) {
        try {
            l /= divisor;
        } catch (Exception e) {
            if (e instanceof ArithmeticException)
                l = Long.MAX_VALUE;
            else
                l = 0;
        }
        return (float)l;
    }
    double gausser() {
        Random r = new Random();
        double[] val = new double[2];
        val[0] = r.nextGaussian();
        val[1] = r.nextGaussian();
        return (val[0] + val[1]) / 2;
    }
    Collection&lt;Number&gt; fromArray(Number[] na) {
        Collection&lt;Number&gt; cn = new ArrayList&lt;Number&gt;();
        for (Number n : na) cn.add(n);
        return cn;
    }
    &lt;S&gt; void loop(S s) { this.&lt;S&gt;loop(s); }  
}
</pre><p class="note">In this example, types are used in declarations of
                     the following:
                  </p>
                  <div class="note">
                     <ul class="note" type="disc">
                        <li class="listitem">
                           <p class="note">Imported types (<a class="xref" href="jls-7.html#jls-7.5" title="7.5.&nbsp;Import Declarations">&sect;7.5</a>); here
                                    the type <code class="literal">Random</code>, imported from the
                                    type <code class="literal">java.util.Random</code> of the
                                    package <code class="literal">java.util</code>, is declared
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="note">Fields, which are the class variables and
                                    instance variables of classes (<a class="xref" href="jls-8.html#jls-8.3" title="8.3.&nbsp;Field Declarations">&sect;8.3</a>), and
                                    constants of interfaces (<a class="xref" href="jls-9.html#jls-9.3" title="9.3.&nbsp;Field (Constant) Declarations">&sect;9.3</a>); here the
                                    field <code class="literal">divisor</code> in the
                                    class <code class="literal">MiscMath</code> is declared to be of type
                                    <code class="literal">int</code></p>
                        </li>
                        <li class="listitem">
                           <p class="note">Method parameters (<a class="xref" href="jls-8.html#jls-8.4.1" title="8.4.1.&nbsp;Formal Parameters">&sect;8.4.1</a>);
                                    here the parameter <code class="literal">l</code> of the
                                    method <code class="literal">ratio</code> is declared to be of type
                                    <code class="literal">long</code></p>
                        </li>
                        <li class="listitem">
                           <p class="note">Method results (<a class="xref" href="jls-8.html#jls-8.4" title="8.4.&nbsp;Method Declarations">&sect;8.4</a>); here
                                    the result of the method <code class="literal">ratio</code> is declared to
                                    be of type <code class="literal">float</code>, and the result of the
                                    method <code class="literal">gausser</code> is declared to be of type
                                    <code class="literal">double</code></p>
                        </li>
                        <li class="listitem">
                           <p class="note">Constructor parameters
                                    (<a class="xref" href="jls-8.html#jls-8.8.1" title="8.8.1.&nbsp;Formal Parameters">&sect;8.8.1</a>); here the parameter of the
                                    constructor for <code class="literal">MiscMath</code> is declared to be of
                                    type <code class="literal">int</code></p>
                        </li>
                        <li class="listitem">
                           <p class="note">Local variables (<a class="xref" href="jls-14.html#jls-14.4" title="14.4.&nbsp;Local Variable Declaration Statements">&sect;14.4</a>,
                                    <a class="xref" href="jls-14.html#jls-14.14" title="14.14.&nbsp;The for Statement">&sect;14.14</a>); the local
                                    variables <code class="literal">r</code> and <code class="literal">val</code> of the
                                    method <code class="literal">gausser</code> are declared to be of
                                    types <code class="literal">Random</code> and <code class="literal">double</code><code class="literal">[]</code> (array of
                                    <code class="literal">double</code>)
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="note">Exception parameters
                                    (<a class="xref" href="jls-14.html#jls-14.20" title="14.20.&nbsp;The try statement">&sect;14.20</a>); here the exception
                                    parameter <code class="literal">e</code> of the <code class="literal">catch</code> clause is declared
                                    to be of type <code class="literal">Exception</code></p>
                        </li>
                        <li class="listitem">
                           <p class="note">Type parameters (<a class="xref" href="jls-4.html#jls-4.4" title="4.4.&nbsp;Type Variables">&sect;4.4</a>);
                                    here the type parameter of <code class="literal">MiscMath</code> is a type
                                    variable <code class="literal">T</code> with the
                                    type <code class="literal">Number</code> as its declared bound
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="note">In any declaration that uses a parameterized
                                    type; here the type <code class="literal">Number</code> is used as a type
                                    argument (<a class="xref" href="jls-4.html#jls-4.5.1" title="4.5.1.&nbsp;Type Arguments of Parameterized Types">&sect;4.5.1</a>) in the parameterized
                                    type <code class="literal">Collection&lt;Number&gt;</code>.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p class="note">and in expressions of the following kinds:</p>
                  <div class="note">
                     <ul class="note" type="disc">
                        <li class="listitem">
                           <p class="note">Class instance creations
                                    (<a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>); here a local
                                    variable <code class="literal">r</code> of
                                    method <code class="literal">gausser</code> is initialized by a class
                                    instance creation expression that uses the
                                    type <code class="literal">Random</code></p>
                        </li>
                        <li class="listitem">
                           <p class="note">Generic class (<a class="xref" href="jls-8.html#jls-8.1.2" title="8.1.2.&nbsp;Generic Classes and Type Parameters">&sect;8.1.2</a>)
                                    instance creations (<a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>);
                                    here <code class="literal">Number</code> is used as a type argument in the
                                    expression <code class="literal">new
                                       ArrayList&lt;Number&gt;()</code></p>
                        </li>
                        <li class="listitem">
                           <p class="note">Array creations (<a class="xref" href="jls-15.html#jls-15.10.1" title="15.10.1.&nbsp;Array Creation Expressions">&sect;15.10.1</a>);
                                    here the local variable <code class="literal">val</code> of
                                    method <code class="literal">gausser</code> is initialized by an array
                                    creation expression that creates an array of <code class="literal">double</code> with size
                                    2
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="note">Generic method (<a class="xref" href="jls-8.html#jls-8.4.4" title="8.4.4.&nbsp;Generic Methods">&sect;8.4.4</a>) or
                                    constructor (<a class="xref" href="jls-8.html#jls-8.8.4" title="8.8.4.&nbsp;Generic Constructors">&sect;8.8.4</a>) invocations
                                    (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>); here the
                                    method <code class="literal">loop</code> calls itself with an explicit
                                    type argument <code class="literal">S</code></p>
                        </li>
                        <li class="listitem">
                           <p class="note">Casts (<a class="xref" href="jls-15.html#jls-15.16" title="15.16.&nbsp;Cast Expressions">&sect;15.16</a>); here the
                                    <code class="literal">return</code> statement of the method <code class="literal">ratio</code> uses
                                    the <code class="literal">float</code> type in a cast
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="note">The <code class="literal">instanceof</code> operator
                                   (<a class="xref" href="jls-15.html#jls-15.20.2" title="15.20.2.&nbsp;Type Comparison Operator instanceof">&sect;15.20.2</a>); here the <code class="literal">instanceof</code> operator
                                   tests whether <code class="literal">e</code> is assignment-compatible with
                                   the type <code class="literal">ArithmeticException</code></p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><br class="example-break"></div>
         <div class="section" title="4.12.&nbsp;Variables">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-4.12"></a>4.12.&nbsp;Variables
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-4.12-100"></a>A variable
               is a storage location and has an associated type, sometimes called
               its <span class="emphasis"><em>compile-time type</em></span>, that is either a primitive
               type (<a class="xref" href="jls-4.html#jls-4.2" title="4.2.&nbsp;Primitive Types and Values">&sect;4.2</a>) or a reference type
               (<a class="xref" href="jls-4.html#jls-4.3" title="4.3.&nbsp;Reference Types and Values">&sect;4.3</a>).
            </p>
            <p class="norm"><a name="jls-4.12-110"></a>A variable's value is changed
               by an assignment (<a class="xref" href="jls-15.html#jls-15.26" title="15.26.&nbsp;Assignment Operators">&sect;15.26</a>) or by a prefix or
               postfix <code class="literal">++</code> (increment) or <code class="literal">--</code> (decrement) operator
               (<a class="xref" href="jls-15.html#jls-15.14.2" title="15.14.2.&nbsp;Postfix Increment Operator ++">&sect;15.14.2</a>, <a class="xref" href="jls-15.html#jls-15.14.3" title="15.14.3.&nbsp;Postfix Decrement Operator --">&sect;15.14.3</a>,
               <a class="xref" href="jls-15.html#jls-15.15.1" title="15.15.1.&nbsp;Prefix Increment Operator ++">&sect;15.15.1</a>, <a class="xref" href="jls-15.html#jls-15.15.2" title="15.15.2.&nbsp;Prefix Decrement Operator --">&sect;15.15.2</a>).
            </p>
            <p class="norm"><a name="jls-4.12-120"></a>Compatibility of the value of
               a variable with its type is guaranteed by the design of the
               Java programming language, as long as a program does not give rise to compile-time
               unchecked warnings (<a class="xref" href="jls-4.html#jls-4.12.2" title="4.12.2.&nbsp;Variables of Reference Type">&sect;4.12.2</a>). Default values
               (<a class="xref" href="jls-4.html#jls-4.12.5" title="4.12.5.&nbsp;Initial Values of Variables">&sect;4.12.5</a>) are compatible and all assignments to a
               variable are checked for assignment compatibility
               (<a class="xref" href="jls-5.html#jls-5.2" title="5.2.&nbsp;Assignment Contexts">&sect;5.2</a>), usually at compile time, but, in a single
               case involving arrays, a run-time check is made
               (<a class="xref" href="jls-10.html#jls-10.5" title="10.5.&nbsp;Array Store Exception">&sect;10.5</a>).
            </p>
            <div class="section" title="4.12.1.&nbsp;Variables of Primitive Type">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.12.1"></a>4.12.1.&nbsp;Variables of Primitive Type
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-dynamic"><a name="jls-4.12.1-100"></a>A
                  variable of a primitive type always holds
                  a primitive value of that exact primitive
                  type.
               </p>
            </div>
            <div class="section" title="4.12.2.&nbsp;Variables of Reference Type">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.12.2"></a>4.12.2.&nbsp;Variables of Reference Type
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-dynamic"><a name="jls-4.12.2-100"></a>A
                  variable of a class type <span class="type">T</span> can hold a null reference or a reference
                  to an instance of class <span class="type">T</span> or of any class that is a subclass of
                  <span class="type">T</span>.
               </p>
               <p class="norm-dynamic"><a name="jls-4.12.2-110"></a>A
                  variable of an interface type can hold a null reference or a reference
                  to any instance of any class that implements the interface.
               </p>
               <p class="note">Note that a variable is not guaranteed to always
                  refer to a subtype of its declared type, but only to subclasses or
                  subinterfaces of the declared type. This is due to the possibility of
                  heap pollution discussed below.
               </p>
               <p class="norm-dynamic"><a name="jls-4.12.2-200"></a>If <span class="type">T</span>
                  is a primitive type, then a variable of type "array of <span class="type">T</span>" can hold a
                  null reference or a reference to any array of type "array of
                  <span class="type">T</span>".
               </p>
               <p class="norm-dynamic"><a name="jls-4.12.2-210"></a>If <span class="type">T</span>
                  is a reference type, then a variable of type "array of <span class="type">T</span>" can hold a
                  null reference or a reference to any array of type "array of <span class="type">S</span>" such
                  that type <span class="type">S</span> is a subclass or subinterface of type <span class="type">T</span>.
               </p>
               <p class="norm-dynamic"><a name="jls-4.12.2-220"></a>A
                  variable of type <code class="literal">Object</code><code class="literal">[]</code> can hold a reference to an array
                  of any reference type.
               </p>
               <p class="norm-dynamic"><a name="jls-4.12.2-230"></a>A
                  variable of type <code class="literal">Object</code> can hold a null reference or a reference to
                  any object, whether it is an instance of a class or an array.
               </p>
               <p class="norm"><a name="jls-4.12.2-300"></a>It is possible that a variable of a
                  parameterized type will refer to an object that is not of that
                  parameterized type. This situation is known as <span class="emphasis"><em>heap
                        pollution</em></span>.
               </p>
               <p class="norm-dynamic"><a name="jls-4.12.2-310"></a>Heap
                  pollution can only occur if the program performed some operation
                  involving a raw type that would give rise to a compile-time unchecked
                  warning (<a class="xref" href="jls-4.html#jls-4.8" title="4.8.&nbsp;Raw Types">&sect;4.8</a>, <a class="xref" href="jls-5.html#jls-5.1.9" title="5.1.9.&nbsp;Unchecked Conversion">&sect;5.1.9</a>,
                  <a class="xref" href="jls-5.html#jls-5.5.2" title="5.5.2.&nbsp;Checked Casts and Unchecked Casts">&sect;5.5.2</a>, <a class="xref" href="jls-8.html#jls-8.4.1" title="8.4.1.&nbsp;Formal Parameters">&sect;8.4.1</a>,
                  <a class="xref" href="jls-8.html#jls-8.4.8.3" title="8.4.8.3.&nbsp;Requirements in Overriding and Hiding">&sect;8.4.8.3</a>, <a class="xref" href="jls-8.html#jls-8.4.8.4" title="8.4.8.4.&nbsp;Inheriting Methods with Override-Equivalent Signatures">&sect;8.4.8.4</a>,
                  <a class="xref" href="jls-9.html#jls-9.4.1.2" title="9.4.1.2.&nbsp;Requirements in Overriding">&sect;9.4.1.2</a>, <a class="xref" href="jls-15.html#jls-15.12.4.2" title="15.12.4.2.&nbsp;Evaluate Arguments">&sect;15.12.4.2</a>), or if
                  the program aliases an array variable of non-reifiable element type
                  through an array variable of a supertype which is either raw or
                  non-generic.
               </p>
               <div class="informalexample">
                  <p class="note">For example, the code:</p><pre class="programlisting">
List l = new ArrayList&lt;Number&gt;();
List&lt;String&gt; ls = l;  // Unchecked warning
</pre><p class="note">gives rise to a compile-time unchecked warning,
                     because it is not possible to ascertain, either at compile time
                     (within the limits of the compile-time type checking rules) or at run
                     time, whether the variable <code class="literal">l</code> does indeed refer to
                     a <code class="literal">List&lt;String&gt;</code>.
                  </p>
                  <p class="note">If the code above is executed, heap pollution
                     arises, as the variable <code class="literal">ls</code>, declared to be
                     a <code class="literal">List&lt;String&gt;</code>, refers to a value that is not
                     in fact a <code class="literal">List&lt;String&gt;</code>.
                  </p>
                  <p class="note">The problem cannot be identified at run time
                     because type variables are not reified, and thus instances do not
                     carry any information at run time regarding the type arguments used to
                     create them.
                  </p>
                  <p class="note">In a simple example as given above, it may appear
                     that it should be straightforward to identify the situation at compile
                     time and give an error. However, in the general (and typical) case,
                     the value of the variable <code class="literal">l</code> may be the result of an
                     invocation of a separately compiled method, or its value may depend
                     upon arbitrary control flow. The code above is therefore very
                     atypical, and indeed very bad style.
                  </p>
                  <p class="note">Furthermore, the fact that <code class="literal">Object</code><code class="literal">[]</code> is a
                     supertype of all array types means that unsafe aliasing can occur
                     which leads to heap pollution. For example, the following code
                     compiles because it is statically type-correct:
                  </p><pre class="programlisting">

static void m(List&lt;String&gt;... stringLists) {
    Object[] array = stringLists;
    List&lt;Integer&gt; tmpList = Arrays.asList(42);
    array[0] = tmpList;                // (1)
    String s = stringLists[0].get(0);  // (2)
}

</pre><p class="note">Heap pollution occurs at (1) because a component in
                     the <code class="literal">stringLists</code> array that should refer to a
                     <code class="literal">List&lt;String&gt;</code> now refers to
                     a <code class="literal">List&lt;Integer&gt;</code>. There is no way to detect
                     this pollution in the presence of both a universal supertype
                     (<code class="literal">Object</code><code class="literal">[]</code>) and a non-reifiable type (the declared type of
                     the formal
                     parameter, <code class="literal">List&lt;String&gt;</code><code class="literal">[]</code>). No
                     unchecked warning is justified at (1); nevertheless, at run time, a
                     <code class="literal">ClassCastException</code> will occur at (2).
                  </p>
                  <p class="note">A compile-time unchecked warning will be given at
                     any invocation of the method above because an invocation is considered
                     by the Java programming language's static type system to create an array whose
                     element type, <code class="literal">List&lt;String&gt;</code>, is non-reifiable
                     (<a class="xref" href="jls-15.html#jls-15.12.4.2" title="15.12.4.2.&nbsp;Evaluate Arguments">&sect;15.12.4.2</a>). <span class="emphasis"><em>If and only if</em></span>
                     the body of the method was type-safe with respect to the variable
                     arity parameter, then the programmer could use the <code class="literal">SafeVarargs</code>
                     annotation to silence warnings at invocations
                     (<a class="xref" href="jls-9.html#jls-9.6.4.7" title="9.6.4.7.&nbsp;@SafeVarargs">&sect;9.6.4.7</a>). Since the body of the method as
                     written above causes heap pollution, it would be completely
                     inappropriate to use the annotation to disable warnings for
                     callers.
                  </p>
                  <p class="note">Finally, note that
                     the <code class="literal">stringLists</code> array could be aliased through
                     variables of types other than <code class="literal">Object</code><code class="literal">[]</code>, and heap pollution
                     could still occur. For example, the type of
                     the <code class="literal">array</code> variable could
                     be <code class="literal">java.util.Collection[]</code> - a raw element type -
                     and the body of the method above would compile without warnings or
                     errors and still cause heap pollution. And if the Java SE platform defined,
                     say, <code class="literal">Sequence</code> as a non-generic supertype
                     of <code class="literal">List&lt;T&gt;</code>, then
                     using <code class="literal">Sequence</code> as the type
                     of <code class="literal">array</code> would also cause heap pollution.
                  </p>
               </div>
               <p class="norm-static"><a name="jls-4.12.2-320"></a>The
                  variable will always refer to an object that is an instance of a class
                  that represents the parameterized type.
               </p>
               <p class="note">The value of <code class="literal">ls</code> in the example
                  above is always an instance of a class that provides a representation
                  of a <code class="literal">List</code>.
               </p>
               <p class="note">Assignment from an expression of a raw type to a
                  variable of a parameterized type should only be used when combining
                  legacy code which does not make use of parameterized types with more
                  modern code that does.
               </p>
               <p class="note">If no operation that requires a compile-time
                  unchecked warning to be issued takes place, and no unsafe
                  aliasing occurs of array variables with non-reifiable element
                  types, then heap pollution cannot occur. Note that this does
                  not imply that heap pollution only occurs if a compile-time unchecked
                  warning actually occurred. It is possible to run a program where some
                  of the binaries were produced by a compiler for an older version of
                  the Java programming language, or from sources that explicitly suppressed unchecked
                  warnings. This practice is unhealthy at best.
               </p>
               <p class="note">Conversely, it is possible that despite executing
                  code that could (and perhaps did) give rise to a compile-time
                  unchecked warning, no heap pollution takes place. Indeed, good
                  programming practice requires that the programmer satisfy herself that
                  despite any unchecked warning, the code is correct and heap pollution
                  will not occur.
               </p>
            </div>
            <div class="section" title="4.12.3.&nbsp;Kinds of Variables">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.12.3"></a>4.12.3.&nbsp;Kinds of Variables
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-4.12.3-100"></a>There are eight kinds of
                  variables:
               </p>
               <div class="orderedlist">
                  <ol class="orderedlist" type="1">
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.12.3-100-A"></a>
                                A <span class="emphasis"><em>class variable</em></span> is a field declared using
                                the keyword <code class="literal">static</code> within a class declaration
                                (<a class="xref" href="jls-8.html#jls-8.3.1.1" title="8.3.1.1.&nbsp;static Fields">&sect;8.3.1.1</a>), or with or without the keyword
                                <code class="literal">static</code> within an interface declaration
                                (<a class="xref" href="jls-9.html#jls-9.3" title="9.3.&nbsp;Field (Constant) Declarations">&sect;9.3</a>).
                        </p>
                        <p class="norm"><a name="jls-4.12.3-100-A.1"></a>
                                 A class variable is created when its class or interface is
                                 prepared (<a class="xref" href="jls-12.html#jls-12.3.2" title="12.3.2.&nbsp;Preparation of a Class or Interface Type">&sect;12.3.2</a>) and is initialized to a
                                 default value (<a class="xref" href="jls-4.html#jls-4.12.5" title="4.12.5.&nbsp;Initial Values of Variables">&sect;4.12.5</a>). The class variable
                                 effectively ceases to exist when its class or interface is
                                 unloaded (<a class="xref" href="jls-12.html#jls-12.7" title="12.7.&nbsp;Unloading of Classes and Interfaces">&sect;12.7</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.12.3-100-B"></a>
                                 An <span class="emphasis"><em>instance variable</em></span> is a field declared
                                 within a class declaration without using the keyword <code class="literal">static</code>
                                 (<a class="xref" href="jls-8.html#jls-8.3.1.1" title="8.3.1.1.&nbsp;static Fields">&sect;8.3.1.1</a>).
                        </p>
                        <p class="norm"><a name="jls-4.12.3-100-B.1"></a>
                                 If a class <span class="type">T</span> has a field <code class="literal">a</code> that is an
                                 instance variable, then a new instance
                                 variable <code class="literal">a</code> is created and initialized to a
                                 default value (<a class="xref" href="jls-4.html#jls-4.12.5" title="4.12.5.&nbsp;Initial Values of Variables">&sect;4.12.5</a>) as part of each
                                 newly created object of class <span class="type">T</span> or of any class that is a
                                 subclass of <span class="type">T</span> (<a class="xref" href="jls-8.html#jls-8.1.4" title="8.1.4.&nbsp;Superclasses and Subclasses">&sect;8.1.4</a>). The instance
                                 variable effectively ceases to exist when the object of which it
                                 is a field is no longer referenced, after any necessary
                                 finalization of the object (<a class="xref" href="jls-12.html#jls-12.6" title="12.6.&nbsp;Finalization of Class Instances">&sect;12.6</a>) has been
                                 completed.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.12.3-100-C"></a>
                                 <span class="emphasis"><em>Array components</em></span> are unnamed variables that
                                 are created and initialized to default values
                                 (<a class="xref" href="jls-4.html#jls-4.12.5" title="4.12.5.&nbsp;Initial Values of Variables">&sect;4.12.5</a>) whenever a new object that is an
                                 array is created (<a class="xref" href="jls-10.html" title="Chapter&nbsp;10.&nbsp;Arrays">&sect;10 (<i>Arrays</i>)</a>,
                                 <a class="xref" href="jls-15.html#jls-15.10.2" title="15.10.2.&nbsp;Run-Time Evaluation of Array Creation Expressions">&sect;15.10.2</a>). The array components effectively
                                 cease to exist when the array is no longer referenced.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.12.3-100-D"></a>
                                 <span class="emphasis"><em>Method parameters</em></span>
                                 (<a class="xref" href="jls-8.html#jls-8.4.1" title="8.4.1.&nbsp;Formal Parameters">&sect;8.4.1</a>) name argument values passed to a
                                 method.
                        </p>
                        <p class="norm"><a name="jls-4.12.3-100-D.1"></a>
                                 For every parameter declared in a method declaration, a new
                                 parameter variable is created each time that method is invoked
                                 (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>). The new variable is initialized
                                 with the corresponding argument value from the method
                                 invocation. The method parameter effectively ceases to exist
                                 when the execution of the body of the method is complete.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.12.3-100-E"></a>
                                 <span class="emphasis"><em>Constructor parameters</em></span>
                                 (<a class="xref" href="jls-8.html#jls-8.8.1" title="8.8.1.&nbsp;Formal Parameters">&sect;8.8.1</a>) name argument values passed to a
                                 constructor.
                        </p>
                        <p class="norm"><a name="jls-4.12.3-100-E.1"></a>
                                 For every parameter declared in a constructor declaration, a new
                                 parameter variable is created each time a class instance
                                 creation expression (<a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>) or explicit
                                 constructor invocation (<a class="xref" href="jls-8.html#jls-8.8.7" title="8.8.7.&nbsp;Constructor Body">&sect;8.8.7</a>) invokes
                                 that constructor. The new variable is initialized with the
                                 corresponding argument value from the creation expression or
                                 constructor invocation. The constructor parameter effectively
                                 ceases to exist when the execution of the body of the
                                 constructor is complete.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.12.3-100-F"></a>
                                 <span class="emphasis"><em>Lambda parameters</em></span>
                                 (<a class="xref" href="jls-15.html#jls-15.27.1" title="15.27.1.&nbsp;Lambda Parameters">&sect;15.27.1</a>) name argument values passed to a
                                 lambda expression body (<a class="xref" href="jls-15.html#jls-15.27.2" title="15.27.2.&nbsp;Lambda Body">&sect;15.27.2</a>).
                        </p>
                        <p class="norm"><a name="jls-4.12.3-100-F.1"></a>
                                 For every parameter declared in a lambda expression, a new
                                 parameter variable is created each time a method implemented by
                                 the lambda body is invoked (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>). The
                                 new variable is initialized with the corresponding argument
                                 value from the method invocation.  The lambda parameter
                                 effectively ceases to exist when the execution of the lambda
                                 expression body is complete.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.12.3-100-G"></a>
                                 An <span class="emphasis"><em>exception parameter</em></span> is created each time
                                 an exception is caught by a <code class="literal">catch</code> clause of a <code class="literal">try</code> statement
                                 (<a class="xref" href="jls-14.html#jls-14.20" title="14.20.&nbsp;The try statement">&sect;14.20</a>).
                        </p>
                        <p class="norm"><a name="jls-4.12.3-100-G.1"></a>
                                 The new variable is initialized with the actual object
                                 associated with the exception (<a class="xref" href="jls-11.html#jls-11.3" title="11.3.&nbsp;Run-Time Handling of an Exception">&sect;11.3</a>,
                                 <a class="xref" href="jls-14.html#jls-14.18" title="14.18.&nbsp;The throw Statement">&sect;14.18</a>). The exception parameter
                                 effectively ceases to exist when execution of the block
                                 associated with the <code class="literal">catch</code> clause is complete.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-4.12.3-100-H"></a>
                                 <span class="emphasis"><em>Local variables</em></span> are declared by local
                                 variable declaration statements
                                 (<a class="xref" href="jls-14.html#jls-14.4" title="14.4.&nbsp;Local Variable Declaration Statements">&sect;14.4</a>).
                        </p>
                        <p class="norm"><a name="jls-4.12.3-100-H.1"></a>
                                 Whenever the flow of control enters a block
                                 (<a class="xref" href="jls-14.html#jls-14.2" title="14.2.&nbsp;Blocks">&sect;14.2</a>) or <code class="literal">for</code> statement
                                 (<a class="xref" href="jls-14.html#jls-14.14" title="14.14.&nbsp;The for Statement">&sect;14.14</a>), a new variable is created for
                                 each local variable declared in a local variable declaration
                                 statement immediately contained within that block or <code class="literal">for</code>
                                 statement.
                        </p>
                        <p class="norm"><a name="jls-4.12.3-100-H.2"></a>
                                 A local variable declaration statement may contain an expression
                                 which initializes the variable. The local variable with an
                                 initializing expression is not initialized, however, until the
                                 local variable declaration statement that declares it is
                                 executed. (The rules of definite assignment
                                 (<a class="xref" href="jls-16.html" title="Chapter&nbsp;16.&nbsp;Definite Assignment">&sect;16 (<i>Definite Assignment</i>)</a>) prevent the value of a local variable
                                 from being used before it has been initialized or otherwise
                                 assigned a value.) The local variable effectively ceases to
                                 exist when the execution of the block or for statement is
                                 complete.
                        </p>
                        <p class="note">Were it not for one exceptional situation, a
                                 local variable could always be regarded as being created when
                                 its local variable declaration statement is executed. The
                                 exceptional situation involves the <code class="literal">switch</code> statement
                                 (<a class="xref" href="jls-14.html#jls-14.11" title="14.11.&nbsp;The switch Statement">&sect;14.11</a>), where it is possible for control
                                 to enter a block but bypass execution of a local variable
                                 declaration statement. Because of the restrictions imposed by
                                 the rules of definite assignment (<a class="xref" href="jls-16.html" title="Chapter&nbsp;16.&nbsp;Definite Assignment">&sect;16 (<i>Definite Assignment</i>)</a>),
                                 however, the local variable declared by such a bypassed local
                                 variable declaration statement cannot be used before it has been
                                 definitely assigned a value by an assignment expression
                                 (<a class="xref" href="jls-15.html#jls-15.26" title="15.26.&nbsp;Assignment Operators">&sect;15.26</a>).
                        </p>
                     </li>
                  </ol>
               </div>
               <div class="example"><a name="d5e4955"></a><p class="title"><b>Example&nbsp;4.12.3-1.&nbsp;Different Kinds of Variables</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Point {
    static int numPoints;   // numPoints is a class variable
    int x, y;               // x and y are instance variables
    int[] w = new int[10];  // w[0] is an array component
    int setX(int x) {       // x is a method parameter
        int oldx = this.x;  // oldx is a local variable
        this.x = x;
        return oldx;
    }
}
</pre></div>
               </div><br class="example-break"></div>
            <div class="section" title="4.12.4.&nbsp;final Variables">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.12.4"></a>4.12.4.&nbsp;<code class="literal">final</code> Variables
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-error"><a name="jls-4.12.4-100"></a>A variable
                  can be declared <code class="literal">final</code>. A <code class="literal">final</code> variable may only be assigned to
                  once. It is a compile-time error if a <code class="literal">final</code> variable is assigned to
                  unless it is definitely unassigned immediately prior to the assignment
                  (<a class="xref" href="jls-16.html" title="Chapter&nbsp;16.&nbsp;Definite Assignment">&sect;16 (<i>Definite Assignment</i>)</a>).
               </p>
               <p class="norm-dynamic"><a name="jls-4.12.4-110"></a>Once a
                  <code class="literal">final</code> variable has been assigned, it always contains the same
                  value. If a <code class="literal">final</code> variable holds a reference to an object, then the
                  state of the object may be changed by operations on the object, but
                  the variable will always refer to the same object. This applies also
                  to arrays, because arrays are objects; if a <code class="literal">final</code> variable holds a
                  reference to an array, then the components of the array may be changed
                  by operations on the array, but the variable will always refer to the
                  same array.
               </p>
               <p class="norm-static"><a name="jls-4.12.4-200"></a>
                  A <span class="emphasis"><em>blank <code class="literal">final</code></em></span> is a <code class="literal">final</code> variable whose
                  declaration lacks an initializer.
               </p>
               <p class="norm-static"><a name="jls-4.12.4-300"></a>
                  A <span class="emphasis"><em>constant variable</em></span> is a <code class="literal">final</code> variable of
                  primitive type or type <code class="literal">String</code> that is initialized with a constant
                  expression (<a class="xref" href="jls-15.html#jls-15.28" title="15.28.&nbsp;Constant Expressions">&sect;15.28</a>). Whether a variable is a
                  constant variable or not may have implications with respect to class
                  initialization (<a class="xref" href="jls-12.html#jls-12.4.1" title="12.4.1.&nbsp;When Initialization Occurs">&sect;12.4.1</a>), binary compatibility
                  (<a class="xref" href="jls-13.html#jls-13.1" title="13.1.&nbsp;The Form of a Binary">&sect;13.1</a>, <a class="xref" href="jls-13.html#jls-13.4.9" title="13.4.9.&nbsp;final Fields and static Constant Variables">&sect;13.4.9</a>), and
                  definite assignment (<a class="xref" href="jls-16.html" title="Chapter&nbsp;16.&nbsp;Definite Assignment">&sect;16 (<i>Definite Assignment</i>)</a>).
               </p>
               <p class="norm-static"><a name="jls-4.12.4-400"></a>Three kinds of
                  variable are implicitly declared <code class="literal">final</code>: a field of an interface
                  (<a class="xref" href="jls-9.html#jls-9.3" title="9.3.&nbsp;Field (Constant) Declarations">&sect;9.3</a>), a local variable which is a resource of a
                  <code class="literal">try</code>-with-resources statement (<a class="xref" href="jls-14.html#jls-14.20.3" title="14.20.3.&nbsp;try-with-resources">&sect;14.20.3</a>), and an
                  exception parameter of a multi-<code class="literal">catch</code> clause
                  (<a class="xref" href="jls-14.html#jls-14.20" title="14.20.&nbsp;The try statement">&sect;14.20</a>). An exception parameter of a uni-<code class="literal">catch</code>
                  clause is never implicitly declared <code class="literal">final</code>, but may be effectively
                  final.
               </p>
               <div class="example"><a name="d5e4992"></a><p class="title"><b>Example&nbsp;4.12.4-1.&nbsp;Final Variables</b></p>
                  <div class="example-contents">
                     <p class="note">Declaring a variable <code class="literal">final</code> can serve as useful
                        documentation that its value will not change and can help avoid
                        programming errors. In this program:
                     </p><pre class="programlisting">
class Point {
    int x, y;
    int useCount;
    Point(int x, int y) { this.x = x; this.y = y; }
    static final Point origin = new Point(0, 0);
}
</pre><p class="note">the class <code class="literal">Point</code> declares a
                        <code class="literal">final</code> class variable <code class="literal">origin</code>. The
                        <code class="literal">origin</code> variable holds a reference to an object that
                        is an instance of class <code class="literal">Point</code> whose coordinates are
                        (0, 0). The value of the variable <code class="literal">Point.origin</code> can
                        never change, so it always refers to the same <code class="literal">Point</code>
                        object, the one created by its initializer. However, an operation on
                        this <code class="literal">Point</code> object might change its state - for
                        example, modifying its <code class="literal">useCount</code> or even,
                        misleadingly, its <code class="literal">x</code> or <code class="literal">y</code>
                        coordinate.
                     </p>
                  </div>
               </div><br class="example-break"><p class="norm-static"><a name="jls-4.12.4-500"></a>
                  Certain variables that are not declared <code class="literal">final</code> may instead be
                  considered <span class="emphasis"><em>effectively final</em></span>.
               </p>
               <p class="norm-static"><a name="jls-4.12.4-510"></a>A local variable
                  or a method, constructor, lambda, or exception parameter
                  is <span class="emphasis"><em>effectively final</em></span> if it is not declared
                  <code class="literal">final</code> but it never occurs as the left hand operand of an assignment
                  operator (<a class="xref" href="jls-15.html#jls-15.26" title="15.26.&nbsp;Assignment Operators">&sect;15.26</a>) or as the operand of a prefix
                  or postfix increment or decrement operator
                  (<a class="xref" href="jls-15.html#jls-15.14" title="15.14.&nbsp;Postfix Expressions">&sect;15.14</a>, <a class="xref" href="jls-15.html#jls-15.15" title="15.15.&nbsp;Unary Operators">&sect;15.15</a>).
               </p>
               <p class="norm-static"><a name="jls-4.12.4-520"></a>In addition, a
                  local variable whose declaration lacks an initializer
                  is <span class="emphasis"><em>effectively final</em></span> if all of the following are
                  true:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.12.4-520-A"></a>
                                 It is not declared <code class="literal">final</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.12.4-520-B"></a>
                                 Whenever it occurs as the left-hand operand of an assignment
                                 operator, it is definitely unassigned and not definitely
                                 assigned before the assignment; that is, it is definitely
                                 unassigned and not definitely assigned after the right-hand
                                 operand of the assignment (<a class="xref" href="jls-16.html" title="Chapter&nbsp;16.&nbsp;Definite Assignment">&sect;16 (<i>Definite Assignment</i>)</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-4.12.4-520-C"></a>
                                 It never occurs as the operand of a prefix or postfix increment
                                 or decrement operator.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-4.12.4-530"></a>If a variable is
                  effectively final, adding the <code class="literal">final</code> modifier to its declaration will
                  not introduce any compile-time errors. Conversely, a local variable or
                  parameter that is declared <code class="literal">final</code> in a valid program becomes
                  effectively final if the <code class="literal">final</code> modifier is removed.
               </p>
            </div>
            <div class="section" title="4.12.5.&nbsp;Initial Values of Variables">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.12.5"></a>4.12.5.&nbsp;Initial Values of Variables
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-dynamic"><a name="jls-4.12.5-100"></a>Every
                  variable in a program must have a value before its value is
                  used:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-4.12.5-100-A"></a>
                                 Each class variable, instance variable, or array component is
                                 initialized with a <span class="emphasis"><em>default value</em></span> when it is
                                 created (<a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>,
                                 <a class="xref" href="jls-15.html#jls-15.10.2" title="15.10.2.&nbsp;Run-Time Evaluation of Array Creation Expressions">&sect;15.10.2</a>):
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-4.12.5-100-A-A"></a>
                                    	  For type <code class="literal">byte</code>, the default value is zero, that is, the
                                    	  value of <code class="literal">(byte)0</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-4.12.5-100-A-B"></a>
                                    	  For type <code class="literal">short</code>, the default value is zero, that is, the
                                    	  value of <code class="literal">(short)0</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-4.12.5-100-A-C"></a>
                                    	  For type <code class="literal">int</code>, the default value is zero, that is, <code class="literal">0</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-4.12.5-100-A-D"></a>
                                    	  For type <code class="literal">long</code>, the default value is zero, that
                                    	  is, <code class="literal">0L</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-4.12.5-100-A-E"></a>
                                    	  For type <code class="literal">float</code>, the default value is positive zero, that
                                    	  is, <code class="literal">0.0f</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-4.12.5-100-A-F"></a>
                                    	  For type <code class="literal">double</code>, the default value is positive zero, that
                                    	  is, <code class="literal">0.0d</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-4.12.5-100-A-G"></a>
                                    	  For type <code class="literal">char</code>, the default value is the null character,
                                    	  that is, <code class="literal">'\u0000'</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-4.12.5-100-A-H"></a>
                                    	  For type <code class="literal">boolean</code>, the default value is <code class="literal">false</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-dynamic"><a name="jls-4.12.5-100-A-I"></a>
                                    	  For all reference types (<a class="xref" href="jls-4.html#jls-4.3" title="4.3.&nbsp;Reference Types and Values">&sect;4.3</a>), the
                                    	  default value is <code class="literal">null</code>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-4.12.5-100-B"></a>
                                 Each method parameter (<a class="xref" href="jls-8.html#jls-8.4.1" title="8.4.1.&nbsp;Formal Parameters">&sect;8.4.1</a>) is
                                 initialized to the corresponding argument value provided by the
                                 invoker of the method (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-4.12.5-100-C"></a>
                                 Each constructor parameter (<a class="xref" href="jls-8.html#jls-8.8.1" title="8.8.1.&nbsp;Formal Parameters">&sect;8.8.1</a>) is
                                 initialized to the corresponding argument value provided by a
                                 class instance creation expression (<a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>)
                                 or explicit constructor invocation
                                 (<a class="xref" href="jls-8.html#jls-8.8.7" title="8.8.7.&nbsp;Constructor Body">&sect;8.8.7</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-4.12.5-100-D"></a>
                                 An exception parameter (<a class="xref" href="jls-14.html#jls-14.20" title="14.20.&nbsp;The try statement">&sect;14.20</a>) is
                                 initialized to the thrown object representing the exception
                                 (<a class="xref" href="jls-11.html#jls-11.3" title="11.3.&nbsp;Run-Time Handling of an Exception">&sect;11.3</a>,
                                 <a class="xref" href="jls-14.html#jls-14.18" title="14.18.&nbsp;The throw Statement">&sect;14.18</a>). 
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-4.12.5-100-E"></a>
                                 A local variable (<a class="xref" href="jls-14.html#jls-14.4" title="14.4.&nbsp;Local Variable Declaration Statements">&sect;14.4</a>,
                                 <a class="xref" href="jls-14.html#jls-14.14" title="14.14.&nbsp;The for Statement">&sect;14.14</a>) must be explicitly given a value
                                 before it is used, by either initialization
                                 (<a class="xref" href="jls-14.html#jls-14.4" title="14.4.&nbsp;Local Variable Declaration Statements">&sect;14.4</a>) or assignment
                                 (<a class="xref" href="jls-15.html#jls-15.26" title="15.26.&nbsp;Assignment Operators">&sect;15.26</a>), in a way that can be verified
                                 using the rules for definite assignment
                                 (<a class="xref" href="jls-16.html" title="Chapter&nbsp;16.&nbsp;Definite Assignment">&sect;16 (<i>Definite Assignment</i>)</a>).
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="example"><a name="d5e5100"></a><p class="title"><b>Example&nbsp;4.12.5-1.&nbsp;Initial Values of Variables</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Point {
    static int npoints;
    int x, y;
    Point root;
}

class Test {
    public static void main(String[] args) {
        System.out.println("npoints=" + Point.npoints);
        Point p = new Point();
        System.out.println("p.x=" + p.x + ", p.y=" + p.y);
        System.out.println("p.root=" + p.root);
    }
}
</pre><p class="note">This program prints:</p><pre class="programlisting">
npoints=0
p.x=0, p.y=0
p.root=null
</pre><p class="note">illustrating the default initialization
                        of <code class="literal">npoints</code>, which occurs when the
                        class <code class="literal">Point</code> is prepared
                        (<a class="xref" href="jls-12.html#jls-12.3.2" title="12.3.2.&nbsp;Preparation of a Class or Interface Type">&sect;12.3.2</a>), and the default initialization
                        of <code class="literal">x</code>, <code class="literal">y</code>,
                        and <code class="literal">root</code>, which occurs when a
                        new <code class="literal">Point</code> is instantiated. See
                        <a class="xref" href="jls-12.html" title="Chapter&nbsp;12.&nbsp;Execution">&sect;12 (<i>Execution</i>)</a> for a full description of all aspects of
                        loading, linking, and initialization of classes and interfaces, plus a
                        description of the instantiation of classes to make new class
                        instances.
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="4.12.6.&nbsp;Types, Classes, and Interfaces">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-4.12.6"></a>4.12.6.&nbsp;Types, Classes, and Interfaces
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-4.12.6-100"></a>In the Java programming language, every
                  variable and every expression has a type that can be determined at
                  compile time. The type may be a primitive type or a reference
                  type. Reference types include class types and interface
                  types. Reference types are introduced by <span class="emphasis"><em>type
                        declarations</em></span>, which include class declarations
                  (<a class="xref" href="jls-8.html#jls-8.1" title="8.1.&nbsp;Class Declarations">&sect;8.1</a>) and interface declarations
                  (<a class="xref" href="jls-9.html#jls-9.1" title="9.1.&nbsp;Interface Declarations">&sect;9.1</a>). We often use the
                  term <span class="emphasis"><em>type</em></span> to refer to either a class or an
                  interface.
               </p>
               <p class="norm"><a name="jls-4.12.6-110"></a>In the Java Virtual Machine, every object
                  belongs to some particular class: the class that was mentioned in the
                  creation expression that produced the object
                  (<a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>), or the class whose <code class="literal">Class</code> object was
                  used to invoke a reflective method to produce the object, or the
                  <code class="literal">String</code> class for objects implicitly created by the string
                  concatenation operator <code class="literal">+</code> (<a class="xref" href="jls-15.html#jls-15.18.1" title="15.18.1.&nbsp;String Concatenation Operator +">&sect;15.18.1</a>). This
                  class is called the <span class="emphasis"><em>class of the object</em></span>. An
                  object is said to be an <span class="emphasis"><em>instance</em></span> of its class and
                  of all superclasses of its class.
               </p>
               <p class="norm"><a name="jls-4.12.6-120"></a>Every array also has a
                  class. The method <code class="literal">getClass</code>, when invoked for an
                  array object, will return a class object (of class <code class="literal">Class</code>) that
                  represents the <span class="emphasis"><em>class of the array</em></span>
                  (<a class="xref" href="jls-10.html#jls-10.8" title="10.8.&nbsp;Class Objects for Arrays">&sect;10.8</a>).
               </p>
               <p class="norm-dynamic"><a name="jls-4.12.6-200"></a>The
                  compile-time type of a variable is always declared, and the
                  compile-time type of an expression can be deduced at compile time. The
                  compile-time type limits the possible values that the variable can
                  hold at run time or the expression can produce at run time. If a
                  run-time value is a reference that is not <code class="literal">null</code>, it refers to an
                  object or array that has a class, and that class will necessarily be
                  compatible with the compile-time type.
               </p>
               <p class="norm-dynamic"><a name="jls-4.12.6-210"></a>Even
                  though a variable or expression may have a compile-time type that is
                  an interface type, there are no instances of interfaces. A variable or
                  expression whose type is an interface type can reference any object
                  whose class implements (<a class="xref" href="jls-8.html#jls-8.1.5" title="8.1.5.&nbsp;Superinterfaces">&sect;8.1.5</a>) that
                  interface.
               </p>
               <p class="norm"><a name="jls-4.12.6-300"></a>Sometimes a variable or
                  expression is said to have a "run-time type". This refers to the class
                  of the object referred to by the value of the variable or expression
                  at run time, assuming that the value is not <code class="literal">null</code>.
               </p>
               <p class="norm-dynamic"><a name="jls-4.12.6-310"></a>The
                  correspondence between compile-time types and run-time types is
                  incomplete for two reasons:
               </p>
               <div class="orderedlist">
                  <ol class="orderedlist" type="1">
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-4.12.6-310-A"></a>
                                 At run time, classes and interfaces are loaded by the Java Virtual Machine
                                 using class loaders. Each class loader defines its own set of
                                 classes and interfaces. As a result, it is possible for two
                                 loaders to load an identical class or interface definition but
                                 produce distinct classes or interfaces at run
                                 time. Consequently, code that compiled correctly may fail at
                                 link time if the class loaders that load it are
                                 inconsistent.
                        </p>
                        <p class="note">See the paper <em class="citetitle">Dynamic Class Loading
                                    in the Java Virtual Machine</em>, by Sheng Liang and
                                 Gilad Bracha, in <em class="citetitle">Proceedings of OOPSLA
                                    '98</em>, published as <em class="citetitle">ACM SIGPLAN
                                    Notices</em>, Volume 33, Number 10, October 1998, pages
                                 36-44, and <em class="citetitle">The Java Virtual Machine Specification, Java SE 8 Edition</em> for more details.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-dynamic"><a name="jls-4.12.6-310-B"></a>
                                 Type variables (<a class="xref" href="jls-4.html#jls-4.4" title="4.4.&nbsp;Type Variables">&sect;4.4</a>) and type arguments
                                 (<a class="xref" href="jls-4.html#jls-4.5.1" title="4.5.1.&nbsp;Type Arguments of Parameterized Types">&sect;4.5.1</a>) are not reified at run time. As a
                                 result, the same class or interface at run time represents
                                 multiple parameterized types (<a class="xref" href="jls-4.html#jls-4.5" title="4.5.&nbsp;Parameterized Types">&sect;4.5</a>) from
                                 compile time. Specifically, all compile-time parameterizations
                                 of a given generic type (<a class="xref" href="jls-8.html#jls-8.1.2" title="8.1.2.&nbsp;Generic Classes and Type Parameters">&sect;8.1.2</a>,
                                 <a class="xref" href="jls-9.html#jls-9.1.2" title="9.1.2.&nbsp;Generic Interfaces and Type Parameters">&sect;9.1.2</a>) share a single run-time
                                 representation.
                        </p>
                        <p class="note-dynamic">Under certain conditions, it is possible that a
                                 variable of a parameterized type refers to an object that is not
                                 of that parameterized type. This situation is known
                                 as <span class="emphasis"><em>heap pollution</em></span>
                                 (<a class="xref" href="jls-4.html#jls-4.12.2" title="4.12.2.&nbsp;Variables of Reference Type">&sect;4.12.2</a>). The variable will always refer
                                 to an object that is an instance of a class that represents the
                                 parameterized type.
                        </p>
                     </li>
                  </ol>
               </div>
               <div class="example"><a name="d5e5159"></a><p class="title"><b>Example&nbsp;4.12.6-1.&nbsp;Type of a Variable versus Class of an Object</b></p>
                  <div class="example-contents"><pre class="programlisting">
interface Colorable {
    void setColor(byte r, byte g, byte b);
}

class Point { int x, y; }

class ColoredPoint extends Point implements Colorable {
    byte r, g, b;
    public void setColor(byte rv, byte gv, byte bv) {
        r = rv; g = gv; b = bv;
    }
}

class Test {
    public static void main(String[] args) {
        Point p = new Point();
        ColoredPoint cp = new ColoredPoint();
        p = cp;
        Colorable c = cp;
    }
}
</pre><p class="note">In this example:</p>
                     <div class="note">
                        <ul class="note" type="disc">
                           <li class="listitem">
                              <p class="note">The local variable <code class="literal">p</code> of the
                                       method <code class="literal">main</code> of class <code class="literal">Test</code>
                                       has type <code class="literal">Point</code> and is initially assigned a
                                       reference to a new instance of
                                       class <code class="literal">Point</code>.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="note">The local variable <code class="literal">cp</code>
                                       similarly has as its type <code class="literal">ColoredPoint</code>, and
                                       is initially assigned a reference to a new instance of
                                       class <code class="literal">ColoredPoint</code>.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="note">The assignment of the value
                                       of <code class="literal">cp</code> to the variable <code class="literal">p</code>
                                       causes <code class="literal">p</code> to hold a reference to
                                       a <code class="literal">ColoredPoint</code> object. This is permitted
                                       because <code class="literal">ColoredPoint</code> is a subclass
                                       of <code class="literal">Point</code>, so the
                                       class <code class="literal">ColoredPoint</code> is assignment-compatible
                                       (<a class="xref" href="jls-5.html#jls-5.2" title="5.2.&nbsp;Assignment Contexts">&sect;5.2</a>) with the
                                       type <code class="literal">Point</code>. A <code class="literal">ColoredPoint</code>
                                       object includes support for all the methods of
                                       a <code class="literal">Point</code>. In addition to its particular
                                       fields <code class="literal">r</code>, <code class="literal">g</code>,
                                       and <code class="literal">b</code>, it has the fields of
                                       class <code class="literal">Point</code>, namely <code class="literal">x</code>
                                       and <code class="literal">y</code>.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="note">The local variable <code class="literal">c</code> has as
                                       its type the interface type <code class="literal">Colorable</code>, so it
                                       can hold a reference to any object whose class
                                       implements <code class="literal">Colorable</code>; specifically, it can
                                       hold a reference to a <code class="literal">ColoredPoint</code>.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <p class="note">Note that an expression such as <code class="literal">new
                           Colorable()</code> is not valid because it is not possible to
                        create an instance of an interface, only of a class. However, the
                        expression <code class="literal">new Colorable() { public void
                           setColor... }</code> is valid because it declares an anonymous
                        class (<a class="xref" href="jls-15.html#jls-15.9.5" title="15.9.5.&nbsp;Anonymous Class Declarations">&sect;15.9.5</a>) that implements
                        the <code class="literal">Colorable</code> interface.
                     </p>
                  </div>
               </div><br class="example-break"></div>
         </div>
      </div>
      <div class="navfooter">
         <hr>
         <table width="100%" summary="Navigation footer">
            <tr>
               <td width="40%" align="left"><a accesskey="p" href="jls-3.html">Prev</a>&nbsp;
               </td>
               <td width="20%" align="center">&nbsp;</td>
               <td width="40%" align="right">&nbsp;<a accesskey="n" href="jls-5.html">Next</a></td>
            </tr>
            <tr>
               <td width="40%" align="left" valign="top">Chapter&nbsp;3.&nbsp;Lexical Structure&nbsp;</td>
               <td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
               <td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;5.&nbsp;Conversions and Contexts</td>
            </tr>
         </table>
      </div>
      <div xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:rx="http://www.renderx.com/XSL/Extensions" class="navfooter">
         <hr><a href="jls-0-front.html">
                Legal Notice
              </a></div>
   </body>
</html>