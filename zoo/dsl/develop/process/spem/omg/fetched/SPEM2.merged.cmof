<?xml version="1.0" encoding="UTF-8"?>
<xmi:XMI xmi:version="2.1" xmlns:xmi="http://schema.omg.org/spec/XMI/2.1" xmlns:cmof="http://schema.omg.org/spec/MOF/2.0/cmof.xml">
	<cmof:Package xmi:id="_0" name="SPEM2-Complete" uri="http://schema.omg.org/spec/SPEM/2.0/spem.xml">
		<ownedComment xmi:type="cmof:Comment" xmi:id="_ownedComment.0" annotatedElement="_0">
			<body>The Core meta-model package contains that meta-model classes and abstractions that build the fundament for all other meta-model packages.  In other words, all the common classes amongst all compliance levels defining the core of SPEM 2.0 have been place here.  Core mainly defines classes for two SPEM 2.0 capabilities:  (1) The ability for a SPEM 2.0 user to create user-defined qualifications for a SPEM 2.0 classes allowing users to distinguish different 'kinds' SPEM 2.0 class instances. (2) A set of abstract classes to define work expressed as SPEM 2.0 processes.  All SPEM 2.0 classes that derive from these classes are intended to map to behavior classes of behavior models (e.g. can be assigned as stereotypes to UML 2.0 Activities or linked to behaviored classifiers).&#xD;
</body>
		</ownedComment>
		<ownedComment xmi:type="cmof:Comment" xmi:id="_ownedComment.1" annotatedElement="_0">
			<body>This package defines the base for all process models.  It supports the creation of simple and flexible process models.  Its core data structure is a breakdown or decomposition of nested Activities that maintain lists of references to performing Role classes as well as input and output Work Product classes for each Activity.  In addition it provides mechanism for process reuse such as the dynamic binding of process patterns that allow users assembling processes with sets of dynamically linked Activities.  These structures are used to represent high-level and basic processes that are not textually documented and ideal for the ad-hoc assembly of processes especially the representation of agile processes and self-organizing team approaches.</body>
		</ownedComment>
		<ownedComment xmi:type="cmof:Comment" xmi:id="_ownedComment.2" annotatedElement="_0">
			<body>Development processes are in many cases not only represented as models, but documented and managed as natural language descriptions.  For many software development approaches and methods human consumable documentation providing understandable guidance for best development practices is more important than precise models.  In other words, the practicality of techniques and methods expressed with these practices is in many cases perceived to provide higher value than strict obedience to a formally defined process.  The reasons for this are that many development approaches see software development rather as a creative process that requires constant reevaluation and adoption than a strict sequence of activities.  For example, for modern agile development teams, best practices of software development are communicated through mentoring and short practice descriptions in white paper format, rather than formally defined models.  They assume certain values and a development culture that cannot be formalized with models, but can only be captured in natural language documentation. The Managed Content meta-model package introduced concepts for managing the textual content of such descriptions.  These concepts can either be used standalone or in combination with process structure concepts.  For example, a SPEM 2.0 based process could be solely comprised of a set of instances of the guidance meta-class defining development best practices in whitepaper format. It could also be comprised of a combination of these guidance elements with a process structure using relationships defined in the Managed Content meta-model package that allows associating guidance elements with process structure elements.</body>
		</ownedComment>
		<ownedComment xmi:type="cmof:Comment" xmi:id="_ownedComment.3" annotatedElement="_0">
			<body>The Method Content meta-model package provides the concepts for SPEM 2.0 users and organization to build up a development knowledgebase that is independent of any specific processes and development projects.  It adds concepts for defining lifecycle and process-independent reusable method content elements that provide a base of documented knowledge of software development methods, techniques, and concrete realizations of best practices.  Method Content comprises of textual step-by-step explanations, describing how specific fine-granular development goals are achieved by which roles with which resources and results, independent of the placement of these steps within a specific development lifecycle. Processes would reuse these method content elements and relate them into semi-ordered sequences that are customized to specific types of projects.  A SPEM 2.0 user can define Method Content as general guidance and build up a knowledge base of development methods without ever creating a process, but adding a little bit more structure for her content as provided by the generic meta-classes defined in the Managed Content package.  These structures selected for the Method Content package have been derived from best practices in the industry.  Development processes can be based on reusable method content (as defined in the Process with Methods meta-model package), but they can also be independent of method content (by just using the Process Structure meta-model package) defining ad-hoc processes that are not based on such reusable methods.</body>
		</ownedComment>
		<ownedComment xmi:type="cmof:Comment" xmi:id="_ownedComment.4" annotatedElement="_0">
			<body>The Process with Methods meta-model package defines new and redefines existing structures for integrating processes defined with the concepts from the Process Structure meta-model package with instances of concepts from the Method Content meta-model package.  Whereas Method Content defines fundamental methods and techniques for software development, processes place these methods and techniques into the context of a lifecycle model comprising, for example, of phases and milestones.  When applying method content such as Tasks, Roles, and Work Products to specific parts of the process reference classes (referred to as Method Content Use in this specification) are created that can store individual changes to their referenced Method Content classes expressing how and which parts of the method will be applied in that particular point in the process.</body>
		</ownedComment>
		<ownedComment xmi:type="cmof:Comment" xmi:id="_ownedComment.5" annotatedElement="_0">
			<body>The Method Plug-in meta-model package introduces concepts for 'designing' and managing maintainable, large scale, reusable, and configurable libraries or repositories of method content and processes.   The concepts introduced in this package allow arranging different parts of such a library based on different layers of concern similar to layered software architectures.  With concepts such as Method Plug-in, Process Component, and Variability one can define processes that are granularly extended with more and more capabilities.  Users can then select the process capabilities they are interested in by defining so-called method configurations.  Only those selected capabilities will then be surfaced within these configurations to the end-user allowing process authors to define consistent and maintainable processes for different audiences that are configurable for specific end-user needs.</body>
		</ownedComment>
		<ownedComment xmi:type="cmof:Comment" xmi:id="_ownedComment.6" annotatedElement="_0">
			<body>The concepts of the Process Structure package represent a process as a static breakdown structure allowing nesting of activities and defining predecessor dependencies amongst them.  The Process Behavior meta-model package allows extending these structures with behavioral models. However, it does not define it own behavior modeling approach, but rather provides 'links' to existing externally defined behavior models enabling reuse of these approaches from other OMG or third party specifications.  For example, a process defined with the Process Structure concepts can be linked to UML 2 Activity diagrams that represent the behavior of such process.  Such process models can utilize the SPEM UML 2 Profile for a consistent presentation for such UML 2 models in addition to the 'links' defined in this Process Behavior meta-model package.</body>
		</ownedComment>
		<ownedMember xmi:type="cmof:Class" xmi:id="Classifier" name="Classifier" isAbstract="true" superClass="Namespace Type">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Classifier-_ownedComment.0" annotatedElement="Classifier">
				<body>A classifier is a classification of instances - it describes a set of instances that have features in common. A classifier can specify a generalization hierarchy by referencing its general classifiers.</body>
			</ownedComment>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="Classifier-no_cycles_in_generalization" name="no_cycles_in_generalization" constrainedElement="Classifier" namespace="Classifier">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Classifier-no_cycles_in_generalization-_ownedComment.0" annotatedElement="Classifier-no_cycles_in_generalization">
					<body>Generalization hierarchies must be directed and acyclical. A classifier can not be both a transitively general and transitively specific classifier of the same classifier.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="Classifier-no_cycles_in_generalization-_specification">
					<language>OCL</language>
					<body>not self.allParents()->includes(self)</body>
				</specification>
			</ownedRule>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="Classifier-specialize_type" name="specialize_type" constrainedElement="Classifier" namespace="Classifier">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Classifier-specialize_type-_ownedComment.0" annotatedElement="Classifier-specialize_type">
					<body>A classifier may only specialize classifiers of a valid type.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="Classifier-specialize_type-_specification">
					<language>OCL</language>
					<body>self.parents()->forAll(c | self.maySpecializeType(c))</body>
				</specification>
			</ownedRule>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Classifier-attribute" name="attribute" type="Property" upper="*" lower="0" isReadOnly="true" isDerived="true" isDerivedUnion="true" subsettedProperty="Classifier-feature" association="A_attribute_classifier">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Classifier-attribute-_ownedComment.0" annotatedElement="Classifier-attribute">
					<body>Refers to all of the Properties that are direct (i.e. not inherited or imported) attributes of the classifier.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Classifier-feature" name="feature" type="Feature" upper="*" lower="0" isReadOnly="true" isDerived="true" isDerivedUnion="true" subsettedProperty="Namespace-member" association="A_feature_featuringClassifier">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Classifier-feature-_ownedComment.0" annotatedElement="Classifier-feature">
					<body>Note that there may be members of the Classifier that are of the type Feature but are not included in this association, e.g. inherited features.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Classifier-general" name="general" type="Classifier" upper="*" lower="0" association="A_general_classifier">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Classifier-general-_ownedComment.0" annotatedElement="Classifier-general">
					<body>References the general classifier in the Generalization relationship.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Classifier-inheritedMember" name="inheritedMember" type="NamedElement" upper="*" lower="0" isReadOnly="true" isDerived="true" subsettedProperty="Namespace-member" association="A_inheritedMember_classifier">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Classifier-inheritedMember-_ownedComment.0" annotatedElement="Classifier-inheritedMember">
					<body>Specifies all elements inherited by this classifier from the general classifiers.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Classifier-conformsTo" name="conformsTo" class="Classifier" isQuery="true" redefinedOperation="Type-conformsTo" bodyCondition="Classifier-conformsTo-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Classifier-conformsTo-_ownedComment.0" annotatedElement="Classifier-conformsTo">
					<body>The query conformsTo() gives true for a classifier that defines a type that conforms to another. This is used, for example, in the specification of signature conformance for operations.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Classifier-conformsTo-spec" name="spec" constrainedElement="Classifier-conformsTo" namespace="Classifier-conformsTo">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Classifier-conformsTo-spec-_specification">
						<language>OCL</language>
						<body>result = (self=other) or (self.allParents()->includes(other))</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Classifier-conformsTo-_ownedParameter.0" type="Boolean" direction="return"/>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Classifier-conformsTo-other" name="other" type="Classifier"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Classifier-allFeatures" name="allFeatures" class="Classifier" isQuery="true" bodyCondition="Classifier-allFeatures-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Classifier-allFeatures-_ownedComment.0" annotatedElement="Classifier-allFeatures">
					<body>The query allFeatures() gives all of the features in the namespace of the classifier. In general, through mechanisms such as inheritance, this will be a larger set than feature.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Classifier-allFeatures-spec" name="spec" constrainedElement="Classifier-allFeatures" namespace="Classifier-allFeatures">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Classifier-allFeatures-spec-_specification">
						<language>OCL</language>
						<body>result = member->select(oclIsKindOf(Feature))</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Classifier-allFeatures-_ownedParameter.0" type="Feature" upper="*" lower="0" direction="return"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Classifier-general.1" name="general" class="Classifier" isQuery="true" bodyCondition="Classifier-general.1-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Classifier-general.1-_ownedComment.0" annotatedElement="Classifier-general.1">
					<body>The general classifiers are the classifiers referenced by the generalization relationships.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Classifier-general.1-spec" name="spec" constrainedElement="Classifier-general.1 Classifier-general" namespace="Classifier-general.1">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Classifier-general.1-spec-_specification">
						<language>OCL</language>
						<body>result = self.parents()</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Classifier-general.1-_ownedParameter.0" type="Classifier" upper="*" lower="0" direction="return"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Classifier-parents" name="parents" class="Classifier" isQuery="true" bodyCondition="Classifier-parents-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Classifier-parents-_ownedComment.0" annotatedElement="Classifier-parents">
					<body>The query parents() gives all of the immediate ancestors of a generalized Classifier.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Classifier-parents-spec" name="spec" constrainedElement="Classifier-parents" namespace="Classifier-parents">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Classifier-parents-spec-_specification">
						<language>OCL</language>
						<body>result = generalization.general</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Classifier-parents-_ownedParameter.0" type="Classifier" upper="*" lower="0" direction="return"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Classifier-inheritedMember.1" name="inheritedMember" class="Classifier" isQuery="true" bodyCondition="Classifier-inheritedMember.1-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Classifier-inheritedMember.1-_ownedComment.0" annotatedElement="Classifier-inheritedMember.1">
					<body>The inheritedMember association is derived by inheriting the inheritable members of the parents.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Classifier-inheritedMember.1-spec" name="spec" constrainedElement="Classifier-inheritedMember.1 Classifier-inheritedMember" namespace="Classifier-inheritedMember.1">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Classifier-inheritedMember.1-spec-_specification">
						<language>OCL</language>
						<body>result = self.inherit(self.parents()->collect(p | p.inheritableMembers(self))</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Classifier-inheritedMember.1-_ownedParameter.0" type="NamedElement" upper="*" lower="0" direction="return"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Classifier-allParents" name="allParents" class="Classifier" isQuery="true" bodyCondition="Classifier-allParents-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Classifier-allParents-_ownedComment.0" annotatedElement="Classifier-allParents">
					<body>The query allParents() gives all of the direct and indirect ancestors of a generalized Classifier.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Classifier-allParents-spec" name="spec" constrainedElement="Classifier-allParents" namespace="Classifier-allParents">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Classifier-allParents-spec-_specification">
						<language>OCL</language>
						<body>result = self.parents()->union(self.parents()->collect(p | p.allParents())</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Classifier-allParents-_ownedParameter.0" type="Classifier" upper="*" lower="0" direction="return"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Classifier-inheritableMembers" name="inheritableMembers" class="Classifier" isQuery="true" precondition="Classifier-inheritableMembers-_ownedRule.0" bodyCondition="Classifier-inheritableMembers-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Classifier-inheritableMembers-_ownedComment.0" annotatedElement="Classifier-inheritableMembers">
					<body>The query inheritableMembers() gives all of the members of a classifier that may be inherited in one of its descendants, subject to whatever visibility restrictions apply.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Classifier-inheritableMembers-_ownedRule.0" constrainedElement="Classifier-inheritableMembers" namespace="Classifier-inheritableMembers">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Classifier-inheritableMembers-_ownedRule.0-_specification">
						<language>OCL</language>
						<body>c.allParents()->includes(self)</body>
					</specification>
				</ownedRule>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Classifier-inheritableMembers-spec" name="spec" constrainedElement="Classifier-inheritableMembers" namespace="Classifier-inheritableMembers">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Classifier-inheritableMembers-spec-_specification">
						<language>OCL</language>
						<body>result = member->select(m | c.hasVisibilityOf(m))</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Classifier-inheritableMembers-_ownedParameter.0" type="NamedElement" upper="*" lower="0" direction="return"/>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Classifier-inheritableMembers-c" name="c" type="Classifier"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Classifier-hasVisibilityOf" name="hasVisibilityOf" class="Classifier" isQuery="true" precondition="Classifier-hasVisibilityOf-_ownedRule.0" bodyCondition="Classifier-hasVisibilityOf-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Classifier-hasVisibilityOf-_ownedComment.0" annotatedElement="Classifier-hasVisibilityOf">
					<body>The query hasVisibilityOf() determines whether a named element is visible in the classifier. By default all are visible. It is only called when the argument is something owned by a parent.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Classifier-hasVisibilityOf-_ownedRule.0" constrainedElement="Classifier-hasVisibilityOf" namespace="Classifier-hasVisibilityOf">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Classifier-hasVisibilityOf-_ownedRule.0-_specification">
						<language>OCL</language>
						<body>self.allParents()->collect(c | c.member)->includes(n)</body>
					</specification>
				</ownedRule>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Classifier-hasVisibilityOf-spec" name="spec" constrainedElement="Classifier-hasVisibilityOf" namespace="Classifier-hasVisibilityOf">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Classifier-hasVisibilityOf-spec-_specification">
						<language>OCL</language>
						<body>result = if (self.inheritedMember->includes(n)) then (n.visibility &lt;> #private) else true</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Classifier-hasVisibilityOf-_ownedParameter.0" type="Boolean" direction="return"/>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Classifier-hasVisibilityOf-n" name="n" type="NamedElement"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Classifier-inherit" name="inherit" class="Classifier" isQuery="true" bodyCondition="Classifier-inherit-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Classifier-inherit-_ownedComment.0" annotatedElement="Classifier-inherit">
					<body>The inherit operation is overridden to exclude redefined properties.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Classifier-inherit-spec" name="spec" constrainedElement="Classifier-inherit" namespace="Classifier-inherit">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Classifier-inherit-spec-_specification">
						<language>OCL</language>
						<body>result = inhs</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Classifier-inherit-_ownedParameter.0" type="NamedElement" upper="*" lower="0" direction="return"/>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Classifier-inherit-inhs" name="inhs" type="NamedElement" upper="*" lower="0"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Classifier-maySpecializeType" name="maySpecializeType" class="Classifier" isQuery="true" bodyCondition="Classifier-maySpecializeType-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Classifier-maySpecializeType-_ownedComment.0" annotatedElement="Classifier-maySpecializeType">
					<body>The query maySpecializeType() determines whether this classifier may have a generalization relationship to classifiers of the specified type. By default a classifier may specialize classifiers of the same or a more general type. It is intended to be redefined by classifiers that have different specialization constraints.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Classifier-maySpecializeType-spec" name="spec" constrainedElement="Classifier-maySpecializeType" namespace="Classifier-maySpecializeType">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Classifier-maySpecializeType-spec-_specification">
						<language>OCL</language>
						<body>result = self.oclIsKindOf(c.oclType)</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Classifier-maySpecializeType-_ownedParameter.0" type="Boolean" direction="return"/>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Classifier-maySpecializeType-c" name="c" type="Classifier"/>
			</ownedOperation>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="DirectedRelationship" name="DirectedRelationship" isAbstract="true" superClass="Relationship">
			<ownedComment xmi:type="cmof:Comment" xmi:id="DirectedRelationship-_ownedComment.0" annotatedElement="DirectedRelationship">
				<body>A directed relationship represents a relationship between a collection of source model elements and a collection of target model elements.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="DirectedRelationship-source" name="source" type="Element" upper="*" isReadOnly="true" isDerived="true" isDerivedUnion="true" subsettedProperty="Relationship-relatedElement" association="A_source_directedRelationship">
				<ownedComment xmi:type="cmof:Comment" xmi:id="DirectedRelationship-source-_ownedComment.0" annotatedElement="DirectedRelationship-source">
					<body>Specifies the sources of the DirectedRelationship.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="DirectedRelationship-target" name="target" type="Element" upper="*" isReadOnly="true" isDerived="true" isDerivedUnion="true" subsettedProperty="Relationship-relatedElement" association="A_target_directedRelationship">
				<ownedComment xmi:type="cmof:Comment" xmi:id="DirectedRelationship-target-_ownedComment.0" annotatedElement="DirectedRelationship-target">
					<body>Specifies the targets of the DirectedRelationship.</body>
				</ownedComment>
			</ownedAttribute>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="Feature" name="Feature" isAbstract="true" superClass="RedefinableElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Feature-_ownedComment.0" annotatedElement="Feature">
				<body>A feature declares a behavioral or structural characteristic of instances of classifiers.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Feature-featuringClassifier" name="featuringClassifier" type="Classifier" upper="*" lower="0" isReadOnly="true" isDerived="true" isDerivedUnion="true" association="A_feature_featuringClassifier">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Feature-featuringClassifier-_ownedComment.0" annotatedElement="Feature-featuringClassifier">
					<body>The Classifiers that have this Feature as a feature.</body>
				</ownedComment>
			</ownedAttribute>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="MultiplicityElement" name="MultiplicityElement" isAbstract="true" superClass="Element">
			<ownedComment xmi:type="cmof:Comment" xmi:id="MultiplicityElement-_ownedComment.0" annotatedElement="MultiplicityElement">
				<body>A multiplicity is a definition of an inclusive interval of non-negative integers beginning with a lower bound and ending with a (possibly infinite) upper bound. A multiplicity element embeds this information to specify the allowable cardinalities for an instantiation of this element.</body>
			</ownedComment>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="MultiplicityElement-upper_gt_0" name="upper_gt_0" constrainedElement="MultiplicityElement" namespace="MultiplicityElement">
				<ownedComment xmi:type="cmof:Comment" xmi:id="MultiplicityElement-upper_gt_0-_ownedComment.0" annotatedElement="MultiplicityElement-upper_gt_0">
					<body>A multiplicity must define at least one valid cardinality that is greater than zero.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="MultiplicityElement-upper_gt_0-_specification">
					<language>OCL</language>
					<body>upperBound()->notEmpty() implies upperBound() > 0</body>
				</specification>
			</ownedRule>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="MultiplicityElement-upper_ge_lower" name="upper_ge_lower" constrainedElement="MultiplicityElement" namespace="MultiplicityElement">
				<ownedComment xmi:type="cmof:Comment" xmi:id="MultiplicityElement-upper_ge_lower-_ownedComment.0" annotatedElement="MultiplicityElement-upper_ge_lower">
					<body>The upper bound must be greater than or equal to the lower bound.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="MultiplicityElement-upper_ge_lower-_specification">
					<language>OCL</language>
					<body>(upperBound()->notEmpty() and lowerBound()->notEmpty()) implies upperBound() >= lowerBound()</body>
				</specification>
			</ownedRule>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="MultiplicityElement-lower_ge_0" name="lower_ge_0" constrainedElement="MultiplicityElement" namespace="MultiplicityElement">
				<ownedComment xmi:type="cmof:Comment" xmi:id="MultiplicityElement-lower_ge_0-_ownedComment.0" annotatedElement="MultiplicityElement-lower_ge_0">
					<body>The lower bound must be a non-negative integer literal.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="MultiplicityElement-lower_ge_0-_specification">
					<language>OCL</language>
					<body>lowerBound()->notEmpty() implies lowerBound() >= 0</body>
				</specification>
			</ownedRule>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="MultiplicityElement-isOrdered" name="isOrdered" type="Boolean" default="false">
				<ownedComment xmi:type="cmof:Comment" xmi:id="MultiplicityElement-isOrdered-_ownedComment.0" annotatedElement="MultiplicityElement-isOrdered">
					<body>For a multivalued multiplicity, this attribute specifies whether the values in an instantiation of this element are sequentially ordered.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="MultiplicityElement-isUnique" name="isUnique" type="Boolean" default="true">
				<ownedComment xmi:type="cmof:Comment" xmi:id="MultiplicityElement-isUnique-_ownedComment.0" annotatedElement="MultiplicityElement-isUnique">
					<body>For a multivalued multiplicity, this attributes specifies whether the values in an instantiation of this element are unique.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="MultiplicityElement-lower" name="lower" type="Integer" lower="0" default="1">
				<ownedComment xmi:type="cmof:Comment" xmi:id="MultiplicityElement-lower-_ownedComment.0" annotatedElement="MultiplicityElement-lower">
					<body>Specifies the lower bound of the multiplicity interval.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="MultiplicityElement-upper" name="upper" type="UnlimitedNatural" lower="0" default="1">
				<ownedComment xmi:type="cmof:Comment" xmi:id="MultiplicityElement-upper-_ownedComment.0" annotatedElement="MultiplicityElement-upper">
					<body>Specifies the upper bound of the multiplicity interval.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="MultiplicityElement-isMultivalued" name="isMultivalued" class="MultiplicityElement" isQuery="true" precondition="MultiplicityElement-isMultivalued-_ownedRule.0" bodyCondition="MultiplicityElement-isMultivalued-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="MultiplicityElement-isMultivalued-_ownedComment.0" annotatedElement="MultiplicityElement-isMultivalued">
					<body>The query isMultivalued() checks whether this multiplicity has an upper bound greater than one.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="MultiplicityElement-isMultivalued-_ownedRule.0" constrainedElement="MultiplicityElement-isMultivalued" namespace="MultiplicityElement-isMultivalued">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="MultiplicityElement-isMultivalued-_ownedRule.0-_specification">
						<language>OCL</language>
						<body>upperBound()->notEmpty()</body>
					</specification>
				</ownedRule>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="MultiplicityElement-isMultivalued-spec" name="spec" constrainedElement="MultiplicityElement-isMultivalued" namespace="MultiplicityElement-isMultivalued">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="MultiplicityElement-isMultivalued-spec-_specification">
						<language>OCL</language>
						<body>result = upperBound() > 1</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="MultiplicityElement-isMultivalued-_ownedParameter.0" type="Boolean" direction="return"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="MultiplicityElement-includesMultiplicity" name="includesMultiplicity" class="MultiplicityElement" isQuery="true" precondition="MultiplicityElement-includesMultiplicity-_ownedRule.0" bodyCondition="MultiplicityElement-includesMultiplicity-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="MultiplicityElement-includesMultiplicity-_ownedComment.0" annotatedElement="MultiplicityElement-includesMultiplicity">
					<body>The query includesMultiplicity() checks whether this multiplicity includes all the cardinalities allowed by the specified multiplicity.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="MultiplicityElement-includesMultiplicity-_ownedRule.0" constrainedElement="MultiplicityElement-includesMultiplicity" namespace="MultiplicityElement-includesMultiplicity">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="MultiplicityElement-includesMultiplicity-_ownedRule.0-_specification">
						<language>OCL</language>
						<body>self.upperBound()->notEmpty() and self.lowerBound()->notEmpty() and M.upperBound()->notEmpty() and M.lowerBound()->notEmpty()</body>
					</specification>
				</ownedRule>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="MultiplicityElement-includesMultiplicity-spec" name="spec" constrainedElement="MultiplicityElement-includesMultiplicity" namespace="MultiplicityElement-includesMultiplicity">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="MultiplicityElement-includesMultiplicity-spec-_specification">
						<language>OCL</language>
						<body>result = (self.lowerBound() &lt;= M.lowerBound()) and (self.upperBound() >= M.upperBound())</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="MultiplicityElement-includesMultiplicity-_ownedParameter.0" type="Boolean" direction="return"/>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="MultiplicityElement-includesMultiplicity-M" name="M" type="MultiplicityElement"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="MultiplicityElement-includesCardinality" name="includesCardinality" class="MultiplicityElement" isQuery="true" precondition="MultiplicityElement-includesCardinality-_ownedRule.0" bodyCondition="MultiplicityElement-includesCardinality-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="MultiplicityElement-includesCardinality-_ownedComment.0" annotatedElement="MultiplicityElement-includesCardinality">
					<body>The query includesCardinality() checks whether the specified cardinality is valid for this multiplicity.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="MultiplicityElement-includesCardinality-_ownedRule.0" constrainedElement="MultiplicityElement-includesCardinality" namespace="MultiplicityElement-includesCardinality">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="MultiplicityElement-includesCardinality-_ownedRule.0-_specification">
						<language>OCL</language>
						<body>upperBound()->notEmpty() and lowerBound()->notEmpty()</body>
					</specification>
				</ownedRule>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="MultiplicityElement-includesCardinality-spec" name="spec" constrainedElement="MultiplicityElement-includesCardinality" namespace="MultiplicityElement-includesCardinality">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="MultiplicityElement-includesCardinality-spec-_specification">
						<language>OCL</language>
						<body>result = (lowerBound() &lt;= C) and (upperBound() >= C)</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="MultiplicityElement-includesCardinality-_ownedParameter.0" type="Boolean" direction="return"/>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="MultiplicityElement-includesCardinality-C" name="C" type="Integer"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="MultiplicityElement-lowerBound" name="lowerBound" class="MultiplicityElement" isQuery="true" bodyCondition="MultiplicityElement-lowerBound-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="MultiplicityElement-lowerBound-_ownedComment.0" annotatedElement="MultiplicityElement-lowerBound">
					<body>The query lowerBound() returns the lower bound of the multiplicity as an integer.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="MultiplicityElement-lowerBound-spec" name="spec" constrainedElement="MultiplicityElement-lowerBound" namespace="MultiplicityElement-lowerBound">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="MultiplicityElement-lowerBound-spec-_specification">
						<language>OCL</language>
						<body>result = if lower->notEmpty() then lower else 1 endif</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="MultiplicityElement-lowerBound-_ownedParameter.0" type="Integer" direction="return"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="MultiplicityElement-upperBound" name="upperBound" class="MultiplicityElement" isQuery="true" bodyCondition="MultiplicityElement-upperBound-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="MultiplicityElement-upperBound-_ownedComment.0" annotatedElement="MultiplicityElement-upperBound">
					<body>The query upperBound() returns the upper bound of the multiplicity for a bounded multiplicity as an unlimited natural.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="MultiplicityElement-upperBound-spec" name="spec" constrainedElement="MultiplicityElement-upperBound" namespace="MultiplicityElement-upperBound">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="MultiplicityElement-upperBound-spec-_specification">
						<language>OCL</language>
						<body>result = if upper->notEmpty() then upper else 1 endif</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="MultiplicityElement-upperBound-_ownedParameter.0" type="UnlimitedNatural" direction="return"/>
			</ownedOperation>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="Namespace" name="Namespace" isAbstract="true" superClass="NamedElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Namespace-_ownedComment.0" annotatedElement="Namespace">
				<body>A namespace is an element in a model that contains a set of named elements that can be identified by name.</body>
			</ownedComment>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="Namespace-members_distinguishable" name="members_distinguishable" constrainedElement="Namespace" namespace="Namespace">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Namespace-members_distinguishable-_ownedComment.0" annotatedElement="Namespace-members_distinguishable">
					<body>All the members of a Namespace are distinguishable within it.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="Namespace-members_distinguishable-_specification">
					<language>OCL</language>
					<body>membersAreDistinguishable()</body>
				</specification>
			</ownedRule>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Namespace-importedMember" name="importedMember" type="PackageableElement" upper="*" lower="0" isReadOnly="true" isDerived="true" subsettedProperty="Namespace-member" association="A_importedMember_namespace">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Namespace-importedMember-_ownedComment.0" annotatedElement="Namespace-importedMember">
					<body>References the PackageableElements that are members of this Namespace as a result of either PackageImports or ElementImports.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Namespace-elementImport" name="elementImport" type="ElementImport" upper="*" lower="0" isComposite="true" subsettedProperty="Element-ownedElement" association="A_elementImport_importingNamespace">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Namespace-elementImport-_ownedComment.0" annotatedElement="Namespace-elementImport">
					<body>References the ElementImports owned by the Namespace.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Namespace-packageImport" name="packageImport" type="PackageImport" upper="*" lower="0" isComposite="true" subsettedProperty="Element-ownedElement" association="A_packageImport_importingNamespace">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Namespace-packageImport-_ownedComment.0" annotatedElement="Namespace-packageImport">
					<body>References the PackageImports owned by the Namespace.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Namespace-ownedMember" name="ownedMember" type="NamedElement" upper="*" lower="0" isReadOnly="true" isDerived="true" isDerivedUnion="true" isComposite="true" subsettedProperty="Namespace-member Element-ownedElement" association="A_ownedMember_namespace">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Namespace-ownedMember-_ownedComment.0" annotatedElement="Namespace-ownedMember">
					<body>A collection of NamedElements owned by the Namespace.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Namespace-member" name="member" type="NamedElement" upper="*" lower="0" isReadOnly="true" isDerived="true" isDerivedUnion="true" association="A_member_namespace">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Namespace-member-_ownedComment.0" annotatedElement="Namespace-member">
					<body>A collection of NamedElements identifiable within the Namespace, either by being owned or by being introduced by importing or inheritance.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Namespace-ownedRule" name="ownedRule" type="Constraint" upper="*" lower="0" isComposite="true" subsettedProperty="Namespace-ownedMember" association="A_ownedRule_context"/>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Namespace-importedMember.1" name="importedMember" class="Namespace" isQuery="true" bodyCondition="Namespace-importedMember.1-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Namespace-importedMember.1-_ownedComment.0" annotatedElement="Namespace-importedMember.1">
					<body>The importedMember property is derived from the ElementImports and the PackageImports. References the PackageableElements that are members of this Namespace as a result of either PackageImports or ElementImports.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Namespace-importedMember.1-spec" name="spec" constrainedElement="Namespace-importedMember.1 Namespace-importedMember" namespace="Namespace-importedMember.1">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Namespace-importedMember.1-spec-_specification">
						<language>OCL</language>
						<body>result = self.importMembers(self.elementImport.importedElement.asSet()->union(self.packageImport.importedPackage->collect(p | p.visibleMembers())))</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Namespace-importedMember.1-_ownedParameter.0" type="PackageableElement" upper="*" lower="0" direction="return"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Namespace-getNamesOfMember" name="getNamesOfMember" class="Namespace" isQuery="true" bodyCondition="Namespace-getNamesOfMember-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Namespace-getNamesOfMember-_ownedComment.0" annotatedElement="Namespace-getNamesOfMember">
					<body>The query getNamesOfMember() takes importing into account. It gives back the set of names that an element would have in an importing namespace, either because it is owned, or if not owned then imported individually, or if not individually then from a package.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Namespace-getNamesOfMember-spec" name="spec" constrainedElement="Namespace-getNamesOfMember" namespace="Namespace-getNamesOfMember">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Namespace-getNamesOfMember-spec-_specification">
						<language>OCL</language>
						<body>result = if self.ownedMember->includes(element)&#xA;then Set{}->include(element.name)&#xA;else let elementImports: ElementImport = self.elementImport->select(ei | ei.importedElement = element) in&#xA;  if elementImports->notEmpty()&#xA;  then elementImports->collect(el | el.getName())&#xA;  else self.packageImport->select(pi | pi.importedPackage.visibleMembers()->includes(element))->collect(pi | pi.importedPackage.getNamesOfMember(element))&#xA;  endif&#xA;endif</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Namespace-getNamesOfMember-_ownedParameter.0" type="String" upper="*" lower="0" direction="return"/>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Namespace-getNamesOfMember-element" name="element" type="NamedElement"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Namespace-importMembers" name="importMembers" class="Namespace" isQuery="true" bodyCondition="Namespace-importMembers-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Namespace-importMembers-_ownedComment.0" annotatedElement="Namespace-importMembers">
					<body>The query importMembers() defines which of a set of PackageableElements are actually imported into the namespace. This excludes hidden ones, i.e., those which have names that conflict with names of owned members, and also excludes elements which would have the same name when imported.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Namespace-importMembers-spec" name="spec" constrainedElement="Namespace-importMembers" namespace="Namespace-importMembers">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Namespace-importMembers-spec-_specification">
						<language>OCL</language>
						<body>result = self.excludeCollisions(imps)->select(imp | self.ownedMember->forAll(mem | mem.imp.isDistinguishableFrom(mem, self)))</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Namespace-importMembers-_ownedParameter.0" type="PackageableElement" upper="*" lower="0" direction="return"/>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Namespace-importMembers-imps" name="imps" type="PackageableElement" upper="*" lower="0"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Namespace-excludeCollisions" name="excludeCollisions" class="Namespace" isQuery="true" bodyCondition="Namespace-excludeCollisions-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Namespace-excludeCollisions-_ownedComment.0" annotatedElement="Namespace-excludeCollisions">
					<body>The query excludeCollisions() excludes from a set of PackageableElements any that would not be distinguishable from each other in this namespace.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Namespace-excludeCollisions-spec" name="spec" constrainedElement="Namespace-excludeCollisions" namespace="Namespace-excludeCollisions">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Namespace-excludeCollisions-spec-_specification">
						<language>OCL</language>
						<body>result = imps->reject(imp1 | imps.exists(imp2 | not imp1.isDistinguishableFrom(imp2, self)))</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Namespace-excludeCollisions-_ownedParameter.0" type="PackageableElement" upper="*" lower="0" direction="return"/>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Namespace-excludeCollisions-imps" name="imps" type="PackageableElement" upper="*" lower="0"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Namespace-membersAreDistinguishable" name="membersAreDistinguishable" class="Namespace" isQuery="true" bodyCondition="Namespace-membersAreDistinguishable-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Namespace-membersAreDistinguishable-_ownedComment.0" annotatedElement="Namespace-membersAreDistinguishable">
					<body>The Boolean query membersAreDistinguishable() determines whether all of the namespace's members are distinguishable within it.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Namespace-membersAreDistinguishable-spec" name="spec" constrainedElement="Namespace-membersAreDistinguishable" namespace="Namespace-membersAreDistinguishable">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Namespace-membersAreDistinguishable-spec-_specification">
						<language>OCL</language>
						<body>result = self.member->forAll( memb |&#xA;&#x9;self.member->excluding(memb)->forAll(other |&#xA;&#x9;&#x9;memb.isDistinguishableFrom(other, self)))</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Namespace-membersAreDistinguishable-_ownedParameter.0" type="Boolean" direction="return"/>
			</ownedOperation>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="PackageableElement" name="PackageableElement" isAbstract="true" superClass="NamedElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="PackageableElement-_ownedComment.0" annotatedElement="PackageableElement">
				<body>A packageable element indicates a named element that may be owned directly by a package.</body>
			</ownedComment>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="RedefinableElement" name="RedefinableElement" isAbstract="true" superClass="NamedElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="RedefinableElement-_ownedComment.0" annotatedElement="RedefinableElement">
				<body>A redefinable element is an element that, when defined in the context of a classifier, can be redefined more specifically or differently in the context of another classifier that specializes (directly or indirectly) the context classifier.</body>
			</ownedComment>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="RedefinableElement-redefinition_context_valid" name="redefinition_context_valid" constrainedElement="RedefinableElement" namespace="RedefinableElement">
				<ownedComment xmi:type="cmof:Comment" xmi:id="RedefinableElement-redefinition_context_valid-_ownedComment.0" annotatedElement="RedefinableElement-redefinition_context_valid">
					<body>At least one of the redefinition contexts of the redefining element must be a specialization of at least one of the redefinition contexts for each redefined element.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="RedefinableElement-redefinition_context_valid-_specification">
					<language>OCL</language>
					<body>self.redefinedElement->forAll(e | self.isRedefinitionContextValid(e))</body>
				</specification>
			</ownedRule>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="RedefinableElement-redefinition_consistent" name="redefinition_consistent" constrainedElement="RedefinableElement" namespace="RedefinableElement">
				<ownedComment xmi:type="cmof:Comment" xmi:id="RedefinableElement-redefinition_consistent-_ownedComment.0" annotatedElement="RedefinableElement-redefinition_consistent">
					<body>A redefining element must be consistent with each redefined element.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="RedefinableElement-redefinition_consistent-_specification">
					<language>OCL</language>
					<body>self.redefinedElement->forAll(re | re.isConsistentWith(self))</body>
				</specification>
			</ownedRule>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="RedefinableElement-redefinitionContext" name="redefinitionContext" type="Classifier" upper="*" lower="0" isReadOnly="true" isDerived="true" isDerivedUnion="true" association="A_redefinitionContext_redefinableElement">
				<ownedComment xmi:type="cmof:Comment" xmi:id="RedefinableElement-redefinitionContext-_ownedComment.0" annotatedElement="RedefinableElement-redefinitionContext">
					<body>References the contexts that this element may be redefined from.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="RedefinableElement-redefinedElement" name="redefinedElement" type="RedefinableElement" upper="*" lower="0" isReadOnly="true" isDerived="true" isDerivedUnion="true" association="A_redefinedElement_redefinableElement">
				<ownedComment xmi:type="cmof:Comment" xmi:id="RedefinableElement-redefinedElement-_ownedComment.0" annotatedElement="RedefinableElement-redefinedElement">
					<body>The redefinable element that is being redefined by this element.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="RedefinableElement-isConsistentWith" name="isConsistentWith" class="RedefinableElement" isQuery="true" bodyCondition="RedefinableElement-isConsistentWith-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="RedefinableElement-isConsistentWith-_ownedComment.0" annotatedElement="RedefinableElement-isConsistentWith">
					<body>The query isConsistentWith() specifies, for any two RedefinableElements in a context in which redefinition is possible, whether redefinition would be logically consistent. By default, this is false; this operation must be overridden for subclasses of RedefinableElement to define the consistency conditions.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="RedefinableElement-isConsistentWith-spec" name="spec" constrainedElement="RedefinableElement-isConsistentWith" namespace="RedefinableElement-isConsistentWith">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="RedefinableElement-isConsistentWith-spec-_specification">
						<language>OCL</language>
						<body>result = false</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="RedefinableElement-isConsistentWith-_ownedParameter.0" type="Boolean" direction="return"/>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="RedefinableElement-isConsistentWith-redefinee" name="redefinee" type="RedefinableElement"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="RedefinableElement-isRedefinitionContextValid" name="isRedefinitionContextValid" class="RedefinableElement" isQuery="true" bodyCondition="RedefinableElement-isRedefinitionContextValid-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="RedefinableElement-isRedefinitionContextValid-_ownedComment.0" annotatedElement="RedefinableElement-isRedefinitionContextValid">
					<body>The query isRedefinitionContextValid() specifies whether the redefinition contexts of this RedefinableElement are properly related to the redefinition contexts of the specified RedefinableElement to allow this element to redefine the other. By default at least one of the redefinition contexts of this element must be a specialization of at least one of the redefinition contexts of the specified element.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="RedefinableElement-isRedefinitionContextValid-spec" name="spec" constrainedElement="RedefinableElement-isRedefinitionContextValid" namespace="RedefinableElement-isRedefinitionContextValid">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="RedefinableElement-isRedefinitionContextValid-spec-_specification">
						<language>OCL</language>
						<body>result = self.redefinitionContext->exists(c | redefined.redefinitionContext->exists(r | c.allParents()->includes(r)))</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="RedefinableElement-isRedefinitionContextValid-_ownedParameter.0" type="Boolean" direction="return"/>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="RedefinableElement-isRedefinitionContextValid-redefined" name="redefined" type="RedefinableElement"/>
			</ownedOperation>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="Relationship" name="Relationship" isAbstract="true" superClass="Element">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Relationship-_ownedComment.0" annotatedElement="Relationship">
				<body>Relationship is an abstract concept that specifies some kind of relationship between elements.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Relationship-relatedElement" name="relatedElement" type="Element" upper="*" isReadOnly="true" isDerived="true" isDerivedUnion="true" association="A_relatedElement_relationship">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Relationship-relatedElement-_ownedComment.0" annotatedElement="Relationship-relatedElement">
					<body>Specifies the elements related by the Relationship.</body>
				</ownedComment>
			</ownedAttribute>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="StructuralFeature" name="StructuralFeature" isAbstract="true" superClass="Feature TypedElement MultiplicityElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="StructuralFeature-_ownedComment.0" annotatedElement="StructuralFeature">
				<body>A structural feature is a typed feature of a classifier that specifies the structure of instances of the classifier.</body>
			</ownedComment>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="TypedElement" name="TypedElement" isAbstract="true" superClass="NamedElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="TypedElement-_ownedComment.0" annotatedElement="TypedElement">
				<body>A typed element is a kind of named element that represents an element with a type.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="TypedElement-type" name="type" type="Type" lower="0" association="A_type_typedElement">
				<ownedComment xmi:type="cmof:Comment" xmi:id="TypedElement-type-_ownedComment.0" annotatedElement="TypedElement-type">
					<body>This information is derived from the return result for this Operation.</body>
				</ownedComment>
			</ownedAttribute>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="ValueSpecification" name="ValueSpecification" isAbstract="true" superClass="TypedElement PackageableElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="ValueSpecification-_ownedComment.0" annotatedElement="ValueSpecification">
				<body>A value specification is the specification of a (possibly empty) set of instances, including both objects and data values.</body>
			</ownedComment>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="ValueSpecification-isComputable" name="isComputable" class="ValueSpecification" isQuery="true" bodyCondition="ValueSpecification-isComputable-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ValueSpecification-isComputable-_ownedComment.0" annotatedElement="ValueSpecification-isComputable">
					<body>The query isComputable() determines whether a value specification can be computed in a model. This operation cannot be fully defined in OCL. A conforming implementation is expected to deliver true for this operation for all value specifications that it can compute, and to compute all of those for which the operation is true. A conforming implementation is expected to be able to compute the value of all literals.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="ValueSpecification-isComputable-spec" name="spec" constrainedElement="ValueSpecification-isComputable" namespace="ValueSpecification-isComputable">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="ValueSpecification-isComputable-spec-_specification">
						<language>OCL</language>
						<body>result = false</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="ValueSpecification-isComputable-_ownedParameter.0" type="Boolean" direction="return"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="ValueSpecification-integerValue" name="integerValue" class="ValueSpecification" isQuery="true" bodyCondition="ValueSpecification-integerValue-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ValueSpecification-integerValue-_ownedComment.0" annotatedElement="ValueSpecification-integerValue">
					<body>The query integerValue() gives a single Integer value when one can be computed.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="ValueSpecification-integerValue-spec" name="spec" constrainedElement="ValueSpecification-integerValue" namespace="ValueSpecification-integerValue">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="ValueSpecification-integerValue-spec-_specification">
						<language>OCL</language>
						<body>result = Set{}</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="ValueSpecification-integerValue-_ownedParameter.0" type="Integer" direction="return"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="ValueSpecification-booleanValue" name="booleanValue" class="ValueSpecification" isQuery="true" bodyCondition="ValueSpecification-booleanValue-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ValueSpecification-booleanValue-_ownedComment.0" annotatedElement="ValueSpecification-booleanValue">
					<body>The query booleanValue() gives a single Boolean value when one can be computed.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="ValueSpecification-booleanValue-spec" name="spec" constrainedElement="ValueSpecification-booleanValue" namespace="ValueSpecification-booleanValue">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="ValueSpecification-booleanValue-spec-_specification">
						<language>OCL</language>
						<body>result = Set{}</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="ValueSpecification-booleanValue-_ownedParameter.0" type="Boolean" direction="return"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="ValueSpecification-stringValue" name="stringValue" class="ValueSpecification" isQuery="true" bodyCondition="ValueSpecification-stringValue-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ValueSpecification-stringValue-_ownedComment.0" annotatedElement="ValueSpecification-stringValue">
					<body>The query stringValue() gives a single String value when one can be computed.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="ValueSpecification-stringValue-spec" name="spec" constrainedElement="ValueSpecification-stringValue" namespace="ValueSpecification-stringValue">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="ValueSpecification-stringValue-spec-_specification">
						<language>OCL</language>
						<body>result = Set{}</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="ValueSpecification-stringValue-_ownedParameter.0" type="String" direction="return"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="ValueSpecification-unlimitedValue" name="unlimitedValue" class="ValueSpecification" isQuery="true" bodyCondition="ValueSpecification-unlimitedValue-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ValueSpecification-unlimitedValue-_ownedComment.0" annotatedElement="ValueSpecification-unlimitedValue">
					<body>The query unlimitedValue() gives a single UnlimitedNatural value when one can be computed.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="ValueSpecification-unlimitedValue-spec" name="spec" constrainedElement="ValueSpecification-unlimitedValue" namespace="ValueSpecification-unlimitedValue">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="ValueSpecification-unlimitedValue-spec-_specification">
						<language>OCL</language>
						<body>result = Set{}</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="ValueSpecification-unlimitedValue-_ownedParameter.0" type="UnlimitedNatural" direction="return"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="ValueSpecification-isNull" name="isNull" class="ValueSpecification" isQuery="true" bodyCondition="ValueSpecification-isNull-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ValueSpecification-isNull-_ownedComment.0" annotatedElement="ValueSpecification-isNull">
					<body>The query isNull() returns true when it can be computed that the value is null.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="ValueSpecification-isNull-spec" name="spec" constrainedElement="ValueSpecification-isNull" namespace="ValueSpecification-isNull">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="ValueSpecification-isNull-spec-_specification">
						<language>OCL</language>
						<body>result = false</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="ValueSpecification-isNull-_ownedParameter.0" type="Boolean" direction="return"/>
			</ownedOperation>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="Association" name="Association" superClass="Classifier Relationship">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Association-_ownedComment.0" annotatedElement="Association">
				<body>An association describes a set of tuples whose values refer to typed instances. An instance of an association is called a link.</body>
			</ownedComment>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="Association-association_ends" name="association_ends" constrainedElement="Association" namespace="Association">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Association-association_ends-_ownedComment.0" annotatedElement="Association-association_ends">
					<body>Association ends of associations with more than two ends must be owned by the association.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="Association-association_ends-_specification">
					<language>OCL</language>
					<body>if memberEnd->size() > 2 then ownedEnd->includesAll(memberEnd)</body>
				</specification>
			</ownedRule>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Association-isDerived" name="isDerived" type="Boolean" default="false">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Association-isDerived-_ownedComment.0" annotatedElement="Association-isDerived">
					<body>Specifies whether the association is derived from other model elements such as other associations or constraints.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Association-ownedEnd" name="ownedEnd" type="Property" isOrdered="true" upper="*" lower="0" isComposite="true" subsettedProperty="Association-memberEnd Classifier-feature Namespace-ownedMember" association="A_ownedEnd_owningAssociation">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Association-ownedEnd-_ownedComment.0" annotatedElement="Association-ownedEnd">
					<body>The ends that are owned by the association itself.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Association-endType" name="endType" type="Type" upper="*" isReadOnly="true" isDerived="true" subsettedProperty="Relationship-relatedElement" association="A_endType_association">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Association-endType-_ownedComment.0" annotatedElement="Association-endType">
					<body>References the classifiers that are used as types of the ends of the association.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Association-memberEnd" name="memberEnd" type="Property" isOrdered="true" upper="*" lower="2" subsettedProperty="Namespace-member" association="A_memberEnd_association">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Association-memberEnd-_ownedComment.0" annotatedElement="Association-memberEnd">
					<body>Each end represents participation of instances of the classifier connected to the end in links of the association.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Association-navigableOwnedEnd" name="navigableOwnedEnd" type="Property" upper="*" lower="0" subsettedProperty="Association-ownedEnd" association="A_navigableOwnedEnd_association">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Association-navigableOwnedEnd-_ownedComment.0" annotatedElement="Association-navigableOwnedEnd">
					<body>The navigable ends that are owned by the association itself.</body>
				</ownedComment>
			</ownedAttribute>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="Property" name="Property" superClass="StructuralFeature">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Property-_ownedComment.0" annotatedElement="Property">
				<body>A property is a structural feature of a classifier that characterizes instances of the classifier. A property related by ownedAttribute to a classifier (other than an association) represents an attribute and might also represent an association end. It relates an instance of the class to a value or set of values of the type of the attribute. A property related by memberEnd or its specializations to an association represents an end of the association. The type of the property is the type of the end of the association.</body>
			</ownedComment>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="Property-multiplicity_of_composite" name="multiplicity_of_composite" constrainedElement="Property" namespace="Property">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Property-multiplicity_of_composite-_ownedComment.0" annotatedElement="Property-multiplicity_of_composite">
					<body>A multiplicity of a composite aggregation must not have an upper bound greater than 1.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="Property-multiplicity_of_composite-_specification">
					<language>OCL</language>
					<body>isComposite implies (upperBound()->isEmpty() or upperBound() &lt;= 1)</body>
				</specification>
			</ownedRule>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="Property-subsetting_context_conforms" name="subsetting_context_conforms" constrainedElement="Property" namespace="Property">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Property-subsetting_context_conforms-_ownedComment.0" annotatedElement="Property-subsetting_context_conforms">
					<body>Subsetting may only occur when the context of the subsetting property conforms to the context of the subsetted property.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="Property-subsetting_context_conforms-_specification">
					<language>OCL</language>
					<body>self.subsettedProperty->notEmpty() implies&#xA;  (self.subsettingContext()->notEmpty() and self.subsettingContext()->forAll (sc |&#xA;    self.subsettedProperty->forAll(sp |&#xA;      sp.subsettingContext()->exists(c | sc.conformsTo(c)))))</body>
				</specification>
			</ownedRule>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="Property-redefined_property_inherited" name="redefined_property_inherited" constrainedElement="Property" namespace="Property">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Property-redefined_property_inherited-_ownedComment.0" annotatedElement="Property-redefined_property_inherited">
					<body>A redefined property must be inherited from a more general classifier containing the redefining property.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="Property-redefined_property_inherited-_specification">
					<language>OCL</language>
					<body>if (redefinedProperty->notEmpty()) then&#xA;  (redefinitionContext->notEmpty() and&#xA;      redefinedProperty->forAll(rp|&#xA;        ((redefinitionContext->collect(fc|&#xA;          fc.allParents()))->asSet())->collect(c| c.allFeatures())->asSet()->includes(rp))</body>
				</specification>
			</ownedRule>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="Property-subsetting_rules" name="subsetting_rules" constrainedElement="Property" namespace="Property">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Property-subsetting_rules-_ownedComment.0" annotatedElement="Property-subsetting_rules">
					<body>A subsetting property may strengthen the type of the subsetted property, and its upper bound may be less.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="Property-subsetting_rules-_specification">
					<language>OCL</language>
					<body>self.subsettedProperty->forAll(sp |&#xA;  self.type.conformsTo(sp.type) and&#xA;    ((self.upperBound()->notEmpty() and sp.upperBound()->notEmpty()) implies&#xA;      self.upperBound()&lt;=sp.upperBound() ))</body>
				</specification>
			</ownedRule>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="Property-navigable_readonly" name="navigable_readonly" constrainedElement="Property" namespace="Property">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Property-navigable_readonly-_ownedComment.0" annotatedElement="Property-navigable_readonly">
					<body>Only a navigable property can be marked as readOnly.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="Property-navigable_readonly-_specification">
					<language>OCL</language>
					<body>isReadOnly implies isNavigable()</body>
				</specification>
			</ownedRule>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="Property-derived_union_is_derived" name="derived_union_is_derived" constrainedElement="Property" namespace="Property">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Property-derived_union_is_derived-_ownedComment.0" annotatedElement="Property-derived_union_is_derived">
					<body>A derived union is derived.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="Property-derived_union_is_derived-_specification">
					<language>OCL</language>
					<body>isDerivedUnion implies isDerived</body>
				</specification>
			</ownedRule>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="Property-subsetted_property_names" name="subsetted_property_names" constrainedElement="Property" namespace="Property">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Property-subsetted_property_names-_ownedComment.0" annotatedElement="Property-subsetted_property_names">
					<body>A property may not subset a property with the same name.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="Property-subsetted_property_names-_specification">
					<language>OCL</language>
					<body>true</body>
				</specification>
			</ownedRule>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Property-isReadOnly" name="isReadOnly" type="Boolean" default="false">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Property-isReadOnly-_ownedComment.0" annotatedElement="Property-isReadOnly">
					<body>If isReadOnly is true, the attribute may not be written to after initialization.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Property-default" name="default" type="String" lower="0">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Property-default-_ownedComment.0" annotatedElement="Property-default">
					<body>Specifies a String that represents a value to be used when no argument is supplied for the Property.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Property-isComposite" name="isComposite" type="Boolean" default="false">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Property-isComposite-_ownedComment.0" annotatedElement="Property-isComposite">
					<body>If isComposite is true, the object containing the attribute is a container for the object or value contained in the attribute.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Property-isDerived" name="isDerived" type="Boolean" default="false">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Property-isDerived-_ownedComment.0" annotatedElement="Property-isDerived">
					<body>If isDerived is true, the value of the attribute is derived from information elsewhere.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Property-isDerivedUnion" name="isDerivedUnion" type="Boolean" default="false">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Property-isDerivedUnion-_ownedComment.0" annotatedElement="Property-isDerivedUnion">
					<body>Specifies whether the property is derived as the union of all of the properties that are constrained to subset it.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Property-class" name="class" type="Class" lower="0" subsettedProperty="NamedElement-namespace Feature-featuringClassifier A_attribute_classifier-classifier" association="A_ownedAttribute_class">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Property-class-_ownedComment.0" annotatedElement="Property-class">
					<body>References the Class that owns the Property.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Property-owningAssociation" name="owningAssociation" type="Association" lower="0" subsettedProperty="Property-association NamedElement-namespace Feature-featuringClassifier" association="A_ownedEnd_owningAssociation">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Property-owningAssociation-_ownedComment.0" annotatedElement="Property-owningAssociation">
					<body>References the owning association of this property, if any.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Property-redefinedProperty" name="redefinedProperty" type="Property" upper="*" lower="0" subsettedProperty="RedefinableElement-redefinedElement" association="A_redefinedProperty_property">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Property-redefinedProperty-_ownedComment.0" annotatedElement="Property-redefinedProperty">
					<body>References the properties that are redefined by this property.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Property-subsettedProperty" name="subsettedProperty" type="Property" upper="*" lower="0" association="A_subsettedProperty_property">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Property-subsettedProperty-_ownedComment.0" annotatedElement="Property-subsettedProperty">
					<body>References the properties of which this property is constrained to be a subset.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Property-opposite" name="opposite" type="Property" lower="0" isDerived="true" association="A_opposite_property">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Property-opposite-_ownedComment.0" annotatedElement="Property-opposite">
					<body>In the case where the property is one navigable end of a binary association with both ends navigable, this gives the other end.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Property-datatype" name="datatype" type="DataType" lower="0" subsettedProperty="NamedElement-namespace Feature-featuringClassifier A_attribute_classifier-classifier" association="A_ownedAttribute_datatype">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Property-datatype-_ownedComment.0" annotatedElement="Property-datatype">
					<body>The DataType that owns this Property.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Property-association" name="association" type="Association" lower="0" association="A_memberEnd_association">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Property-association-_ownedComment.0" annotatedElement="Property-association">
					<body>References the association of which this property is a member, if any.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Property-opposite.1" name="opposite" class="Property" isQuery="true" bodyCondition="Property-opposite.1-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Property-opposite.1-_ownedComment.0" annotatedElement="Property-opposite.1">
					<body>If this property is owned by a class, associated with a binary association, and the other end of the association is also owned by a class, then opposite gives the other end.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Property-opposite.1-spec" name="spec" constrainedElement="Property-opposite.1 Property-opposite" namespace="Property-opposite.1">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Property-opposite.1-spec-_specification">
						<language>OCL</language>
						<body>result = if owningAssociation->isEmpty() and association.memberEnd->size() = 2&#xA;  then&#xA;    let otherEnd = (association.memberEnd - self)->any() in&#xA;      if otherEnd.owningAssociation->isEmpty() then otherEnd else Set{} endif&#xA;    else Set {}&#xA;    endif</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Property-opposite.1-_ownedParameter.0" type="Property" direction="return"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Property-isConsistentWith" name="isConsistentWith" class="Property" isQuery="true" precondition="Property-isConsistentWith-_ownedRule.0" redefinedOperation="RedefinableElement-isConsistentWith" bodyCondition="Property-isConsistentWith-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Property-isConsistentWith-_ownedComment.0" annotatedElement="Property-isConsistentWith">
					<body>The query isConsistentWith() specifies, for any two Properties in a context in which redefinition is possible, whether redefinition would be logically consistent. A redefining property is consistent with a redefined property if the type of the redefining property conforms to the type of the redefined property, the multiplicity of the redefining property (if specified) is contained in the multiplicity of the redefined property, and the redefining property is derived if the redefined property is derived.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Property-isConsistentWith-_ownedRule.0" constrainedElement="Property-isConsistentWith" namespace="Property-isConsistentWith">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Property-isConsistentWith-_ownedRule.0-_specification">
						<language>OCL</language>
						<body>redefinee.isRedefinitionContextValid(self)</body>
					</specification>
				</ownedRule>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Property-isConsistentWith-spec" name="spec" constrainedElement="Property-isConsistentWith" namespace="Property-isConsistentWith">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Property-isConsistentWith-spec-_specification">
						<language>OCL</language>
						<body>result = redefinee.oclIsKindOf(Property) and &#xA;  let prop : Property = redefinee.oclAsType(Property) in &#xA;  (prop.type.conformsTo(self.type) and &#xA;  ((prop.lowerBound()->notEmpty() and self.lowerBound()->notEmpty()) implies prop.lowerBound() >= self.lowerBound()) and &#xA;  ((prop.upperBound()->notEmpty() and self.upperBound()->notEmpty()) implies prop.lowerBound() &lt;= self.lowerBound()) and &#xA;  (self.isDerived implies prop.isDerived) and&#xA;  (self.isComposite implies prop.isComposite))</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Property-isConsistentWith-_ownedParameter.0" type="Boolean" direction="return"/>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Property-isConsistentWith-redefinee" name="redefinee" type="RedefinableElement"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Property-subsettingContext" name="subsettingContext" class="Property" isQuery="true" bodyCondition="Property-subsettingContext-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Property-subsettingContext-_ownedComment.0" annotatedElement="Property-subsettingContext">
					<body>The query subsettingContext() gives the context for subsetting a property. It consists, in the case of an attribute, of the corresponding classifier, and in the case of an association end, all of the classifiers at the other ends.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Property-subsettingContext-spec" name="spec" constrainedElement="Property-subsettingContext" namespace="Property-subsettingContext">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Property-subsettingContext-spec-_specification">
						<language>OCL</language>
						<body>result = if association->notEmpty()&#xA;then association.endType-type &#xA;else if classifier->notEmpty then Set{classifier} else Set{} endif&#xA;endif</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Property-subsettingContext-_ownedParameter.0" type="Classifier" upper="*" lower="0" direction="return"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Property-isNavigable" name="isNavigable" class="Property" isQuery="true" bodyCondition="Property-isNavigable-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Property-isNavigable-_ownedComment.0" annotatedElement="Property-isNavigable">
					<body>The query isNavigable() indicates whether it is possible to navigate across the property.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Property-isNavigable-spec" name="spec" constrainedElement="Property-isNavigable" namespace="Property-isNavigable">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Property-isNavigable-spec-_specification">
						<language>OCL</language>
						<body>result = not classifier->isEmpty() or&#xA;association.owningAssociation.navigableOwnedEnd->includes(self)</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Property-isNavigable-_ownedParameter.0" type="Boolean" direction="return"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Property-isAttribute" name="isAttribute" class="Property" isQuery="true" bodyCondition="Property-isAttribute-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Property-isAttribute-_ownedComment.0" annotatedElement="Property-isAttribute">
					<body>The query isAttribute() is true if the Property is defined as an attribute of some classifier.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Property-isAttribute-spec" name="spec" constrainedElement="Property-isAttribute" namespace="Property-isAttribute">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Property-isAttribute-spec-_specification">
						<language>OCL</language>
						<body>result = Classifier->allInstances->exists(c | c.attribute->includes(p))</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Property-isAttribute-_ownedParameter.0" type="Boolean" direction="return"/>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Property-isAttribute-p" name="p" type="Property"/>
			</ownedOperation>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="DataType" name="DataType" superClass="Classifier">
			<ownedComment xmi:type="cmof:Comment" xmi:id="DataType-_ownedComment.0" annotatedElement="DataType">
				<body>A data type is a type whose instances are identified only by their value. A data type may contain attributes to support the modeling of structured data types.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="DataType-ownedAttribute" name="ownedAttribute" type="Property" isOrdered="true" upper="*" lower="0" isComposite="true" subsettedProperty="Classifier-attribute Namespace-ownedMember" association="A_ownedAttribute_datatype">
				<ownedComment xmi:type="cmof:Comment" xmi:id="DataType-ownedAttribute-_ownedComment.0" annotatedElement="DataType-ownedAttribute">
					<body>The Attributes owned by the DataType.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="DataType-ownedOperation" name="ownedOperation" type="Operation" isOrdered="true" upper="*" lower="0" isComposite="true" subsettedProperty="Classifier-feature Namespace-ownedMember" association="A_ownedOperation_datatype">
				<ownedComment xmi:type="cmof:Comment" xmi:id="DataType-ownedOperation-_ownedComment.0" annotatedElement="DataType-ownedOperation">
					<body>The Operations owned by the DataType.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="DataType-inherit" name="inherit" class="DataType" isQuery="true" redefinedOperation="Classifier-inherit" bodyCondition="DataType-inherit-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="DataType-inherit-_ownedComment.0" annotatedElement="DataType-inherit">
					<body>The inherit operation is overridden to exclude redefined properties.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="DataType-inherit-spec" name="spec" constrainedElement="DataType-inherit" namespace="DataType-inherit">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="DataType-inherit-spec-_specification">
						<language>OCL</language>
						<body>result = inhs->excluding(inh | ownedMember->select(oclIsKindOf(RedefinableElement))->select(redefinedElement->includes(inh)))</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="DataType-inherit-_ownedParameter.0" type="NamedElement" upper="*" lower="0" direction="return"/>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="DataType-inherit-inhs" name="inhs" type="NamedElement" upper="*" lower="0"/>
			</ownedOperation>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="Enumeration" name="Enumeration" superClass="DataType">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Enumeration-_ownedComment.0" annotatedElement="Enumeration">
				<body>An enumeration is a data type whose values are enumerated in the model as enumeration literals.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Enumeration-ownedLiteral" name="ownedLiteral" type="EnumerationLiteral" isOrdered="true" upper="*" lower="0" isComposite="true" subsettedProperty="Namespace-ownedMember" association="A_ownedLiteral_enumeration">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Enumeration-ownedLiteral-_ownedComment.0" annotatedElement="Enumeration-ownedLiteral">
					<body>The ordered set of literals for this Enumeration.</body>
				</ownedComment>
			</ownedAttribute>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="EnumerationLiteral" name="EnumerationLiteral" superClass="NamedElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="EnumerationLiteral-_ownedComment.0" annotatedElement="EnumerationLiteral">
				<body>An enumeration literal is a user-defined data value for an enumeration.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="EnumerationLiteral-enumeration" name="enumeration" type="Enumeration" lower="0" subsettedProperty="NamedElement-namespace" association="A_ownedLiteral_enumeration">
				<ownedComment xmi:type="cmof:Comment" xmi:id="EnumerationLiteral-enumeration-_ownedComment.0" annotatedElement="EnumerationLiteral-enumeration">
					<body>The Enumeration that this EnumerationLiteral is a member of.</body>
				</ownedComment>
			</ownedAttribute>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="PrimitiveType" name="PrimitiveType" superClass="DataType">
			<ownedComment xmi:type="cmof:Comment" xmi:id="PrimitiveType-_ownedComment.0" annotatedElement="PrimitiveType">
				<body>A primitive type defines a predefined data type, without any relevant substructure (i.e., it has no parts in the context of UML). A primitive datatype may have an algebra and operations defined outside of UML, for example, mathematically.</body>
			</ownedComment>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="Constraint" name="Constraint" superClass="PackageableElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Constraint-_ownedComment.0" annotatedElement="Constraint">
				<body>A constraint is a condition or restriction expressed in natural language text or in a machine readable language for the purpose of declaring some of the semantics of an element.</body>
			</ownedComment>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="Constraint-not_apply_to_self" name="not_apply_to_self" constrainedElement="Constraint" namespace="Constraint">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Constraint-not_apply_to_self-_ownedComment.0" annotatedElement="Constraint-not_apply_to_self">
					<body>A constraint cannot be applied to itself.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="Constraint-not_apply_to_self-_specification">
					<language>OCL</language>
					<body>not constrainedElement->includes(self)</body>
				</specification>
			</ownedRule>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="Constraint-value_specification_boolean" name="value_specification_boolean" constrainedElement="Constraint" namespace="Constraint">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Constraint-value_specification_boolean-_ownedComment.0" annotatedElement="Constraint-value_specification_boolean">
					<body>The value specification for a constraint must evaluate to a Boolean value.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="Constraint-value_specification_boolean-_specification">
					<language>OCL</language>
					<body>self.specification().booleanValue().isOclKindOf(Boolean)</body>
				</specification>
			</ownedRule>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Constraint-constrainedElement" name="constrainedElement" type="Element" isOrdered="true" upper="*" lower="0" association="A_constrainedElement_constraint">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Constraint-constrainedElement-_ownedComment.0" annotatedElement="Constraint-constrainedElement">
					<body>The ordered set of Elements referenced by this Constraint.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Constraint-specification" name="specification" type="ValueSpecification" isComposite="true" subsettedProperty="Element-ownedElement" association="A_specification_owningConstraint">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Constraint-specification-_ownedComment.0" annotatedElement="Constraint-specification">
					<body>A condition that must be true when evaluated in order for the constraint to be satisfied.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Constraint-context" name="context" type="Namespace" lower="0" subsettedProperty="NamedElement-namespace" association="A_ownedRule_context"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="OpaqueExpression" name="OpaqueExpression" superClass="ValueSpecification">
			<ownedComment xmi:type="cmof:Comment" xmi:id="OpaqueExpression-_ownedComment.0" annotatedElement="OpaqueExpression">
				<body>An opaque expression is an uninterpreted textual statement that denotes a (possibly empty) set of values when evaluated in a context.</body>
			</ownedComment>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="OpaqueExpression-language_body_size" name="language_body_size" constrainedElement="OpaqueExpression" namespace="OpaqueExpression">
				<ownedComment xmi:type="cmof:Comment" xmi:id="OpaqueExpression-language_body_size-_ownedComment.0" annotatedElement="OpaqueExpression-language_body_size">
					<body>If the language attribute is not empty, then the size of the body and language arrays must be the same.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="OpaqueExpression-language_body_size-_specification">
					<language>OCL</language>
					<body>language->notEmpty() implies (body->size() = language->size())</body>
				</specification>
			</ownedRule>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="OpaqueExpression-body" name="body" type="String" isOrdered="true" upper="*" lower="0" isComposite="true">
				<ownedComment xmi:type="cmof:Comment" xmi:id="OpaqueExpression-body-_ownedComment.0" annotatedElement="OpaqueExpression-body">
					<body>The text of the expression, possibly in multiple languages.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="OpaqueExpression-language" name="language" type="String" isOrdered="true" upper="*" lower="0" isComposite="true">
				<ownedComment xmi:type="cmof:Comment" xmi:id="OpaqueExpression-language-_ownedComment.0" annotatedElement="OpaqueExpression-language">
					<body>Specifies the languages in which the expression is stated. The interpretation of the expression body depends on the languages. If the languages are unspecified, they might be implicit from the expression body or the context. Languages are matched to body strings by order.</body>
				</ownedComment>
			</ownedAttribute>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="Operation" name="Operation" superClass="BehavioralFeature">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Operation-_ownedComment.0" annotatedElement="Operation">
				<body>An operation is a behavioral feature of a classifier that specifies the name, type, parameters, and constraints for invoking an associated behavior.</body>
			</ownedComment>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="Operation-only_body_for_query" name="only_body_for_query" constrainedElement="Operation" namespace="Operation">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Operation-only_body_for_query-_ownedComment.0" annotatedElement="Operation-only_body_for_query">
					<body>A bodyCondition can only be specified for a query operation.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="Operation-only_body_for_query-_specification">
					<language>OCL</language>
					<body>bodyCondition->notEmpty() implies isQuery</body>
				</specification>
			</ownedRule>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="Operation-at_most_one_return" name="at_most_one_return" constrainedElement="Operation" namespace="Operation">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Operation-at_most_one_return-_ownedComment.0" annotatedElement="Operation-at_most_one_return">
					<body>An operation can have at most one return parameter; i.e., an owned parameter with the direction set to 'return'</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="Operation-at_most_one_return-_specification">
					<language>OCL</language>
					<body>self.ownedParameter->select(par | par.direction = #return)->size() &lt;= 1</body>
				</specification>
			</ownedRule>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Operation-isQuery" name="isQuery" type="Boolean" default="false">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Operation-isQuery-_ownedComment.0" annotatedElement="Operation-isQuery">
					<body>Specifies whether an execution of the BehavioralFeature leaves the state of the system unchanged (isQuery=true) or whether side effects may occur (isQuery=false).</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Operation-isOrdered" name="isOrdered" type="Boolean" isDerived="true" default="false">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Operation-isOrdered-_ownedComment.0" annotatedElement="Operation-isOrdered">
					<body>This information is derived from the return result for this Operation.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Operation-isUnique" name="isUnique" type="Boolean" isDerived="true" default="true">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Operation-isUnique-_ownedComment.0" annotatedElement="Operation-isUnique">
					<body>This information is derived from the return result for this Operation.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Operation-lower" name="lower" type="Integer" lower="0" isDerived="true" default="1">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Operation-lower-_ownedComment.0" annotatedElement="Operation-lower">
					<body>This information is derived from the return result for this Operation.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Operation-upper" name="upper" type="UnlimitedNatural" lower="0" isDerived="true" default="1">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Operation-upper-_ownedComment.0" annotatedElement="Operation-upper">
					<body>This information is derived from the return result for this Operation.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Operation-class" name="class" type="Class" lower="0" subsettedProperty="RedefinableElement-redefinitionContext NamedElement-namespace Feature-featuringClassifier" association="A_ownedOperation_class">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Operation-class-_ownedComment.0" annotatedElement="Operation-class">
					<body>The class that owns the operation.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Operation-datatype" name="datatype" type="DataType" lower="0" subsettedProperty="RedefinableElement-redefinitionContext NamedElement-namespace Feature-featuringClassifier" association="A_ownedOperation_datatype">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Operation-datatype-_ownedComment.0" annotatedElement="Operation-datatype">
					<body>The DataType that owns this Operation.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Operation-raisedException" name="raisedException" type="Type" upper="*" lower="0" redefinedProperty="BehavioralFeature-raisedException" association="A_raisedException_operation">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Operation-raisedException-_ownedComment.0" annotatedElement="Operation-raisedException">
					<body>References the Types representing exceptions that may be raised during an invocation of this operation.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Operation-redefinedOperation" name="redefinedOperation" type="Operation" upper="*" lower="0" subsettedProperty="RedefinableElement-redefinedElement" association="A_redefinedOperation_operation">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Operation-redefinedOperation-_ownedComment.0" annotatedElement="Operation-redefinedOperation">
					<body>References the Operations that are redefined by this Operation.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Operation-type" name="type" type="Type" lower="0" isDerived="true" association="A_type_operation">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Operation-type-_ownedComment.0" annotatedElement="Operation-type">
					<body>This information is derived from the return result for this Operation.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Operation-ownedParameter" name="ownedParameter" type="Parameter" isOrdered="true" upper="*" lower="0" isComposite="true" redefinedProperty="BehavioralFeature-ownedParameter" association="A_ownedParameter_operation">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Operation-ownedParameter-_ownedComment.0" annotatedElement="Operation-ownedParameter">
					<body>Specifies the ordered set of formal parameters of this BehavioralFeature.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Operation-precondition" name="precondition" type="Constraint" upper="*" lower="0" isComposite="true" subsettedProperty="Namespace-ownedRule" association="A_precondition_preContext"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Operation-postcondition" name="postcondition" type="Constraint" upper="*" lower="0" isComposite="true" subsettedProperty="Namespace-ownedRule" association="A_postcondition_postContext"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Operation-bodyCondition" name="bodyCondition" type="Constraint" lower="0" isComposite="true" subsettedProperty="Namespace-ownedRule" association="A_bodyCondition_bodyContext"/>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Operation-isOrdered.1" name="isOrdered" class="Operation" isQuery="true" bodyCondition="Operation-isOrdered.1-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Operation-isOrdered.1-_ownedComment.0" annotatedElement="Operation-isOrdered.1">
					<body>If this operation has a return parameter, isOrdered equals the value of isOrdered for that parameter. Otherwise isOrdered is false.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Operation-isOrdered.1-spec" name="spec" constrainedElement="Operation-isOrdered.1 Operation-isOrdered" namespace="Operation-isOrdered.1">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Operation-isOrdered.1-spec-_specification">
						<language>OCL</language>
						<body>result = if returnResult->size() = 1 then returnResult->any().isOrdered else false endif</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Operation-isOrdered.1-_ownedParameter.0" type="Boolean" direction="return"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Operation-isUnique.1" name="isUnique" class="Operation" isQuery="true" bodyCondition="Operation-isUnique.1-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Operation-isUnique.1-_ownedComment.0" annotatedElement="Operation-isUnique.1">
					<body>If this operation has a return parameter, isUnique equals the value of isUnique for that parameter. Otherwise isUnique is true.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Operation-isUnique.1-spec" name="spec" constrainedElement="Operation-isUnique.1 Operation-isUnique" namespace="Operation-isUnique.1">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Operation-isUnique.1-spec-_specification">
						<language>OCL</language>
						<body>result = if returnResult->size() = 1 then returnResult->any().isUnique else true endif</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Operation-isUnique.1-_ownedParameter.0" type="Boolean" direction="return"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Operation-lower.1" name="lower" class="Operation" isQuery="true" bodyCondition="Operation-lower.1-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Operation-lower.1-_ownedComment.0" annotatedElement="Operation-lower.1">
					<body>If this operation has a return parameter, lower equals the value of lower for that parameter. Otherwise lower is not defined.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Operation-lower.1-spec" name="spec" constrainedElement="Operation-lower.1 Operation-lower" namespace="Operation-lower.1">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Operation-lower.1-spec-_specification">
						<language>OCL</language>
						<body>result = if returnResult->size() = 1 then returnResult->any().lower else Set{} endif</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Operation-lower.1-_ownedParameter.0" type="Integer" direction="return"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Operation-upper.1" name="upper" class="Operation" isQuery="true" bodyCondition="Operation-upper.1-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Operation-upper.1-_ownedComment.0" annotatedElement="Operation-upper.1">
					<body>If this operation has a return parameter, upper equals the value of upper for that parameter. Otherwise upper is not defined.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Operation-upper.1-spec" name="spec" constrainedElement="Operation-upper.1 Operation-upper" namespace="Operation-upper.1">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Operation-upper.1-spec-_specification">
						<language>OCL</language>
						<body>result = if returnResult->size() = 1 then returnResult->any().upper else Set{} endif</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Operation-upper.1-_ownedParameter.0" type="UnlimitedNatural" direction="return"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Operation-type.1" name="type" class="Operation" isQuery="true" bodyCondition="Operation-type.1-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Operation-type.1-_ownedComment.0" annotatedElement="Operation-type.1">
					<body>If this operation has a return parameter, type equals the value of type for that parameter. Otherwise type is not defined.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Operation-type.1-spec" name="spec" constrainedElement="Operation-type.1 Operation-type" namespace="Operation-type.1">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Operation-type.1-spec-_specification">
						<language>OCL</language>
						<body>result = if returnResult->size() = 1 then returnResult->any().type else Set{} endif</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Operation-type.1-_ownedParameter.0" type="Type" direction="return"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Operation-isConsistentWith" name="isConsistentWith" class="Operation" isQuery="true" precondition="Operation-isConsistentWith-_ownedRule.0" redefinedOperation="RedefinableElement-isConsistentWith" bodyCondition="Operation-isConsistentWith-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Operation-isConsistentWith-_ownedComment.0" annotatedElement="Operation-isConsistentWith">
					<body>The query isConsistentWith() specifies, for any two Operations in a context in which redefinition is possible, whether redefinition would be consistent in the sense of maintaining type covariance. Other senses of consistency may be required, for example to determine consistency in the sense of contravariance. Users may define alternative queries under names different from 'isConsistentWith()', as for example, users may define a query named 'isContravariantWith()'.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Operation-isConsistentWith-_ownedRule.0" constrainedElement="Operation-isConsistentWith" namespace="Operation-isConsistentWith">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Operation-isConsistentWith-_ownedRule.0-_specification">
						<language>OCL</language>
						<body>redefinee.isRedefinitionContextValid(self)</body>
					</specification>
				</ownedRule>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Operation-isConsistentWith-spec" name="spec" constrainedElement="Operation-isConsistentWith" namespace="Operation-isConsistentWith">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Operation-isConsistentWith-spec-_specification">
						<language>OCL</language>
						<body>result = (redefinee.oclIsKindOf(Operation) and&#xA;    let op: Operation = redefinee.oclAsType(Operation) in&#xA;        self.formalParameter.size() = op.formalParameter.size() and&#xA;        self.returnResult.size() = op.returnResult.size() and&#xA;        forAll(i | op.formalParameter[i].type.conformsTo(self.formalParameter[i].type)) and&#xA;        forAll(i | op.returnResult[i].type.conformsTo(self.returnResult[i].type))&#xA;)</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Operation-isConsistentWith-_ownedParameter.0" type="Boolean" direction="return"/>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Operation-isConsistentWith-redefinee" name="redefinee" type="RedefinableElement"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Operation-returnResult" name="returnResult" class="Operation" isQuery="true" bodyCondition="Operation-returnResult-spec">
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Operation-returnResult-spec" name="spec" constrainedElement="Operation-returnResult" namespace="Operation-returnResult">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Operation-returnResult-spec-_specification">
						<language>OCL</language>
						<body>result = ownedParameter->select (par | par.direction = #return)</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Operation-returnResult-_ownedParameter.0" type="Parameter" upper="*" lower="0" direction="return"/>
			</ownedOperation>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="Parameter" name="Parameter" superClass="TypedElement MultiplicityElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Parameter-_ownedComment.0" annotatedElement="Parameter">
				<body>A parameter is a specification of an argument used to pass information into or out of an invocation of a behavioral feature.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Parameter-default" name="default" type="String" lower="0">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Parameter-default-_ownedComment.0" annotatedElement="Parameter-default">
					<body>Specifies a String that represents a value to be used when no argument is supplied for the Parameter.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Parameter-direction" name="direction" type="ParameterDirectionKind" default="in">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Parameter-direction-_ownedComment.0" annotatedElement="Parameter-direction">
					<body>Indicates whether a parameter is being sent into or out of a behavioral element.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Parameter-operation" name="operation" type="Operation" lower="0" subsettedProperty="NamedElement-namespace" association="A_ownedParameter_operation">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Parameter-operation-_ownedComment.0" annotatedElement="Parameter-operation">
					<body>References the Operation owning this parameter.</body>
				</ownedComment>
			</ownedAttribute>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="BehavioralFeature" name="BehavioralFeature" isAbstract="true" superClass="Feature Namespace">
			<ownedComment xmi:type="cmof:Comment" xmi:id="BehavioralFeature-_ownedComment.0" annotatedElement="BehavioralFeature">
				<body>A behavioral feature is a feature of a classifier that specifies an aspect of the behavior of its instances.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="BehavioralFeature-ownedParameter" name="ownedParameter" type="Parameter" isOrdered="true" upper="*" lower="0" isComposite="true" subsettedProperty="Namespace-ownedMember" association="A_ownedParameter_ownerFormalParam">
				<ownedComment xmi:type="cmof:Comment" xmi:id="BehavioralFeature-ownedParameter-_ownedComment.0" annotatedElement="BehavioralFeature-ownedParameter">
					<body>Specifies the ordered set of formal parameters of this BehavioralFeature.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="BehavioralFeature-raisedException" name="raisedException" type="Type" upper="*" lower="0" association="A_raisedException_behavioralFeature">
				<ownedComment xmi:type="cmof:Comment" xmi:id="BehavioralFeature-raisedException-_ownedComment.0" annotatedElement="BehavioralFeature-raisedException">
					<body>References the Types representing exceptions that may be raised during an invocation of this feature.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="BehavioralFeature-isDistinguishableFrom" name="isDistinguishableFrom" class="BehavioralFeature" isQuery="true" redefinedOperation="NamedElement-isDistinguishableFrom" bodyCondition="BehavioralFeature-isDistinguishableFrom-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="BehavioralFeature-isDistinguishableFrom-_ownedComment.0" annotatedElement="BehavioralFeature-isDistinguishableFrom">
					<body>The query isDistinguishableFrom() determines whether two BehavioralFeatures may coexist in the same Namespace. It specifies that they have to have different signatures.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="BehavioralFeature-isDistinguishableFrom-spec" name="spec" constrainedElement="BehavioralFeature-isDistinguishableFrom" namespace="BehavioralFeature-isDistinguishableFrom">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="BehavioralFeature-isDistinguishableFrom-spec-_specification">
						<language>OCL</language>
						<body>result = if n.oclIsKindOf(BehavioralFeature)&#xA;then&#xA;  if ns.getNamesOfMember(self)->intersection(ns.getNamesOfMember(n))->notEmpty()&#xA;  then Set{}->include(self)->include(n)->isUnique( bf | bf.parameter->collect(type))&#xA;  else true&#xA;  endif&#xA;else true&#xA;endif</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="BehavioralFeature-isDistinguishableFrom-_ownedParameter.0" type="Boolean" direction="return"/>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="BehavioralFeature-isDistinguishableFrom-n" name="n" type="NamedElement"/>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="BehavioralFeature-isDistinguishableFrom-ns" name="ns" type="Namespace"/>
			</ownedOperation>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="ElementImport" name="ElementImport" superClass="DirectedRelationship">
			<ownedComment xmi:type="cmof:Comment" xmi:id="ElementImport-_ownedComment.0" annotatedElement="ElementImport">
				<body>An element import identifies an element in another package, and allows the element to be referenced using its name without a qualifier.</body>
			</ownedComment>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="ElementImport-visibility_public_or_private" name="visibility_public_or_private" constrainedElement="ElementImport" namespace="ElementImport">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ElementImport-visibility_public_or_private-_ownedComment.0" annotatedElement="ElementImport-visibility_public_or_private">
					<body>The visibility of an ElementImport is either public or private.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="ElementImport-visibility_public_or_private-_specification">
					<language>OCL</language>
					<body>self.visibility = #public or self.visibility = #private</body>
				</specification>
			</ownedRule>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="ElementImport-imported_element_is_public" name="imported_element_is_public" constrainedElement="ElementImport" namespace="ElementImport">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ElementImport-imported_element_is_public-_ownedComment.0" annotatedElement="ElementImport-imported_element_is_public">
					<body>An importedElement has either public visibility or no visibility at all.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="ElementImport-imported_element_is_public-_specification">
					<language>OCL</language>
					<body>self.importedElement.visibility.notEmpty() implies self.importedElement.visibility = #public</body>
				</specification>
			</ownedRule>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="ElementImport-visibility" name="visibility" type="VisibilityKind" default="public">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ElementImport-visibility-_ownedComment.0" annotatedElement="ElementImport-visibility">
					<body>Specifies the visibility of the imported PackageableElement within the importing Package. The default visibility is the same as that of the imported element. If the imported element does not have a visibility, it is possible to add visibility to the element import.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="ElementImport-alias" name="alias" type="String" lower="0">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ElementImport-alias-_ownedComment.0" annotatedElement="ElementImport-alias">
					<body>Specifies the name that should be added to the namespace of the importing package in lieu of the name of the imported packagable element. The aliased name must not clash with any other member name in the importing package. By default, no alias is used.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="ElementImport-importedElement" name="importedElement" type="PackageableElement" subsettedProperty="DirectedRelationship-target" association="A_importedElement_elementImport">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ElementImport-importedElement-_ownedComment.0" annotatedElement="ElementImport-importedElement">
					<body>Specifies the PackageableElement whose name is to be added to a Namespace.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="ElementImport-importingNamespace" name="importingNamespace" type="Namespace" subsettedProperty="DirectedRelationship-source Element-owner" association="A_elementImport_importingNamespace">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ElementImport-importingNamespace-_ownedComment.0" annotatedElement="ElementImport-importingNamespace">
					<body>Specifies the Namespace that imports a PackageableElement from another Package.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="ElementImport-getName" name="getName" class="ElementImport" isQuery="true" bodyCondition="ElementImport-getName-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ElementImport-getName-_ownedComment.0" annotatedElement="ElementImport-getName">
					<body>The query getName() returns the name under which the imported PackageableElement will be known in the importing namespace.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="ElementImport-getName-spec" name="spec" constrainedElement="ElementImport-getName" namespace="ElementImport-getName">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="ElementImport-getName-spec-_specification">
						<language>OCL</language>
						<body>result = if self.alias->notEmpty() then &#xA;  self.alias&#xA;else&#xA;  self.importedElement.name&#xA;endif</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="ElementImport-getName-_ownedParameter.0" type="String" direction="return"/>
			</ownedOperation>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="PackageImport" name="PackageImport" superClass="DirectedRelationship">
			<ownedComment xmi:type="cmof:Comment" xmi:id="PackageImport-_ownedComment.0" annotatedElement="PackageImport">
				<body>A package import is a relationship that allows the use of unqualified names to refer to package members from other namespaces.</body>
			</ownedComment>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="PackageImport-public_or_private" name="public_or_private" constrainedElement="PackageImport" namespace="PackageImport">
				<ownedComment xmi:type="cmof:Comment" xmi:id="PackageImport-public_or_private-_ownedComment.0" annotatedElement="PackageImport-public_or_private">
					<body>The visibility of a PackageImport is either public or private.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="PackageImport-public_or_private-_specification">
					<language>OCL</language>
					<body>self.visibility = #public or self.visibility = #private</body>
				</specification>
			</ownedRule>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="PackageImport-visibility" name="visibility" type="VisibilityKind" default="public">
				<ownedComment xmi:type="cmof:Comment" xmi:id="PackageImport-visibility-_ownedComment.0" annotatedElement="PackageImport-visibility">
					<body>Specifies the visibility of the imported PackageableElements within the importing Namespace, i.e., whether imported elements will in turn be visible to other packages that use that importingPackage as an importedPackage. If the PackageImport is public, the imported elements will be visible outside the package, while if it is private they will not.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="PackageImport-importedPackage" name="importedPackage" type="Package" subsettedProperty="DirectedRelationship-target" association="A_importedPackage_packageImport">
				<ownedComment xmi:type="cmof:Comment" xmi:id="PackageImport-importedPackage-_ownedComment.0" annotatedElement="PackageImport-importedPackage">
					<body>Specifies the Package whose members are imported into a Namespace.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="PackageImport-importingNamespace" name="importingNamespace" type="Namespace" subsettedProperty="DirectedRelationship-source Element-owner" association="A_packageImport_importingNamespace">
				<ownedComment xmi:type="cmof:Comment" xmi:id="PackageImport-importingNamespace-_ownedComment.0" annotatedElement="PackageImport-importingNamespace">
					<body>Specifies the Namespace that imports the members from a Package.</body>
				</ownedComment>
			</ownedAttribute>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="PackageMerge" name="PackageMerge" superClass="DirectedRelationship">
			<ownedComment xmi:type="cmof:Comment" xmi:id="PackageMerge-_ownedComment.0" annotatedElement="PackageMerge">
				<body>A package merge defines how the contents of one package are extended by the contents of another package.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="PackageMerge-receivingPackage" name="receivingPackage" type="Package" subsettedProperty="DirectedRelationship-source Element-owner" association="A_receivingPackage_packageMerge">
				<ownedComment xmi:type="cmof:Comment" xmi:id="PackageMerge-receivingPackage-_ownedComment.0" annotatedElement="PackageMerge-receivingPackage">
					<body>References the Package that is being extended with the contents of the merged package of the PackageMerge.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="PackageMerge-mergedPackage" name="mergedPackage" type="Package" subsettedProperty="DirectedRelationship-target" association="A_mergedPackage_packageMerge">
				<ownedComment xmi:type="cmof:Comment" xmi:id="PackageMerge-mergedPackage-_ownedComment.0" annotatedElement="PackageMerge-mergedPackage">
					<body>References the Package that is to be merged with the receiving package of the PackageMerge.</body>
				</ownedComment>
			</ownedAttribute>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="Type" name="Type" isAbstract="true" superClass="PackageableElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Type-_ownedComment.0" annotatedElement="Type">
				<body>A type is a named element that is used as the type for a typed element. A type can be contained in a package.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Type-package" name="package" type="Package" lower="0" subsettedProperty="NamedElement-namespace" association="A_ownedType_package">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Type-package-_ownedComment.0" annotatedElement="Type-package">
					<body>Specifies the owning package of this classifier, if any.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Type-conformsTo" name="conformsTo" class="Type" isQuery="true" bodyCondition="Type-conformsTo-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Type-conformsTo-_ownedComment.0" annotatedElement="Type-conformsTo">
					<body>The query conformsTo() gives true for a type that conforms to another. By default, two types do not conform to each other. This query is intended to be redefined for specific conformance situations.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Type-conformsTo-spec" name="spec" constrainedElement="Type-conformsTo" namespace="Type-conformsTo">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Type-conformsTo-spec-_specification">
						<language>OCL</language>
						<body>result = false</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Type-conformsTo-_ownedParameter.0" type="Boolean" direction="return"/>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Type-conformsTo-other" name="other" type="Type"/>
			</ownedOperation>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="Expression" name="Expression" superClass="ValueSpecification">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Expression-_ownedComment.0" annotatedElement="Expression">
				<body>An expression is a structured tree of symbols that denotes a (possibly empty) set of values when evaluated in a context.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Expression-operand" name="operand" type="ValueSpecification" isOrdered="true" upper="*" lower="0" isComposite="true" subsettedProperty="Element-ownedElement" association="A_operand_expression">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Expression-operand-_ownedComment.0" annotatedElement="Expression-operand">
					<body>Specifies a sequence of operands.</body>
				</ownedComment>
			</ownedAttribute>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="Comment" name="Comment" superClass="Element">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Comment-_ownedComment.0" annotatedElement="Comment">
				<body>A comment is a textual annotation that can be attached to a set of elements.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Comment-body" name="body" type="String" lower="0">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Comment-body-_ownedComment.0" annotatedElement="Comment-body">
					<body>Specifies a string that is the comment.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Comment-annotatedElement" name="annotatedElement" type="Element" upper="*" lower="0" association="A_annotatedElement_comment">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Comment-annotatedElement-_ownedComment.0" annotatedElement="Comment-annotatedElement">
					<body>References the Element(s) being commented.</body>
				</ownedComment>
			</ownedAttribute>
		</ownedMember>
		<ownedMember xmi:type="cmof:Enumeration" xmi:id="VisibilityKind" name="VisibilityKind">
			<ownedComment xmi:type="cmof:Comment" xmi:id="VisibilityKind-_ownedComment.0" annotatedElement="VisibilityKind">
				<body>VisibilityKind is an enumeration type that defines literals to determine the visibility of elements in a model.</body>
			</ownedComment>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="VisibilityKind-bestVisibility" name="bestVisibility" isQuery="true" datatype="VisibilityKind" bodyCondition="VisibilityKind-bestVisibility-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="VisibilityKind-bestVisibility-_ownedComment.0" annotatedElement="VisibilityKind-bestVisibility">
					<body>The query bestVisibility() examines a set of VisibilityKinds, and returns public as the preferred visibility.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="VisibilityKind-bestVisibility-spec" name="spec" constrainedElement="VisibilityKind-bestVisibility" namespace="VisibilityKind-bestVisibility">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="VisibilityKind-bestVisibility-spec-_specification">
						<language>OCL</language>
						<body>result = if vis->includes(#public) then #public else #private endif</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="VisibilityKind-bestVisibility-_ownedParameter.0" type="VisibilityKind" direction="return"/>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="VisibilityKind-bestVisibility-vis" name="vis" type="VisibilityKind" upper="*" lower="0"/>
			</ownedOperation>
			<ownedLiteral xmi:type="cmof:EnumerationLiteral" xmi:id="VisibilityKind-public" name="public" enumeration="VisibilityKind">
				<ownedComment xmi:type="cmof:Comment" xmi:id="VisibilityKind-public-_ownedComment.0" annotatedElement="VisibilityKind-public">
					<body>A public element is visible to all elements that can access the contents of the namespace that owns it.</body>
				</ownedComment>
			</ownedLiteral>
			<ownedLiteral xmi:type="cmof:EnumerationLiteral" xmi:id="VisibilityKind-private" name="private" enumeration="VisibilityKind">
				<ownedComment xmi:type="cmof:Comment" xmi:id="VisibilityKind-private-_ownedComment.0" annotatedElement="VisibilityKind-private">
					<body>A private element is only visible inside the namespace that owns it.</body>
				</ownedComment>
			</ownedLiteral>
			<ownedLiteral xmi:type="cmof:EnumerationLiteral" xmi:id="VisibilityKind-protected" name="protected" enumeration="VisibilityKind">
				<ownedComment xmi:type="cmof:Comment" xmi:id="VisibilityKind-protected-_ownedComment.0" annotatedElement="VisibilityKind-protected">
					<body>A protected element is visible to elements that have a generalization relationship to the namespace that owns it.</body>
				</ownedComment>
			</ownedLiteral>
			<ownedLiteral xmi:type="cmof:EnumerationLiteral" xmi:id="VisibilityKind-package" name="package" enumeration="VisibilityKind">
				<ownedComment xmi:type="cmof:Comment" xmi:id="VisibilityKind-package-_ownedComment.0" annotatedElement="VisibilityKind-package">
					<body>A package element is owned by a namespace that is not a package, and is visible to elements that are in the same package as its owning namespace. Only named elements that are not owned by packages can be marked as having package visibility.  Any element marked as having package visibility is visible to all elements within the nearest enclosing package (given that other owning elements have proper visibility).  Outside the nearest enclosing package, an element marked as having package visibility is not visible.</body>
				</ownedComment>
			</ownedLiteral>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_type_typedElement" name="A_type_typedElement" memberEnd="TypedElement-type A_type_typedElement-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_type_typedElement-_ownedEnd.0" type="TypedElement" upper="*" lower="0" owningAssociation="A_type_typedElement" association="A_type_typedElement"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_ownedAttribute_class" name="A_ownedAttribute_class" general="A_attribute_classifier A_ownedMember_namespace" memberEnd="Class-ownedAttribute Property-class"/>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_ownedOperation_class" name="A_ownedOperation_class" general="A_feature_featuringClassifier A_ownedMember_namespace A_redefinitionContext_redefinableElement" memberEnd="Class-ownedOperation Operation-class"/>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_ownedEnd_owningAssociation" name="A_ownedEnd_owningAssociation" general="A_memberEnd_association A_feature_featuringClassifier A_ownedMember_namespace" memberEnd="Association-ownedEnd Property-owningAssociation"/>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_attribute_classifier" name="A_attribute_classifier" general="A_feature_featuringClassifier A_redefinitionContext_redefinableElement" memberEnd="Classifier-attribute A_attribute_classifier-classifier">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_attribute_classifier-classifier" name="classifier" type="Classifier" lower="0" owningAssociation="A_attribute_classifier" subsettedProperty="RedefinableElement-redefinitionContext" association="A_attribute_classifier"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_redefinedProperty_property" name="A_redefinedProperty_property" general="A_redefinedElement_redefinableElement" memberEnd="Property-redefinedProperty A_redefinedProperty_property-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_redefinedProperty_property-_ownedEnd.0" type="Property" upper="*" lower="0" owningAssociation="A_redefinedProperty_property" association="A_redefinedProperty_property"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_subsettedProperty_property" name="A_subsettedProperty_property" memberEnd="Property-subsettedProperty A_subsettedProperty_property-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_subsettedProperty_property-_ownedEnd.0" type="Property" upper="*" lower="0" owningAssociation="A_subsettedProperty_property" association="A_subsettedProperty_property"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_opposite_property" name="A_opposite_property" memberEnd="Property-opposite A_opposite_property-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_opposite_property-_ownedEnd.0" type="Property" lower="0" owningAssociation="A_opposite_property" association="A_opposite_property"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_superClass_class" name="A_superClass_class" general="A_general_classifier" memberEnd="Class-superClass A_superClass_class-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_superClass_class-_ownedEnd.0" type="Class" upper="*" lower="0" owningAssociation="A_superClass_class" association="A_superClass_class"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_endType_association" name="A_endType_association" general="A_relatedElement_relationship" memberEnd="Association-endType A_endType_association-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_endType_association-_ownedEnd.0" type="Association" upper="*" lower="0" owningAssociation="A_endType_association" association="A_endType_association"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_ownedLiteral_enumeration" name="A_ownedLiteral_enumeration" general="A_ownedMember_namespace" memberEnd="Enumeration-ownedLiteral EnumerationLiteral-enumeration"/>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_ownedAttribute_datatype" name="A_ownedAttribute_datatype" general="A_attribute_classifier A_ownedMember_namespace" memberEnd="DataType-ownedAttribute Property-datatype"/>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_ownedOperation_datatype" name="A_ownedOperation_datatype" general="A_feature_featuringClassifier A_ownedMember_namespace A_redefinitionContext_redefinableElement" memberEnd="DataType-ownedOperation Operation-datatype"/>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_raisedException_operation" name="A_raisedException_operation" general="A_raisedException_behavioralFeature" memberEnd="Operation-raisedException A_raisedException_operation-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_raisedException_operation-_ownedEnd.0" type="Operation" upper="*" lower="0" owningAssociation="A_raisedException_operation" association="A_raisedException_operation"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_redefinedOperation_operation" name="A_redefinedOperation_operation" general="A_redefinedElement_redefinableElement" memberEnd="Operation-redefinedOperation A_redefinedOperation_operation-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_redefinedOperation_operation-_ownedEnd.0" type="Operation" upper="*" lower="0" owningAssociation="A_redefinedOperation_operation" association="A_redefinedOperation_operation"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_ownedParameter_ownerFormalParam" name="A_ownedParameter_ownerFormalParam" general="A_ownedMember_namespace" memberEnd="BehavioralFeature-ownedParameter A_ownedParameter_ownerFormalParam-ownerFormalParam">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_ownedParameter_ownerFormalParam-ownerFormalParam" name="ownerFormalParam" type="BehavioralFeature" lower="0" owningAssociation="A_ownedParameter_ownerFormalParam" subsettedProperty="NamedElement-namespace" association="A_ownedParameter_ownerFormalParam"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_raisedException_behavioralFeature" name="A_raisedException_behavioralFeature" memberEnd="BehavioralFeature-raisedException A_raisedException_behavioralFeature-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_raisedException_behavioralFeature-_ownedEnd.0" type="BehavioralFeature" upper="*" lower="0" owningAssociation="A_raisedException_behavioralFeature" association="A_raisedException_behavioralFeature"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_importedMember_namespace" name="A_importedMember_namespace" general="A_member_namespace" memberEnd="Namespace-importedMember A_importedMember_namespace-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_importedMember_namespace-_ownedEnd.0" type="Namespace" upper="*" lower="0" owningAssociation="A_importedMember_namespace" association="A_importedMember_namespace"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_importedPackage_packageImport" name="A_importedPackage_packageImport" general="A_target_directedRelationship" memberEnd="PackageImport-importedPackage A_importedPackage_packageImport-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_importedPackage_packageImport-_ownedEnd.0" type="PackageImport" upper="*" lower="0" owningAssociation="A_importedPackage_packageImport" association="A_importedPackage_packageImport"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_importedElement_elementImport" name="A_importedElement_elementImport" general="A_target_directedRelationship" memberEnd="ElementImport-importedElement A_importedElement_elementImport-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_importedElement_elementImport-_ownedEnd.0" type="ElementImport" upper="*" lower="0" owningAssociation="A_importedElement_elementImport" association="A_importedElement_elementImport"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_elementImport_importingNamespace" name="A_elementImport_importingNamespace" general="A_ownedElement_owner A_source_directedRelationship" memberEnd="Namespace-elementImport ElementImport-importingNamespace"/>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_packageImport_importingNamespace" name="A_packageImport_importingNamespace" general="A_ownedElement_owner A_source_directedRelationship" memberEnd="Namespace-packageImport PackageImport-importingNamespace"/>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_packagedElement_owningPackage" name="A_packagedElement_owningPackage" general="A_ownedMember_namespace" memberEnd="Package-packagedElement A_packagedElement_owningPackage-owningPackage">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_packagedElement_owningPackage-owningPackage" name="owningPackage" type="Package" lower="0" owningAssociation="A_packagedElement_owningPackage" subsettedProperty="NamedElement-namespace" association="A_packagedElement_owningPackage"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_ownedType_package" name="A_ownedType_package" general="A_packagedElement_owningPackage" memberEnd="Package-ownedType Type-package"/>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_memberEnd_association" name="A_memberEnd_association" general="A_member_namespace" memberEnd="Association-memberEnd Property-association"/>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_nestedPackage_nestingPackage" name="A_nestedPackage_nestingPackage" general="A_packagedElement_owningPackage" memberEnd="Package-nestedPackage Package-nestingPackage"/>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_type_operation" name="A_type_operation" memberEnd="Operation-type A_type_operation-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_type_operation-_ownedEnd.0" type="Operation" upper="*" lower="0" owningAssociation="A_type_operation" association="A_type_operation"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_receivingPackage_packageMerge" name="A_receivingPackage_packageMerge" general="A_source_directedRelationship A_ownedElement_owner" memberEnd="PackageMerge-receivingPackage Package-packageMerge"/>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_mergedPackage_packageMerge" name="A_mergedPackage_packageMerge" general="A_target_directedRelationship" memberEnd="PackageMerge-mergedPackage A_mergedPackage_packageMerge-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_mergedPackage_packageMerge-_ownedEnd.0" type="PackageMerge" upper="*" lower="0" owningAssociation="A_mergedPackage_packageMerge" association="A_mergedPackage_packageMerge"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_ownedElement_owner" name="A_ownedElement_owner" memberEnd="Element-ownedElement Element-owner"/>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_annotatedElement_comment" name="A_annotatedElement_comment" memberEnd="Comment-annotatedElement A_annotatedElement_comment-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_annotatedElement_comment-_ownedEnd.0" type="Comment" upper="*" lower="0" owningAssociation="A_annotatedElement_comment" association="A_annotatedElement_comment"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_relatedElement_relationship" name="A_relatedElement_relationship" memberEnd="Relationship-relatedElement A_relatedElement_relationship-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_relatedElement_relationship-_ownedEnd.0" type="Relationship" upper="*" lower="0" owningAssociation="A_relatedElement_relationship" association="A_relatedElement_relationship"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_source_directedRelationship" name="A_source_directedRelationship" general="A_relatedElement_relationship" memberEnd="DirectedRelationship-source A_source_directedRelationship-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_source_directedRelationship-_ownedEnd.0" type="DirectedRelationship" upper="*" lower="0" owningAssociation="A_source_directedRelationship" association="A_source_directedRelationship"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_target_directedRelationship" name="A_target_directedRelationship" general="A_relatedElement_relationship" memberEnd="DirectedRelationship-target A_target_directedRelationship-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_target_directedRelationship-_ownedEnd.0" type="DirectedRelationship" upper="*" lower="0" owningAssociation="A_target_directedRelationship" association="A_target_directedRelationship"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_redefinitionContext_redefinableElement" name="A_redefinitionContext_redefinableElement" memberEnd="RedefinableElement-redefinitionContext A_redefinitionContext_redefinableElement-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_redefinitionContext_redefinableElement-_ownedEnd.0" type="RedefinableElement" upper="*" lower="0" owningAssociation="A_redefinitionContext_redefinableElement" association="A_redefinitionContext_redefinableElement"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_redefinedElement_redefinableElement" name="A_redefinedElement_redefinableElement" memberEnd="RedefinableElement-redefinedElement A_redefinedElement_redefinableElement-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_redefinedElement_redefinableElement-_ownedEnd.0" type="RedefinableElement" upper="*" lower="0" owningAssociation="A_redefinedElement_redefinableElement" association="A_redefinedElement_redefinableElement"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_feature_featuringClassifier" name="A_feature_featuringClassifier" general="A_member_namespace" memberEnd="Classifier-feature Feature-featuringClassifier"/>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_constrainedElement_constraint" name="A_constrainedElement_constraint" memberEnd="Constraint-constrainedElement A_constrainedElement_constraint-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_constrainedElement_constraint-_ownedEnd.0" type="Constraint" upper="*" lower="0" owningAssociation="A_constrainedElement_constraint" association="A_constrainedElement_constraint"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_specification_owningConstraint" name="A_specification_owningConstraint" general="A_ownedElement_owner" memberEnd="Constraint-specification A_specification_owningConstraint-owningConstraint">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_specification_owningConstraint-owningConstraint" name="owningConstraint" type="Constraint" lower="0" owningAssociation="A_specification_owningConstraint" subsettedProperty="Element-owner" association="A_specification_owningConstraint"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_general_classifier" name="A_general_classifier" memberEnd="Classifier-general A_general_classifier-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_general_classifier-_ownedEnd.0" type="Classifier" upper="*" lower="0" owningAssociation="A_general_classifier" association="A_general_classifier"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_ownedMember_namespace" name="A_ownedMember_namespace" general="A_member_namespace A_ownedElement_owner" memberEnd="Namespace-ownedMember NamedElement-namespace"/>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_member_namespace" name="A_member_namespace" memberEnd="Namespace-member A_member_namespace-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_member_namespace-_ownedEnd.0" type="Namespace" upper="*" lower="0" owningAssociation="A_member_namespace" association="A_member_namespace"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_operand_expression" name="A_operand_expression" general="A_ownedElement_owner" memberEnd="Expression-operand A_operand_expression-expression">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_operand_expression-expression" name="expression" type="Expression" lower="0" owningAssociation="A_operand_expression" subsettedProperty="Element-owner" association="A_operand_expression"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_navigableOwnedEnd_association" name="A_navigableOwnedEnd_association" general="A_ownedEnd_owningAssociation" memberEnd="Association-navigableOwnedEnd A_navigableOwnedEnd_association-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_navigableOwnedEnd_association-_ownedEnd.0" type="Association" lower="0" owningAssociation="A_navigableOwnedEnd_association" association="A_navigableOwnedEnd_association"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_ownedParameter_operation" name="A_ownedParameter_operation" general="A_ownedParameter_ownerFormalParam" memberEnd="Operation-ownedParameter Parameter-operation"/>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_ownedComment_owningElement" name="A_ownedComment_owningElement" general="A_ownedElement_owner" memberEnd="Element-ownedComment A_ownedComment_owningElement-owningElement">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_ownedComment_owningElement-owningElement" name="owningElement" type="Element" lower="0" owningAssociation="A_ownedComment_owningElement" subsettedProperty="Element-owner" association="A_ownedComment_owningElement"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_inheritedMember_classifier" name="A_inheritedMember_classifier" general="A_member_namespace" memberEnd="Classifier-inheritedMember A_inheritedMember_classifier-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_inheritedMember_classifier-_ownedEnd.0" type="Classifier" upper="*" lower="0" owningAssociation="A_inheritedMember_classifier" association="A_inheritedMember_classifier"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_precondition_preContext" name="A_precondition_preContext" general="A_ownedRule_context" memberEnd="Operation-precondition A_precondition_preContext-preContext">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_precondition_preContext-preContext" name="preContext" type="Operation" lower="0" owningAssociation="A_precondition_preContext" subsettedProperty="Constraint-context" association="A_precondition_preContext"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_postcondition_postContext" name="A_postcondition_postContext" general="A_ownedRule_context" memberEnd="Operation-postcondition A_postcondition_postContext-postContext">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_postcondition_postContext-postContext" name="postContext" type="Operation" lower="0" owningAssociation="A_postcondition_postContext" subsettedProperty="Constraint-context" association="A_postcondition_postContext"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_bodyCondition_bodyContext" name="A_bodyCondition_bodyContext" general="A_ownedRule_context" memberEnd="Operation-bodyCondition A_bodyCondition_bodyContext-bodyContext">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_bodyCondition_bodyContext-bodyContext" name="bodyContext" type="Operation" lower="0" owningAssociation="A_bodyCondition_bodyContext" subsettedProperty="Constraint-context" association="A_bodyCondition_bodyContext"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_ownedRule_context" name="A_ownedRule_context" general="A_ownedMember_namespace" memberEnd="Namespace-ownedRule Constraint-context"/>
		<ownedMember xmi:type="cmof:PrimitiveType" xmi:id="Integer" name="Integer">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Integer-_ownedComment.0" annotatedElement="Integer">
				<body>An integer is a primitive type representing integer values.</body>
			</ownedComment>
		</ownedMember>
		<ownedMember xmi:type="cmof:PrimitiveType" xmi:id="Boolean" name="Boolean">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Boolean-_ownedComment.0" annotatedElement="Boolean">
				<body>A Boolean type is used for logical expression, consisting of the predefined values true and false.</body>
			</ownedComment>
		</ownedMember>
		<ownedMember xmi:type="cmof:PrimitiveType" xmi:id="String" name="String">
			<ownedComment xmi:type="cmof:Comment" xmi:id="String-_ownedComment.0" annotatedElement="String">
				<body>A string is a sequence of characters in some suitable character set used to display information about the model. Character sets may include non-Roman alphabets and characters.</body>
			</ownedComment>
		</ownedMember>
		<ownedMember xmi:type="cmof:PrimitiveType" xmi:id="UnlimitedNatural" name="UnlimitedNatural">
			<ownedComment xmi:type="cmof:Comment" xmi:id="UnlimitedNatural-_ownedComment.0" annotatedElement="UnlimitedNatural">
				<body>An unlimited natural is a primitive type representing unlimited natural values.</body>
			</ownedComment>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="WorkDefinitionPerformer" name="WorkDefinitionPerformer" isAbstract="true" superClass="Classifier">
			<ownedComment xmi:type="cmof:Comment" xmi:id="WorkDefinitionPerformer-_ownedComment.0" annotatedElement="WorkDefinitionPerformer">
				<body>Work Definition Performer is an abstract Classifier that represents the relationship of a work performer to a Work Definition.  Different specialization of Work Definition will introduce different kinds of performers.  Work Definition Performer is intended to be specialized adding the association to the concrete performer class.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="WorkDefinitionPerformer-linkedWorkDefinition" name="linkedWorkDefinition" type="WorkDefinition" isReadOnly="true" isDerived="true" isDerivedUnion="true" association="A_workDefinitionPerformer_WorkDefinition">
				<ownedComment xmi:type="cmof:Comment" xmi:id="WorkDefinitionPerformer-linkedWorkDefinition-_ownedComment.0" annotatedElement="WorkDefinitionPerformer-linkedWorkDefinition">
					<body>This derived union provides access to all the Work Definitions a Work Definition Performer instance is related to.</body>
				</ownedComment>
			</ownedAttribute>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="Kind" name="Kind" superClass="ExtensibleElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Kind-_ownedComment.0" annotatedElement="Kind">
				<body>Kind is an Extensible Element which instances are used to qualify other SPEM 2.0 Extensible Element instances with a user-defined type or kind.&#xD;
As many methods and processes to be modeled with SPEM 2.0 need to define their own refined vocabulary, Kind provides the ability to a SPEM 2.0 modeler to expresses such user-defined qualifications for instances of Extensible Element.  Because Kind is an Extensible Element itself one can define Kinds for the Kind class itself as well.&#xD;
For example, a subclass of Extensible Elements that typically utilizes Kinds is the meta-model class Guidance. Typical Guidance kinds would be: White Paper, Guideline, Checklist, Template, Reports, etc.  Because of the Applicable MetaClass constraints, these Kinds can only be related to instances of the Guidance class as well as instances of any subclasses of Guidance such as Metric.&#xD;
Other examples are Kinds for Breakdown Elements such as Phase, Iteration, Sprint, or Increment; Kinds of Work Products such as Artifact, Deliverable, or Outcome; Kinds of Categories such as Classification, View, Grouping, Practice, Discipline, Domain, etc.  All of these allow SPEM 2.0 users to distinguish the special kinds of SPEM 2.0 elements that play important role in their method or process.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Kind-applicableMetaClass" name="applicableMetaClass" type="Class" association="A_kind_applicableMetaclass">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Kind-applicableMetaClass-_ownedComment.0" annotatedElement="Kind-applicableMetaClass">
					<body>An instance of Kind can only be used for instances of exactly one SPEM 2.0 Extensible Element subclass or its subclasses.  This property specifies which one.</body>
				</ownedComment>
			</ownedAttribute>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="ExtensibleElement" name="ExtensibleElement" isAbstract="true" superClass="Classifier">
			<ownedComment xmi:type="cmof:Comment" xmi:id="ExtensibleElement-_ownedComment.0" annotatedElement="ExtensibleElement">
				<body>Extensible Element is an abstract generalization that represents any SPEM 2.0 class for which it is possible to assign a Kind to its instances expressing a user-defined qualification.  Every SPEM 2.0 class that allows such a qualification derives directly or indirectly from Extensible Element.&#xD;
Extensible Element provides the property to relate a Kind class for its sub-classes.  Such Kinds cannot be reused for many different subtypes of Extensible Element and therefore can only be related to exactly one meta-model class.&#xD;
Extensible Element defines a constraint called Applicable MetaClass.  The constraint defines that the Kind an instance of Extensible Element links to has to link to an applicable Meta Class that is either of the same class as Extensible Element or a superclass of the Extensible Element class.  See Kind for more details.</body>
			</ownedComment>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="ExtensibleElement-ApplicableMetaClass" name="Applicable MetaClass" constrainedElement="Kind" namespace="ExtensibleElement">
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="ExtensibleElement-ApplicableMetaClass-_specification">
					<language>OCL</language>
					<body>self.conformsTo(self.kind.applicableMetaClass)</body>
				</specification>
			</ownedRule>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="ExtensibleElement-kind" name="kind" type="Kind" lower="0" association="A_extendedElement_kind">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ExtensibleElement-kind-_ownedComment.0" annotatedElement="ExtensibleElement-kind">
					<body>An instance of Extensible Element can be linked to zero or one Kind in which the Kind instance expresses a specific user-defined qualification for that Extensible Element instance.</body>
				</ownedComment>
			</ownedAttribute>
		</ownedMember>
		<ownedMember xmi:type="cmof:Enumeration" xmi:id="ParameterDirectionKind" name="ParameterDirectionKind">
			<ownedComment xmi:type="cmof:Comment" xmi:id="ParameterDirectionKind-_ownedComment.0" annotatedElement="ParameterDirectionKind">
				<body>Parameter direction kind is an enumeration type that defines literals used to specify direction of parameters.</body>
			</ownedComment>
			<ownedComment xmi:type="cmof:Comment" xmi:id="ParameterDirectionKind-_ownedComment.1" annotatedElement="ParameterDirectionKind">
				<body>This enumeration defines for Work Definition Parameter instances whether the parameter represents an input, output, or input as well as output.</body>
			</ownedComment>
			<ownedLiteral xmi:type="cmof:EnumerationLiteral" xmi:id="ParameterDirectionKind-return" name="return" enumeration="ParameterDirectionKind">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ParameterDirectionKind-return-_ownedComment.0" annotatedElement="ParameterDirectionKind-return">
					<body>Indicates that parameter values are passed as return values from a behavioral element back to the caller.</body>
				</ownedComment>
			</ownedLiteral>
			<ownedLiteral xmi:type="cmof:EnumerationLiteral" xmi:id="ParameterDirectionKind-in" name="in" enumeration="ParameterDirectionKind">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ParameterDirectionKind-in-_ownedComment.0" annotatedElement="ParameterDirectionKind-in">
					<body>Indicates that parameter values are passed into the behavioral element by the caller.</body>
				</ownedComment>
				<ownedComment xmi:type="cmof:Comment" xmi:id="ParameterDirectionKind-in-_ownedComment.1" annotatedElement="ParameterDirectionKind-in">
					<body>A Work Definition Parameter instance with this direction value represents an input.</body>
				</ownedComment>
			</ownedLiteral>
			<ownedLiteral xmi:type="cmof:EnumerationLiteral" xmi:id="ParameterDirectionKind-out" name="out" enumeration="ParameterDirectionKind">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ParameterDirectionKind-out-_ownedComment.0" annotatedElement="ParameterDirectionKind-out">
					<body>Indicates that parameter values are passed from a behavioral element out to the caller.</body>
				</ownedComment>
				<ownedComment xmi:type="cmof:Comment" xmi:id="ParameterDirectionKind-out-_ownedComment.1" annotatedElement="ParameterDirectionKind-out">
					<body>A Work Definition Parameter instance with this direction value represents an output.</body>
				</ownedComment>
			</ownedLiteral>
			<ownedLiteral xmi:type="cmof:EnumerationLiteral" xmi:id="ParameterDirectionKind-inout" name="inout" enumeration="ParameterDirectionKind">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ParameterDirectionKind-inout-_ownedComment.0" annotatedElement="ParameterDirectionKind-inout">
					<body>Indicates that parameter values are passed into a behavioral element by the caller and then back out to the caller from the behavioral element.</body>
				</ownedComment>
				<ownedComment xmi:type="cmof:Comment" xmi:id="ParameterDirectionKind-inout-_ownedComment.1" annotatedElement="ParameterDirectionKind-inout">
					<body>A Work Definition Parameter instance with this direction value represents an input and output.</body>
				</ownedComment>
			</ownedLiteral>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_kind_applicableMetaclass" name="A_kind_applicableMetaclass" memberEnd="Kind-applicableMetaClass A_kind_applicableMetaclass-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_kind_applicableMetaclass-_ownedComment.0" annotatedElement="A_kind_applicableMetaclass">
				<body>An instance of Kind can only be used for instances of exactly one SPEM 2.0 Extensible Element subclass or its subclasses.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_kind_applicableMetaclass-_ownedEnd.0" visibility="private" type="Kind" upper="*" lower="0" owningAssociation="A_kind_applicableMetaclass" association="A_kind_applicableMetaclass"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_workDefinitionPerformer_WorkDefinition" name="A_workDefinitionPerformer_WorkDefinition" memberEnd="WorkDefinitionPerformer-linkedWorkDefinition A_workDefinitionPerformer_WorkDefinition-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_workDefinitionPerformer_WorkDefinition-_ownedComment.0" annotatedElement="A_workDefinitionPerformer_WorkDefinition">
				<body>This derived union provides access to all the Work Definitions a Work Definition Performer instance is related to.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_workDefinitionPerformer_WorkDefinition-_ownedEnd.0" visibility="private" type="WorkDefinitionPerformer" upper="*" lower="0" owningAssociation="A_workDefinitionPerformer_WorkDefinition" association="A_workDefinitionPerformer_WorkDefinition"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_workDefinition_postcondition" name="A_workDefinition_postcondition" general="A_ownedRule_context" memberEnd="WorkDefinition-postcondition A_workDefinition_postcondition-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_workDefinition_postcondition-_ownedComment.0" annotatedElement="A_workDefinition_postcondition">
				<body>This composition association adds an optional post-condition to a Work Definition.  A post-condition defines any kind of constraint that must evaluate to true before the work described for the Work Definition can be declared completed or finished and which other Work Definitions might depend upon (e.g. for their pre-conditions).  For example, a post-condition could define that a work product defined to be the output must be in a specific state before the Work Definition can end (e.g. Use Case must be in state fully described and reviewed by System Analyst).</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_workDefinition_postcondition-_ownedEnd.0" type="WorkDefinition" lower="0" owningAssociation="A_workDefinition_postcondition" association="A_workDefinition_postcondition"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_workDefinition_precondition" name="A_workDefinition_precondition" general="A_ownedRule_context" memberEnd="WorkDefinition-precondition A_workDefinition_precondition-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_workDefinition_precondition-_ownedComment.0" annotatedElement="A_workDefinition_precondition">
				<body>This composition association adds an optional pre-condition to a Work Definition.  A pre-condition defines any kind of constraint that must evaluate to true before the work described for the Work Definition can start. For example, a pre-condition could define that an input Work Product needs to be in a specific state or that other related work must be in a certain state (e.g. Input document X has been reviewed and signed by customer AND the work defined by Work Definition Management Review is complete) before the work can begin.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_workDefinition_precondition-_ownedEnd.0" type="WorkDefinition" lower="0" owningAssociation="A_workDefinition_precondition" association="A_workDefinition_precondition"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_workDefinition_ownedParameter" name="A_workDefinition_ownedParameter" general="A_ownedElement_owner" memberEnd="A_workDefinition_ownedParameter-_ownedEnd.0 WorkDefinition-ownedParameter">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_workDefinition_ownedParameter-_ownedComment.0" annotatedElement="A_workDefinition_ownedParameter">
				<body>Work Definition can define an ordered set of parameters to specify inputs and outputs.  The concrete subclasses of Work Definition need to define their own subclasses of Work Definition Parameter to add reference to concrete input/output meta types.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_workDefinition_ownedParameter-_ownedEnd.0" type="WorkDefinition" owningAssociation="A_workDefinition_ownedParameter" association="A_workDefinition_ownedParameter"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_extendedElement_kind" name="A_extendedElement_kind" memberEnd="ExtensibleElement-kind A_extendedElement_kind-extendedElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_extendedElement_kind-_ownedComment.0" annotatedElement="A_extendedElement_kind">
				<body>An instance of Extensible Element can be linked to zero or one Kind in which the Kind instance expresses a specific user-defined qualification for that Extensible Element instance.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_extendedElement_kind-extendedElement" name="extendedElement" type="ExtensibleElement" upper="*" lower="0" isDerived="true" owningAssociation="A_extendedElement_kind" association="A_extendedElement_kind"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="Milestone" name="Milestone" superClass="WorkBreakdownElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Milestone-_ownedComment.0" annotatedElement="Milestone">
				<body>A Milestone describes a significant event in a development project, such as a major decision, completion of a deliverable, or meeting of a major dependency (like completion of a project phase).  Because, Milestone is commonly used to refer to both the event itself and the point in time at which the event is scheduled to happen, it is modeled as a Breakdown Element (i.e. it appears as part of a breakdown structure).</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Milestone-requiredResults" name="requiredResults" type="WorkProductUse" upper="*" lower="0" association="A_milestone_requiredResults"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="ProcessParameter" name="ProcessParameter" superClass="WorkDefinitionParameter BreakdownElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="ProcessParameter-_ownedComment.0" annotatedElement="ProcessParameter">
				<body>A Process Parameter is a Work Definition Parameter used for process definitions.  It defines input and output meta-types to be Work Product Uses.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="ProcessParameter-parameterType" name="parameterType" type="WorkProductUse" lower="0" association="A_processParameter_parameterType">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ProcessParameter-parameterType-_ownedComment.0" annotatedElement="ProcessParameter-parameterType">
					<body>This association links zero or one Work Product Use instances to a parameter.  Processes could leave the type specification open and not specify a concrete Work Product Use.</body>
				</ownedComment>
			</ownedAttribute>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="WorkProductUseRelationship" name="WorkProductUseRelationship" superClass="BreakdownElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="WorkProductUseRelationship-_ownedComment.0" annotatedElement="WorkProductUseRelationship">
				<body>A Work Product Use Relationship expresses a general relationship amongst work products.  Kind class instances shall be used to specify the nature of this relationship.&#xD;
The Work Product Use Relationship can be used to express different kinds of relationships amongst Work Products Uses.  Typical Kinds are composition expressing that a work product use instance of an instance is part of another work product instance of an instance. For example, an instance of Actor is part of an instance of Use Case Model.  In contrast to composition another Kind could express aggregation indicating that a Work Product Use is used with another Work Product Use.  For example, a customer design deliverable could be defined as a compilation of different other work product uses that are assemble as a report that is delivered to the customer for review.  A third key Kind is dependency indicating that a work product use impacts another work product use.  For example, if a use case model work product changes the use case realization work product needs to be updated with these changes.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="WorkProductUseRelationship-target" name="target" type="WorkProductUse" upper="*" association="A_workProductUseRelationship_target"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="WorkProductUseRelationship-source" name="source" type="WorkProductUse" association="A_workProductUseRelationship_source"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Enumeration" xmi:id="WorkSequenceKind" name="WorkSequenceKind">
			<ownedComment xmi:type="cmof:Comment" xmi:id="WorkSequenceKind-_ownedComment.0" annotatedElement="WorkSequenceKind">
				<body>Work Sequence represents a relationship between two Work Breakdown Element in which one Work Breakdown Element (referred to as (B) below) depends on the start or finish of another Work Breakdown Element (referred to as (A) below) in order to begin or end. This enumeration defines the different kinds of Work Sequence relationships available in SPEM 2.0 and is used to provide values for Work Sequence's linkKind attribute.</body>
			</ownedComment>
			<ownedLiteral xmi:type="cmof:EnumerationLiteral" xmi:id="WorkSequenceKind-finishToStart" name="finishToStart" enumeration="WorkSequenceKind">
				<ownedComment xmi:type="cmof:Comment" xmi:id="WorkSequenceKind-finishToStart-_ownedComment.0" annotatedElement="WorkSequenceKind-finishToStart">
					<body>Work Breakdown Element (B) cannot start until Work Breakdown Element (A) finishes. For example, if you have two Work Breakdown Elements, &quot;Construct fence&quot; and &quot;Paint fence,&quot; &quot;Paint fence&quot; can't start until &quot;Construct fence&quot; finishes. This is the most common type of dependency and the default for a new Work Sequence instance.
</body>
				</ownedComment>
			</ownedLiteral>
			<ownedLiteral xmi:type="cmof:EnumerationLiteral" xmi:id="WorkSequenceKind-finishToFinish" name="finishToFinish" enumeration="WorkSequenceKind">
				<ownedComment xmi:type="cmof:Comment" xmi:id="WorkSequenceKind-finishToFinish-_ownedComment.0" annotatedElement="WorkSequenceKind-finishToFinish">
					<body>Breakdown Element (B) cannot finish until Work Breakdown Element (A) finishes. For example, if you have two Work Breakdown Elements, &quot;Add wiring&quot; and &quot;Inspect electrical,&quot; &quot;Inspect electrical&quot; can't finish until &quot;Add wiring&quot; finishes.
</body>
				</ownedComment>
			</ownedLiteral>
			<ownedLiteral xmi:type="cmof:EnumerationLiteral" xmi:id="WorkSequenceKind-startToStart" name="startToStart" enumeration="WorkSequenceKind">
				<ownedComment xmi:type="cmof:Comment" xmi:id="WorkSequenceKind-startToStart-_ownedComment.0" annotatedElement="WorkSequenceKind-startToStart">
					<body>Breakdown Element (B) cannot start until Work Breakdown Element (A) starts. For example, if you have two Work Breakdown Elements, &quot;Pour foundation&quot; and &quot;Level concrete,&quot; &quot;Level concrete&quot; can't begin until &quot;Pour foundation&quot; begins.
</body>
				</ownedComment>
			</ownedLiteral>
			<ownedLiteral xmi:type="cmof:EnumerationLiteral" xmi:id="WorkSequenceKind-startToFinish" name="startToFinish" enumeration="WorkSequenceKind">
				<ownedComment xmi:type="cmof:Comment" xmi:id="WorkSequenceKind-startToFinish-_ownedComment.0" annotatedElement="WorkSequenceKind-startToFinish">
					<body>Breakdown Element (B) cannot finish until Work Breakdown Element (A) starts. This dependency type can be used for just-in-time scheduling up to a milestone or the project finish date to minimize the risk of a Work Breakdown Element finishing late if its dependent Work Breakdown Elements slip. If a related Work Breakdown Element needs to finish before the milestone or project finish date, but it doesn't matter exactly when and you don't want a late finish to affect the just-in-time Work Breakdown Element, you can create an SF dependency between the Work Breakdown Element you want scheduled just in time (the predecessor) and its related Work Breakdown Element (the successor). Then if you update progress on the successor Work Breakdown Element, it won't affect the scheduled dates of the predecessor Work Breakdown Element.</body>
				</ownedComment>
			</ownedLiteral>
		</ownedMember>
		<ownedMember xmi:type="cmof:Enumeration" xmi:id="ActivityUseKind" name="ActivityUseKind">
			<ownedComment xmi:type="cmof:Comment" xmi:id="ActivityUseKind-_ownedComment.0" annotatedElement="ActivityUseKind">
				<body>This enumeration defines the nature of the reuse for an Activity that relates to exactly one other Activity via the used Activity association.  Activity Use in SPEM defines the ability to reuse the structures defined for one Activity via its nested Breakdown Element composition in a second Activity without the need to physically copy these structures.  Instead Activity Use defines a way to dynamically inherit these structures from the referenced the activity.  Such reuse is typically established via an Extension relationship and then further refined using additional local Contribution and local Replacement relationships amongst substructure elements of the extending activities.</body>
			</ownedComment>
			<ownedLiteral xmi:type="cmof:EnumerationLiteral" xmi:id="ActivityUseKind-na" name="na" enumeration="ActivityUseKind">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ActivityUseKind-na-_ownedComment.0" annotatedElement="ActivityUseKind-na">
					<body>This is the default value for Activities that do not instantiate the usedActivity association.</body>
				</ownedComment>
			</ownedLiteral>
			<ownedLiteral xmi:type="cmof:EnumerationLiteral" xmi:id="ActivityUseKind-extension" name="extension" enumeration="ActivityUseKind">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ActivityUseKind-extension-_ownedComment.0" annotatedElement="ActivityUseKind-extension">
					<body>Extends provides a mechanism for dynamically reusing Activity substructures (elements contained via the nested Breakdown Element composition) in other Activities. Typical applications of Extension are to represent reusable process patterns as activities, which are then dynamically bound to different activities via the Extension use Kind in a larger process.  An Activity is linked via extension by defining a usedActivity association instance from an Activity within the Processes to the Activity representing the process pattern and setting the useKind attribute to the Extension value.  The source Activity inherits all association instances and sub-structures from the base Activity and the Activity appears to be part of the resulting Process after interpretation of the used Activity association.</body>
				</ownedComment>
			</ownedLiteral>
			<ownedLiteral xmi:type="cmof:EnumerationLiteral" xmi:id="ActivityUseKind-localContribution" name="localContribution" enumeration="ActivityUseKind">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ActivityUseKind-localContribution-_ownedComment.0" annotatedElement="ActivityUseKind-localContribution">
					<body>Local Contribution defines a mechanism for defining specific local additions (or contributions) to breakdown elements inherited via the extension Activity Use Kind within the context of the reusing Activity.  Hence, usedActivity relationships of this kind are used in addition to a usedActivity relationship of the kind Extension.  For example, an Activity could be defined as a child of a second Activity which defines an extension relationship to a third Activity adding additional new sub-elements (such as new sub-Activities) to the set of sub-elements the second Activity inherited from the third Activity via the extension relationship.</body>
				</ownedComment>
			</ownedLiteral>
			<ownedLiteral xmi:type="cmof:EnumerationLiteral" xmi:id="ActivityUseKind-localReplacement" name="localReplacement" enumeration="ActivityUseKind">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ActivityUseKind-localReplacement-_ownedComment.0" annotatedElement="ActivityUseKind-localReplacement">
					<body>Local Replace defines a mechanism for defining local replacements to specific breakdown elements inherited via the Extension Activity Use Kind in the context of the reusing Activity.  UsedActivity relationships of this kind are used in addition to a usedActivity relationship of the kind Extension.  Instances of this type replace inherited Activity sub-elements with their own sub-elements.  For example, an Activity could be defined as a child of a second Activity which defines an extension relationship to a third Activity replacing the inherited sub-elements (such as its sub-Activities), that the second Activity inherited from the third Activity via the extension relationship, with its own set of sub-elements.</body>
				</ownedComment>
			</ownedLiteral>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_activity_nestedBreakdownElement" name="A_activity_nestedBreakdownElement" general="A_ownedMember_namespace" memberEnd="Activity-nestedBreakdownElement A_activity_nestedBreakdownElement-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_activity_nestedBreakdownElement-_ownedComment.0" annotatedElement="A_activity_nestedBreakdownElement">
				<body>This association represents breakdown structure nesting.  It defines an n-level hierarchy of Activities grouping together other Breakdown Elements such as other Activities, Milestones, etc.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_activity_nestedBreakdownElement-_ownedEnd.0" type="Activity" lower="0" owningAssociation="A_activity_nestedBreakdownElement" association="A_activity_nestedBreakdownElement"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_processResponsibilityAssignment_linkedRoleUse" name="A_processResponsibilityAssignment_linkedRoleUse" memberEnd="A_processResponsibilityAssignment_linkedRoleUse-_ownedEnd.0 ProcessResponsibilityAssignment-linkedRoleUse">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_processResponsibilityAssignment_linkedRoleUse-_ownedComment.0" annotatedElement="A_processResponsibilityAssignment_linkedRoleUse">
				<body>A Process Responsibility Assignment links to one or more Role Use.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_processResponsibilityAssignment_linkedRoleUse-_ownedEnd.0" type="ProcessResponsibilityAssignment" upper="*" lower="0" owningAssociation="A_processResponsibilityAssignment_linkedRoleUse" association="A_processResponsibilityAssignment_linkedRoleUse"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_milestone_requiredResults" name="A_milestone_requiredResults" memberEnd="Milestone-requiredResults A_milestone_requiredResults-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_milestone_requiredResults-_ownedComment.0" annotatedElement="A_milestone_requiredResults">
				<body>This association links the Work Product Uses instances to a Milestone instance that need to be produced for that Milestone.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_milestone_requiredResults-_ownedEnd.0" type="Milestone" upper="*" lower="0" owningAssociation="A_milestone_requiredResults" association="A_milestone_requiredResults"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_successor_linkToPredecessor" name="A_successor_linkToPredecessor" memberEnd="WorkSequence-successor WorkBreakdownElement-linkToPredecessor">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_successor_linkToPredecessor-_ownedComment.0" annotatedElement="A_successor_linkToPredecessor">
				<body>This association links a Work Breakdown Element to its predecessor.  Every Work Breakdown Element can have predecessor information associated to it.  This predecessor information is stored in instances of the class Work Sequence, which defines the kind of predecessor another Work Breakdown Element represents for another.</body>
			</ownedComment>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_predecessor_linkToSuccessor" name="A_predecessor_linkToSuccessor" memberEnd="WorkSequence-predecessor WorkBreakdownElement-linkToSuccessor">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_predecessor_linkToSuccessor-_ownedComment.0" annotatedElement="A_predecessor_linkToSuccessor">
				<body>This association links a Work Breakdown Element to its successor.  Every Work Breakdown Element can have successor information associated to it.  This successor information is stored in instances of the class Work Sequence, which defines the kind of successor another Work Breakdown Element represents for another.</body>
			</ownedComment>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_processPerformer_linkedRoleUse" name="A_processPerformer_linkedRoleUse" memberEnd="ProcessPerformer-linkedRoleUse A_processPerformer_linkedRoleUse-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_processPerformer_linkedRoleUse-_ownedComment.0" annotatedElement="A_processPerformer_linkedRoleUse">
				<body>A Process Performer links to one or more Role Use via this association.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_processPerformer_linkedRoleUse-_ownedEnd.0" type="ProcessPerformer" upper="*" lower="0" owningAssociation="A_processPerformer_linkedRoleUse" association="A_processPerformer_linkedRoleUse"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_processParameter_parameterType" name="A_processParameter_parameterType" memberEnd="A_processParameter_parameterType-_ownedEnd.0 ProcessParameter-parameterType">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_processParameter_parameterType-_ownedComment.0" annotatedElement="A_processParameter_parameterType">
				<body>This association links zero or one Work Product Use instances to a parameter.  Processes could leave the type specification open and not specify a concrete Work Product Use.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_processParameter_parameterType-_ownedEnd.0" type="ProcessParameter" owningAssociation="A_processParameter_parameterType" association="A_processParameter_parameterType"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_activity_usedActivity" name="A_activity_usedActivity" memberEnd="Activity-usedActivity A_activity_usedActivity-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_activity_usedActivity-_ownedComment.0" annotatedElement="A_activity_usedActivity">
				<body>This association defines a reuse generalization for Activities according to the semantics defined for Activity Use Kind. Activity instances on the to-many end of the association can reuse properties of the Activity instance on the to-one end (base) of the association.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_activity_usedActivity-_ownedEnd.0" type="Activity" upper="*" lower="0" owningAssociation="A_activity_usedActivity" association="A_activity_usedActivity"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_processResponsibilityAssignment_linkedWorkProductUse" name="A_processResponsibilityAssignment_linkedWorkProductUse" memberEnd="ProcessResponsibilityAssignment-linkedWorkProductUse A_processResponsibilityAssignment_linkedWorkProductUse-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_processResponsibilityAssignment_linkedWorkProductUse-_ownedComment.0" annotatedElement="A_processResponsibilityAssignment_linkedWorkProductUse">
				<body>A Process Responsibility Assignment links to exactly one Work Product Use.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_processResponsibilityAssignment_linkedWorkProductUse-_ownedEnd.0" visibility="private" type="ProcessResponsibilityAssignment" upper="*" lower="0" owningAssociation="A_processResponsibilityAssignment_linkedWorkProductUse" association="A_processResponsibilityAssignment_linkedWorkProductUse"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_workProductUseRelationship_target" name="A_workProductUseRelationship_target" memberEnd="WorkProductUseRelationship-target A_workProductUseRelationship_target-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_workProductUseRelationship_target-_ownedEnd.0" visibility="private" type="WorkProductUseRelationship" upper="*" lower="0" owningAssociation="A_workProductUseRelationship_target" association="A_workProductUseRelationship_target"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_workProductUseRelationship_source" name="A_workProductUseRelationship_source" memberEnd="WorkProductUseRelationship-source A_workProductUseRelationship_source-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_workProductUseRelationship_source-_ownedEnd.0" visibility="private" type="WorkProductUseRelationship" upper="*" lower="0" owningAssociation="A_workProductUseRelationship_source" association="A_workProductUseRelationship_source"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_processPerformer_linkedActivity" name="A_processPerformer_linkedActivity" general="A_workDefinitionPerformer_WorkDefinition" memberEnd="ProcessPerformer-linkedActivity A_processPerformer_linkedActivity-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_processPerformer_linkedActivity-_ownedComment.0" annotatedElement="A_processPerformer_linkedActivity">
				<body>A Process Performer links to zero or one Activity via this association.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_processPerformer_linkedActivity-_ownedEnd.0" type="ProcessPerformer" upper="*" lower="0" redefinedProperty="A_workDefinitionPerformer_WorkDefinition-_ownedEnd.0" owningAssociation="A_processPerformer_linkedActivity" association="A_processPerformer_linkedActivity"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_activity_ownedParameter" name="A_activity_ownedParameter" general="A_workDefinition_ownedParameter" memberEnd="Activity-ownedProcessParameter A_activity_ownedParameter-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_activity_ownedParameter-_ownedComment.0" annotatedElement="A_activity_ownedParameter">
				<body>This composition association manages a list of ordered ProcessParameters for an Activity instance.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_activity_ownedParameter-_ownedEnd.0" type="Activity" redefinedProperty="A_workDefinition_ownedParameter-_ownedEnd.0" owningAssociation="A_activity_ownedParameter" association="A_activity_ownedParameter"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_activity_suppressedBreakdownElement" name="A_activity_suppressedBreakdownElement" memberEnd="Activity-suppressedBreakdownElement A_activity_suppressedBreakdownElement-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_activity_suppressedBreakdownElement-_ownedComment.0" annotatedElement="A_activity_suppressedBreakdownElement">
				<body>The suppressed association allows hiding any Breakdown Element from the interpretation of a process structure.  It is used in combination with the usedActivity association for elements that are inherited by usedActivity.  The reusing activity can define its own local elements that refer to the base activitys element to denote the suppression (see Activity Use for more details).</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_activity_suppressedBreakdownElement-_ownedEnd.0" visibility="private" type="Activity" lower="0" owningAssociation="A_activity_suppressedBreakdownElement" association="A_activity_suppressedBreakdownElement"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="ContentDescription" name="ContentDescription" superClass="Class">
			<ownedComment xmi:type="cmof:Comment" xmi:id="ContentDescription-_ownedComment.0" annotatedElement="ContentDescription">
				<body>Content Description is a Class that is used to store the textual description for a Describable Element.  It defines standard attributes applicable for all Describable Element subtypes.&#xD;
Implementers of this specification can subclass Content Description to define their own matching Content Description subtypes that add user-defined description attributes to all instances of a specific Describable Elements Content Description.  Additionally, user-defined attributes can be added to individual Content Description instances when the SPEM 2.0 meta-model is instantiated creating UML 2.0 attributes for the Content Description class accessible via the ownedAttribute inherited from Class.  Content Descriptions are typically localized using a resource allocation mechanism for its String type attributes.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="ContentDescription-presentationName" name="presentationName" type="String">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ContentDescription-presentationName-_ownedComment.0" annotatedElement="ContentDescription-presentationName">
					<body>Every Describable Element described by a Content Description has a name (inherited from Named Element in UML 2.0 Infrastructure), which is used for internal references of the element.  In addition to name every Describable Element can maintain a presentation name as part of the Content Description, which is the externally visible/published name of the element, which might be localized.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="ContentDescription-briefDescription" name="briefDescription" type="String">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ContentDescription-briefDescription-_ownedComment.0" annotatedElement="ContentDescription-briefDescription">
					<body>Every Describable Element shall be briefly described with one or two sentences summarizing the element.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="ContentDescription-mainDescription" name="mainDescription" type="String">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ContentDescription-mainDescription-_ownedComment.0" annotatedElement="ContentDescription-mainDescription">
					<body>This attribute stores the main descriptive text for the Describable Element.  All text that is not part of any of the more specific attributes shall be stored here.  If the description is divided into sections using the Section class, then only the text from the head of the content description to the first section will be stored here (similar to a normal document where you can place text between its beginning and its first section heading).</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="ContentDescription-purpose" name="purpose" type="String">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ContentDescription-purpose-_ownedComment.0" annotatedElement="ContentDescription-purpose">
					<body>This attribute summarizes the main reason or rationale for having or performing this Describable Element as part of a Process or Method. It describes what is intended to be achieved with it and why the Process Practitioner should include it.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="ContentDescription-section" name="section" type="Section" isOrdered="true" upper="*" lower="0" isComposite="true" subsettedProperty="Namespace-ownedMember" association="A_contentDescription_section">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ContentDescription-section-_ownedComment.0" annotatedElement="ContentDescription-section">
					<body>A Content Description can optionally be structured into Sections.  This association is use to decompose the mainDescription attribute into a hierarchy of Sections.  Text stored in mainDescription when Sections are defined represents text presented before the first Section.</body>
				</ownedComment>
			</ownedAttribute>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="DescribableElement" name="DescribableElement" isAbstract="true" superClass="ExtensibleElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="DescribableElement-_ownedComment.0" annotatedElement="DescribableElement">
				<body>Describable Element is a Extensible Element that represents an abstract generalization for all elements in SPEM 2.0 that can be documented with textual descriptions.  Examples for Describable Elements are Roles or Work Products, which have descriptive text associated that textually define the element as well as providing guidance on how to use it.&#xD;
Describable Element is the superclass for elements in Process Structure as well as Method Content for which concrete textual descriptions are being defined in the form of documenting attributes grouped in a matching Content Description instance.  Describable Elements are intended to be published in method or process publications.  Describable Element defines that the element it represents will have content attached to it.  Content Description is the abstraction for the actual places in which the content is being represented.  This separation allows a distinction between core model elements describing the structure of the model from the actual description container providing, for example, the documentation of the Describable Element in different alternatives languages, audiences, licensing levels, etc.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="DescribableElement-guidance" name="guidance" type="Guidance" upper="*" lower="0" association="A_describableElement_guidance"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="DescribableElement-description" name="description" type="ContentDescription" lower="0" isComposite="true" subsettedProperty="Namespace-ownedMember" association="A_describableElement_description"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="DescribableElement-metric" name="metric" type="Metric" upper="*" lower="0" association="A_describableElement_metric"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="Metric" name="Metric" superClass="DescribableElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Metric-_ownedComment.0" annotatedElement="Metric">
				<body>A Metric is special Guidance that contains one or more constraints that provide measurements for any Describable Element. Because Metric is Guidance, different Kinds (Section 8.2) can be defined for Metrics to distinguish different groups of Metrics such as Productivity, Quality, or Scale.&#xD;
A Metric defines a standard measurement for instances of a Describable Element in SPEM 2.0.  For example, a process engineer can define Metrics for Work Definitions such as Activities (estimated effort in man hours), Metrics for Work Products (quality averages such as error per klocs), or Metrics for Roles (costs per hour; cost per delivered results). A Metric is documented with Content Descriptions associated to the Metric as well as formalized using instances of the UML 2.0 Constraint class. Metrics can be qualified with Kinds.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Metric-expression" name="expression" type="ValueSpecification" upper="*" isComposite="true" subsettedProperty="Namespace-ownedMember" association="A_metric_expression">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Metric-expression-_ownedComment.0" annotatedElement="Metric-expression">
					<body>A Metric defines one or more Constraints.  The property subsets the inherited ownedRule property from UML 2.0 Infrastructures Namespace.</body>
				</ownedComment>
			</ownedAttribute>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_category_subCategory" name="A_category_subCategory" memberEnd="A_category_subCategory-_ownedEnd.0 Category-subCategory">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_category_subCategory-_ownedComment.0" annotatedElement="A_category_subCategory">
				<body>A Category can have any number of Categories defined as sub-categories.  Therefore, one could define Categories as n-level hierarchies.  This relationship does not define a strict nesting, i.e. a Category can be a subcategory of many other Categories.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_category_subCategory-_ownedEnd.0" type="Category" upper="*" lower="0" owningAssociation="A_category_subCategory" association="A_category_subCategory"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_describableElement_guidance" name="A_describableElement_guidance" memberEnd="A_describableElement_guidance-_ownedEnd.0 DescribableElement-guidance">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_describableElement_guidance-_ownedComment.0" annotatedElement="A_describableElement_guidance">
				<body>A Describable Element can be related to many Guidance elements.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_describableElement_guidance-_ownedEnd.0" type="DescribableElement" upper="*" lower="0" owningAssociation="A_describableElement_guidance" association="A_describableElement_guidance"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_describableElement_description" name="A_describableElement_description" general="A_ownedMember_namespace" memberEnd="A_describableElement_description-_ownedEnd.0 DescribableElement-description">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_describableElement_description-_ownedComment.0" annotatedElement="A_describableElement_description">
				<body>A Describable Element can contain one Content Description element that stores textual descriptions for this Describable Element.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_describableElement_description-_ownedEnd.0" type="DescribableElement" owningAssociation="A_describableElement_description" association="A_describableElement_description"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_category_categorizedElement" name="A_category_categorizedElement" memberEnd="Category-categorizedElement A_category_categorizedElement-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_category_categorizedElement-_ownedComment.0" annotatedElement="A_category_categorizedElement">
				<body>A Category groups together any number of Describable Elements (including other Categories).</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_category_categorizedElement-_ownedEnd.0" type="Category" upper="*" lower="0" owningAssociation="A_category_categorizedElement" association="A_category_categorizedElement"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_contentDescription_section" name="A_contentDescription_section" general="A_ownedMember_namespace" memberEnd="A_contentDescription_section-_ownedEnd.0 ContentDescription-section">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_contentDescription_section-_ownedComment.0" annotatedElement="A_contentDescription_section">
				<body>A Content Description can optionally be structured into Sections.  This association is use to decompose the mainDescription attribute into a hierarchy of Sections.  Text stored in mainDescription when Sections are defined represents text presented before the first Section.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_contentDescription_section-_ownedEnd.0" type="ContentDescription" owningAssociation="A_contentDescription_section" association="A_contentDescription_section"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_section_subSection" name="A_section_subSection" general="A_ownedMember_namespace" memberEnd="Section-subSection A_section_subSection-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_section_subSection-_ownedComment.0" annotatedElement="A_section_subSection">
				<body>Sections can be further decomposed into n levels of sub-sections.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_section_subSection-_ownedEnd.0" type="Section" owningAssociation="A_section_subSection" association="A_section_subSection"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_metric_expression" name="A_metric_expression" general="A_ownedMember_namespace" memberEnd="Metric-expression A_metric_expression-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_metric_expression-_ownedComment.0" annotatedElement="A_metric_expression">
				<body>A Metric defines one or more Constraints.  The property subsets the inherited ownedRule property from UML 2.0 Infrastructures Namespace.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_metric_expression-_ownedEnd.0" type="Metric" lower="0" owningAssociation="A_metric_expression" association="A_metric_expression"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_describableElement_metric" name="A_describableElement_metric" memberEnd="DescribableElement-metric A_describableElement_metric-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_describableElement_metric-_ownedEnd.0" type="DescribableElement" upper="*" lower="0" owningAssociation="A_describableElement_metric" association="A_describableElement_metric"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="Default_TaskDefinitionParameter" name="Default_TaskDefinitionParameter" superClass="WorkDefinitionParameter MethodContentElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Default_TaskDefinitionParameter-_ownedComment.0" annotatedElement="Default_TaskDefinitionParameter">
				<body>A Task Definition Parameter is a special Work Definition Parameter that uses Work Product Definitions as well as adds an Optionalilty attribute.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Default_TaskDefinitionParameter-optionality" name="optionality" type="OptionalityKind">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Default_TaskDefinitionParameter-optionality-_ownedComment.0" annotatedElement="Default_TaskDefinitionParameter-optionality">
					<body>This attribute represents if the input or output parameter is optional, i.e. mandatory to provide to the Task Definition or to be produced by the Task Definition respectively.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Default_TaskDefinitionParameter-paramterType" name="paramterType" type="WorkProductDefinition" lower="0" association="A_taskDefinitionParameter_paramterType">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Default_TaskDefinitionParameter-paramterType-_ownedComment.0" annotatedElement="Default_TaskDefinitionParameter-paramterType">
					<body>This association links zero or one Work Product Definitions instances to a parameter.  Task Definitions can leave the type specification open and not specify a concrete Work Product Definition at all.</body>
				</ownedComment>
			</ownedAttribute>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="Step" name="Step" superClass="Section WorkDefinition">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Step-_ownedComment.0" annotatedElement="Step">
				<body>A Step is a Section and Work Definition that is used to organize a Task Definitions Content Description into parts or subunits of work.  Steps inherit the subSection decomposition from Section and can therefore describe sub-Steps nested into Steps.&#xD;
A Step describes a meaningful and consistent part of the overall work described for a Task Definition.  The collection of Steps defined for a Task Definition represents all the work that should be done to achieve the overall development goal of the Task Definition.  Not all steps are necessarily performed each time a Task is invoked in a Process (see Task Use defined Section 13.6), so they can also be expressed in the form of alternate flows of work.  Different ways of achieving the same development goal can then be assembled by selecting different combinations of steps when applying the Task Definition in a Process.  Typical kinds of steps a Task Definition author should consider are: Thinking steps: where the individual roles understand the nature of the task, gathers and examines the input artifacts, and formulates the outcome. Performing steps: where the individual roles create or update some artifacts. Reviewing steps: where the individual roles inspects the results against some criteria.</body>
			</ownedComment>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="TaskDefinition" name="TaskDefinition" superClass="MethodContentElement WorkDefinition">
			<ownedComment xmi:type="cmof:Comment" xmi:id="TaskDefinition-_ownedComment.0" annotatedElement="TaskDefinition">
				<body>A Task Definition is a Method Content Element and a Work Definition that defines work being performed by Roles Definition instances.  A Task is associated to input and output Work Products.  Inputs are differentiated in mandatory versus optional inputs.  The relationships to Work Products via Work Definition Parameters are not instantiatable/variable-like parameters.  They rather express (hyper-)links to the descriptions of the work products types that are related to the Task as inputs and outputs.  In other words, these associations are not intended to be used to capture which concrete instances will be passed when instantiating the method in a project.  All of the Task Definitions default associations and Parameters can be overridden in an actual process definition.&#xD;
A Task Definition describes an assignable unit of work.  Every Task Definition is assigned to specific Role Definitions.  The granularity of a Task Definition is generally a few hours to a few days.  It usually affects one or only a small number of work products. A Task Definition is used as an element of defining a process. Tasks Definition are further used for planning and tracking progress; therefore, if they are defined too fine-grained, they will be neglected, and if they are too large, progress would have to be expressed in terms of a Task Definitions parts (e.g. Steps, which is not recommended).&#xD;
A Task Definition has a clear purpose in which the performing roles achieve a well defined goal.  It provides complete step-by-step explanations of doing all the work that needs to be done to achieve this goal.  This description is complete, independent of when in a process lifecycle the work would actually be done.  It therefore does not describe when you do what work at what point of time, but describes all the work that gets done throughout the development lifecycle that contributes to the achievement of this goal.  When the Task Definition instance is being applied in a process then this process application (defined as Task Use) provides the information of which pieces of the Task Definition will actually be performed at any particular point in time. This assumes that the Task Definition will be performed in the process over and over again, but each time with a slightly different emphasis on different steps or aspects of the task description. &#xD;
For example, a Task Definition such as Develop Use Case Model describes all the work that needs to be done to develop a complete use case model. This would comprise of the identification and naming of use cases and actors, the writing of a brief description, the modeling of use cases and their relationships in diagrams, the detailed description of a basic flow, the detailed description of alternatives flows, performing of walkthroughs workshops and reviews, etc.  All of these parts contribute to the development goal of developing the use case model, but the parts will be performed at different points in time in a process.  Identification, naming, and brief descriptions would be performed early in a typical development process versus the writing of detailed alternative flows which would be performed much later.  All these parts or steps within the same Task define the method of Developing a Use Case Model.  Applying such a method in a lifecycle (i.e. in a process) is defining which steps are done when going from one iteration to the next.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="TaskDefinition-step" name="step" type="Step" isOrdered="true" upper="*" lower="0" isDerived="true" isComposite="true" subsettedProperty="Namespace-ownedMember" association="A_taskDefinition_step">
				<ownedComment xmi:type="cmof:Comment" xmi:id="TaskDefinition-step-_ownedComment.0" annotatedElement="TaskDefinition-step">
					<body>This derived association is a shortcut for navigation along the association properties self.description.section.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="TaskDefinition-usedTool" name="usedTool" type="ToolDefinition" upper="*" lower="0" association="A_taskDefinition_usedTool">
				<ownedComment xmi:type="cmof:Comment" xmi:id="TaskDefinition-usedTool-_ownedComment.0" annotatedElement="TaskDefinition-usedTool">
					<body>A Task Definition can recommend a specific set of tools to be used to support the Task.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="TaskDefinition-ownedTaskDefinitionParameter" name="ownedTaskDefinitionParameter" type="Default_TaskDefinitionParameter" isOrdered="true" upper="*" lower="0" isComposite="true" subsettedProperty="WorkDefinition-ownedParameter" association="A_taskDefinition_ownedTaskDefinitionParameter"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="TaskDefinition-requiredQualification" name="requiredQualification" visibility="public" type="Qualification" upper="*" lower="0" association="A_taskDefinition_requiredQualification"/>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="TaskDefinition-step.1" name="step" class="TaskDefinition" isQuery="true" bodyCondition="TaskDefinition-step.1-_ownedRule.0">
				<ownedRule xmi:type="cmof:Constraint" xmi:id="TaskDefinition-step.1-_ownedRule.0" constrainedElement="TaskDefinition-step.1" namespace="TaskDefinition-step.1">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="TaskDefinition-step.1-_ownedRule.0-_specification">
						<language>OCL</language>
						<body>result = self.description.section</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="TaskDefinition-step.1-_ownedParameter.0" type="Step" direction="return"/>
			</ownedOperation>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="ToolDefinition" name="ToolDefinition" superClass="MethodContentElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="ToolDefinition-_ownedComment.0" annotatedElement="ToolDefinition">
				<body>A Tool Definition is a special Method Content Element that can be used to specify a tool's participation in a Task Definition.&#xD;
A Tool Definition describes the capabilities of a CASE tool, general purpose tool, or any other automation unit that supports the associated instances of Role Definitions in performing the work defined by a Task Definition.  A Tool Definition can represent a resource useful, recommended, or necessary for a tasks completion.  The Task Definition can refer to the associated list of Tool Definitions to clarify their role. </body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="ToolDefinition-managedWorkProduct" name="managedWorkProduct" type="WorkProductDefinition" upper="*" lower="0" association="A_toolDefinition_managedWorkProduct"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="WorkProductDefinitionRelationship" name="WorkProductDefinitionRelationship" superClass="MethodContentElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="WorkProductDefinitionRelationship-_ownedComment.0" annotatedElement="WorkProductDefinitionRelationship">
				<body>A Work Product Definition Relationship expresses a general relationship amongst Work Products Definitions.  Kind class instances shall be used to specify the nature of this relationship.&#xD;
The Work Product Definition Relationship can be used to express different kinds of relationships amongst Work Product Definition.  Typical Kinds are composition expressing that a Work Product Definition instance of an instance is part of another Work Product Definition instance of an instance. For example, an instance of Actor is part of an instance of Use Case Model.  In contrast to composition another Kind could express aggregation indicating that a Work Product Definition is used with another Work Product Definition.  For example, a customer design deliverable could be defined as a compilation of different other work product uses that are assemble as a report that is delivered to the customer for review.  A third key Kind is dependency indicating that a Work Product Definition impacts another Work Product Definition.  For example, if a use case model Work Product Definition changes the use case realization Work Product Definition needs to be updated with these changes.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="WorkProductDefinitionRelationship-source" name="source" type="WorkProductDefinition" association="A_workProductDefinitionRealtionship_source">
				<ownedComment xmi:type="cmof:Comment" xmi:id="WorkProductDefinitionRelationship-source-_ownedComment.0" annotatedElement="WorkProductDefinitionRelationship-source">
					<body>This association links to the exact one source of the Work Product Definition Relationship.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="WorkProductDefinitionRelationship-target" name="target" type="WorkProductDefinition" upper="*" association="A_workProductDefinitionRelationship_target">
				<ownedComment xmi:type="cmof:Comment" xmi:id="WorkProductDefinitionRelationship-target-_ownedComment.0" annotatedElement="WorkProductDefinitionRelationship-target">
					<body>This association links to one or more targets of the Work Product Definition Relationship.</body>
				</ownedComment>
			</ownedAttribute>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="Guidance" name="Guidance" superClass="MethodContentElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Guidance-_ownedComment.0" annotatedElement="Guidance">
				<body>Guidance is a Describable Element that provides additional information related to Describable Elements.  The particular Guidance should be classified with Kinds (Section 8.2) that indicates a specific type of guidance for which perhaps a specific structure and type of content is assumed.  Examples for Kinds for Guidance are Guidelines, Templates, Checklists, Tool Mentors, Estimates, Supporting Materials, Reports, Concepts, etc.</body>
			</ownedComment>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="Category" name="Category" superClass="MethodContentElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Category-_ownedComment.0" annotatedElement="Category">
				<body>A Category is a Describable Element used to categorize, i.e. group any number of Describable Elements of any subtype based on user-defined criteria.  Because Categories are Describable Elements themselves they can be used to recursively categorize other Category instances as well.  Categories can also be nested using the subCategory association.&#xD;
Categories can be used to categorize content based on the user's criteria as well as to define whole tree-structures of nested categories allowing the user to systematically navigate and browse method content and processes based on these categories.  For example, one could create a Category to logically organize content relevant for the user's development organization departments; e.g. a &quot;Testing&quot; category that groups together all Roles, Work Products, Tasks, and Guidance elements relevant to testing.  Another example would be Categories that express licensing levels of the content, grouping freely distributable method content versus content that represents intellectual property and requires a purchased license for use.  Whereas Kinds are limited to one Kind instance per meta-model instance and stored as properties of the Extensible Element, Categories store the relationships to Describable Elements.  Describable Elements can be categorized by as many Categories as needed.  Categories can categorize Categories as well as well as can be hierarchical.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Category-subCategory" name="subCategory" type="Category" upper="*" lower="0" association="A_category_subCategory"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Category-categorizedElement" name="categorizedElement" type="DescribableElement" upper="*" lower="0" association="A_category_categorizedElement"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="Default_TaskDefinitionPerformer" name="Default_TaskDefinitionPerformer" superClass="WorkDefinitionPerformer MethodContentElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Default_TaskDefinitionPerformer-_ownedComment.0" annotatedElement="Default_TaskDefinitionPerformer">
				<body>A Default Task Definition Performer is a Work Definition Performer that represents a relationship between Task Definition instances and Role Definition instances. An instance of Default Task Definition Performer links one or more Role Definition instances to one Task Definition instance.&#xD;
The Default Task Definition Performer links Role Definition to Task Definitions indicating that these Role Definition instances participate in the work defined by the Task Definition in one or another way.  The kind of involvement of the Role Definition in the Task Definition needs to be defined by Kind class instances that qualify the Default Task Definition Performer instances.  Typical examples for Kinds of Default Task Definition Performers would be Primary Performer, Additional Performer, Assisting Performer, Supervising Performer, Consulted Performer, etc.  The popular RACI-VS diagram defines another set of commonly used Kinds for the Default Task Definition Performer: Responsible, Accountable, Consulted, Informed, Verifies and Signs.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Default_TaskDefinitionPerformer-linkedRoleDefinition" name="linkedRoleDefinition" type="RoleDefinition" upper="*" association="A_taskDefinitionPerformer_linkedRoleDefinition"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Default_TaskDefinitionPerformer-linkedTaskDefinition" name="linkedTaskDefinition" type="TaskDefinition" subsettedProperty="WorkDefinitionPerformer-linkedWorkDefinition" association="A_taskDefinitionPerformer_linkedTaskDefinition"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="Qualification" name="Qualification">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Qualification-_ownedComment.0" annotatedElement="Qualification">
				<body>Qualification is a Method Content Element that documents zero or more required qualifications, skills, or competencies for Role Definitions.  In addition to informally describing the qualification using its Content Element documentation properties, Qualification can be further categorized by defining specific Kinds.&#xD;
A Qualification documents one specific skill or competency that is used to model and represent the qualifications provided by instances of a Role Definition and/or the qualifications required for the performance of a Task.  These qualifications can be used to find and map roles for tasks when assembling method content and assigning organization specific roles to these tasks dynamically.  Qualifications can also be used to find individuals (i.e. people) as instances of the Role Definition instances.  For example, Qualifications of the Kind &quot;Soft Skills&quot; associated to the &quot;System Analyst&quot; Role Definition could be &quot;captures stakeholder needs&quot;, &quot;selects elicitation techniques&quot;, &quot;adapts elicitation techniques&quot;, &quot;negotiates scope&quot;, etc.   &#xD;
A Role Use can select a sub-set of valid Qualifications for the use of the Role Definitions in the context of a particular Activity.  One can then express that for the Role Use within a particular Activity only the selects elicitation techniques Qualification of the System Analyst Role Definition is required.</body>
			</ownedComment>
		</ownedMember>
		<ownedMember xmi:type="cmof:Enumeration" xmi:id="OptionalityKind" name="OptionalityKind">
			<ownedComment xmi:type="cmof:Comment" xmi:id="OptionalityKind-_ownedComment.0" annotatedElement="OptionalityKind">
				<body>This enumeration provides the values for the Task Definition Parameter attribute optionality.</body>
			</ownedComment>
			<ownedLiteral xmi:type="cmof:EnumerationLiteral" xmi:id="OptionalityKind-mandatory" name="mandatory" enumeration="OptionalityKind">
				<ownedComment xmi:type="cmof:Comment" xmi:id="OptionalityKind-mandatory-_ownedComment.0" annotatedElement="OptionalityKind-mandatory">
					<body>It is mandatory to provide the Work Product Definition specified in this parameter as input or to provide an instance of the Work Product Definition as output respectively.</body>
				</ownedComment>
			</ownedLiteral>
			<ownedLiteral xmi:type="cmof:EnumerationLiteral" xmi:id="OptionalityKind-optional" name="optional" enumeration="OptionalityKind">
				<ownedComment xmi:type="cmof:Comment" xmi:id="OptionalityKind-optional-_ownedComment.0" annotatedElement="OptionalityKind-optional">
					<body>It is optional to provide the Work Product Definition specified in this parameter as input or to provide an instance of the Work Product Definition as output respectively.</body>
				</ownedComment>
			</ownedLiteral>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_taskDefinitionParameter_paramterType" name="A_taskDefinitionParameter_paramterType" memberEnd="Default_TaskDefinitionParameter-paramterType A_taskDefinitionParameter_paramterType-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_taskDefinitionParameter_paramterType-_ownedComment.0" annotatedElement="A_taskDefinitionParameter_paramterType">
				<body>This association links zero or one Work Product Definitions instances to a parameter.  Task Definitions can leave the type specification open and not specify a concrete Work Product Definition at all.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_taskDefinitionParameter_paramterType-_ownedEnd.0" type="Default_TaskDefinitionParameter" owningAssociation="A_taskDefinitionParameter_paramterType" association="A_taskDefinitionParameter_paramterType"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_taskDefinition_step" name="A_taskDefinition_step" general="A_ownedMember_namespace" memberEnd="TaskDefinition-step A_taskDefinition_step-_ownedEnd.0" isDerived="true">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_taskDefinition_step-_ownedComment.0" annotatedElement="A_taskDefinition_step">
				<body>This derived association is a shortcut for navigation along the association properties self.description.section.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_taskDefinition_step-_ownedEnd.0" type="TaskDefinition" owningAssociation="A_taskDefinition_step" association="A_taskDefinition_step"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_taskDefinition_usedTool" name="A_taskDefinition_usedTool" memberEnd="TaskDefinition-usedTool A_taskDefinition_usedTool-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_taskDefinition_usedTool-_ownedComment.0" annotatedElement="A_taskDefinition_usedTool">
				<body>A Task Definition can recommend a specific set of tools to be used to support the Task.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_taskDefinition_usedTool-_ownedEnd.0" type="TaskDefinition" upper="*" lower="0" owningAssociation="A_taskDefinition_usedTool" association="A_taskDefinition_usedTool"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_toolDefinition_managedWorkProduct" name="A_toolDefinition_managedWorkProduct" memberEnd="ToolDefinition-managedWorkProduct A_toolDefinition_managedWorkProduct-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_toolDefinition_managedWorkProduct-_ownedComment.0" annotatedElement="A_toolDefinition_managedWorkProduct">
				<body>A Tool can manage instances of one or more Work Product Definitions. For example a Tool can be modeled that specializes in managing Use Case Models or another Tool that manages Analysis and Design Models.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_toolDefinition_managedWorkProduct-_ownedEnd.0" type="ToolDefinition" upper="*" lower="0" owningAssociation="A_toolDefinition_managedWorkProduct" association="A_toolDefinition_managedWorkProduct"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_workProductDefinitionRealtionship_source" name="A_workProductDefinitionRealtionship_source" memberEnd="WorkProductDefinitionRelationship-source A_workProductDefinitionRealtionship_source-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_workProductDefinitionRealtionship_source-_ownedComment.0" annotatedElement="A_workProductDefinitionRealtionship_source">
				<body>This association links to the exact one source of the Work Product Definition Relationship.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_workProductDefinitionRealtionship_source-_ownedEnd.0" type="WorkProductDefinitionRelationship" upper="*" lower="0" owningAssociation="A_workProductDefinitionRealtionship_source" association="A_workProductDefinitionRealtionship_source"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_workProductDefinitionRelationship_target" name="A_workProductDefinitionRelationship_target" memberEnd="WorkProductDefinitionRelationship-target A_workProductDefinitionRelationship_target-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_workProductDefinitionRelationship_target-_ownedComment.0" annotatedElement="A_workProductDefinitionRelationship_target">
				<body>This association links to one or more targets of the Work Product Definition Relationship.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_workProductDefinitionRelationship_target-_ownedEnd.0" type="WorkProductDefinitionRelationship" upper="*" lower="0" owningAssociation="A_workProductDefinitionRelationship_target" association="A_workProductDefinitionRelationship_target"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_taskDefinition_ownedTaskDefinitionParameter" name="A_taskDefinition_ownedTaskDefinitionParameter" general="A_workDefinition_ownedParameter" memberEnd="TaskDefinition-ownedTaskDefinitionParameter A_taskDefinition_ownedTaskDefinitionParameter-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_taskDefinition_ownedTaskDefinitionParameter-_ownedComment.0" annotatedElement="A_taskDefinition_ownedTaskDefinitionParameter">
				<body>This ordered association subsets ownedParamter from Work Definition.  Tasks Definitions manage Task Definition Parameter instances which are subclasses of the Work Definition Parameters adding the optionality property of a parameter.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_taskDefinition_ownedTaskDefinitionParameter-_ownedEnd.0" type="TaskDefinition" redefinedProperty="A_workDefinition_ownedParameter-_ownedEnd.0" owningAssociation="A_taskDefinition_ownedTaskDefinitionParameter" association="A_taskDefinition_ownedTaskDefinitionParameter"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_taskDefinitionPerformer_linkedRoleDefinition" name="A_taskDefinitionPerformer_linkedRoleDefinition" memberEnd="Default_TaskDefinitionPerformer-linkedRoleDefinition A_taskDefinitionPerformer_linkedRoleDefinition-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_taskDefinitionPerformer_linkedRoleDefinition-_ownedComment.0" annotatedElement="A_taskDefinitionPerformer_linkedRoleDefinition">
				<body>A Default Task Definition Performer links to one or more Role Definition.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_taskDefinitionPerformer_linkedRoleDefinition-_ownedEnd.0" type="Default_TaskDefinitionPerformer" upper="*" lower="0" owningAssociation="A_taskDefinitionPerformer_linkedRoleDefinition" association="A_taskDefinitionPerformer_linkedRoleDefinition"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_taskDefinitionPerformer_linkedTaskDefinition" name="A_taskDefinitionPerformer_linkedTaskDefinition" general="A_workDefinitionPerformer_WorkDefinition" memberEnd="Default_TaskDefinitionPerformer-linkedTaskDefinition A_taskDefinitionPerformer_linkedTaskDefinition-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_taskDefinitionPerformer_linkedTaskDefinition-_ownedComment.0" annotatedElement="A_taskDefinitionPerformer_linkedTaskDefinition">
				<body>A Default Task Definition Performer links to exactly one Task Definition.  The linked Task Definition property subsets the linkedWorkDefinition property from the Work Definition Performer defined in Core.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_taskDefinitionPerformer_linkedTaskDefinition-_ownedEnd.0" type="Default_TaskDefinitionPerformer" upper="*" lower="0" redefinedProperty="A_workDefinitionPerformer_WorkDefinition-_ownedEnd.0" owningAssociation="A_taskDefinitionPerformer_linkedTaskDefinition" association="A_taskDefinitionPerformer_linkedTaskDefinition"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_responsibilityAssignment_linkedRoleDefinition" name="A_responsibilityAssignment_linkedRoleDefinition" memberEnd="Default_ResponsibilityAssignment-linkedRoleDefinition A_responsibilityAssignment_linkedRoleDefinition-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_responsibilityAssignment_linkedRoleDefinition-_ownedComment.0" annotatedElement="A_responsibilityAssignment_linkedRoleDefinition">
				<body>A Process Responsibility Assignment links to one or more Role Definition.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_responsibilityAssignment_linkedRoleDefinition-_ownedEnd.0" type="Default_ResponsibilityAssignment" upper="*" lower="0" owningAssociation="A_responsibilityAssignment_linkedRoleDefinition" association="A_responsibilityAssignment_linkedRoleDefinition"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_responsibilityAssignment_linkedWorkProductDefinition" name="A_responsibilityAssignment_linkedWorkProductDefinition" memberEnd="Default_ResponsibilityAssignment-linkedWorkproductDefinition A_responsibilityAssignment_linkedWorkProductDefinition-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_responsibilityAssignment_linkedWorkProductDefinition-_ownedComment.0" annotatedElement="A_responsibilityAssignment_linkedWorkProductDefinition">
				<body>A Process Responsibility Assignment links to exactly one Work Product Definition.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_responsibilityAssignment_linkedWorkProductDefinition-_ownedEnd.0" type="Default_ResponsibilityAssignment" upper="*" lower="0" owningAssociation="A_responsibilityAssignment_linkedWorkProductDefinition" association="A_responsibilityAssignment_linkedWorkProductDefinition"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_roleDefinition_providedQualification" name="A_roleDefinition_providedQualification" memberEnd="RoleDefinition-providedQualification A_roleDefinition_providedQualification-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_roleDefinition_providedQualification-_ownedComment.0" annotatedElement="A_roleDefinition_providedQualification">
				<body>Provides a list of qualifications that the role typically provides.  This list can be mapped against the required qualifications list defined for Task Definitions. The qualifications need to be present by individual that are represented as instances of instances of the Role Definitions.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_roleDefinition_providedQualification-_ownedEnd.0" visibility="private" type="RoleDefinition" upper="*" lower="0" owningAssociation="A_roleDefinition_providedQualification" association="A_roleDefinition_providedQualification"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_taskDefinition_requiredQualification" name="A_taskDefinition_requiredQualification" memberEnd="TaskDefinition-requiredQualification A_taskDefinition_requiredQualification-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_taskDefinition_requiredQualification-_ownedComment.0" annotatedElement="A_taskDefinition_requiredQualification">
				<body>Provides a list of qualifications that the task typically requires to be performed by one or more roles.  This list can be mapped against the provided qualifications list defined for Role Definitions.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_taskDefinition_requiredQualification-_ownedEnd.0" name="" visibility="private" type="TaskDefinition" upper="*" lower="0" owningAssociation="A_taskDefinition_requiredQualification" association="A_taskDefinition_requiredQualification"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="ProcessKind" name="ProcessKind" superClass="Kind ProcessElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="ProcessKind-_ownedComment.0" annotatedElement="ProcessKind">
				<body>Process Kind is a Kind and Process Element that represent a process specific refinement of the Kind class defined in Core.  Only Process Elements can be used for Process Kinds.  It can be packaged in Process Packages.</body>
			</ownedComment>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="MethodContentKind" name="MethodContentKind" superClass="MethodContentElement Kind">
			<ownedComment xmi:type="cmof:Comment" xmi:id="MethodContentKind-_ownedComment.0" annotatedElement="MethodContentKind">
				<body>Method Content Kind is a Kind and Method Content Element that represent a method content specific refinement of the Kind class defined in Core.  Only Method Content Elements can be used for Method Content Kinds.  It can be packaged in Method Content Packages.</body>
			</ownedComment>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="MethodContentPackage" name="MethodContentPackage" superClass="Package MethodContentPackageableElement MethodPluginPackageableElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="MethodContentPackage-_ownedComment.0" annotatedElement="MethodContentPackage">
				<body>A Method Content Package is a Method Content Packageable Element and Package that contains Method Content Elements only.  Examples for Method Content Element are Work Product Definition, Task Definition, Role Definition, etc.&#xD;
A key separation of concerns in SPEM 2.0 is the distinction between Method Content and Process.  This separation is enforced by special package types, which do not allow the mixing of method content with processes.  Method Content Elements are organized in Method Content Packages to structure large scales of method content as well as to define a mechanism for reuse.  Method Content Elements from one package can reuse element from other packages by defining an imports dependency (defined in the UML 2 Infrastructure) between them.  For example, a Work Product Definition defined in one package can be used as an input for Task Definitions defined in other packages.  By reusing it from one common place (i.e. the package in which it has been defined) ensures that no redundant definitions of the same elements are required.  Also maintenance of method content is greatly improved as changes can be performed in only one place.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="MethodContentPackage-ownedMethodContentMember" name="ownedMethodContentMember" type="MethodContentPackageableElement" upper="*" lower="0" isComposite="true" redefinedProperty="Package-packagedElement" association="A_owningMethodContentPackage_ownedMethodContentMember"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="MethodContentPackageableElement" name="MethodContentPackageableElement" isAbstract="true" superClass="PackageableElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="MethodContentPackageableElement-_ownedComment.0" annotatedElement="MethodContentPackageableElement">
				<body>Method Content Packageable Element is an abstract generalization for Method Content Package and Method Content Element supporting the redefinition of the packagedElement association of Method Content Package inherited from the UML 2 class.</body>
			</ownedComment>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="ProcessPackage" name="ProcessPackage" superClass="Package ProcessPackageableElement MethodPluginPackageableElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="ProcessPackage-_ownedComment.0" annotatedElement="ProcessPackage">
				<body>Process Package is a special Package that can only contain Process Elements and UML 2 Diagram Interchange Diagrams.  It redefines the packagedElement and ownedMembers association to only allow elements of these two types.&#xD;
A process package can only contain Process Elements and Diagrams.  A key separation of concerns in SPEM 2.0 is the distinction between Method Content and Process.  This separation is enforced by special package types, which do not allow the mixing of method content with processes.  Method Content is managed in Method Content Packages.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="ProcessPackage-ownedProcessMember" name="ownedProcessMember" type="ProcessPackageableElement" upper="*" lower="0" isComposite="true" redefinedProperty="Package-packagedElement" association="A_owningProcessPackage_ownedProcessMember"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="ProcessPackageableElement" name="ProcessPackageableElement" isAbstract="true" superClass="PackageableElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="ProcessPackageableElement-_ownedComment.0" annotatedElement="ProcessPackageableElement">
				<body>Process Packageable Element is an abstract generalization for Process Package and Process Element supporting the redefinition of the packagedElement association of Process inherited from the UML 2 class.</body>
			</ownedComment>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="BreakdownElement" name="BreakdownElement" isAbstract="true" superClass="ProcessElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="BreakdownElement-_ownedComment.0" annotatedElement="BreakdownElement">
				<body>Breakdown Element is an abstract generalization for any type of Process Element that is part of a breakdown structure.  It defines a set of properties available to all of its specializations.  Any of its concrete subclasses can be placed inside an Activity (via the nested Breakdown Element association) to become part of a breakdown of Activities as well as the Activities namespace.  As Activities are Breakdown Elements themselves and therefore can be nested inside other activities, an n-level breakdown structure is defined by n nested Activities.  In addition to Activities other Breakdown Elements can be nested inside Activities as leaf elements of the breakdown.</body>
			</ownedComment>
			<ownedComment xmi:type="cmof:Comment" xmi:id="BreakdownElement-_ownedComment.1" annotatedElement="BreakdownElement">
				<body>Breakdown Element is an abstract generalization for any type of Process Element that is part of a breakdown structure.  It defines a set of properties available to all of its specializations.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="BreakdownElement-hasMultipleOccurrences" name="hasMultipleOccurrences" type="Boolean" default="false">
				<ownedComment xmi:type="cmof:Comment" xmi:id="BreakdownElement-hasMultipleOccurrences-_ownedComment.0" annotatedElement="BreakdownElement-hasMultipleOccurrences">
					<body>The hasMultipleOccurrences attribute expresses that if set to true then when the process is enacted that the respective Breakdown Element typically will occur in more than one instance (i.e. more than one instance for the Breakdown Element instance).&#xD;
This might provide important guidance for creating plans from a Process.  For example, a Work Definition such as Detail Use Case would be performed for every use case identified for a particular Iteration or Activity.  Generating a plan would list one Work Definition instance per use case each listing a different use case instance as the input/output.  In contrast to the isRepeatable attribute defined for Work Breakdown Element the hasMultipleOccurrences attribute does not assume any dependencies amongst the occurrences of the Breakdown Element.  For example, the Detail Use Case Work Definition occurrences mentioned above can be performed in parallel as well as one after the other.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="BreakdownElement-isOptional" name="isOptional" type="Boolean" default="false">
				<ownedComment xmi:type="cmof:Comment" xmi:id="BreakdownElement-isOptional-_ownedComment.0" annotatedElement="BreakdownElement-isOptional">
					<body>The isOptional attribute indicates that the Breakdown Element describes work, a work product, or even work performer, which inclusion is not mandatory when performing a project that is planned based on a process containing this element.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="BreakdownElement-planningData" name="planningData" type="PlanningData" lower="0" isComposite="true" subsettedProperty="Element-ownedElement" association="A_breakdownElement_planningData"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="BreakdownElement-isPlanned" name="isPlanned" type="Boolean" default="true">
				<ownedComment xmi:type="cmof:Comment" xmi:id="BreakdownElement-isPlanned-_ownedComment.0" annotatedElement="BreakdownElement-isPlanned">
					<body>A key application for Development Processes expressed with Breakdown structures is to generate a project plan from it.  A process as defined in SPEM 2.0 is a multi-dimensional structure defining what work is being performed at what time by which roles using which input and producing what outputs.  A project plan as it is represented in project planning tools such as IBM Rational Portfolio Manager or Microsoft Project normally does not need all this information and is normally limited to just representing a subset.  For example, a typical MS Project plan only represents the work breakdown consisting of Tasks and Activities (sometimes referred to as summary tasks).  It does not show the input and output Work Products for a Task, but it can show which roles shall be staffed for performing the Task.  However, such role allocation need to be replaced with concrete resources when instantiating the plan for a concrete project.  Sometimes project plans can then again be organized differently by organizing work by deliverables in which Work Products are mapped to the plan's summary tasks and Task that have these work products as output mapped below such as summary task.  Therefore, a process can make recommendations about which elements to include and which to exclude when generating a plan.  When the isPlanned attribute is set to False for an instance of a Breakdown Element, then this element shall not be not included when a concrete project plan is being generated from the breakdown structure that contains this element.&#xD;
&#xD;
&#xD;
</body>
				</ownedComment>
			</ownedAttribute>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="CompositeRole" name="CompositeRole" superClass="RoleUse">
			<ownedComment xmi:type="cmof:Comment" xmi:id="CompositeRole-_ownedComment.0" annotatedElement="CompositeRole">
				<body>A Composite Role is a special Role Use that relates to more than one Role Definition.  It represents a grouping of Roles Definition references with the main purpose of simplification, i.e. reducing the number of roles defined in method content for a process.&#xD;
A Composite Role is a grouping of Role Definitions that can be used in an Activity or Process to reduce the number of Roles.  A typical application would be a process for a small team in which a standard set of roles from the method content would be all performed by one or more resource.  By using Composite Roles the process would suggest a typical clustering of Roles to Resources.  A Composite Role could perform all Tasks Definitions defined for the Roles Definition it refers to.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="CompositeRole-aggregatedRole" name="aggregatedRole" type="RoleDefinition" upper="*" lower="0" association="A_compositeRole_aggregatedRole">
				<ownedComment xmi:type="cmof:Comment" xmi:id="CompositeRole-aggregatedRole-_ownedComment.0" annotatedElement="CompositeRole-aggregatedRole">
					<body>This association lists all the Roles Definitions represented by the Composite Role.</body>
				</ownedComment>
			</ownedAttribute>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="MethodContentUse" name="MethodContentUse" isAbstract="true" superClass="BreakdownElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="MethodContentUse-_ownedComment.0" annotatedElement="MethodContentUse">
				<body>A Method Content Use is an abstract generalization for special Breakdown Elements that references one concrete Method Content Element.  A Method Content Use provides a proxy-like representation of a Method Content Element within breakdown structures.  In addition to just referencing Method Content Elements it allows overriding the Method Content Elements structural relationships by defining its own sets of associations and adding its own Content Description.&#xD;
Method Content Uses are the key concept for realizing the separation of processes from method content.  A Method Content Use can be characterized as a reference object for one particular Method Content Element, which has its own relationships and properties.  When a Method Content Use is created it shall be provided with congruent copies of the relationships defined for the referenced content element.  However, a user can modify these relationships for the particular process situation for which the Method Content Use has been created. </body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="MethodContentUse-isSynchronizedWithSource" name="isSynchronizedWithSource" type="Boolean" default="true"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="PlanningData" name="PlanningData" superClass="ProcessElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="PlanningData-_ownedComment.0" annotatedElement="PlanningData">
				<body>Planning Data is a Process Element that adds planning data to Breakdown Elements when it is used for generating project plans from a process.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="PlanningData-startDate" name="startDate" type="String">
				<ownedComment xmi:type="cmof:Comment" xmi:id="PlanningData-startDate-_ownedComment.0" annotatedElement="PlanningData-startDate">
					<body>Defines the absolute start date for the Breakdown Element.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="PlanningData-finishDate" name="finishDate" type="String">
				<ownedComment xmi:type="cmof:Comment" xmi:id="PlanningData-finishDate-_ownedComment.0" annotatedElement="PlanningData-finishDate">
					<body>Defines the absolute finish date for the Breakdown Element.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="PlanningData-rank" name="rank" type="Integer">
				<ownedComment xmi:type="cmof:Comment" xmi:id="PlanningData-rank-_ownedComment.0" annotatedElement="PlanningData-rank">
					<body>Defines the ranking of the Breakdown Element relative to other Breakdown Elements in same Activity.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="PlanningData-duration" name="duration" type="String">
				<ownedComment xmi:type="cmof:Comment" xmi:id="PlanningData-duration-_ownedComment.0" annotatedElement="PlanningData-duration">
					<body>Duration of a Breakdown Element.  Could be an exact recommended duration, or a ratio.</body>
				</ownedComment>
			</ownedAttribute>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="TaskUse" name="TaskUse" superClass="MethodContentUse WorkBreakdownElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="TaskUse-_ownedComment.0" annotatedElement="TaskUse">
				<body>A Task Use is a Method Content Use and Work Breakdown Element that represents a proxy for a Task Definition in the context of one specific Activity.  Every breakdown structure can define different relationships of Task Uses to Work Product Uses and Role Uses. Therefore one Task Definition can be represented by many Task Uses each within the context of an Activity with its own set of relationships.&#xD;
A key difference between Method Content and Process is that a Method Content Element such as Task Definition describes all aspects of doing work defined around this task.  This description is managed in steps, which are modeled as Sections of the Task Definitions Content Descriptions.  When applying a Task Definition in a Process Activity with a Task Use a Process Engineer needs to indicate that at that particular point in time in the Process definition for which the Task Use has been created, only a subset of steps shall be performed.  She defines this selection using the selectedSteps association depicted in Figure 59.  If she wants to add steps to a Task Use, she can describe these either pragmatically in the refinedDescription attribute or properly create a contributing Task Definition to the Task the Task Use refers to (see Section 14.2 on Contribution).&#xD;
&#xD;
&#xD;
</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="TaskUse-selectedStep" name="selectedStep" type="Step" upper="*" lower="0" association="A_taskUse_selectedStep">
				<ownedComment xmi:type="cmof:Comment" xmi:id="TaskUse-selectedStep-_ownedComment.0" annotatedElement="TaskUse-selectedStep">
					<body>List the steps that have been selected to be performed for the instance of the Task Use.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="TaskUse-task" name="task" type="TaskDefinition" lower="0" association="A_taskUse_task">
				<ownedComment xmi:type="cmof:Comment" xmi:id="TaskUse-task-_ownedComment.0" annotatedElement="TaskUse-task">
					<body>This association represents the reference from the Method Content Use to the Method Content Element it refers to.  Every Task Use can reference only on Task Definition.  However, a Task Definition can be represented by many Task Uses.  In the SPEM 2.0 Profile this association is instantiated by a dependency relationship with a trace stereotype.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="TaskUse-ownedProcessParameter" name="ownedProcessParameter" type="ProcessParameter" isOrdered="true" upper="*" lower="0" isComposite="true" association="A_taskUse_ownedParameter"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="TaskUse-usedQualification" name="usedQualification" visibility="public" type="Qualification" upper="*" lower="0" association="A_taskUse_usedQualification"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="TeamProfile" name="TeamProfile" superClass="BreakdownElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="TeamProfile-_ownedComment.0" annotatedElement="TeamProfile">
				<body>A Team Profile is a Breakdown Element that groups Role Uses or Composite Roles defining a nested hierarchy of teams and team members.&#xD;
Work assignments and Work Product responsibilities can be different from Activity to Activity in a development project. Different phases require different staffing profiles, i.e. different skills and resources doing different types of work.  Therefore, a process needs to define such different profiles in a flexible manner.  Whereas Core Method Content defines standard responsibilities and assignments, a process expressed in breakdown structures needs to be able to refine and redefine these throughout its definition.  Role Uses, Composite Roles, as well as Team Profiles provide the data structure necessary to achieve this flexibility and to provide a process user with the capability to define different teams and role relationships for every Activity (including Activities on any nesting-level as well as Iterations or Phases).&#xD;
Hence, in addition to the work breakdown and work product breakdown structures defined so far, Team Profiles are used to define a third type of breakdown structure: team breakdown structures.  These are created as an Activity specific hierarchy of Team Profiles comprising of Role Uses and Composite Roles.  These structures can be presented as well-known Org-Charts.  The diagram shows three instances of Team Profile forming a hierarchy (the top-level node being just a logical node just grouping all the teams and roles defined for an Activity together).  Every Team Profile instance has a number of Roles associated which will be represented as Role Uses.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="TeamProfile-superTeam" name="superTeam" type="TeamProfile" lower="0" association="A_superTeam_subTeam"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="TeamProfile-teamRole" name="teamRole" type="RoleUse" upper="*" lower="0" association="A_teamProfile_teamRole">
				<ownedComment xmi:type="cmof:Comment" xmi:id="TeamProfile-teamRole-_ownedComment.0" annotatedElement="TeamProfile-teamRole">
					<body>This association specifies the roles of team members with Role Uses.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="TeamProfile-subTeam" name="subTeam" type="TeamProfile" upper="*" lower="0" isComposite="true" association="A_superTeam_subTeam"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="WorkBreakdownElement" name="WorkBreakdownElement" isAbstract="true" superClass="BreakdownElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="WorkBreakdownElement-_ownedComment.0" annotatedElement="WorkBreakdownElement">
				<body>A Work Breakdown Element is a special Breakdown Element that provides specific properties for Breakdown Elements that represent work.  The properties are specific to breakdown structures and do not apply to all Work Definition subclasses, though.&#xD;
Work Breakdown Element represents a work specific breakdown element to be used in a work breakdown structure.&#xD;
</body>
			</ownedComment>
			<ownedComment xmi:type="cmof:Comment" xmi:id="WorkBreakdownElement-_ownedComment.1" annotatedElement="WorkBreakdownElement">
				<body>A Work Breakdown Element is a special Breakdown Element that provides specific properties for Breakdown Elements that represent or refer to Work Definitions.  For example its subclass Activity defines work as it is also a subclass of Work Definition.  Its subclass Task Descriptor does not define work by itself, but refers to a Work Definition and therefore can have the same common properties and Work Breakdown Element has.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="WorkBreakdownElement-linkToPredecessor" name="linkToPredecessor" type="WorkSequence" upper="*" lower="0" association="A_successor_linkToPredecessor"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="WorkBreakdownElement-linkToSuccessor" name="linkToSuccessor" type="WorkSequence" upper="*" lower="0" association="A_predecessor_linkToSuccessor"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="WorkBreakdownElement-isRepeatable" name="isRepeatable" type="Boolean" default="false">
				<ownedComment xmi:type="cmof:Comment" xmi:id="WorkBreakdownElement-isRepeatable-_ownedComment.0" annotatedElement="WorkBreakdownElement-isRepeatable">
					<body>This attribute is used to define repetition of work, e.g. iterations.  A Work Breakdown Element with this attribute set to True shall be repeated more than once on the same set of artifacts.  For example, if one wants to model that a specific Activity instance shall represent an iteration in a process then this attribute shall be set to true indicating that the Activity and therefore all of its sub-Activities will be performed more than once.&#xD;
The difference to the hasMultipleOccurrences attribute defined for Breakdown Element is that Work Breakdown Elements with the isRepeatable flag will be performed one after the other (i.e. not in parallel).  For Breakdown Elements with hasMultipleOccurrences set to true this is undefined and up to the project planner.  If both attributes are set to true then isRepeatable takes precedence.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="WorkBreakdownElement-isOngoing" name="isOngoing" type="Boolean" default="false">
				<ownedComment xmi:type="cmof:Comment" xmi:id="WorkBreakdownElement-isOngoing-_ownedComment.0" annotatedElement="WorkBreakdownElement-isOngoing">
					<body>If the isOngoing attribute is set to true for a Work Breakdown Element instance, then the element describes an ongoing piece of work without a fixed duration or end state.  For example, the Work Breakdown Element could represent work of an administrator continuously (e.g. 3h a day) working to ensure that systems are kept in a certain state.  Another example would be program management work overseeing many different projects being scheduled for one particular project at specific reoccurring intervals during the whole lifecycle of the project.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="WorkBreakdownElement-isEventDriven" name="isEventDriven" type="Boolean" default="false">
				<ownedComment xmi:type="cmof:Comment" xmi:id="WorkBreakdownElement-isEventDriven-_ownedComment.0" annotatedElement="WorkBreakdownElement-isEventDriven">
					<body>The isEventDriven attribute indicates that the Work Breakdown Element describes an instance of work which is not started because it has been scheduled to start at a certain point of time, because preceding work is being completed, or input work products are available, but because another specific event has occurred.&#xD;
Examples for such events are exceptions or problem situations which require specific work to be performed as a result.  Also change management work can be modeled as event driven work analyzing a change request or defect and allocating work dynamically to resources to deal with it following the work described with such Work Breakdown Element.  The events themselves are not modeled in this version of the specification.  They shall be described as part of the normal descriptions fields available.&#xD;
&#xD;
&#xD;
&#xD;
</body>
				</ownedComment>
			</ownedAttribute>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="ProcessElement" name="ProcessElement" isAbstract="true" superClass="DescribableElement ProcessPackageableElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="ProcessElement-_ownedComment.0" annotatedElement="ProcessElement">
				<body>Process Elements is an Extensible Element that represents abstract generalization for all elements that are part of a SPEM 2.0 Process.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="ProcessElement-processKind" name="processKind" type="ProcessKind" lower="0" redefinedProperty="ExtensibleElement-kind" association="A_processElement_processKind"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="ProcessPerformer" name="ProcessPerformer" superClass="WorkDefinitionPerformer BreakdownElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="ProcessPerformer-_ownedComment.0" annotatedElement="ProcessPerformer">
				<body>A Process Performer is a Breakdown Element and Work Definition Performer that represents a relationship between Activity instances and Role Use instances. An instance of Process Performer links one or more Role Use instances to one Activity. (Modeled as 0..1 Activities because the Process with Methods meta-model package will add an alternative class to Activity.)&#xD;
The Process Performer links Role Uses to Activities indicating that the Role Use participated in the work defined by the activity in one or another way.  The kind of involvement of the Role Use in the Activity needs to be defined by a Kind class instances that qualifies the Process Performer instances.  Typical examples for Kinds of Process Performers would be Primary Performer, Additional Performer, Assisting Performer, Supervising Performer, Consulted Performer, etc.  The popular RACI-VS diagram defines another set of commonly used Kinds for the Process Performer: Responsible, Accountable, Consulted, Informed, Verifies and Signs.</body>
			</ownedComment>
			<ownedComment xmi:type="cmof:Comment" xmi:id="ProcessPerformer-_ownedComment.1" annotatedElement="ProcessPerformer">
				<body>Process Performer in this meta-model package extends the Process Performer of defined the Process Structure meta-model package with an additional association to Task Use.  Process Performer can be used optionally to indicate performance of an Activity or a Task Use.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="ProcessPerformer-linkedRoleUse" name="linkedRoleUse" type="RoleUse" upper="*" association="A_processPerformer_linkedRoleUse"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="ProcessPerformer-linkedActivity" name="linkedActivity" type="Activity" lower="0" subsettedProperty="WorkDefinitionPerformer-linkedWorkDefinition" association="A_processPerformer_linkedActivity">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ProcessPerformer-linkedActivity-_ownedComment.0" annotatedElement="ProcessPerformer-linkedActivity">
					<body>A Process Performer links to zero or one Activity via this association. The linked Activity property subsets the linked Work Definition property from the Work Definition Performer defined in Core.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="ProcessPerformer-linkedTaskUse" name="linkedTaskUse" type="TaskUse" association="A_processPerformer_linkedTaskUse">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ProcessPerformer-linkedTaskUse-_ownedComment.0" annotatedElement="ProcessPerformer-linkedTaskUse">
					<body>This association links exactly one Task Use to a Process Performer.</body>
				</ownedComment>
			</ownedAttribute>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_roleUse_appliedQualification" name="A_roleUse_appliedQualification" memberEnd="RoleUse-appliedQualification A_roleUse_appliedQualification-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_roleUse_appliedQualification-_ownedComment.0" annotatedElement="A_roleUse_appliedQualification">
				<body>A Role Use can select a sub-set of valid Qualifications defined for the Role Definition for this one use of the Role Definition in the context of a particular Activity.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_roleUse_appliedQualification-_ownedEnd.0" visibility="private" type="RoleUse" upper="*" lower="0" owningAssociation="A_roleUse_appliedQualification" association="A_roleUse_appliedQualification"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_processElement_processKind" name="A_processElement_processKind" general="A_extendedElement_kind" memberEnd="ProcessElement-processKind A_processElement_processKind-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_processElement_processKind-_ownedEnd.0" type="ProcessElement" upper="*" lower="0" isDerived="true" owningAssociation="A_processElement_processKind" association="A_processElement_processKind"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_methodContentElement_methodContentKind" name="A_methodContentElement_methodContentKind" general="A_extendedElement_kind" memberEnd="MethodContentElement-methodContentKind A_methodContentElement_methodContentKind-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_methodContentElement_methodContentKind-_ownedEnd.0" type="MethodContentElement" upper="*" lower="0" owningAssociation="A_methodContentElement_methodContentKind" association="A_methodContentElement_methodContentKind"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_taskUse_selectedStep" name="A_taskUse_selectedStep" memberEnd="TaskUse-selectedStep A_taskUse_selectedStep-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_taskUse_selectedStep-_ownedComment.0" annotatedElement="A_taskUse_selectedStep">
				<body>List the steps that have been selected to be performed for the instance of the Task Use.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_taskUse_selectedStep-_ownedEnd.0" type="TaskUse" upper="*" lower="0" owningAssociation="A_taskUse_selectedStep" association="A_taskUse_selectedStep"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_compositeRole_aggregatedRole" name="A_compositeRole_aggregatedRole" memberEnd="CompositeRole-aggregatedRole A_compositeRole_aggregatedRole-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_compositeRole_aggregatedRole-_ownedComment.0" annotatedElement="A_compositeRole_aggregatedRole">
				<body>This association lists all the Roles Definitions represented by the Composite Role.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_compositeRole_aggregatedRole-_ownedEnd.0" type="CompositeRole" upper="*" lower="0" owningAssociation="A_compositeRole_aggregatedRole" association="A_compositeRole_aggregatedRole"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_roleUse_role" name="A_roleUse_role" memberEnd="A_roleUse_role-_ownedEnd.0 RoleUse-role">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_roleUse_role-_ownedComment.0" annotatedElement="A_roleUse_role">
				<body>This association represents the reference from the Method Content Use to the method content element it refers to.  Every Role Use can reference only one Role Definition.  However, a Role Definition can be represented by many Role Uses.  In the SPEM 2.0 Profile this association is instantiated by a dependency relationship with a trace stereotype.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_roleUse_role-_ownedEnd.0" type="RoleUse" upper="*" lower="0" owningAssociation="A_roleUse_role" association="A_roleUse_role"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_workProductUse_workProduct" name="A_workProductUse_workProduct" memberEnd="A_workProductUse_workProduct-_ownedEnd.0 WorkProductUse-workProduct">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_workProductUse_workProduct-_ownedComment.0" annotatedElement="A_workProductUse_workProduct">
				<body>This association represents the reference from the Method Content Use to the core content element it refers to.  Every Work Product Use can reference only one Work Product Definition.  However, a Work Product can be represented by many Work Product Uses.  In the SPEM 2.0 Profile this association is instantiated by a dependency relationship with a trace stereotype.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_workProductUse_workProduct-_ownedEnd.0" type="WorkProductUse" upper="*" lower="0" owningAssociation="A_workProductUse_workProduct" association="A_workProductUse_workProduct"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_taskUse_task" name="A_taskUse_task" memberEnd="A_taskUse_task-_ownedEnd.0 TaskUse-task">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_taskUse_task-_ownedComment.0" annotatedElement="A_taskUse_task">
				<body>This association represents the reference from the Method Content Use to the Method Content Element it refers to.  Every Task Use can reference only on Task Definition.  However, a Task Definition can be represented by many Task Uses.  In the SPEM 2.0 Profile this association is instantiated by a dependency relationship with a trace stereotype.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_taskUse_task-_ownedEnd.0" type="TaskUse" upper="*" lower="0" owningAssociation="A_taskUse_task" association="A_taskUse_task"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_superTeam_subTeam" name="A_superTeam_subTeam" memberEnd="TeamProfile-subTeam TeamProfile-superTeam">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_superTeam_subTeam-_ownedComment.0" annotatedElement="A_superTeam_subTeam">
				<body>This composition association relates a Sub-Team to its Super-Team, i.e. the Team that it is part of.</body>
			</ownedComment>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_teamProfile_teamRole" name="A_teamProfile_teamRole" memberEnd="A_teamProfile_teamRole-_ownedEnd.0 TeamProfile-teamRole">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_teamProfile_teamRole-_ownedComment.0" annotatedElement="A_teamProfile_teamRole">
				<body>This association specifies the roles of team members with Role Uses.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_teamProfile_teamRole-_ownedEnd.0" type="TeamProfile" upper="*" lower="0" owningAssociation="A_teamProfile_teamRole" association="A_teamProfile_teamRole"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_taskUse_ownedParameter" name="A_taskUse_ownedParameter" memberEnd="TaskUse-ownedProcessParameter A_taskUse_ownedParameter-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_taskUse_ownedParameter-_ownedComment.0" annotatedElement="A_taskUse_ownedParameter">
				<body>This ordered association links a Task Use to its Process Parameters.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_taskUse_ownedParameter-_ownedEnd.0" type="TaskUse" owningAssociation="A_taskUse_ownedParameter" association="A_taskUse_ownedParameter"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_breakdownElement_planningData" name="A_breakdownElement_planningData" general="A_ownedElement_owner" memberEnd="BreakdownElement-planningData A_breakdownElement_planningData-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_breakdownElement_planningData-_ownedComment.0" annotatedElement="A_breakdownElement_planningData">
				<body>The PlanningData class factors out specific optional data needed for representing planning templates.  This association allows to access planning data if it is stored for the Breakdown Element.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_breakdownElement_planningData-_ownedEnd.0" type="BreakdownElement" owningAssociation="A_breakdownElement_planningData" association="A_breakdownElement_planningData"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_owningProcessPackage_ownedProcessMember" name="A_owningProcessPackage_ownedProcessMember" general="A_packagedElement_owningPackage" memberEnd="ProcessPackage-ownedProcessMember A_owningProcessPackage_ownedProcessMember-owningProcessPackage">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_owningProcessPackage_ownedProcessMember-owningProcessPackage" name="owningProcessPackage" type="ProcessPackage" lower="0" owningAssociation="A_owningProcessPackage_ownedProcessMember" association="A_owningProcessPackage_ownedProcessMember"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_owningMethodContentPackage_ownedMethodContentMember" name="A_owningMethodContentPackage_ownedMethodContentMember" general="A_packagedElement_owningPackage" memberEnd="MethodContentPackage-ownedMethodContentMember A_owningMethodContentPackage_ownedMethodContentMember-owningMethodContentPackage">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_owningMethodContentPackage_ownedMethodContentMember-_ownedComment.0" annotatedElement="A_owningMethodContentPackage_ownedMethodContentMember">
				<body>A Method Content Package contains Method Content Packageable Elements.  A Method Content Element instance can be part of only one package instance.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_owningMethodContentPackage_ownedMethodContentMember-owningMethodContentPackage" name="owningMethodContentPackage" type="MethodContentPackage" lower="0" owningAssociation="A_owningMethodContentPackage_ownedMethodContentMember" association="A_owningMethodContentPackage_ownedMethodContentMember"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_processPerformer_linkedTaskUse" name="A_processPerformer_linkedTaskUse" memberEnd="ProcessPerformer-linkedTaskUse A_processPerformer_linkedTaskUse-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_processPerformer_linkedTaskUse-_ownedComment.0" annotatedElement="A_processPerformer_linkedTaskUse">
				<body>This association links exactly one Task Use to a Process Performer.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_processPerformer_linkedTaskUse-_ownedEnd.0" type="ProcessPerformer" upper="*" lower="0" owningAssociation="A_processPerformer_linkedTaskUse" association="A_processPerformer_linkedTaskUse"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_taskUse_usedQualification" name="A_taskUse_usedQualification" memberEnd="TaskUse-usedQualification A_taskUse_usedQualification-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_taskUse_usedQualification-_ownedComment.0" annotatedElement="A_taskUse_usedQualification">
				<body>A Task Use can select a sub-set of valid Qualifications defined for the Task Definition for this one use of the Task Definition in the context of a particular Activity.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_taskUse_usedQualification-_ownedEnd.0" name="" visibility="private" type="TaskUse" upper="*" lower="0" owningAssociation="A_taskUse_usedQualification" association="A_taskUse_usedQualification"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="MethodPlugin" name="MethodPlugin" superClass="Package MethodLibraryPackageableElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="MethodPlugin-_ownedComment.0" annotatedElement="MethodPlugin">
				<body>A Method Plugin is a Package that represents a physical container for Content and Process Packages.  It defines a granularity level for the modularization and organization of method content and processes.  A Method Plugin can extend many other Method Plugins and it can be extended by many Method Plugins.  It can also be used stand-alone, i.e. with no Extension relationship to other plug-ins.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="MethodPlugin-userChangeable" name="userChangeable" type="Boolean" default="false"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="MethodPlugin-basePlugin" name="basePlugin" type="MethodPlugin" upper="*" lower="0" association="A_extendingPlugin_basePlugin"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="MethodPlugin-ownedMethodContentPackage" name="ownedMethodContentPackage" type="MethodContentPackage" upper="*" lower="0" isDerived="true" isComposite="true" subsettedProperty="MethodPlugin-packagedElement" association="A_methodPlugin_ownedMethodContentPackage"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="MethodPlugin-ownedProcessPackage" name="ownedProcessPackage" type="ProcessPackage" upper="*" lower="0" isDerived="true" isComposite="true" subsettedProperty="MethodPlugin-packagedElement" association="A_methodPlugin_ownedProcessPackage"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="MethodPlugin-packagedElement" name="packagedElement" type="MethodPluginPackageableElement" upper="*" lower="0" isComposite="true" redefinedProperty="Package-packagedElement" association="A_owningMethodPlugin_packagedElement"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="MethodContentElement" name="MethodContentElement" isAbstract="true" superClass="DescribableElement MethodContentPackageableElement VariabilityElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="MethodContentElement-_ownedComment.0" annotatedElement="MethodContentElement">
				<body>Method Content Element is an abstract Describable Element that represents an abstract generalization for all Method Content Elements in SPEM 2.0.  Because Method Content Element derives from Describable Element it contains textual descriptions.</body>
			</ownedComment>
			<ownedComment xmi:type="cmof:Comment" xmi:id="MethodContentElement-_ownedComment.1" annotatedElement="MethodContentElement">
				<body>Content Element in the package Method Plugin inherits from Variability Element and not directly from Method Element anymore.  This is achieved using UML 2.0 package merge semantics.  Only if an adopter of this meta-model decides to realize Method Plugins, he would get the variability and extension capabilities for all Content Elements.
Content Element inherits the semantics of Variability Element.
</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="MethodContentElement-methodContentKind" name="methodContentKind" type="MethodContentKind" lower="0" redefinedProperty="ExtensibleElement-kind" association="A_methodContentElement_methodContentKind"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="MethodContentElement-suppressedMethodContentElement" name="suppressedMethodContentElement" type="MethodContentElement" upper="*" lower="0" association="A_methodContentElement_suppressedMethodContentElement"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="VariabilityElement" name="VariabilityElement" isAbstract="true" superClass="Classifier">
			<ownedComment xmi:type="cmof:Comment" xmi:id="VariabilityElement-_ownedComment.0" annotatedElement="VariabilityElement">
				<body>Variability Element is an abstract class derived from Classifier that provides capabilities for content variation and extension to a specific list of SPEM 2.0 classes.  It defines a superclass for Activity (Section 9.1), and Section Section (11.6), and Method Content Element (Section 12.4) in the overall SPEM 2.0 taxonomy of classes using the UML 2 package merge mechanism.  The association Variability Specialization shall only be instantiated between two subclasses of Variability Element of the same concrete type.  The element on varaibilitySpecialElement side of the relationship defines a value for the attribute variabilityType defining the nature of the relationship using a literal from the enumeration Variability Type.&#xD;
Variability Element of the meta-model package Method Plugins adds the capabilities of variation and extension to SPEM Elements that derive from it.  Variability provides a mechanism for customizing Variability Elements without actually directly modifying their original structures or textual content, but by just being able to describe with separate objects the differences (additions, changes, omissions) relative to the original.  This Method Plugin concept allows users to factor their method content and processes in interrelated units and even to architect method content and processes in layers that extend each other with new capabilities.  The resulting method and process design can be dynamically combined and applied on demand using the interpretation rules defined for Variability Element Specializations assembling for process practitioners the most accurate method and process descriptions possible.  It also allows process practitioners to extend and tailor method content and processes they do not own and to easily upgrade to newer versions by simply reapply their personal changes to these upgrades.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="VariabilityElement-variabilityType" name="variabilityType" type="VariabilityType" default="na">
				<ownedComment xmi:type="cmof:Comment" xmi:id="VariabilityElement-variabilityType-_ownedComment.0" annotatedElement="VariabilityElement-variabilityType">
					<body>If in instance of the variabilitySpecialization association between two Variability Elements of the same type exists, then the variabilityType attribute specifies how the element at the variabilitySpecialElement end of the association changes the Content Element at the variabilityBasedOnElement end. See the Variability Type enumeration class for definitions for the different types of variability.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="VariabilityElement-variabilityBasedOnElement" name="variabilityBasedOnElement" type="VariabilityElement" association="A_variabilitySpecialElement_variabilityBasedOnElement"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="Section" name="Section" superClass="Class VariabilityElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Section-_ownedComment.0" annotatedElement="Section">
				<body>A Section is a special Class that represents a structural subsection of a Content Descriptions mainDescription attribute.  It is used for either large scale documentation of Describable Elements organized into sections as well as to flexibly add new Sections to Describable Elements using contribution variability added to the Section concept for Method Plug-ins.</body>
			</ownedComment>
			<ownedComment xmi:type="cmof:Comment" xmi:id="Section-_ownedComment.1" annotatedElement="Section">
				<body>Section in the package Method Plugin inherits from Variability Element and extends Section defined in Managed Content (Section 11.6) with new capabilities for variability.&#xD;
For example, when a Task Definition contributes to another Task Definition its description association is contributed including its Sections (i.e. its Steps), which are modeled as parts of the Content Description instance.  Sections can be nested and therefore the Task Definitions descriptions can be flexibly organized in Steps with sub-Steps.  Sections are Variability Elements themselves, so they can contribute to each other.  For example, one could model a Task Definition Step as a Section instance without relating it to a Task Definitions Content Description that directly contributes to (or replaces) another Section which is part of a Content Description.  This contribution (or replacement) would add new description text to the original step description (or replace the original step description).  Another example would be to contribute to Guidance; for example contribute new check list items organized as Sections to an existing check list guidance element.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Section-sectionName" name="sectionName" type="String">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Section-sectionName-_ownedComment.0" annotatedElement="Section-sectionName">
					<body>This attributes stores the name or the header of the section.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Section-sectionDescription" name="sectionDescription" type="String">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Section-sectionDescription-_ownedComment.0" annotatedElement="Section-sectionDescription">
					<body>This attribute stores the description text for a Content Descriptions Section.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Section-subSection" name="subSection" type="Section" isOrdered="true" upper="*" lower="0" isComposite="true" subsettedProperty="Namespace-ownedMember" association="A_section_subSection"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Section-predecessor" name="predecessor" type="Section" lower="0" association="A_section_predecessor">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Section-predecessor-_ownedComment.0" annotatedElement="Section-predecessor">
					<body>This association defines the predecessor for contributed Sections to be inserted into an existing list of Sections of a Content Description.</body>
				</ownedComment>
			</ownedAttribute>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="Activity" name="Activity" superClass="WorkDefinition VariabilityElement WorkBreakdownElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Activity-_ownedComment.0" annotatedElement="Activity">
				<body>An Activity is a Work Breakdown Element and Work Definition that defines basic units of work within a Process. It relates to Work Product Use instances via instances of the Process Parameter class and Role Use instances via Process Performer instances.&#xD;
Activity supports the nesting and logical grouping of related Breakdown Elements forming breakdown structures.  The concrete breakdown structure an Activity defines (i.e. its contained elements) can be reused by another Activity via the used Activity association, which allows the second Activity to inherit its complete sub-structure.&#xD;
Activity is a concrete Work Definition that represents a general unit of work assignable to specific performers represented by Role Use.  An Activity can rely on inputs and produce outputs represented by Work Product Uses.  Activity also represents a grouping element for other Breakdown Elements such as Activities, Method Content Uses, Milestones, etc.  It is not per-se a high-level grouping of only work as in other meta-models, but groups any kind of Breakdown Elements.  For example, one can define valid Activities that group only Work Product Uses without any matching Role Uses or Parameters.  Such a structure expresses the information that the Activity requires work on these Work Products, without specifying how and who providing the flexibility required for modeling partial or Agile processes. Activity instances can inherit, contribute, or replace properties from other reused activities.  The semantics for the three kinds of reuse defined are specified for Activity Use Kind.</body>
			</ownedComment>
			<ownedComment xmi:type="cmof:Comment" xmi:id="Activity-_ownedComment.1" annotatedElement="Activity">
				<body>Activity in the package Method Plugin inherits from Variability Element to extend Activity with new capabilities for variability. &#xD;
Activity inherits the semantics of Variability Element which provides key mechanism to enable dynamic modification of Activities in a process from a Method Plugin.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Activity-useKind" name="useKind" type="ActivityUseKind" default="na">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Activity-useKind-_ownedComment.0" annotatedElement="Activity-useKind">
					<body>This attribute is set to a value of the enumeration Activity Use Kind other than its default &quot;na&quot; when the Activity instance is associated to another Activity via the useActivity association for reuse. The value of the attribute of the Activity of the to-many end defines the semantics of the association according to the definitions in Activity Use Kind.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Activity-nestedBreakdownElement" name="nestedBreakdownElement" type="BreakdownElement" isOrdered="true" upper="*" lower="0" isComposite="true" subsettedProperty="Namespace-ownedMember" association="A_activity_nestedBreakdownElement">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Activity-nestedBreakdownElement-_ownedComment.0" annotatedElement="Activity-nestedBreakdownElement">
					<body>This association represents breakdown structure nesting.  It defines an n-level hierarchy of Activities grouping together other Breakdown Elements such as other Activities, Milestones, etc.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Activity-usedActivity" name="usedActivity" type="Activity" lower="0" association="A_activity_usedActivity">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Activity-usedActivity-_ownedComment.0" annotatedElement="Activity-usedActivity">
					<body>This association defines a reuse generalization for Activities according to the semantics defined for Activity Use Kind. Activity instances on the to-many end of the association can reuse properties of the Activity instance on the to-one end (base) of the association.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Activity-ownedProcessParameter" name="ownedProcessParameter" type="ProcessParameter" isOrdered="true" upper="*" lower="0" isComposite="true" subsettedProperty="WorkDefinition-ownedParameter" association="A_activity_ownedParameter">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Activity-ownedProcessParameter-_ownedComment.0" annotatedElement="Activity-ownedProcessParameter">
					<body>The association property subsets the ownedWorkDefinitionParamter of Work Definition.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Activity-suppressedBreakdownElement" name="suppressedBreakdownElement" type="BreakdownElement" upper="*" lower="0" association="A_activity_suppressedBreakdownElement">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Activity-suppressedBreakdownElement-_ownedComment.0" annotatedElement="Activity-suppressedBreakdownElement">
					<body>The suppressed association allows hiding any Breakdown Element from the interpretation of a process structure.  It is used in combination with the usedActivity association for elements that are inherited by usedActivity.  The reusing activity can define its own local elements that refer to the base activitys element to denote the suppression (see Activity Use for more details).</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Activity-validContext" name="validContext" type="MethodConfiguration" upper="*" lower="0" association="A_process_validContext"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Activity-defaultContext" name="defaultContext" type="MethodConfiguration" lower="0" association="A_process_defaultContext"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="MethodLibrary" name="MethodLibrary" superClass="Package">
			<ownedComment xmi:type="cmof:Comment" xmi:id="MethodLibrary-_ownedComment.0" annotatedElement="MethodLibrary">
				<body>A Method Library is a physical container for Method Plugins and Method Configuration definitions.  All Method Elements are stored in a Method Library.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="MethodLibrary-predefinedConfiguration" name="predefinedConfiguration" type="MethodConfiguration" upper="*" lower="0" isDerived="true" isComposite="true" subsettedProperty="MethodLibrary-packagedElement" association="A_predefinedConfiguration_methodLibrary"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="MethodLibrary-ownedMethodPlugin" name="ownedMethodPlugin" type="MethodPlugin" upper="*" lower="0" isDerived="true" isComposite="true" subsettedProperty="MethodLibrary-packagedElement" association="A_methodLibrary_ownedMethodPlugin"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="MethodLibrary-packagedElement" name="packagedElement" type="MethodLibraryPackageableElement" upper="*" lower="0" isComposite="true" redefinedProperty="Package-packagedElement" association="A_owningMethodLibrary_packagedElement"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="MethodConfiguration" name="MethodConfiguration" superClass="MethodLibraryPackageableElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="MethodConfiguration-_ownedComment.0" annotatedElement="MethodConfiguration">
				<body>A Method Configuration is a collection of selected Method Plugins, as well as sub-sets of Method Content Packages and Process Packages of respective Method Plugins.  The definition of a configuration can be further refined by subtraction of all Content Elements categorized by a Category associated via the subtracted Category association.&#xD;
</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="MethodConfiguration-baseConfiguration" name="baseConfiguration" type="MethodConfiguration" upper="*" lower="0" association="A_methodConfiguration_baseConfiguration"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="MethodConfiguration-defaultView" name="defaultView" type="Category" association="A_methodConfiguration_defaultView"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="MethodConfiguration-processView" name="processView" type="Category" upper="*" lower="0" association="A_methodConfiguration_processView"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="MethodConfiguration-methodPluginSelection" name="methodPluginSelection" type="MethodPlugin" upper="*" isDerived="true" association="A_methodConfiguration_methodPluginSelection"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="MethodConfiguration-substractedCategory" name="substractedCategory" type="Category" upper="*" lower="0" association="A_methodConfiguration_substractedCategory"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="MethodConfiguration-processPackageSelection" name="processPackageSelection" type="ProcessPackage" upper="*" lower="0" association="A_methodConfiguration_processPackageSelection"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="MethodConfiguration-contentPackageSelection" name="contentPackageSelection" type="MethodContentPackage" upper="*" lower="0" association="A_methodConfiguration_contentPackageSelection"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="ProcessComponent" name="ProcessComponent" superClass="ProcessPackage">
			<ownedComment xmi:type="cmof:Comment" xmi:id="ProcessComponent-_ownedComment.0" annotatedElement="ProcessComponent">
				<body>A Process Component is a special Process Package that applies the principles of encapsulation.  A Process Component contains exactly one Process and defines a set of Work Product Ports that define the inputs and outputs for a Process Component.  There might be many components defining the same Work Product Ports, but using different techniques (i.e. Process) to achieve similar outputs for similar inputs.  Whereas the Work Product Port represents the component specifications (black box view on the component), good candidates for component realizations can be found in Capability Patterns (white box descriptions for the component).&#xD;
SPEM 2.0 supports replaceable and reusable Process Components realizing the principles of encapsulation. Certain situations in a software development project might require that concrete realizations of parts of the process remain undecided or will be decided by the executing team itself (e.g. in outsourcing situations).  Process components support an assembly mechanism that provides that is based on the &quot;black box&quot; principle. At any point during a project the component &quot;realization&quot; detailing the work can be added to the process.  The component approach also allows that different styles or techniques of doing work can be replaced with one another.  For example, a software code output of a component could be produced with a model-driven development or a code-centric technique.  The component concept encapsulates the actual work and lets the development team choose the appropriate technique and fill the component's realization with their choice of Activities that produce the required outputs.&#xD;
</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="ProcessComponent-ownedPort" name="ownedPort" type="WorkProductPort" upper="*" lower="0" isComposite="true" association="A_processComponent_ownedPort"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="ProcessComponent-process" name="process" type="Activity" isComposite="true" association="A_processComponent_process"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="ProcessComponentUse" name="ProcessComponentUse" superClass="MethodContentUse">
			<ownedComment xmi:type="cmof:Comment" xmi:id="ProcessComponentUse-_ownedComment.0" annotatedElement="ProcessComponentUse">
				<body>A Process Component Use represents a Process Component application in a Process, i.e. the breakdown structure defining the Process.  The Process Component Use is used to encapsulate the details of the component in a breakdown structure and to provide its own set of relationships such as it own predecessors and successors.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="ProcessComponentUse-usedPort" name="usedPort" type="WorkProductPort" upper="*" lower="0" isComposite="true" association="A_processComponentUse_workProductPort">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ProcessComponentUse-usedPort-_ownedComment.0" annotatedElement="ProcessComponentUse-usedPort">
					<body>This association links the Process Component Use to used Work Product Ports of the Process Component.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="ProcessComponentUse-processComponent" name="processComponent" type="ProcessComponent" association="A_processComponentUse_processComponent"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="WorkProductPort" name="WorkProductPort" superClass="ProcessElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="WorkProductPort-_ownedComment.0" annotatedElement="WorkProductPort">
				<body>A Work Product Port defines the work products input and outputs for a Process Component.  It is defined based on exactly one type of Work Product and defines for exactly one Process Component if this Work Product type is to be expected as a required (input) or supplied (output) by the Process Component.  It also specifies if this input or output is optional or not. </body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="WorkProductPort-portKind" name="portKind" type="ParameterDirectionKind" default="inout">
				<ownedComment xmi:type="cmof:Comment" xmi:id="WorkProductPort-portKind-_ownedComment.0" annotatedElement="WorkProductPort-portKind">
					<body>This attribute defines if the port represents and input or output Work Product.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="WorkProductPort-isOptional" name="isOptional" default="false" type="Boolean">
				<ownedComment xmi:type="cmof:Comment" xmi:id="WorkProductPort-isOptional-_ownedComment.0" annotatedElement="WorkProductPort-isOptional">
					<body>This attribute specifies if the port represents a mandatory or optional Work Product input or output.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="WorkProductPort-portType" name="portType" type="WorkProductDefinition" lower="0" association="A_workProductPort_portType"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="WorkProductPortConnector" name="WorkProductPortConnector" superClass="BreakdownElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="WorkProductPortConnector-_ownedComment.0" annotatedElement="WorkProductPortConnector">
				<body>A Work Product Port Connector is used to connect Work Product Ports for assembling Process Components.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="WorkProductPortConnector-connectedPort" name="connectedPort" type="WorkProductPort" upper="*" lower="0" association="A_workProductPortConnector_workProductPort">
				<ownedComment xmi:type="cmof:Comment" xmi:id="WorkProductPortConnector-connectedPort-_ownedComment.0" annotatedElement="WorkProductPortConnector-connectedPort">
					<body>This association connects many Work Product Ports with many other Work Product Ports.</body>
				</ownedComment>
			</ownedAttribute>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="MethodLibraryPackageableElement" name="MethodLibraryPackageableElement" isAbstract="true" superClass="PackageableElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="MethodLibraryPackageableElement-_ownedComment.0" annotatedElement="MethodLibraryPackageableElement">
				<body>Method Library Element is an abstract generalization for Method Plugin and Method Configuration supporting the redefinition of the packagedElement association of Method Library inherited from the UML 2 class.&#xD;
Method Library Packageable Element represents an element that can be packaged in a Method Library.  It prevents SPEM 2.0 user from nesting Method Libraries.</body>
			</ownedComment>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="MethodPluginPackageableElement" name="MethodPluginPackageableElement" isAbstract="true" superClass="PackageableElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="MethodPluginPackageableElement-_ownedComment.0" annotatedElement="MethodPluginPackageableElement">
				<body>Method Plugin Element is an abstract generalization for Method Content Package and Process Package supporting the redefinition of the packagedElement association of Method Plugin inherited from the UML 2 class.&#xD;
Method Plugin Packageable Element represents an element that can be packaged in a Method Plugin.  It prevents SPEM 2.0 user from nesting Method Plugins.</body>
			</ownedComment>
		</ownedMember>
		<ownedMember xmi:type="cmof:Enumeration" xmi:id="VariabilityType" name="VariabilityType">
			<ownedComment xmi:type="cmof:Comment" xmi:id="VariabilityType-_ownedComment.0" annotatedElement="VariabilityType">
				<body>Variability Type is an Enumeration used for values for instances of Variability Element's attribute variabilityType.  It defines the nature of how a Variability Element extends another Variability Element. See enumeration literals for definitions for each type.</body>
			</ownedComment>
			<ownedLiteral xmi:type="cmof:EnumerationLiteral" xmi:id="VariabilityType-na" name="na" enumeration="VariabilityType">
				<ownedComment xmi:type="cmof:Comment" xmi:id="VariabilityType-na-_ownedComment.0" annotatedElement="VariabilityType-na">
					<body>This is the default &quot;not assigned&quot; value of a Variabillity Element's variabilityType attribute which is set in the case no variability association is present between the Variability Element and other Variability Elements.
</body>
				</ownedComment>
			</ownedLiteral>
			<ownedLiteral xmi:type="cmof:EnumerationLiteral" xmi:id="VariabilityType-contributes" name="contributes" enumeration="VariabilityType">
				<ownedComment xmi:type="cmof:Comment" xmi:id="VariabilityType-contributes-_ownedComment.0" annotatedElement="VariabilityType-contributes">
					<body>Contributes provides a way for instances of Variability Elements to contribute their properties into their base Variability Element without directly altering any of its existing properties, i.e. in an additive fashion.  Properties contributed are: attribute values and association instances.  The effect after interpretation of contribution is that the base Variability Element is logically replaced with an augmented variant of the element that combines attribute values and association instances.  The way this combination is realized depends on the type of the attribute or association.  For example, String attributes are concatenated resolving embedded commands for dependent text or merging text fragments (e.g. descriptions for content elements).  Additional elements in to-many associations are added (e.g. additional Guidance elements or Task Descriptors of an Activity).  Different elements in to-one associations are ignored (e.g. the one Primary Performer of a Task).  Multiple Content Elements can contribute to the same base element and all of these contributions properties are added to the base in the same fashion. The following table provides the detailed list of interpretation rules:&#xD;
&#xD;
attribute values:	String values from the special Variability Element are concatenated with values from the based-on Variability Element.  Other values from the special Variability Element of any other type such as Integer, Date are ignored.&#xD;
The identifying attributes guid and name of Method Element are exempt from this rule and will not be modified.&#xD;
0..1-association instances:	The one association instance of the based-on Variability Element is kept and any association from the contributing special Variability Element is ignored.&#xD;
0..n-association instances:	Association instances of the special Variability Element are added to the already existing association instances of the based-on element.  If both Variability Elements refer to the same object then only one instance of the association will remain.&#xD;
</body>
				</ownedComment>
			</ownedLiteral>
			<ownedLiteral xmi:type="cmof:EnumerationLiteral" xmi:id="VariabilityType-extends" name="extends" enumeration="VariabilityType">
				<ownedComment xmi:type="cmof:Comment" xmi:id="VariabilityType-extends-_ownedComment.0" annotatedElement="VariabilityType-extends">
					<body>Extension allows Method Plugins to easily reuse elements from a Base Plugin by providing a kind of inheritance for the special Variability Element.  Attribute values and Association instances are inherited from the based-on Variability Element to the special Variability Element.  The result of interpretation is that the special element has the same properties as the based-on has, but might override the inherited properties with its own values.  Hence extends is not used to modify content of the base Plugin, but to provide the ability for the extending Plugin to define its own content which is a variant of content already defined (e.g. a special version of a generic Review Record for a specific type of review).  The effect of this is that the base Variability Element and any number of extending Variability Elements can be used side by side, but refer to each other via the extends relationship.  Extends also provides the key mechanism for binding Capability Patterns to Processes: A pattern is applied by defining an extends relationships from an Activity of the applying Processes to the Pattern.  The Activity inherits associations instances from the pattern and the pattern appears to be part of the resulting Process after Interpretation.&#xD;
&#xD;
attribute values:	Values from the based-on Variability element are inherited and used to populate the special Variability Elements attributes.  If the special element attributes are already populated the inherited values are ignored.  &#xD;
The identifying attributes guid and name of Method Element are exempt from this rule and will not be modified.&#xD;
0..1-association instances:	The one association instance of the based-on Variability Element is inherited to the special Variability Element.  If the special Variability Element defines its own association instance then the inherited one is ignored.&#xD;
0..n-association instances:	Association instances defined for the based-on Variability Element are inherited to the special Variability Element.  If the special Variability Element defines its own association instances, then the inherited ones are ignored.&#xD;
&#xD;
</body>
				</ownedComment>
			</ownedLiteral>
			<ownedLiteral xmi:type="cmof:EnumerationLiteral" xmi:id="VariabilityType-replaces" name="replaces" enumeration="VariabilityType">
				<ownedComment xmi:type="cmof:Comment" xmi:id="VariabilityType-replaces-_ownedComment.0" annotatedElement="VariabilityType-replaces">
					<body>Replaces provides a way for Variability Elements to replace a base Variability Element without directly changing any of its existing properties.  This is in most cases used for Method Plugins that aim to replace specific Content Elements such as Roles, Task, or Activities with either a complete new variant or to change fundamental relationships of these elements (e.g. Role-Artifact responsibility).  Properties replaced are attribute values and association instances.  The effect of this is that the base Content Element is logically replaced with this new variant of the element to which all incoming associations still point as before, but which has potentially new attribute values and outgoing association properties.  This provides a very powerful mechanism to replace, for example, whole Activities in a Process with complete new realizations of the Activity.  For instance, replacing an Activity doing use case-based design with an activity doing agile code-centric development doing the same work using a different development technique utilizing different Roles, Tasks, etc.  Another example, would be to replace an Activity that describes database design for an RDBMS with an Activity that describes database design for an OODBMS.  A Variability Element can only be replaced by one other element at a time.  For example, if two Method Plugins replace the same element only one Method Plugin can be used for interpretation (see concept of Method Configuration for more details on how to resolve such conflicts).  The following table provides the detailed list of interpretation rules:&#xD;
&#xD;
attribute values:	Values from the special Variability Element are replaced with values from the based-on Variability Element including unassigned values.&#xD;
The identifying attributes guid and name of Method Element are exempt from this rule and will not be modified.&#xD;
0..1-association instances:	The one association instance of the based-on Variability Element is replaced with the association instance from the replacing special Variability Element.  If the special Variability Element does not have an association instance then resulting element will also not have an association.&#xD;
0..n-association instances:	Association instances of the special Variability Element replace all association instances of the based-on Variability Element.&#xD;
&#xD;
</body>
				</ownedComment>
			</ownedLiteral>
			<ownedLiteral xmi:type="cmof:EnumerationLiteral" xmi:id="VariabilityType-extends-replaces" name="extends-replaces" enumeration="VariabilityType">
				<ownedComment xmi:type="cmof:Comment" xmi:id="VariabilityType-extends-replaces-_ownedComment.0" annotatedElement="VariabilityType-extends-replaces">
					<body>Extends-replaces combines the effects of extends and replace variability into one new variability type. Whereas the replaces variability completely replaces all attributes and outgoing association instances of the base variability element with new values and instances, or removes all values or association instances if the replacing element does not define any. Extends-replaces variability only replaces the values that have been redefined and leaves all other values of the base element as is.  In other words, extends-replace allows selectively replacing only parts of the base elements attributes and association instances. This type of variability can be used for method plug-ins that, for example, would like to rename elements or replace some descriptions with new ones without completely remodeling all other relationships and attributes it needs to keep intact.&#xD;
&#xD;
attribute values:	Values from the special Variability Element are replaced with values from the based-on Variability Element not including unassigned values. This rule also applies to identifying attributes. In other words, after the replacements the resulting object has the object id of the extends-replaces element.&#xD;
0..1-association instances	: A to-one association instance of the based-on Variability Element is replaced with the association instance from the replacing special Variability Element.  If the special Variability Element does not have an association instance, then resulting element will keep its association instance from the base element.&#xD;
0..n-association instances: Association instances of the special Variability Element replace all association instances of the based-on Variability Element.  If the replacing special Variability Element does not define any association instances, but the base element does, then the resulting element will keep these association instances.&#xD;
&#xD;
&#xD;
</body>
				</ownedComment>
			</ownedLiteral>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_extendingPlugin_basePlugin" name="A_extendingPlugin_basePlugin" memberEnd="A_extendingPlugin_basePlugin-extendingPlugin MethodPlugin-basePlugin">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_extendingPlugin_basePlugin-_ownedComment.0" annotatedElement="A_extendingPlugin_basePlugin">
				<body>This association defines that Method Plugins could extend many other Method Plugins.  The extending plug-in contains new SPEM Elements, extends existing SPEM Elements and processes using Variability (e.g. contribution, replace, etc.), provides additional Processes, etc.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_extendingPlugin_basePlugin-extendingPlugin" name="extendingPlugin" type="MethodPlugin" upper="*" lower="0" owningAssociation="A_extendingPlugin_basePlugin" association="A_extendingPlugin_basePlugin"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_variabilitySpecialElement_variabilityBasedOnElement" name="A_variabilitySpecialElement_variabilityBasedOnElement" memberEnd="A_variabilitySpecialElement_variabilityBasedOnElement-variabilitySpecialElement VariabilityElement-variabilityBasedOnElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_variabilitySpecialElement_variabilityBasedOnElement-_ownedComment.0" annotatedElement="A_variabilitySpecialElement_variabilityBasedOnElement">
				<body>This 1-to-many association defines in combination with the variabilityType attribute that a number of special Variability Elements of the same type represent a variation of exactly one other Variability Element.  See the Variability Type enumeration class for definitions for the different types of variability.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_variabilitySpecialElement_variabilityBasedOnElement-variabilitySpecialElement" name="variabilitySpecialElement" type="VariabilityElement" upper="*" lower="0" owningAssociation="A_variabilitySpecialElement_variabilityBasedOnElement" association="A_variabilitySpecialElement_variabilityBasedOnElement"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_section_predecessor" name="A_section_predecessor" memberEnd="Section-predecessor A_section_predecessor-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_section_predecessor-_ownedComment.0" annotatedElement="A_section_predecessor">
				<body>This association defines the predecessor for contributed Sections to be inserted into an existing list of Sections of a Content Description.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_section_predecessor-_ownedEnd.0" type="Section" upper="*" lower="0" owningAssociation="A_section_predecessor" association="A_section_predecessor"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_methodConfiguration_baseConfiguration" name="A_methodConfiguration_baseConfiguration" memberEnd="MethodConfiguration-baseConfiguration A_methodConfiguration_baseConfiguration-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_methodConfiguration_baseConfiguration-_ownedComment.0" annotatedElement="A_methodConfiguration_baseConfiguration">
				<body>The definition of a configuration can be based on the definitions of other configurations.  For example, a configuration A could be defined as the superset of configurations B, C, and D plus add more selected Plugins and Packages.  In such a case A would list B, C, and D as its baseConfigurations.  If any of these base configurations changes all updates would be automatically valid for A as well reducing maintainability overhead for overlapping/dependent configurations. </body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_methodConfiguration_baseConfiguration-_ownedEnd.0" type="MethodConfiguration" upper="*" lower="0" owningAssociation="A_methodConfiguration_baseConfiguration" association="A_methodConfiguration_baseConfiguration"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_methodConfiguration_defaultView" name="A_methodConfiguration_defaultView" memberEnd="MethodConfiguration-defaultView A_methodConfiguration_defaultView-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_methodConfiguration_defaultView-_ownedEnd.0" type="MethodConfiguration" upper="*" lower="0" owningAssociation="A_methodConfiguration_defaultView" association="A_methodConfiguration_defaultView"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_methodConfiguration_processView" name="A_methodConfiguration_processView" memberEnd="A_methodConfiguration_processView-_ownedEnd.0 MethodConfiguration-processView">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_methodConfiguration_processView-_ownedEnd.0" type="MethodConfiguration" upper="*" lower="0" owningAssociation="A_methodConfiguration_processView" association="A_methodConfiguration_processView"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_process_validContext" name="A_process_validContext" memberEnd="A_process_validContext-_ownedEnd.0 Activity-validContext">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_process_validContext-_ownedComment.0" annotatedElement="A_process_validContext">
				<body>A Process can have many additional configurations that have been verified to also produce valid results.  Process Elements (e.g. Descriptors) that refer to content packages that are defined outside the scope of such a configuration would not be shown in the process when published or used under such a configuration.  This allows to easily remove content from a process by removing content packages to from the related configuration.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_process_validContext-_ownedEnd.0" type="Activity" upper="*" lower="0" owningAssociation="A_process_validContext" association="A_process_validContext"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_process_defaultContext" name="A_process_defaultContext" memberEnd="A_process_defaultContext-_ownedEnd.0 Activity-defaultContext">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_process_defaultContext-_ownedComment.0" annotatedElement="A_process_defaultContext">
				<body>A Process has exactly on default configuration.  This is in most cases the configuration in which the process has been created.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_process_defaultContext-_ownedEnd.0" type="Activity" upper="*" lower="0" owningAssociation="A_process_defaultContext" association="A_process_defaultContext"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_predefinedConfiguration_methodLibrary" name="A_predefinedConfiguration_methodLibrary" general="A_owningMethodLibrary_packagedElement" memberEnd="MethodLibrary-predefinedConfiguration A_predefinedConfiguration_methodLibrary-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_predefinedConfiguration_methodLibrary-_ownedComment.0" annotatedElement="A_predefinedConfiguration_methodLibrary">
				<body>A Method Library stores a set of predefined Method Configurations that are regularly used by the library authors (e.g. the configurations that they ship to their users).</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_predefinedConfiguration_methodLibrary-_ownedEnd.0" type="MethodLibrary" owningAssociation="A_predefinedConfiguration_methodLibrary" association="A_predefinedConfiguration_methodLibrary"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_methodLibrary_ownedMethodPlugin" name="A_methodLibrary_ownedMethodPlugin" general="A_owningMethodLibrary_packagedElement" memberEnd="A_methodLibrary_ownedMethodPlugin-_ownedEnd.0 MethodLibrary-ownedMethodPlugin">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_methodLibrary_ownedMethodPlugin-_ownedComment.0" annotatedElement="A_methodLibrary_ownedMethodPlugin">
				<body>A Method Library physically comprises of Method Plugins.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_methodLibrary_ownedMethodPlugin-_ownedEnd.0" type="MethodLibrary" owningAssociation="A_methodLibrary_ownedMethodPlugin" association="A_methodLibrary_ownedMethodPlugin"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_methodConfiguration_methodPluginSelection" name="A_methodConfiguration_methodPluginSelection" memberEnd="A_methodConfiguration_methodPluginSelection-_ownedEnd.0 MethodConfiguration-methodPluginSelection" isDerived="true">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_methodConfiguration_methodPluginSelection-_ownedComment.0" annotatedElement="A_methodConfiguration_methodPluginSelection">
				<body>This derived association includes all Method Plugin that own packages that have been selected as part of the Method configuration using the methodPackageSelection association.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_methodConfiguration_methodPluginSelection-_ownedEnd.0" type="MethodConfiguration" upper="*" lower="0" owningAssociation="A_methodConfiguration_methodPluginSelection" association="A_methodConfiguration_methodPluginSelection"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_methodPlugin_ownedMethodContentPackage" name="A_methodPlugin_ownedMethodContentPackage" general="A_owningMethodPlugin_packagedElement" memberEnd="MethodPlugin-ownedMethodContentPackage A_methodPlugin_ownedMethodContentPackage-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_methodPlugin_ownedMethodContentPackage-_ownedComment.0" annotatedElement="A_methodPlugin_ownedMethodContentPackage">
				<body>This composition association represents that every Content Package is part of exactly one Method Plugin. This property subsets the redefined packagedElement.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_methodPlugin_ownedMethodContentPackage-_ownedEnd.0" type="MethodPlugin" owningAssociation="A_methodPlugin_ownedMethodContentPackage" association="A_methodPlugin_ownedMethodContentPackage"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_methodPlugin_ownedProcessPackage" name="A_methodPlugin_ownedProcessPackage" general="A_owningMethodPlugin_packagedElement" memberEnd="MethodPlugin-ownedProcessPackage A_methodPlugin_ownedProcessPackage-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_methodPlugin_ownedProcessPackage-_ownedComment.0" annotatedElement="A_methodPlugin_ownedProcessPackage">
				<body>This composition association represents that every Process Package is part of exactly one Method Plugin. This property subsets the redefined packagedElement.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_methodPlugin_ownedProcessPackage-_ownedEnd.0" type="MethodPlugin" owningAssociation="A_methodPlugin_ownedProcessPackage" association="A_methodPlugin_ownedProcessPackage"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_methodConfiguration_substractedCategory" name="A_methodConfiguration_substractedCategory" memberEnd="MethodConfiguration-substractedCategory A_methodConfiguration_substractedCategory-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_methodConfiguration_substractedCategory-_ownedEnd.0" type="MethodConfiguration" upper="*" lower="0" owningAssociation="A_methodConfiguration_substractedCategory" association="A_methodConfiguration_substractedCategory"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_methodConfiguration_processPackageSelection" name="A_methodConfiguration_processPackageSelection" memberEnd="MethodConfiguration-processPackageSelection A_methodConfiguration_processPackageSelection-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_methodConfiguration_processPackageSelection-_ownedEnd.0" type="MethodConfiguration" upper="*" lower="0" owningAssociation="A_methodConfiguration_processPackageSelection" association="A_methodConfiguration_processPackageSelection"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_methodConfiguration_contentPackageSelection" name="A_methodConfiguration_contentPackageSelection" memberEnd="MethodConfiguration-contentPackageSelection A_methodConfiguration_contentPackageSelection-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_methodConfiguration_contentPackageSelection-_ownedEnd.0" type="MethodConfiguration" upper="*" lower="0" owningAssociation="A_methodConfiguration_contentPackageSelection" association="A_methodConfiguration_contentPackageSelection"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_processComponent_process" name="A_processComponent_process" memberEnd="ProcessComponent-process A_processComponent_process-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_processComponent_process-_ownedComment.0" annotatedElement="A_processComponent_process">
				<body>A Process Component contains exactly one Process (e.g. a Capability Pattern or a Delivery Process) that is being physically encapsulated by the component.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_processComponent_process-_ownedEnd.0" type="ProcessComponent" lower="0" owningAssociation="A_processComponent_process" association="A_processComponent_process"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_processComponentUse_processComponent" name="A_processComponentUse_processComponent" memberEnd="ProcessComponentUse-processComponent A_processComponentUse_processComponent-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_processComponentUse_processComponent-_ownedComment.0" annotatedElement="A_processComponentUse_processComponent">
				<body>This association represents the reference from the Method Content Use to the Process Component it refers to.  A Process Component Use represents exactly one Process Component.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_processComponentUse_processComponent-_ownedEnd.0" type="ProcessComponentUse" upper="*" lower="0" owningAssociation="A_processComponentUse_processComponent" association="A_processComponentUse_processComponent"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_processComponent_ownedPort" name="A_processComponent_ownedPort" memberEnd="ProcessComponent-ownedPort A_processComponent_ownedPort-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_processComponent_ownedPort-_ownedComment.0" annotatedElement="A_processComponent_ownedPort">
				<body>This association defines the ports required or provided by the Process Component. They define work product types used, produced, or changed by the process component.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_processComponent_ownedPort-_ownedEnd.0" type="ProcessComponent" lower="0" owningAssociation="A_processComponent_ownedPort" association="A_processComponent_ownedPort"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_processComponentUse_workProductPort" name="A_processComponentUse_workProductPort" memberEnd="ProcessComponentUse-usedPort A_processComponentUse_workProductPort-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_processComponentUse_workProductPort-_ownedComment.0" annotatedElement="A_processComponentUse_workProductPort">
				<body>This association links the Process Component Use to used Work Product Ports of the Process Component.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_processComponentUse_workProductPort-_ownedEnd.0" type="ProcessComponentUse" owningAssociation="A_processComponentUse_workProductPort" association="A_processComponentUse_workProductPort"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_workProductPortConnector_workProductPort" name="A_workProductPortConnector_workProductPort" memberEnd="WorkProductPortConnector-connectedPort A_workProductPortConnector_workProductPort-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_workProductPortConnector_workProductPort-_ownedComment.0" annotatedElement="A_workProductPortConnector_workProductPort">
				<body>This association connects many Work Product Ports with many other Work Product Ports.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_workProductPortConnector_workProductPort-_ownedEnd.0" type="WorkProductPortConnector" upper="*" lower="0" owningAssociation="A_workProductPortConnector_workProductPort" association="A_workProductPortConnector_workProductPort"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_workProductPort_portType" name="A_workProductPort_portType" memberEnd="WorkProductPort-portType A_workProductPort_portType-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_workProductPort_portType-_ownedComment.0" annotatedElement="A_workProductPort_portType">
				<body>This association defines the exact type of the Work Product Port.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_workProductPort_portType-_ownedEnd.0" type="WorkProductPort" owningAssociation="A_workProductPort_portType" association="A_workProductPort_portType"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_owningMethodLibrary_packagedElement" name="A_owningMethodLibrary_packagedElement" general="A_packagedElement_owningPackage" memberEnd="MethodLibrary-packagedElement A_owningMethodLibrary_packagedElement-owningMethodLibrary">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_owningMethodLibrary_packagedElement-_ownedComment.0" annotatedElement="A_owningMethodLibrary_packagedElement">
				<body>This association redefines the association from UML Infrastructure Package to only allow MethodLibraryPackageableElements.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_owningMethodLibrary_packagedElement-owningMethodLibrary" name="owningMethodLibrary" type="MethodLibrary" lower="0" owningAssociation="A_owningMethodLibrary_packagedElement" association="A_owningMethodLibrary_packagedElement"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_owningMethodPlugin_packagedElement" name="A_owningMethodPlugin_packagedElement" general="A_packagedElement_owningPackage" memberEnd="MethodPlugin-packagedElement A_owningMethodPlugin_packagedElement-owningMethodPlugin">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_owningMethodPlugin_packagedElement-_ownedComment.0" annotatedElement="A_owningMethodPlugin_packagedElement">
				<body>This association redefines the association from UML Infrastructure Package to only allow MethodPluginPackageableElements.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_owningMethodPlugin_packagedElement-owningMethodPlugin" name="owningMethodPlugin" type="MethodPlugin" lower="0" owningAssociation="A_owningMethodPlugin_packagedElement" association="A_owningMethodPlugin_packagedElement"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_methodContentElement_suppressedMethodContentElement" name="A_methodContentElement_suppressedMethodContentElement" memberEnd="MethodContentElement-suppressedMethodContentElement A_methodContentElement_suppressedMethodContentElement-_ownedEnd.0">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_methodContentElement_suppressedMethodContentElement-_ownedComment.0" annotatedElement="A_methodContentElement_suppressedMethodContentElement">
				<body>If a Variability Element is derived from another Variability Element using the Extends Variability Specialization then this association can be used to suppress inherited Method Elements that were part of the based-on Variability Element, which can be any type of Method Element.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_methodContentElement_suppressedMethodContentElement-_ownedEnd.0" visibility="private" type="MethodContentElement" lower="0" owningAssociation="A_methodContentElement_suppressedMethodContentElement" association="A_methodContentElement_suppressedMethodContentElement"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_externalReference_element" name="A_externalReference_element" memberEnd="ExternalReference-reference A_externalReference_element-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_externalReference_element-_ownedEnd.0" visibility="private" type="ExternalReference" upper="*" lower="0" owningAssociation="A_externalReference_element" association="A_externalReference_element"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="State_ext" name="State_ext" superClass="ExternalReference">
			<ownedComment xmi:type="cmof:Comment" xmi:id="State_ext-_ownedComment.0" annotatedElement="State_ext">
				<body>The State_ext represents a reference to a model class in an external behavior model representing a state.</body>
			</ownedComment>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="Transition_ext" name="Transition_ext" superClass="ExternalReference">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Transition_ext-_ownedComment.0" annotatedElement="Transition_ext">
				<body>The Transition_ext represents a reference to a model class in an external behavior model representing a transition between states.</body>
			</ownedComment>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="ControlFlow_ext" name="ControlFlow_ext" superClass="ExternalReference">
			<ownedComment xmi:type="cmof:Comment" xmi:id="ControlFlow_ext-_ownedComment.0" annotatedElement="ControlFlow_ext">
				<body>The ControlFlow_ext represents a reference to a model class in an external behavior model representing a control flow.</body>
			</ownedComment>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="Activity_ext" name="Activity_ext" superClass="ExternalReference">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Activity_ext-_ownedComment.0" annotatedElement="Activity_ext">
				<body>The Activity_ext represents a reference to a model class in an external behavior model representing a definition of behavior.</body>
			</ownedComment>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="WorkSequence" name="WorkSequence" superClass="BreakdownElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="WorkSequence-_ownedComment.0" annotatedElement="WorkSequence">
				<body>Work Sequence is a Breakdown Element that represents a relationship between two Work Breakdown Elements in which one Work Breakdown Elements depends on the start or finish of another Work Breakdown Elements in order to begin or end.&#xD;
The Work Sequence class defines predecessor and successor relations amongst Work Breakdown Elements.  This information is in particular critical for use of the process in planning applications.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="WorkSequence-linkKind" name="linkKind" type="WorkSequenceKind" default="finishToStart">
				<ownedComment xmi:type="cmof:Comment" xmi:id="WorkSequence-linkKind-_ownedComment.0" annotatedElement="WorkSequence-linkKind">
					<body>This attribute expresses the type of the Work Sequence relationship by assigning a value from the Work Sequence Kind enumeration.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="WorkSequence-successor" name="successor" type="WorkBreakdownElement" association="A_successor_linkToPredecessor"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="WorkSequence-predecessor" name="predecessor" type="WorkBreakdownElement" association="A_predecessor_linkToSuccessor"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="WorkSequence-workSequenceContext" name="workSequenceContext" type="ControlFlow_ext" upper="*" lower="0" association="A_workSequence_controlFlowContext"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="RoleUse" name="RoleUse" superClass="MethodContentUse">
			<ownedComment xmi:type="cmof:Comment" xmi:id="RoleUse-_ownedComment.0" annotatedElement="RoleUse">
				<body>A Role Use is a special Breakdown Element that either represents a performer of an Activity or a participant of the Activity.  If it is a performer the Role Use and Activity need to be related via a Process Performer.  If it is a participant then the Role Use is stored in the nestedBreakdownElement composition of the Activity and might be used by one of the sub-activities as a performer and/or a Process Responsibility Assignment.  Role Uses are only valid within and specific to the context of an Activity and not to be reused across activities.&#xD;
A Role Use represents an activity specific occurrence of an activity performer or participant.  A Role Use is an Activity specific object and not a general reusable definition of an organizational role. (The meta-model package Method Content defines a concepts call Role Definition for that).  A Role Use represents the occurrence of a real person performing activity-specific work and having activity-specific responsibilities.  A Role Use participant stored with an Activity can be only accessed and reused by the Activitys sub-Activities and not by any parent or sibling Activities in the Activity breakdown structure.  This scoping of Role Use in the local namespace of Activities allows to model different Performers as well as different Responsibility Assignments for every Activity, which reflects the fact that work product responsibilities and performance of activities might change throughout the development lifecycle.  In other words, Role Use instances with the same name can be created in different Activities, which all have different responsibilities and perform different work.&#xD;
Many processes do not comprise of Role Definitions and just define the occurrence of a role and imply that all team members know what the Role Use represents (e.g. by just interpreting the Role Use name).  In these situations fitting individuals for the Role Uses are assigned when the process is enacted.  Assigning Role Uses in such a way is also often referred to as self-organizing teams in which team members choose by themselves or via their managers which roles they play during development.</body>
			</ownedComment>
			<ownedComment xmi:type="cmof:Comment" xmi:id="RoleUse-_ownedComment.1" annotatedElement="RoleUse">
				<body>A Role Use represents a Role in the context of one specific Activity.  Every breakdown structure can define different relationships of Role Uses to Task Uses and Work Product Uses.  Therefore one role can be represented by many Role Uses each within the context of an Activity with its own set of relationships.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="RoleUse-role" name="role" type="RoleDefinition" lower="0" association="A_roleUse_role">
				<ownedComment xmi:type="cmof:Comment" xmi:id="RoleUse-role-_ownedComment.0" annotatedElement="RoleUse-role">
					<body>This association represents the reference from the Method Content Use to the method content element it refers to.  Every Role Use can reference only one Role Definition.  However, a Role Definition can be represented by many Role Uses.  In the SPEM 2.0 Profile this association is instantiated by a dependency relationship with a trace stereotype.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="RoleUse-appliedQualification" name="appliedQualification" visibility="public" type="Qualification" upper="*" lower="0" association="A_roleUse_appliedQualification"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="RoleUse-roleUseContext" name="roleUseContext" type="Transition_ext" upper="*" lower="0" association="A_roleUse_transitionContext"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="WorkProductUse" name="WorkProductUse" superClass="MethodContentUse">
			<ownedComment xmi:type="cmof:Comment" xmi:id="WorkProductUse-_ownedComment.0" annotatedElement="WorkProductUse">
				<body>A Work Product Use is a special Breakdown Element that either represents an input and/or output type for an Activity or represents a general participant of the Activity.  If it is an input/output then the Work Product Use needs to be related to the Activity via the Process Parameter class.  If it is a participant then the Work Product Use is stored in the nestedBreakdownElement composition of the Activity and might be used by one of the sub-activities as an input/output and/or be related to a Role Use via a Process Responsibility Assignment.  Role Use instances are only valid within and specific to the context of an Activity and not to be reused across activities.&#xD;
A Work Product Use represents an activity specific occurrence of a Work Product input/output type or an Activity participant.  A Work Product Use instance is an Activity specific object and not a general reusable definition of a work product. (The meta-model package Method Content defines a concepts call Work Product Definition for that).  A Work Product Use represents the occurrence of a real Work Product in the context of an activity.   A Work Product Use participant stored with an Activity can only be accessed and reused by the Activitys sub-Activities and not by any parent or sibling Activities in the Activity breakdown structure.  This scoping of Work Product Use in the local namespace of Activities allows to model different Responsibility Assignments for every Activity, which reflects the fact that work product responsibilities might change throughout the development lifecycle.  In other words, Role Use instances with the same name can be created in different Activities, which all have different Work Product Use responsibilities.&#xD;
Many processes do not comprise of Work Product Definitions and just define the occurrence of a work product and imply that all team members know what the Work Product Use represents (e.g. by just interpreting the Work Product Use name).  For example a process might define that Stakeholder Requests need to be captured, but does not formally define what a Stakeholder Request is nor prescribes any templates or forms for them.  Team members could choose by themselves which form of representation they choose as well as shift responsibilities for the Work Product during the lifecycle phases (i.e. activities).</body>
			</ownedComment>
			<ownedComment xmi:type="cmof:Comment" xmi:id="WorkProductUse-_ownedComment.1" annotatedElement="WorkProductUse">
				<body>A Work Product Use represents a Work Product Definition in the context of one specific Activity.  Every breakdown structure can define different relationships of Work Product Uses to Task Uses and Role Uses.  Therefore one Work Product Definition can be represented by many Work Product Uses each within the context of an Activity with its own set of relationships.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="WorkProductUse-workProduct" name="workProduct" type="WorkProductDefinition" lower="0" association="A_workProductUse_workProduct"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="WorkProductUse-workProductUseContext" name="workProductUseContext" type="State_ext" upper="*" lower="0" association="A_workProductUse_stateContext"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="WorkDefinition" name="WorkDefinition" isAbstract="true" superClass="Classifier">
			<ownedComment xmi:type="cmof:Comment" xmi:id="WorkDefinition-_ownedComment.0" annotatedElement="WorkDefinition">
				<body>Work Definition is an abstract Classifier that generalizes all definitions of work within SPEM 2.0.  Work Definition defines some default associations to Work Definition Parameter and Constraint. Work Definitions can contain sets of pre- and post-conditions defining constraints that need to be valid before the described work can begin or before it can be declared as finished.  Note that general UML constraints inherited via Classifier can be used to define additional constraints and rules for Work Definitions.&#xD;
Work Definitions represent the behavior for doing work.  In contrast to SPEM 1.1 the Work Definition behavior is not bound to one specific classifier as an operation, but is a performer independent definition of work represented as a classifier itself.  For example, a Work Definition could represent work that is being performed by one specific Role (e.g. a Role performing a specific Activity), by many Roles working in close collaboration (many Roles all working together on the same interdisciplinary Activity), or complex work that is performed throughout the lifecycle (e.g. a process defining a breakdown structure for organizing larger composite units of work performed by many Roles working in collaboration).&#xD;
Work Definitions can be modeled with behavior model representations such as UML 2.0 Activity diagrams by merging this UML 2.0 meta-model package into the Process Behavior package.  However, it is also a common practice to just textually describe the behavior of work definitions. Such descriptions can be added by merging this package into the Managed Content package.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="WorkDefinition-postcondition" name="postcondition" type="Constraint" upper="*" lower="0" isComposite="true" subsettedProperty="Namespace-ownedRule" association="A_workDefinition_postcondition">
				<ownedComment xmi:type="cmof:Comment" xmi:id="WorkDefinition-postcondition-_ownedComment.0" annotatedElement="WorkDefinition-postcondition">
					<body>This composition association adds an optional post-condition to a Work Definition.  A post-condition defines any kind of constraint that must evaluate to true before the work described for the Work Definition can be declared completed or finished and which other Work Definitions might depend upon (e.g. for their pre-conditions).  For example, a post-condition could define that a work product defined to be the output must be in a specific state before the Work Definition can end (e.g. Use Case must be in state fully described and reviewed by System Analyst).</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="WorkDefinition-precondition" name="precondition" type="Constraint" upper="*" lower="0" isComposite="true" subsettedProperty="Namespace-ownedRule" association="A_workDefinition_precondition">
				<ownedComment xmi:type="cmof:Comment" xmi:id="WorkDefinition-precondition-_ownedComment.0" annotatedElement="WorkDefinition-precondition">
					<body>This composition association adds an optional pre-condition to a Work Definition.  A pre-condition defines any kind of constraint that must evaluate to true before the work described for the Work Definition can start. For example, a pre-condition could define that an input Work Product needs to be in a specific state or that other related work must be in a certain state (e.g. Input document X has been reviewed and signed by customer AND the work defined by Work Definition Management Review is complete) before the work can begin.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="WorkDefinition-ownedParameter" name="ownedParameter" type="WorkDefinitionParameter" isOrdered="true" upper="*" lower="0" isReadOnly="true" isDerived="true" isDerivedUnion="true" isComposite="true" subsettedProperty="Element-ownedElement" association="A_workDefinition_ownedParameter">
				<ownedComment xmi:type="cmof:Comment" xmi:id="WorkDefinition-ownedParameter-_ownedComment.0" annotatedElement="WorkDefinition-ownedParameter">
					<body>Work Definition can define an ordered set of parameters to specify inputs and outputs.  The concrete subclasses of Work Definition need to define their own subclasses of Work Definition Parameter to add reference to concrete input/output meta types.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="WorkDefinition-workDefinitionActivtyContext" name="workDefinitionActivtyContext" type="Activity_ext" upper="*" lower="0" association="A_workDefinition_activityContext"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="WorkDefinition-workDefinitionTransitionContext" name="workDefinitionTransitionContext" type="Transition_ext" upper="*" lower="0" association="A_workDefinition_transisitonContext"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="ExternalReference" name="ExternalReference" isAbstract="true" superClass="Classifier">
			<ownedComment xmi:type="cmof:Comment" xmi:id="ExternalReference-_ownedComment.0" annotatedElement="ExternalReference">
				<body>External Reference is a Classifier that represents an abstract generalization of all classes representing references to external behavior models.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="ExternalReference-reference" name="reference" type="Element" upper="*" association="A_externalReference_element"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_workDefinitionParameter_exitState" name="A_workDefinitionParameter_exitState" memberEnd="A_workDefinitionParameter_exitState-_ownedEnd.0 WorkDefinitionParameter-exitState">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_workDefinitionParameter_exitState-_ownedComment.0" annotatedElement="A_workDefinitionParameter_exitState">
				<body>Given that an instance of Work Product Definition or Work Product Use has been specified as output for a specific Work Definition, then the Exist State attribute specifies the desired state of instances of the referenced work product instances when work on the Work Definition is finished.</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_workDefinitionParameter_exitState-_ownedEnd.0" type="WorkDefinitionParameter" lower="0" owningAssociation="A_workDefinitionParameter_exitState" association="A_workDefinitionParameter_exitState"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_workDefinitionParameter_entryState" name="A_workDefinitionParameter_entryState" memberEnd="A_workDefinitionParameter_entryState-_ownedEnd.0 WorkDefinitionParameter-entryState">
			<ownedComment xmi:type="cmof:Comment" xmi:id="A_workDefinitionParameter_entryState-_ownedComment.0" annotatedElement="A_workDefinitionParameter_entryState">
				<body>Given that an instance of Work Product Definition or Work Product Use has been specified as an input for a specific Work Definition, then the Entry State attribute specifies the desired state of instances of the referenced work product instance when work on the Work Definition is initiated.&#xD;
For some Work Products Definition or Uses, state is expressed in percentage of completion, compliance to work product checklist, informal state descriptions, etc. Others have very specific states expressed as enumerations such as [identified, briefly described, outlined, detailed] for use cases. Other Work Product states relate to some quality measures or lifecycle states such as [reviewed, implemented, tested].</body>
			</ownedComment>
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_workDefinitionParameter_entryState-_ownedEnd.0" type="WorkDefinitionParameter" lower="0" owningAssociation="A_workDefinitionParameter_entryState" association="A_workDefinitionParameter_entryState"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_workProductUse_stateContext" name="A_workProductUse_stateContext" memberEnd="WorkProductUse-workProductUseContext A_workProductUse_stateContext-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_workProductUse_stateContext-_ownedEnd.0" type="WorkProductUse" lower="0" owningAssociation="A_workProductUse_stateContext" association="A_workProductUse_stateContext"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_workDefinition_transisitonContext" name="A_workDefinition_transisitonContext" memberEnd="WorkDefinition-workDefinitionTransitionContext A_workDefinition_transisitonContext-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_workDefinition_transisitonContext-_ownedEnd.0" type="WorkDefinition" lower="0" owningAssociation="A_workDefinition_transisitonContext" association="A_workDefinition_transisitonContext"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_roleUse_transitionContext" name="A_roleUse_transitionContext" memberEnd="RoleUse-roleUseContext A_roleUse_transitionContext-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_roleUse_transitionContext-_ownedEnd.0" type="RoleUse" lower="0" owningAssociation="A_roleUse_transitionContext" association="A_roleUse_transitionContext"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_workSequence_controlFlowContext" name="A_workSequence_controlFlowContext" memberEnd="WorkSequence-workSequenceContext A_workSequence_controlFlowContext-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_workSequence_controlFlowContext-_ownedEnd.0" type="WorkSequence" owningAssociation="A_workSequence_controlFlowContext" association="A_workSequence_controlFlowContext"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_workDefinition_activityContext" name="A_workDefinition_activityContext" memberEnd="WorkDefinition-workDefinitionActivtyContext A_workDefinition_activityContext-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_workDefinition_activityContext-_ownedEnd.0" type="WorkDefinition" owningAssociation="A_workDefinition_activityContext" association="A_workDefinition_activityContext"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="WorkProductDefinition" name="WorkProductDefinition" superClass="MethodContentElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="WorkProductDefinition-_ownedComment.0" annotatedElement="WorkProductDefinition">
				<body>Work Product Definition is Method Content Element that is used, modified, and produced by Task Definitions.  Work Product Definitions can be related to other Work Product Definitions via the Work Product Definition Relationship.&#xD;
Work Products are in most cases tangible work products consumed, produced, or modified by Tasks.   They may serve as a basis for defining reusable assets.  Roles use Work Products to perform Tasks and produce Work Products in the course of performing Tasks.  Work Products are the responsibility of Role Definitions, making responsibility easy to identify and understand, and promoting the idea that every piece of information produced in the method requires the appropriate set of skills. Even though one Role Definition might &quot;own&quot; a specific type of Work Product, other roles can still use the Work Product for their work, and perhaps even update them if the Role Definition instance instance has been given permission to do so.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="WorkProductDefinition-workProductDefinitionContext" name="workProductDefinitionContext" visibility="public" type="State_ext" upper="*" lower="0" association="A_workProductDefinition_stateContext"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="RoleDefinition" name="RoleDefinition" superClass="MethodContentElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="RoleDefinition-_ownedComment.0" annotatedElement="RoleDefinition">
				<body>A Role Definition is a Method Content Element that defines a set of related skills, competencies, and responsibilities.  Roles are used by Task Definitions to define who performs them as well as define a set of Work Product Definitions they are responsible for.&#xD;
A Role Definition defines a set of related skills, competencies, and responsibilities of an individual or a set of individuals.  Roles are not individuals or resources.  Individual members of the development organization will wear different hats, or perform different roles. The mapping from individual to Role, performed by the project manager when planning and staffing for a project, allows different individuals to act as several different roles, and for a role to be played by several individuals (also refer to Composite Role).</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="RoleDefinition-providedQualification" name="providedQualification" type="Qualification" upper="*" lower="0" association="A_roleDefinition_providedQualification">
				<ownedComment xmi:type="cmof:Comment" xmi:id="RoleDefinition-providedQualification-_ownedComment.0" annotatedElement="RoleDefinition-providedQualification">
					<body>Provides a list of Qualifications required for instances of instances of Role Definitions to fulfill.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="RoleDefinition-roleDefinitionContext" name="roleDefinitionContext" visibility="public" type="Transition_ext" lower="0" association="A_roleDefinition_transitionContext"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="WorkDefinitionParameter" name="WorkDefinitionParameter" superClass="Classifier">
			<ownedComment xmi:type="cmof:Comment" xmi:id="WorkDefinitionParameter-_ownedComment.0" annotatedElement="WorkDefinitionParameter">
				<body>A Work Definition Parameter is an abstract generalization for Process Elements that represent parameter for Work Definitions.  It is used for declarations of inputs and outputs.  The meta-classes for the input/output types are to be defined by Work Definition Parameters concrete subclasses.&#xD;
This class is to be specialized by a class defining an association to the class defining the input/output meta-class. SPEM 2.0 distinguishes between Work Product Definitions and Work Product Use.  The general parameter class Work Definition Parameter defines common properties used by Work Definition specialization that either use Work Product Definitions or Work Product Uses.</body>
			</ownedComment>
			<ownedComment xmi:type="cmof:Comment" xmi:id="WorkDefinitionParameter-_ownedComment.1" annotatedElement="WorkDefinitionParameter">
				<body>This package extends the Work Definition Parameter class introduced in the Core package with associations to entry and/or exist states for its Work Product Use or Work Definition parameter values.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="WorkDefinitionParameter-direction" name="direction" type="ParameterDirectionKind" default="inout">
				<ownedComment xmi:type="cmof:Comment" xmi:id="WorkDefinitionParameter-direction-_ownedComment.0" annotatedElement="WorkDefinitionParameter-direction">
					<body>This attribute represents the kind of the input as specified by the enumeration Parameter Direction Kind.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="WorkDefinitionParameter-exitState" name="exitState" type="State_ext" upper="*" lower="0" isComposite="true" association="A_workDefinitionParameter_exitState">
				<ownedComment xmi:type="cmof:Comment" xmi:id="WorkDefinitionParameter-exitState-_ownedComment.0" annotatedElement="WorkDefinitionParameter-exitState">
					<body>Given that an instance of Work Product Use has been specified as output for a specific Activity, then the Activity Exist State attribute specifies the desired state of instances of the referenced Work Product Use instances when work on the Activity is finished.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="WorkDefinitionParameter-entryState" name="entryState" type="State_ext" upper="*" lower="0" isComposite="true" association="A_workDefinitionParameter_entryState">
				<ownedComment xmi:type="cmof:Comment" xmi:id="WorkDefinitionParameter-entryState-_ownedComment.0" annotatedElement="WorkDefinitionParameter-entryState">
					<body>Given that an instance of Work Product Use has been specified as an input for a specific Activity, then the Activity Entry State attribute specifies the desired state of instances of the referenced Work Product Use instance when work on the Activity is initiated.  &#xD;
For some Work Products Uses state is expressed in percentage of completion, compliance to work product checklist, informal state descriptions, etc.  Others have very specific states expressed as enumerations such as [identified, briefly described, outlined, detailed] for use cases.  Other Work Product states relate to some quality measures or lifecycle states such as [reviewed, implemented, tested].</body>
				</ownedComment>
			</ownedAttribute>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_workProductDefinition_stateContext" name="A_workProductDefinition_stateContext" memberEnd="WorkProductDefinition-workProductDefinitionContext A_workProductDefinition_stateContext-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_workProductDefinition_stateContext-_ownedEnd.0" name="" visibility="private" type="WorkProductDefinition" lower="0" owningAssociation="A_workProductDefinition_stateContext" association="A_workProductDefinition_stateContext"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_roleDefinition_transitionContext" name="A_roleDefinition_transitionContext" memberEnd="RoleDefinition-roleDefinitionContext A_roleDefinition_transitionContext-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_roleDefinition_transitionContext-_ownedEnd.0" name="" visibility="private" type="RoleDefinition" upper="*" lower="0" owningAssociation="A_roleDefinition_transitionContext" association="A_roleDefinition_transitionContext"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="Default_ResponsibilityAssignment" name="Default_ResponsibilityAssignment" superClass="MethodContentElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Default_ResponsibilityAssignment-_ownedComment.0" annotatedElement="Default_ResponsibilityAssignment">
				<body>A Default Responsibility Assignment is a Method Content Element that represents a relationship between instances of Role Definition and Work Product Definition.  An instance of the Default Responsibility Assignment links one or more Role Definition instances to exactly one Work Product Definition.&#xD;
The Process Responsibility Assignment links Role Definitions to Work Product Definitions indicating that the Role Definition has a responsibility relationship with the Work Product Definition.  The Kind of responsibility of the Role Definition for the Work Product Definition needs to be defined by Kind class instances that qualify the Default Responsibility Assignment. The popular RACI-VS diagram defines a set of commonly used Kinds which cannot only be applied for the Default Task Definition Performer, but also often used for work product responsibility: Responsible, Accountable, Consulted, Informed, Verifies and Signs.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Default_ResponsibilityAssignment-linkedRoleDefinition" name="linkedRoleDefinition" type="RoleDefinition" upper="*" association="A_responsibilityAssignment_linkedRoleDefinition"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Default_ResponsibilityAssignment-linkedWorkproductDefinition" name="linkedWorkproductDefinition" type="WorkProductDefinition" association="A_responsibilityAssignment_linkedWorkProductDefinition"/>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Default_ResponsibilityAssignment-defaultResponsibilityContext" name="defaultResponsibilityContext" visibility="public" type="State_ext" upper="*" lower="0" association="A_defaultResponsibilityAssignment_stateContext"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="ProcessResponsibilityAssignment" name="ProcessResponsibilityAssignment" superClass="BreakdownElement">
			<ownedComment xmi:type="cmof:Comment" xmi:id="ProcessResponsibilityAssignment-_ownedComment.0" annotatedElement="ProcessResponsibilityAssignment">
				<body>A Process Responsibility Assignment is a Breakdown Element that represents a relationship between instances of Role Use and Work Product Use.  An instance of the Process Responsibility Assignment links one or more Role Use instances to exactly one Work Product Use.&#xD;
The Process Responsibility Assignment links Role Uses to Work Product Uses indicating that the Role Use has a responsibility relationship with the Work Product Use.  The Kind of responsibility of the Role Use for the Work Product Use needs to be defined by Kind class instances that qualify the Process Responsibility Assignment. The popular RACI-VS diagram defines a set of commonly used Kinds which cannot only be applied for the Process Performer, but also often used for work product responsibility: Responsible, Accountable, Consulted, Informed, Verifies and Signs.&#xD;
Note, that for many processes the Process Performer and Process Responsibility represent two quite different sets of information as a Role Use can be involved in an Activity that modifies a work product without being responsible for the Work Product itself and vice versa: A Role Use can be responsible for a Work Product Use without participating an all the Activities that modify it.  Other processes might chose to only use one of these relationships.  For example, there are processes for self-organizing teams that actually do not define detailed Activities describing which Role Use performs which work.  These approaches might just utilize the Process Responsibility Assignment to express that a Role Use has a certain responsibility, but that the process does not prescribe how that responsibility is achieved.  In such a case the Kinds defined might express work product states such as detailed, implemented, documented, reviewed and so on.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="ProcessResponsibilityAssignment-linkedWorkProductUse" name="linkedWorkProductUse" type="WorkProductUse" association="A_processResponsibilityAssignment_linkedWorkProductUse">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ProcessResponsibilityAssignment-linkedWorkProductUse-_ownedComment.0" annotatedElement="ProcessResponsibilityAssignment-linkedWorkProductUse">
					<body>A Process Responsibility Assignment links to exactly one Work Product Use.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="ProcessResponsibilityAssignment-linkedRoleUse" name="linkedRoleUse" type="RoleUse" upper="*" association="A_processResponsibilityAssignment_linkedRoleUse">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ProcessResponsibilityAssignment-linkedRoleUse-_ownedComment.0" annotatedElement="ProcessResponsibilityAssignment-linkedRoleUse">
					<body>A Process Responsibility Assignment links to one or more Role Use.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="ProcessResponsibilityAssignment-processResponsibilityContext" name="processResponsibilityContext" visibility="public" type="State_ext" upper="*" lower="0" association="A_processResponsibilityAssignment_stateContext"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_defaultResponsibilityAssignment_stateContext" name="A_defaultResponsibilityAssignment_stateContext" memberEnd="Default_ResponsibilityAssignment-defaultResponsibilityContext A_defaultResponsibilityAssignment_stateContext-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_defaultResponsibilityAssignment_stateContext-_ownedEnd.0" name="" visibility="private" type="Default_ResponsibilityAssignment" lower="0" owningAssociation="A_defaultResponsibilityAssignment_stateContext" association="A_defaultResponsibilityAssignment_stateContext"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_processResponsibilityAssignment_stateContext" name="A_processResponsibilityAssignment_stateContext" memberEnd="ProcessResponsibilityAssignment-processResponsibilityContext A_processResponsibilityAssignment_stateContext-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_processResponsibilityAssignment_stateContext-_ownedEnd.0" name="" visibility="private" type="ProcessResponsibilityAssignment" lower="0" owningAssociation="A_processResponsibilityAssignment_stateContext" association="A_processResponsibilityAssignment_stateContext"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="Stereotype" name="Stereotype" superClass="Class">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Stereotype-_ownedComment.0" annotatedElement="Stereotype">
				<body>A stereotype defines how an existing metaclass may be extended, and enables the use of platform or domain specific terminology or notation in place of, or in addition to, the ones used for the extended metaclass.</body>
			</ownedComment>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="Stereotype-name_not_clash" name="name_not_clash" constrainedElement="Stereotype" namespace="Stereotype">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Stereotype-name_not_clash-_ownedComment.0" annotatedElement="Stereotype-name_not_clash">
					<body>Stereotype names should not clash with keyword names for the extended model element.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="Stereotype-name_not_clash-_specification">
					<language>OCL</language>
					<body>true</body>
				</specification>
			</ownedRule>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="Stereotype-generalize" name="generalize" constrainedElement="Stereotype" namespace="Stereotype">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Stereotype-generalize-_ownedComment.0" annotatedElement="Stereotype-generalize">
					<body>A Stereotype may only generalize or specialize another Stereotype.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="Stereotype-generalize-_specification">
					<language>OCL</language>
					<body>generalization.general->forAll(e |e.oclIsKindOf(Stereotype)) and generalization.specific->forAll(e | e.oclIsKindOf(Stereotype)) </body>
				</specification>
			</ownedRule>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Stereotype-icon" name="icon" type="Image" upper="*" lower="0" isComposite="true" association="A_icon_stereotype">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Stereotype-icon-_ownedComment.0" annotatedElement="Stereotype-icon">
					<body>Stereotype can change the graphical appearance of the extended model element by using attached icons. When this association is not null, it references the location of the icon content to be displayed within diagrams presenting the extended model elements.</body>
				</ownedComment>
			</ownedAttribute>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="Profile" name="Profile" superClass="Package">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Profile-_ownedComment.0" annotatedElement="Profile">
				<body>A profile defines limited extensions to a reference metamodel with the purpose of adapting the metamodel to a specific platform or domain.</body>
			</ownedComment>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="Profile-metaclass_reference_not_specialized" name="metaclass_reference_not_specialized" constrainedElement="Profile" namespace="Profile">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Profile-metaclass_reference_not_specialized-_ownedComment.0" annotatedElement="Profile-metaclass_reference_not_specialized">
					<body>An element imported as a metaclassReference is not specialized or generalized in a Profile.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="Profile-metaclass_reference_not_specialized-_specification">
					<language>OCL</language>
					<body>self.metaclassReference.importedElement->&#xD;&#xA;  select(c | c.oclIsKindOf(Classifier) and&#xD;&#xA;    (c.generalization.namespace = self or&#xD;&#xA;      (c.specialization.namespace = self) )->isEmpty()</body>
				</specification>
			</ownedRule>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="Profile-references_same_metamodel" name="references_same_metamodel" constrainedElement="Profile" namespace="Profile">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Profile-references_same_metamodel-_ownedComment.0" annotatedElement="Profile-references_same_metamodel">
					<body>All elements imported either as metaclassReferences or through metamodelReferences are members of the same base reference metamodel.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="Profile-references_same_metamodel-_specification">
					<language>OCL</language>
					<body>self.metamodelReference.importedPackage.elementImport.importedElement.allOwningPackages())->&#xD;&#xA;  union(self.metaclassReference.importedElement.allOwningPackages() )->notEmpty()</body>
				</specification>
			</ownedRule>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Profile-ownedStereotype" name="ownedStereotype" type="Stereotype" upper="*" lower="0" isDerived="true" isComposite="true" subsettedProperty="Package-packagedElement" association="A_ownedStereotype_profile">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Profile-ownedStereotype-_ownedComment.0" annotatedElement="Profile-ownedStereotype">
					<body>References the Stereotypes that are owned by the Profile.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Profile-metaclassReference" name="metaclassReference" type="ElementImport" upper="*" lower="0" isComposite="true" subsettedProperty="Namespace-elementImport" association="A_metaclassReference_profile">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Profile-metaclassReference-_ownedComment.0" annotatedElement="Profile-metaclassReference">
					<body>References a metaclass that may be extended.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Profile-metamodelReference" name="metamodelReference" type="PackageImport" upper="*" lower="0" isComposite="true" subsettedProperty="Namespace-packageImport" association="A_metamodelReference_profile">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Profile-metamodelReference-_ownedComment.0" annotatedElement="Profile-metamodelReference">
					<body>References a package containing (directly or indirectly) metaclasses that may be extended.</body>
				</ownedComment>
			</ownedAttribute>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="Package" name="Package" superClass="PackageableElement Namespace">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Package-_ownedComment.0" annotatedElement="Package">
				<body>A package is used to group elements, and provides a namespace for the grouped elements.</body>
			</ownedComment>
			<ownedComment xmi:type="cmof:Comment" xmi:id="Package-_ownedComment.1" annotatedElement="Package">
				<body>A package can have one or more profile applications to indicate which profiles have been applied. Because a profile is a package, it is possible to apply a profile not only to packages, but also to profiles.</body>
			</ownedComment>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="Package-elements_public_or_private" name="elements_public_or_private" constrainedElement="Package" namespace="Package">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Package-elements_public_or_private-_ownedComment.0" annotatedElement="Package-elements_public_or_private">
					<body>If an element that is owned by a package has visibility, it is public or private.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="Package-elements_public_or_private-_specification">
					<language>OCL</language>
					<body>self.ownedElements->forAll(e | e.visibility->notEmpty() implies e.visbility = #public or e.visibility = #private)</body>
				</specification>
			</ownedRule>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Package-packagedElement" name="packagedElement" type="PackageableElement" upper="*" lower="0" isComposite="true" subsettedProperty="Namespace-ownedMember" association="A_packagedElement_owningPackage">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Package-packagedElement-_ownedComment.0" annotatedElement="Package-packagedElement">
					<body>Specifies the packageable elements that are owned by this Package.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Package-ownedType" name="ownedType" type="Type" upper="*" lower="0" isDerived="true" isComposite="true" subsettedProperty="Package-packagedElement" association="A_ownedType_package">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Package-ownedType-_ownedComment.0" annotatedElement="Package-ownedType">
					<body>References the packaged elements that are Types.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Package-nestedPackage" name="nestedPackage" type="Package" upper="*" lower="0" isDerived="true" isComposite="true" subsettedProperty="Package-packagedElement" association="A_nestedPackage_nestingPackage">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Package-nestedPackage-_ownedComment.0" annotatedElement="Package-nestedPackage">
					<body>References the packaged elements that are Packages.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Package-nestingPackage" name="nestingPackage" type="Package" lower="0" subsettedProperty="NamedElement-namespace" association="A_nestedPackage_nestingPackage">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Package-nestingPackage-_ownedComment.0" annotatedElement="Package-nestingPackage">
					<body>References the Package that owns this Package.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Package-packageMerge" name="packageMerge" type="PackageMerge" upper="*" lower="0" isComposite="true" subsettedProperty="Element-ownedElement" association="A_receivingPackage_packageMerge">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Package-packageMerge-_ownedComment.0" annotatedElement="Package-packageMerge">
					<body>References the PackageMerges that are owned by this Package.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Package-profileApplication" name="profileApplication" type="ProfileApplication" upper="*" lower="0" isComposite="true" subsettedProperty="Element-ownedElement" association="A_profileApplication_applyingPackage">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Package-profileApplication-_ownedComment.0" annotatedElement="Package-profileApplication">
					<body>References the ProfileApplications that indicate which profiles have been applied to the Package.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Package-mustBeOwned" name="mustBeOwned" class="Package" isQuery="true" redefinedOperation="Element-mustBeOwned" bodyCondition="Package-mustBeOwned-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Package-mustBeOwned-_ownedComment.0" annotatedElement="Package-mustBeOwned">
					<body>The query mustBeOwned() indicates whether elements of this type must have an owner.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Package-mustBeOwned-spec" name="spec" constrainedElement="Package-mustBeOwned" namespace="Package-mustBeOwned">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Package-mustBeOwned-spec-_specification">
						<language>OCL</language>
						<body>result = false</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Package-mustBeOwned-_ownedParameter.0" type="Boolean" direction="return"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Package-visibleMembers" name="visibleMembers" class="Package" isQuery="true" bodyCondition="Package-visibleMembers-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Package-visibleMembers-_ownedComment.0" annotatedElement="Package-visibleMembers">
					<body>The query visibleMembers() defines which members of a Package can be accessed outside it.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Package-visibleMembers-spec" name="spec" constrainedElement="Package-visibleMembers" namespace="Package-visibleMembers">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Package-visibleMembers-spec-_specification">
						<language>OCL</language>
						<body>result = member->select( m | self.makesVisible(m))</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Package-visibleMembers-_ownedParameter.0" type="PackageableElement" upper="*" lower="0" direction="return"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Package-makesVisible" name="makesVisible" class="Package" isQuery="true" precondition="Package-makesVisible-_ownedRule.0" bodyCondition="Package-makesVisible-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Package-makesVisible-_ownedComment.0" annotatedElement="Package-makesVisible">
					<body>The query makesVisible() defines whether a Package makes an element visible outside itself. Elements with no visibility and elements with public visibility are made visible.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Package-makesVisible-_ownedRule.0" constrainedElement="Package-makesVisible" namespace="Package-makesVisible">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Package-makesVisible-_ownedRule.0-_specification">
						<language>OCL</language>
						<body>self.member->includes(el)</body>
					</specification>
				</ownedRule>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Package-makesVisible-spec" name="spec" constrainedElement="Package-makesVisible" namespace="Package-makesVisible">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Package-makesVisible-spec-_specification">
						<language>OCL</language>
						<body>result = (ownedMember->includes(el)) or&#xA;   (elementImport->&#xA;      select(ei|ei.visibility = #public)->&#xA;         collect(ei|ei.importedElement)->includes(el)) or&#xA;   (packageImport->&#xA;      select(pi|pi.visibility = #public)->&#xA;        collect(pi|&#xA;           pi.importedPackage.member->includes(el))->notEmpty())</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Package-makesVisible-_ownedParameter.0" type="Boolean" direction="return"/>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Package-makesVisible-el" name="el" type="NamedElement"/>
			</ownedOperation>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="Class" name="Class" superClass="Classifier">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Class-_ownedComment.0" annotatedElement="Class">
				<body>A class describes a set of objects that share the same specifications of features, constraints, and semantics.</body>
			</ownedComment>
			<ownedComment xmi:type="cmof:Comment" xmi:id="Class-_ownedComment.1" annotatedElement="Class">
				<body>Class has derived association that indicates how it may be extended through one or more stereotypes. Stereotype is the only kind of metaclass that cannot be extended by stereotypes.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Class-isAbstract" name="isAbstract" type="Boolean" default="false">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Class-isAbstract-_ownedComment.0" annotatedElement="Class-isAbstract">
					<body>True when a class is abstract.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Class-ownedAttribute" name="ownedAttribute" type="Property" isOrdered="true" upper="*" lower="0" isComposite="true" subsettedProperty="Classifier-attribute Namespace-ownedMember" association="A_ownedAttribute_class">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Class-ownedAttribute-_ownedComment.0" annotatedElement="Class-ownedAttribute">
					<body>The attributes (i.e. the properties) owned by the class.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Class-ownedOperation" name="ownedOperation" type="Operation" isOrdered="true" upper="*" lower="0" isComposite="true" subsettedProperty="Classifier-feature Namespace-ownedMember" association="A_ownedOperation_class">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Class-ownedOperation-_ownedComment.0" annotatedElement="Class-ownedOperation">
					<body>The operations owned by the class.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Class-superClass" name="superClass" type="Class" upper="*" lower="0" redefinedProperty="Classifier-general" association="A_superClass_class">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Class-superClass-_ownedComment.0" annotatedElement="Class-superClass">
					<body>This gives the superclasses of a class.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Class-extension" name="extension" type="Extension" upper="*" lower="0" isReadOnly="true" isDerived="true" association="A_extension_metaclass">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Class-extension-_ownedComment.0" annotatedElement="Class-extension">
					<body>References the Extensions that specify additional properties of the metaclass. The property is derived from the extensions whose memberEnds are typed by the Class.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Class-inherit" name="inherit" class="Class" isQuery="true" redefinedOperation="Classifier-inherit" bodyCondition="Class-inherit-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Class-inherit-_ownedComment.0" annotatedElement="Class-inherit">
					<body>The inherit operation is overridden to exclude redefined properties.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Class-inherit-spec" name="spec" constrainedElement="Class-inherit" namespace="Class-inherit">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Class-inherit-spec-_specification">
						<language>OCL</language>
						<body>result = inhs->excluding(inh | ownedMember->select(oclIsKindOf(RedefinableElement))->select(redefinedElement->includes(inh)))</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Class-inherit-_ownedParameter.0" type="NamedElement" upper="*" lower="0" direction="return"/>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Class-inherit-inhs" name="inhs" type="NamedElement" upper="*" lower="0"/>
			</ownedOperation>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="ProfileApplication" name="ProfileApplication" superClass="DirectedRelationship">
			<ownedComment xmi:type="cmof:Comment" xmi:id="ProfileApplication-_ownedComment.0" annotatedElement="ProfileApplication">
				<body>A profile application is used to show which profiles have been applied to a package.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="ProfileApplication-appliedProfile" name="appliedProfile" type="Profile" subsettedProperty="DirectedRelationship-target" association="A_appliedProfile_profileApplication">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ProfileApplication-appliedProfile-_ownedComment.0" annotatedElement="ProfileApplication-appliedProfile">
					<body>References the Profiles that are applied to a Package through this ProfileApplication.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="ProfileApplication-isStrict" name="isStrict" type="Boolean" default="false">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ProfileApplication-isStrict-_ownedComment.0" annotatedElement="ProfileApplication-isStrict">
					<body>Specifies that the Profile filtering rules for the metaclasses of the referenced metamodel shall be strictly applied.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="ProfileApplication-applyingPackage" name="applyingPackage" type="Package" subsettedProperty="DirectedRelationship-source Element-owner" association="A_profileApplication_applyingPackage">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ProfileApplication-applyingPackage-_ownedComment.0" annotatedElement="ProfileApplication-applyingPackage">
					<body>The package that owns the profile application.</body>
				</ownedComment>
			</ownedAttribute>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="Extension" name="Extension" superClass="Association">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Extension-_ownedComment.0" annotatedElement="Extension">
				<body>An extension is used to indicate that the properties of a metaclass are extended through a stereotype, and gives the ability to flexibly add (and later remove) stereotypes to classes.</body>
			</ownedComment>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="Extension-non_owned_end" name="non_owned_end" constrainedElement="Extension" namespace="Extension">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Extension-non_owned_end-_ownedComment.0" annotatedElement="Extension-non_owned_end">
					<body>The non-owned end of an Extension is typed by a Class.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="Extension-non_owned_end-_specification">
					<language>OCL</language>
					<body>metaclassEnd()->notEmpty() and metaclass()->oclIsKindOf(Class)</body>
				</specification>
			</ownedRule>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="Extension-is_binary" name="is_binary" constrainedElement="Extension" namespace="Extension">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Extension-is_binary-_ownedComment.0" annotatedElement="Extension-is_binary">
					<body>An Extension is binary, i.e., it has only two memberEnds.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="Extension-is_binary-_specification">
					<language>OCL</language>
					<body>memberEnd->size() = 2</body>
				</specification>
			</ownedRule>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Extension-isRequired" name="isRequired" type="Boolean" isReadOnly="true" isDerived="true" default="false">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Extension-isRequired-_ownedComment.0" annotatedElement="Extension-isRequired">
					<body>Indicates whether an instance of the extending stereotype must be created when an instance of the extended class is created. The attribute value is derived from the multiplicity of the Property referenced by Extension::ownedEnd; a multiplicity of 1 means that isRequired is true, but otherwise it is false. Since the default multiplicity of an ExtensionEnd is 0..1, the default value of isRequired is false.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Extension-metaclass" name="metaclass" type="Class" isReadOnly="true" isDerived="true" association="A_extension_metaclass">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Extension-metaclass-_ownedComment.0" annotatedElement="Extension-metaclass">
					<body>References the Class that is extended through an Extension. The property is derived from the type of the memberEnd that is not the ownedEnd.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Extension-ownedEnd" name="ownedEnd" type="ExtensionEnd" isComposite="true" redefinedProperty="Association-ownedEnd" association="A_ownedEnd_extension">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Extension-ownedEnd-_ownedComment.0" annotatedElement="Extension-ownedEnd">
					<body>References the end of the extension that is typed by a Stereotype.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Extension-metaclassEnd" name="metaclassEnd" class="Extension" isQuery="true" bodyCondition="Extension-metaclassEnd-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Extension-metaclassEnd-_ownedComment.0" annotatedElement="Extension-metaclassEnd">
					<body>The query metaclassEnd() returns the Property that is typed by a metaclass (as opposed to a stereotype).</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Extension-metaclassEnd-spec" name="spec" constrainedElement="Extension-metaclassEnd" namespace="Extension-metaclassEnd">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Extension-metaclassEnd-spec-_specification">
						<language>OCL</language>
						<body>result = memberEnd->reject(ownedEnd)</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Extension-metaclassEnd-_ownedParameter.0" type="Property" direction="return"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Extension-metaclass.1" name="metaclass" class="Extension" isQuery="true" bodyCondition="Extension-metaclass.1-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Extension-metaclass.1-_ownedComment.0" annotatedElement="Extension-metaclass.1">
					<body>The query metaclass() returns the metaclass that is being extended (as opposed to the extending stereotype).</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Extension-metaclass.1-spec" name="spec" constrainedElement="Extension-metaclass.1" namespace="Extension-metaclass.1">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Extension-metaclass.1-spec-_specification">
						<language>OCL</language>
						<body>result = metaclassEnd().type</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Extension-metaclass.1-_ownedParameter.0" type="Class" direction="return"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Extension-isRequired.1" name="isRequired" class="Extension" isQuery="true" bodyCondition="Extension-isRequired.1-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Extension-isRequired.1-_ownedComment.0" annotatedElement="Extension-isRequired.1">
					<body>The query isRequired() is true if the owned end has a multiplicity with the lower bound of 1.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Extension-isRequired.1-spec" name="spec" constrainedElement="Extension-isRequired.1" namespace="Extension-isRequired.1">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Extension-isRequired.1-spec-_specification">
						<language>OCL</language>
						<body>result = (ownedEnd->lowerBound() = 1)</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Extension-isRequired.1-_ownedParameter.0" type="Boolean" direction="return"/>
			</ownedOperation>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="ExtensionEnd" name="ExtensionEnd" superClass="Property">
			<ownedComment xmi:type="cmof:Comment" xmi:id="ExtensionEnd-_ownedComment.0" annotatedElement="ExtensionEnd">
				<body>An extension end is used to tie an extension to a stereotype when extending a metaclass.</body>
			</ownedComment>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="ExtensionEnd-multiplicity" name="multiplicity" constrainedElement="ExtensionEnd" namespace="ExtensionEnd">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ExtensionEnd-multiplicity-_ownedComment.0" annotatedElement="ExtensionEnd-multiplicity">
					<body>The multiplicity of ExtensionEnd is 0..1 or 1.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="ExtensionEnd-multiplicity-_specification">
					<language>OCL</language>
					<body>(self->lowerBound() = 0 or self->lowerBound() = 1) and self->upperBound() = 1</body>
				</specification>
			</ownedRule>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="ExtensionEnd-aggregation" name="aggregation" constrainedElement="ExtensionEnd" namespace="ExtensionEnd">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ExtensionEnd-aggregation-_ownedComment.0" annotatedElement="ExtensionEnd-aggregation">
					<body>The aggregation of an ExtensionEnd is composite.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="ExtensionEnd-aggregation-_specification">
					<language>OCL</language>
					<body>self.aggregation = #composite</body>
				</specification>
			</ownedRule>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="ExtensionEnd-type" name="type" type="Stereotype" redefinedProperty="TypedElement-type" association="A_type_extensionEnd">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ExtensionEnd-type-_ownedComment.0" annotatedElement="ExtensionEnd-type">
					<body>References the type of the ExtensionEnd. Note that this association restricts the possible types of an ExtensionEnd to only be Stereotypes.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="ExtensionEnd-lower" name="lower" type="Integer" lower="0" default="0" redefinedProperty="MultiplicityElement-lower">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ExtensionEnd-lower-_ownedComment.0" annotatedElement="ExtensionEnd-lower">
					<body>This redefinition changes the default multiplicity of association ends, since model elements are usually extended by 0 or 1 instance of the extension stereotype.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="ExtensionEnd-lowerBound" name="lowerBound" class="ExtensionEnd" isQuery="true" redefinedOperation="MultiplicityElement-lowerBound" bodyCondition="ExtensionEnd-lowerBound-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="ExtensionEnd-lowerBound-_ownedComment.0" annotatedElement="ExtensionEnd-lowerBound">
					<body>The query lowerBound() returns the lower bound of the multiplicity as an Integer. This is a redefinition of the default&#xD;
lower bound, which normally, for MultiplicityElements, evaluates to 1 if empty.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="ExtensionEnd-lowerBound-spec" name="spec" constrainedElement="ExtensionEnd-lowerBound" namespace="ExtensionEnd-lowerBound">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="ExtensionEnd-lowerBound-spec-_specification">
						<language>OCL</language>
						<body>result = lowerBound = if lowerValue->isEmpty() then 0 else lowerValue->IntegerValue() endif</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="ExtensionEnd-lowerBound-_ownedParameter.0" type="Integer" direction="return"/>
			</ownedOperation>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="Image" name="Image" superClass="Element">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Image-_ownedComment.0" annotatedElement="Image">
				<body>Physical definition of a graphical image.</body>
			</ownedComment>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Image-content" name="content" type="String" lower="0">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Image-content-_ownedComment.0" annotatedElement="Image-content">
					<body>This contains the serialization of the image according to the format. The value could represent a bitmap, image such as a GIF file, or drawing 'instructions' using a standard such as Scalable Vector Graphic (SVG) (which is XML based).</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Image-location" name="location" type="String" lower="0">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Image-location-_ownedComment.0" annotatedElement="Image-location">
					<body>This contains a location that can be used by a tool to locate the image as an alternative to embedding it in the stereotype.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Image-format" name="format" type="String" lower="0">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Image-format-_ownedComment.0" annotatedElement="Image-format">
					<body>This indicates the format of the content - which is how the string content should be interpreted. The following values are reserved: SVG, GIF, PNG, JPG, WMF, EMF, BMP.&#xD;
&#xD;
In addition the prefix 'MIME: ' is also reserved. This option can be used as an alternative to express the reserved values above, for example &quot;SVG&quot; could instead be expressed as &quot;MIME: image/svg+xml&quot;.</body>
				</ownedComment>
			</ownedAttribute>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="Element" name="Element" isAbstract="true">
			<ownedComment xmi:type="cmof:Comment" xmi:id="Element-_ownedComment.0" annotatedElement="Element">
				<body>An element is a constituent of a model. As such, it has the capability of owning other elements.</body>
			</ownedComment>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="Element-not_own_self" name="not_own_self" constrainedElement="Element" namespace="Element">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Element-not_own_self-_ownedComment.0" annotatedElement="Element-not_own_self">
					<body>An element may not directly or indirectly own itself.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="Element-not_own_self-_specification">
					<language>OCL</language>
					<body>not self.allOwnedElements()->includes(self)</body>
				</specification>
			</ownedRule>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="Element-has_owner" name="has_owner" constrainedElement="Element" namespace="Element">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Element-has_owner-_ownedComment.0" annotatedElement="Element-has_owner">
					<body>Elements that must be owned must have an owner.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="Element-has_owner-_specification">
					<language>OCL</language>
					<body>self.mustBeOwned() implies owner->notEmpty()</body>
				</specification>
			</ownedRule>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Element-ownedElement" name="ownedElement" type="Element" upper="*" lower="0" isReadOnly="true" isDerived="true" isDerivedUnion="true" isComposite="true" association="A_ownedElement_owner">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Element-ownedElement-_ownedComment.0" annotatedElement="Element-ownedElement">
					<body>The Elements owned by this element.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Element-owner" name="owner" type="Element" lower="0" isReadOnly="true" isDerived="true" isDerivedUnion="true" association="A_ownedElement_owner">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Element-owner-_ownedComment.0" annotatedElement="Element-owner">
					<body>The Element that owns this element.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="Element-ownedComment" name="ownedComment" type="Comment" upper="*" lower="0" isComposite="true" subsettedProperty="Element-ownedElement" association="A_ownedComment_owningElement">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Element-ownedComment-_ownedComment.0" annotatedElement="Element-ownedComment">
					<body>The Comments owned by this element.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Element-allOwnedElements" name="allOwnedElements" class="Element" isQuery="true" bodyCondition="Element-allOwnedElements-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Element-allOwnedElements-_ownedComment.0" annotatedElement="Element-allOwnedElements">
					<body>The query allOwnedElements() gives all of the direct and indirect owned elements of an element.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Element-allOwnedElements-spec" name="spec" constrainedElement="Element-allOwnedElements" namespace="Element-allOwnedElements">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Element-allOwnedElements-spec-_specification">
						<language>OCL</language>
						<body>result = ownedElement->union(ownedElement->collect(e | e.allOwnedElements()))</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Element-allOwnedElements-_ownedParameter.0" type="Element" upper="*" lower="0" direction="return"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="Element-mustBeOwned" name="mustBeOwned" class="Element" isQuery="true" bodyCondition="Element-mustBeOwned-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="Element-mustBeOwned-_ownedComment.0" annotatedElement="Element-mustBeOwned">
					<body>The query mustBeOwned() indicates whether elements of this type must have an owner. Subclasses of Element that do not require an owner must override this operation.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="Element-mustBeOwned-spec" name="spec" constrainedElement="Element-mustBeOwned" namespace="Element-mustBeOwned">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="Element-mustBeOwned-spec-_specification">
						<language>OCL</language>
						<body>result = true</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="Element-mustBeOwned-_ownedParameter.0" type="Boolean" direction="return"/>
			</ownedOperation>
		</ownedMember>
		<ownedMember xmi:type="cmof:Class" xmi:id="NamedElement" name="NamedElement" isAbstract="true" superClass="Element">
			<ownedComment xmi:type="cmof:Comment" xmi:id="NamedElement-_ownedComment.0" annotatedElement="NamedElement">
				<body>A named element is an element in a model that may have a name.</body>
			</ownedComment>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="NamedElement-has_no_qualified_name" name="has_no_qualified_name" constrainedElement="NamedElement" namespace="NamedElement">
				<ownedComment xmi:type="cmof:Comment" xmi:id="NamedElement-has_no_qualified_name-_ownedComment.0" annotatedElement="NamedElement-has_no_qualified_name">
					<body>If there is no name, or one of the containing namespaces has no name, there is no qualified name.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="NamedElement-has_no_qualified_name-_specification">
					<language>OCL</language>
					<body>(self.name->isEmpty() or self.allNamespaces()->select(ns | ns.name->isEmpty())->notEmpty())&#xD;&#xA;  implies self.qualifiedName->isEmpty()</body>
				</specification>
			</ownedRule>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="NamedElement-has_qualified_name" name="has_qualified_name" constrainedElement="NamedElement" namespace="NamedElement">
				<ownedComment xmi:type="cmof:Comment" xmi:id="NamedElement-has_qualified_name-_ownedComment.0" annotatedElement="NamedElement-has_qualified_name">
					<body>When there is a name, and all of the containing namespaces have a name, the qualified name is constructed from the names of the containing namespaces.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="NamedElement-has_qualified_name-_specification">
					<language>OCL</language>
					<body>(self.name->notEmpty() and self.allNamespaces()->select(ns | ns.name->isEmpty())->isEmpty()) implies&#xA;  self.qualifiedName = self.allNamespaces()->iterate( ns : Namespace; result: String = self.name | ns.name->union(self.separator())->union(result))</body>
				</specification>
			</ownedRule>
			<ownedRule xmi:type="cmof:Constraint" xmi:id="NamedElement-visibility_needs_ownership" name="visibility_needs_ownership" constrainedElement="NamedElement" namespace="NamedElement">
				<ownedComment xmi:type="cmof:Comment" xmi:id="NamedElement-visibility_needs_ownership-_ownedComment.0" annotatedElement="NamedElement-visibility_needs_ownership">
					<body>If a NamedElement is not owned by a Namespace, it does not have a visibility.</body>
				</ownedComment>
				<specification xmi:type="cmof:OpaqueExpression" xmi:id="NamedElement-visibility_needs_ownership-_specification">
					<language>OCL</language>
					<body>namespace->isEmpty() implies visibility->isEmpty()</body>
				</specification>
			</ownedRule>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="NamedElement-name" name="name" type="String" lower="0">
				<ownedComment xmi:type="cmof:Comment" xmi:id="NamedElement-name-_ownedComment.0" annotatedElement="NamedElement-name">
					<body>The name of the NamedElement.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="NamedElement-visibility" name="visibility" type="VisibilityKind" lower="0">
				<ownedComment xmi:type="cmof:Comment" xmi:id="NamedElement-visibility-_ownedComment.0" annotatedElement="NamedElement-visibility">
					<body>Determines where the NamedElement appears within different Namespaces within the overall model, and its accessibility.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="NamedElement-namespace" name="namespace" type="Namespace" lower="0" isReadOnly="true" isDerived="true" isDerivedUnion="true" subsettedProperty="Element-owner" association="A_ownedMember_namespace">
				<ownedComment xmi:type="cmof:Comment" xmi:id="NamedElement-namespace-_ownedComment.0" annotatedElement="NamedElement-namespace">
					<body>Specifies the namespace that owns the NamedElement.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedAttribute xmi:type="cmof:Property" xmi:id="NamedElement-qualifiedName" name="qualifiedName" type="String" lower="0" isReadOnly="true" isDerived="true">
				<ownedComment xmi:type="cmof:Comment" xmi:id="NamedElement-qualifiedName-_ownedComment.0" annotatedElement="NamedElement-qualifiedName">
					<body>A name which allows the NamedElement to be identified within a hierarchy of nested Namespaces. It is constructed from the names of the containing namespaces starting at the root of the hierarchy and ending with the name of the NamedElement itself.</body>
				</ownedComment>
			</ownedAttribute>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="NamedElement-allNamespaces" name="allNamespaces" class="NamedElement" isQuery="true" bodyCondition="NamedElement-allNamespaces-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="NamedElement-allNamespaces-_ownedComment.0" annotatedElement="NamedElement-allNamespaces">
					<body>The query allNamespaces() gives the sequence of namespaces in which the NamedElement is nested, working outwards.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="NamedElement-allNamespaces-spec" name="spec" constrainedElement="NamedElement-allNamespaces" namespace="NamedElement-allNamespaces">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="NamedElement-allNamespaces-spec-_specification">
						<language>OCL</language>
						<body>result = if self.namespace->isEmpty()&#xA;then Sequence{}&#xA;else self.namespace.allNamespaces()->prepend(self.namespace)&#xA;endif</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="NamedElement-allNamespaces-_ownedParameter.0" type="Namespace" isOrdered="true" upper="*" lower="0" direction="return"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="NamedElement-isDistinguishableFrom" name="isDistinguishableFrom" class="NamedElement" isQuery="true" bodyCondition="NamedElement-isDistinguishableFrom-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="NamedElement-isDistinguishableFrom-_ownedComment.0" annotatedElement="NamedElement-isDistinguishableFrom">
					<body>The query isDistinguishableFrom() determines whether two NamedElements may logically co-exist within a Namespace. By default, two named elements are distinguishable if (a) they have unrelated types or (b) they have related types but different names.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="NamedElement-isDistinguishableFrom-spec" name="spec" constrainedElement="NamedElement-isDistinguishableFrom" namespace="NamedElement-isDistinguishableFrom">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="NamedElement-isDistinguishableFrom-spec-_specification">
						<language>OCL</language>
						<body>result = if self.oclIsKindOf(n.oclType) or n.oclIsKindOf(self.oclType)&#xA;then ns.getNamesOfMember(self)->intersection(ns.getNamesOfMember(n))->isEmpty()&#xA;else true&#xA;endif</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="NamedElement-isDistinguishableFrom-_ownedParameter.0" type="Boolean" direction="return"/>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="NamedElement-isDistinguishableFrom-n" name="n" type="NamedElement"/>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="NamedElement-isDistinguishableFrom-ns" name="ns" type="Namespace"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="NamedElement-separator" name="separator" class="NamedElement" isQuery="true" bodyCondition="NamedElement-separator-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="NamedElement-separator-_ownedComment.0" annotatedElement="NamedElement-separator">
					<body>The query separator() gives the string that is used to separate names when constructing a qualified name.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="NamedElement-separator-spec" name="spec" constrainedElement="NamedElement-separator" namespace="NamedElement-separator">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="NamedElement-separator-spec-_specification">
						<language>OCL</language>
						<body>result = '::'</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="NamedElement-separator-_ownedParameter.0" type="String" direction="return"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="NamedElement-qualifiedName.1" name="qualifiedName" class="NamedElement" isQuery="true" bodyCondition="NamedElement-qualifiedName.1-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="NamedElement-qualifiedName.1-_ownedComment.0" annotatedElement="NamedElement-qualifiedName.1">
					<body>When there is a name, and all of the containing namespaces have a name, the qualified name is constructed from the names of the containing namespaces.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="NamedElement-qualifiedName.1-spec" name="spec" constrainedElement="NamedElement-qualifiedName.1" namespace="NamedElement-qualifiedName.1">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="NamedElement-qualifiedName.1-spec-_specification">
						<language>OCL</language>
						<body>result = if self.name->notEmpty() and self.allNamespaces()->select(ns | ns.name->isEmpty())->isEmpty()&#xA;then &#xA;    self.allNamespaces()->iterate( ns : Namespace; result: String = self.name | ns.name->union(self.separator())->union(result))&#xA;else&#xA;    Set{}&#xA;endif</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="NamedElement-qualifiedName.1-_ownedParameter.0" type="String" direction="return"/>
			</ownedOperation>
			<ownedOperation xmi:type="cmof:Operation" xmi:id="NamedElement-allOwningPackages" name="allOwningPackages" class="NamedElement" isQuery="true" bodyCondition="NamedElement-allOwningPackages-spec">
				<ownedComment xmi:type="cmof:Comment" xmi:id="NamedElement-allOwningPackages-_ownedComment.0" annotatedElement="NamedElement-allOwningPackages">
					<body>The query allOwningPackages() returns all the directly or indirectly owning packages.</body>
				</ownedComment>
				<ownedRule xmi:type="cmof:Constraint" xmi:id="NamedElement-allOwningPackages-spec" name="spec" constrainedElement="NamedElement-allOwningPackages" namespace="NamedElement-allOwningPackages">
					<specification xmi:type="cmof:OpaqueExpression" xmi:id="NamedElement-allOwningPackages-spec-_specification">
						<language>OCL</language>
						<body>result = self.namespace->select(p | p.oclIsKindOf(Package))->union(p.allOwningPackages())</body>
					</specification>
				</ownedRule>
				<ownedParameter xmi:type="cmof:Parameter" xmi:id="NamedElement-allOwningPackages-_ownedParameter.0" type="Package" upper="*" lower="0" direction="return"/>
			</ownedOperation>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_profileApplication_applyingPackage" name="A_profileApplication_applyingPackage" general="A_ownedElement_owner A_source_directedRelationship" memberEnd="Package-profileApplication ProfileApplication-applyingPackage"/>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_ownedStereotype_profile" name="A_ownedStereotype_profile" general="A_packagedElement_owningPackage" memberEnd="Profile-ownedStereotype A_ownedStereotype_profile-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_ownedStereotype_profile-_ownedEnd.0" type="Profile" owningAssociation="A_ownedStereotype_profile" association="A_ownedStereotype_profile"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_appliedProfile_profileApplication" name="A_appliedProfile_profileApplication" general="A_target_directedRelationship" memberEnd="ProfileApplication-appliedProfile A_appliedProfile_profileApplication-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_appliedProfile_profileApplication-_ownedEnd.0" type="ProfileApplication" upper="*" lower="0" owningAssociation="A_appliedProfile_profileApplication" association="A_appliedProfile_profileApplication"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_extension_metaclass" name="A_extension_metaclass" memberEnd="Class-extension Extension-metaclass" isDerived="true"/>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_ownedEnd_extension" name="A_ownedEnd_extension" general="A_ownedEnd_owningAssociation" memberEnd="Extension-ownedEnd A_ownedEnd_extension-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_ownedEnd_extension-_ownedEnd.0" type="Extension" owningAssociation="A_ownedEnd_extension" association="A_ownedEnd_extension"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_type_extensionEnd" name="A_type_extensionEnd" general="A_type_typedElement" memberEnd="ExtensionEnd-type A_type_extensionEnd-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_type_extensionEnd-_ownedEnd.0" type="ExtensionEnd" upper="*" lower="0" owningAssociation="A_type_extensionEnd" association="A_type_extensionEnd"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_metaclassReference_profile" name="A_metaclassReference_profile" general="A_elementImport_importingNamespace" memberEnd="Profile-metaclassReference A_metaclassReference_profile-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_metaclassReference_profile-_ownedEnd.0" type="Profile" lower="0" owningAssociation="A_metaclassReference_profile" association="A_metaclassReference_profile"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_metamodelReference_profile" name="A_metamodelReference_profile" general="A_packageImport_importingNamespace" memberEnd="Profile-metamodelReference A_metamodelReference_profile-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_metamodelReference_profile-_ownedEnd.0" type="Profile" lower="0" owningAssociation="A_metamodelReference_profile" association="A_metamodelReference_profile"/>
		</ownedMember>
		<ownedMember xmi:type="cmof:Association" xmi:id="A_icon_stereotype" name="A_icon_stereotype" memberEnd="Stereotype-icon A_icon_stereotype-_ownedEnd.0">
			<ownedEnd xmi:type="cmof:Property" xmi:id="A_icon_stereotype-_ownedEnd.0" type="Stereotype" lower="0" owningAssociation="A_icon_stereotype" association="A_icon_stereotype"/>
		</ownedMember>
	</cmof:Package>
	<cmof:Tag xmi:id="_1" name="org.omg.xmi.nsPrefix" value="spem" element="_0"/>
	<cmof:Tag xmi:id="_2" name="org.omg.xmi.nsURI" value="http://schema.omg.org/spec/SPEM/2.0/spem.xml" element="_0"/>
	<cmof:Tag xmi:id="_3" name="org.omg.xmi.schemaType" value="http://www.w3.org/2001/XMLSchema#integer" element="Integer"/>
	<cmof:Tag xmi:id="_4" name="org.omg.xmi.schemaType" value="http://www.w3.org/2001/XMLSchema#boolean" element="Boolean"/>
</xmi:XMI>
