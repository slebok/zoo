<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="EN" xml:lang="EN">
<head>
<meta name="generator" content=
"HTML Tidy for Windows (vers 14 February 2006), see www.w3.org" />
<title>XML Path Language (XPath) 2.0 (Second Edition)</title>

<style type="text/css">
/*<![CDATA[*/
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }

div.issue
p.title        { margin-left: -2em; }

ol.enumar      { list-style-type: decimal; }
ol.enumla      { list-style-type: lower-alpha; }
ol.enumlr      { list-style-type: lower-roman; }
ol.enumua      { list-style-type: upper-alpha; }
ol.enumur      { list-style-type: upper-roman; }

li p           { margin-top: 0.3em;
                 margin-bottom: 0.3em; }

sup small      { font-style: italic;
                 color: #8F8F8F;
               }
    
div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}

div.issue { border-bottom-color: black;
            border-bottom-style: solid;
            border-bottom-width: 1pt;
            margin-bottom: 20pt;
}

th.issue-toc-head { border-bottom-color: black;
                    border-bottom-style: solid;
                    border-bottom-width: 1pt;
}

/*]]>*/
</style>
<link rel="stylesheet" type="text/css" href=
"http://www.w3.org/StyleSheets/TR/W3C-REC.css" /></head>
<body>
<div class="head">
<p><a href="http://www.w3.org/"><img src=
"http://www.w3.org/Icons/w3c_home" alt="W3C" height="48" width=
"72" /></a></p>
<h1><a name="title" id="title"></a>XML Path Language (XPath)
2.0 (Second Edition)</h1>
<h2><a name="w3c-doctype" id="w3c-doctype"></a>W3C Recommendation
14 December 2010 <em>(Link errors corrected 3 January 2011)</em></h2>
<dl>
<dt>This version:</dt>
<dd><span class="xpath"><a href=
"http://www.w3.org/TR/2010/REC-xpath20-20101214/">http://www.w3.org/TR/2010/REC-xpath20-20101214/</a></span></dd>
<dt>Latest version:</dt>
<dd><span class="xpath"><a href=
"http://www.w3.org/TR/xpath20/">http://www.w3.org/TR/xpath20/</a></span></dd>
<dt>Previous versions:</dt>
<dd><span class="xpath"><a href=
"http://www.w3.org/TR/2009/PER-xpath20-20090421/">http://www.w3.org/TR/2009/PER-xpath20-20090421/,</a></span>
<span class="xpath"><a href=
"http://www.w3.org/TR/2007/REC-xpath20-20070123/">http://www.w3.org/TR/2007/REC-xpath20-20070123/</a></span></dd>
<dt>Editors:</dt>
<dd class="xpath">Anders Berglund (XSL WG), BC&amp;TF <a href=
"http://www.albconsults.com">&lt;http://www.albconsults.com&gt;</a></dd>
<dd>Scott Boag (XSL WG), IBM Research <a href=
"mailto:scott_boag@us.ibm.com">&lt;scott_boag@us.ibm.com&gt;</a></dd>
<dd>Don Chamberlin (XML Query WG) <a href=
"mailto:dchamber@us.ibm.com">&lt;dchamber@us.ibm.com&gt;</a></dd>
<dd>Mary F. Fernández (XML Query WG), AT&amp;T Labs <a href=
"mailto:mff@research.att.com">&lt;mff@research.att.com&gt;</a></dd>
<dd class="xpath">Michael Kay (XSL WG), Saxonica, via <a href=
"http://www.saxonica.com/">http://www.saxonica.com/</a></dd>
<dd>Jonathan Robie (XML Query WG), <span><a href=
"http://www.redhat.com">Red Hat</a></span>, via <a href=
"http://www.ibiblio.org/jwrobie/">http://www.ibiblio.org/jwrobie/</a></dd>
<dd>Jérôme Siméon (XML Query WG), IBM T.J. Watson Research Center
<a href=
"mailto:simeon@us.ibm.com">&lt;simeon@us.ibm.com&gt;</a></dd>
</dl>
<p>Please refer to the <a href=
"http://www.w3.org/XML/2010/qt-errata/xpath20-errata2e.html"><strong>
errata</strong></a> for this document, which may include some
normative corrections.</p>
<p>See also <a href=
"http://www.w3.org/2003/03/Translations/byTechnology?technology=xpath20">
<strong>translations</strong></a>.</p>
<p>This document is also available in these non-normative formats:
<span class="xpath"><a href=
"http://www.w3.org/TR/2010/REC-xpath20-20101214/xpath20-20101214.xml">
XML</a></span> and&#160;<span class="xpath"><a href=
"http://www.w3.org/TR/2010/REC-xpath20-20101214/xpath20-diff-from-REC20070123.html">Change
markings relative to first edition</a></span>.</p>
<p class="copyright"><a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>&#160;©&#160;2010&#160;<a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>®</sup>
(<a href="http://www.csail.mit.edu/"><acronym title=
"Massachusetts Institute of Technology">MIT</acronym></a>, <a href=
"http://www.ercim.eu/"><acronym title=
"European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>,
<a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved.
W3C <a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
<a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a>
and <a href=
"http://www.w3.org/Consortium/Legal/copyright-documents">document
use</a> rules apply.</p>
</div>
<hr />
<div>
<h2><a name="abstract" id="abstract"></a>Abstract</h2>
<div class="xpath">
<p class="xpath">XPath 2.0 is an expression language that allows
the processing of values conforming to the data model defined in
<a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model (Second
Edition)]</a>. The data model provides a tree representation of XML
documents as well as atomic values such as integers, strings, and
booleans, and sequences that may contain both references to nodes
in an XML document and atomic values. The result of an XPath
expression may be a selection of nodes from the input documents, or
an atomic value, or more generally, any sequence allowed by the
data model. The name of the language derives from its most
distinctive feature, the path expression, which provides a means of
hierarchic addressing of the nodes in an XML tree. XPath 2.0 is a
superset of <a href="#XPath">[XPath 1.0]</a>, with the added
capability to support a richer set of data types, and to take
advantage of the type information that becomes available when
documents are validated using XML Schema. A backwards compatibility
mode is provided to ensure that nearly all XPath 1.0 expressions
continue to deliver the same result with XPath 2.0; exceptions to
this policy are noted in [<a href=
"#id-backwards-compatibility"><b>I Backwards Compatibility with
XPath 1.0</b></a>].</p>
</div>
</div>
<div>
<h2><a name="status" id="status"></a>Status of this Document</h2>
<p><em>This section describes the status of this document at the
time of its publication. Other documents may supersede this
document. A list of current W3C publications and the latest
revision of this technical report can be found in the <a href=
"http://www.w3.org/TR/">W3C technical reports index</a> at
http://www.w3.org/TR/.</em></p>
<p>This is one document in a set of eight documents that are being
progressed to Edited Recommendation together (XPath 2.0, XQuery
1.0, XQueryX 1.0, XSLT 2.0, Data Model (XDM), Functions and
Operators, Formal Semantics, Serialization).</p>
<p>This document, published on 14 December 2010, is an Edited
<a href=
"http://www.w3.org/2004/02/Process-20040205/tr.html#RecsW3C">Recommendation</a>
of the W3C. It supersedes the previous W3C Recommendation of 23
January 2007. This second edition is not a new version of this
specification; its purpose is to clarify a number of issues that
have become apparent since the first edition was published. All of
these clarifications (excepting trivial editorial fixes) have been
published in a separate errata document, and published in a
<a href="http://www.w3.org/2004/02/Process-20040205/tr.html#ProposedEditedRec">
Proposed Edited Recommendation</a> in April 2009. The changes are
summarized in an appendix. On 3 January 2011, the original
publication of this Recommendation was replaced by this version in
which two HTML anchors that were omitted by the original
publication have been restored; the W3C Team has retained a copy of
the original publication. This document <span class=
"xpath"><span class="xpath">has been jointly developed by the W3C
<a href="http://www.w3.org/Style/XSL/">XSL Working Group</a> and
the W3C <a href="http://www.w3.org/XML/Query/">XML Query Working
Group</a>, each of which is part of the <a href=
"http://www.w3.org/XML/Activity">XML
Activity</a>.</span></span></p>
<p>This document has been reviewed by W3C Members, by software
developers, and by other W3C groups and interested parties, and is
endorsed by the Director as a W3C Recommendation. It is a stable
document and may be used as reference material or cited from
another document. W3C's role in making the Recommendation is to
draw attention to the specification and to promote its widespread
deployment. This enhances the functionality and interoperability of
the Web.</p>
<p><span class="xpath"><span class="xpath">This document
incorporates changes made against the <a href=
"http://www.w3.org/2004/02/Process-20040205/tr.html#RecsW3C">Recommendation</a>
of 23 January 2007 that resolve all errata known at the date of
publication. Changes to this document since the first edition are
detailed in the <a href="#id-revisions-log"><b>J Changes since the
First Edition</b></a>. This document supersedes the <a href=
"http://www.w3.org/TR/2007/REC-xpath20-20070123/">first
edition</a>.</span></span></p>
<div class="xpath">
<p class="xpath">This specification is designed to be referenced
normatively from other specifications defining a host language for
it; it is not intended to be implemented outside a host language.
The implementability of this specification has been tested in the
context of its normative inclusion in host languages defined by the
<a href="http://www.w3.org/TR/xquery/">XQuery 1.0</a> and <a href=
"http://www.w3.org/TR/xslt20/">XSLT 2.0</a> specifications; see the
<a href=
"http://www.w3.org/XML/Query/test-suite/XQTSReport.html">XQuery 1.0
implementation report</a> and the <a href=
"http://www.w3.org/XML/Group/xslt20-test/Documentation/reportSummary.html">
XSLT 2.0 implementation report</a> (member-only) for details.</p>
</div>
<p>Please report errors in and submit comments on this document
using W3C's <a href="http://www.w3.org/Bugs/Public/">public
Bugzilla system</a> (instructions can be found at <a href=
"http://www.w3.org/XML/2005/04/qt-bugzilla">http://www.w3.org/XML/2005/04/qt-bugzilla</a>).
If access to that system is not feasible, you may send your
comments to the W3C XSLT/XPath/XQuery public comments mailing list,
<a href=
"mailto:public-qt-comments@w3.org">public-qt-comments@w3.org</a>.
It will be very helpful if you include the string “<span class=
"xpath"><span class="xpath">[XPath]</span></span>” in the subject
line of your report, whether made in Bugzilla or in email. Each
Bugzilla entry and email message should contain only one error
report. Archives of the comments and responses are available at
<a href=
"http://lists.w3.org/Archives/Public/public-qt-comments/">http://lists.w3.org/Archives/Public/public-qt-comments/</a>.</p>
<p>This document was produced by <span class="xpath"><span class=
"xpath">groups</span></span> operating under the <a href=
"http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February
2004 W3C Patent Policy</a>. W3C maintains a <a href=
"http://www.w3.org/2004/01/pp-impl/18797/status#disclosures">public
list of any patent disclosures</a> made in connection with the
deliverables of the <span class="xpath"><span class="xpath">XML
Query Working Group</span></span> <span class="xpath"><span class=
"xpath">and also maintains a <a href=
"http://www.w3.org/2004/01/pp-impl/19552/status#disclosures">public
list of any patent disclosures</a> made in connection with the
deliverables of the XSL Working Group; those pages also
include</span></span> instructions for disclosing a patent. An
individual who has actual knowledge of a patent which the
individual believes contains <a href=
"http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">
Essential Claim(s)</a> must disclose the information in accordance
with <a href=
"http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">
section 6 of the W3C Patent Policy</a>.</p>
</div>
<div class="toc">
<h2><a name="contents" id="contents"></a>Table of Contents</h2>
<p class="toc">1 <a href="#id-introduction">Introduction</a><br />
2 <a href="#id-basics">Basics</a><br />
&#160;&#160;&#160;&#160;2.1 <a href="#context">Expression
Context</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1.1 <a href=
"#static_context">Static Context</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.1.2 <a href=
"#eval_context">Dynamic Context</a><br />
&#160;&#160;&#160;&#160;2.2 <a href=
"#id-processing-model">Processing Model</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.1 <a href=
"#id-data-model-generation">Data Model Generation</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.2 <a href=
"#id-schema-import-processing">Schema Import Processing</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.3 <a href=
"#id-expression-processing">Expression Processing</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.3.1
<a href="#id-static-analysis">Static Analysis Phase</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.3.2
<a href="#id-dynamic-evaluation">Dynamic Evaluation Phase</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.4 <a href=
"#id-serialization">Serialization</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.2.5 <a href=
"#id-consistency-constraints">Consistency Constraints</a><br />
&#160;&#160;&#160;&#160;2.3 <a href="#errors">Error
Handling</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.1 <a href=
"#id-kinds-of-errors">Kinds of Errors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.2 <a href=
"#id-identifying-errors">Identifying and Reporting Errors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.3 <a href=
"#id-handling-dynamic">Handling Dynamic Errors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.4 <a href=
"#id-errors-and-opt">Errors and Optimization</a><br />
&#160;&#160;&#160;&#160;2.4 <a href=
"#id-important-concepts">Concepts</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.1 <a href=
"#id-document-order">Document Order</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.2 <a href=
"#id-atomization">Atomization</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.3 <a href=
"#id-ebv">Effective Boolean Value</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.4.4 <a href=
"#id-input-sources">Input Sources</a><br />
&#160;&#160;&#160;&#160;2.5 <a href="#id-types">Types</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.1 <a href=
"#id-predefined-types">Predefined Schema Types</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.2 <a href=
"#id-typed-value">Typed Value and String Value</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.3 <a href=
"#id-sequencetype-syntax">SequenceType Syntax</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.4 <a href=
"#id-sequencetype-matching">SequenceType Matching</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.4.1
<a href="#id-matching-value">Matching a SequenceType and a
Value</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.4.2
<a href="#id-matching-item">Matching an ItemType and an
Item</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.4.3
<a href="#id-element-test">Element Test</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.4.4
<a href="#id-schema-element-test">Schema Element Test</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.4.5
<a href="#id-attribute-test">Attribute Test</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.5.4.6
<a href="#id-schema-attribute-test">Schema Attribute Test</a><br />
&#160;&#160;&#160;&#160;2.6 <a href="#comments">Comments</a><br />
3 <a href="#id-expressions">Expressions</a><br />
&#160;&#160;&#160;&#160;3.1 <a href=
"#id-primary-expressions">Primary Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.1 <a href=
"#id-literals">Literals</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.2 <a href=
"#id-variables">Variable References</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.3 <a href=
"#id-paren-expressions">Parenthesized Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.4 <a href=
"#id-context-item-expression">Context Item Expression</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.1.5 <a href=
"#id-function-calls">Function Calls</a><br />
&#160;&#160;&#160;&#160;3.2 <a href="#id-path-expressions">Path
Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.1 <a href=
"#id-steps">Steps</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.1.1
<a href="#axes">Axes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.1.2
<a href="#node-tests">Node Tests</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.2 <a href=
"#id-predicates">Predicates</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.3 <a href=
"#unabbrev">Unabbreviated Syntax</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.2.4 <a href=
"#abbrev">Abbreviated Syntax</a><br />
&#160;&#160;&#160;&#160;3.3 <a href=
"#id-sequence-expressions">Sequence Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.3.1 <a href=
"#construct_seq">Constructing Sequences</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.3.2 <a href=
"#id-filter-expr">Filter Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.3.3 <a href=
"#combining_seq">Combining Node Sequences</a><br />
&#160;&#160;&#160;&#160;3.4 <a href="#id-arithmetic">Arithmetic
Expressions</a><br />
&#160;&#160;&#160;&#160;3.5 <a href="#id-comparisons">Comparison
Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.5.1 <a href=
"#id-value-comparisons">Value Comparisons</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.5.2 <a href=
"#id-general-comparisons">General Comparisons</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.5.3 <a href=
"#id-node-comparisons">Node Comparisons</a><br />
&#160;&#160;&#160;&#160;3.6 <a href=
"#id-logical-expressions">Logical Expressions</a><br />
&#160;&#160;&#160;&#160;3.7 <a href="#id-for-expressions">For
Expressions</a><br />
&#160;&#160;&#160;&#160;3.8 <a href="#id-conditionals">Conditional
Expressions</a><br />
&#160;&#160;&#160;&#160;3.9 <a href=
"#id-quantified-expressions">Quantified Expressions</a><br />
&#160;&#160;&#160;&#160;3.10 <a href=
"#id-expressions-on-datatypes">Expressions on
SequenceTypes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.1 <a href=
"#id-instance-of">Instance Of</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.2 <a href=
"#id-cast">Cast</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.3 <a href=
"#id-castable">Castable</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.4 <a href=
"#id-constructor-functions">Constructor Functions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.5 <a href=
"#id-treat">Treat</a><br /></p>
<h3><a name="appendices" id="appendices"></a>Appendices</h3>
<p class="toc">A <a href="#nt-bnf">XPath Grammar</a><br />
&#160;&#160;&#160;&#160;A.1 <a href="#id-grammar">EBNF</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.1.1 <a href=
"#EBNFNotation">Notation</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.1.2 <a href=
"#extra-grammatical-constraints">Extra-grammatical
Constraints</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.1.3 <a href=
"#notes-on-parsing">Grammar Notes</a><br />
&#160;&#160;&#160;&#160;A.2 <a href="#lexical-structure">Lexical
structure</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.1 <a href=
"#terminal-symbols">Terminal Symbols</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.2 <a href=
"#id-terminal-delimitation">Terminal Delimitation</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.3 <a href=
"#id-eol-handling">End-of-Line Handling</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.3.1
<a href="#id-xml10-eol-handling">XML 1.0 End-of-Line
Handling</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.3.2
<a href="#id-xml11-eol-handling">XML 1.1 End-of-Line
Handling</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.4 <a href=
"#whitespace-rules">Whitespace Rules</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.4.1
<a href="#DefaultWhitespaceHandling">Default Whitespace
Handling</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A.2.4.2
<a href="#ExplicitWhitespaceHandling">Explicit Whitespace
Handling</a><br />
&#160;&#160;&#160;&#160;A.3 <a href=
"#id-reserved-fn-names">Reserved Function Names</a><br />
&#160;&#160;&#160;&#160;A.4 <a href=
"#id-precedence-order">Precedence Order</a><br />
B <a href="#id-type-promotion-and-operator-mapping">Type Promotion
and Operator Mapping</a><br />
&#160;&#160;&#160;&#160;B.1 <a href="#promotion">Type
Promotion</a><br />
&#160;&#160;&#160;&#160;B.2 <a href="#mapping">Operator
Mapping</a><br />
C <a href="#id-xp-context-components">Context Components</a><br />
&#160;&#160;&#160;&#160;C.1 <a href=
"#id-xp-static-context-components">Static Context
Components</a><br />
&#160;&#160;&#160;&#160;C.2 <a href=
"#id-xp-evaluation-context-components">Dynamic Context
Components</a><br />
D <a href="#id-impl-defined-items">Implementation-Defined
Items</a><br />
E <a href="#id-references">References</a><br />
&#160;&#160;&#160;&#160;E.1 <a href=
"#id-normative-references">Normative References</a><br />
&#160;&#160;&#160;&#160;E.2 <a href=
"#id-non-normative-references">Non-normative References</a><br />
&#160;&#160;&#160;&#160;E.3 <a href=
"#id-background-material">Background Material</a><br />
F <a href="#id-xpath-conformance">Conformance</a><br />
&#160;&#160;&#160;&#160;F.1 <a href=
"#id-xpath-static-typing">Static Typing Feature</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;F.1.1 <a href=
"#id-xpath-static-extensions">Static Typing Extensions</a><br />
G <a href="#id-errors">Error Conditions</a><br />
H <a href="#id-glossary">Glossary</a> (Non-Normative)<br />
I <a href="#id-backwards-compatibility">Backwards Compatibility
with XPath 1.0</a> (Non-Normative)<br />
&#160;&#160;&#160;&#160;I.1 <a href=
"#id-incompat-in-true-mode">Incompatibilities when Compatibility
Mode is true</a><br />
&#160;&#160;&#160;&#160;I.2 <a href=
"#id-incompat-in-false-mode">Incompatibilities when Compatibility
Mode is false</a><br />
&#160;&#160;&#160;&#160;I.3 <a href=
"#id-incompat-when-using-schema">Incompatibilities when using a
Schema</a><br />
J <a href="#id-revisions-log">Changes since the First Edition</a>
(Non-Normative)<br /></p>
</div>
<hr />
<div class="body">
<div class="div1">
<h2><a name="id-introduction" id="id-introduction"></a>1
Introduction</h2>
<div class="xpath">
<p class="xpath">The primary purpose of XPath is to address the
nodes of <a href="#XML">[XML 1.0]</a> or <a href="#XML1.1">[XML
1.1]</a> trees. XPath gets its name from its use of a path notation
for navigating through the hierarchical structure of an XML
document. XPath uses a compact, non-XML syntax to facilitate use of
XPath within URIs and XML attribute values.</p>
</div>
<p>[<a name="dt-datamodel" id="dt-datamodel" title=
"data model">Definition</a>: XPath operates on the abstract,
logical structure of an XML document, rather than its surface
syntax. This logical structure, known as the <b>data model</b>, is
defined in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data
Model (Second Edition)]</a>.]</p>
<div class="xpath">
<p class="xpath">XPath is designed to be embedded in a <b>host
language</b> such as <a href="#XSLT">[XSL Transformations (XSLT)
Version 2.0 (Second Edition)]</a> or <a href="#xquery">[XQuery 1.0:
An XML Query Language (Second Edition)]</a>. XPath has a natural
subset that can be used for matching (testing whether or not a node
matches a pattern); this use of XPath is described in <a href=
"#XSLT">[XSL Transformations (XSLT) Version 2.0 (Second
Edition)]</a>.</p>
</div>
<p>XQuery Version 1.0 is an extension of XPath Version 2.0. Any
expression that is syntactically valid and executes successfully in
both XPath 2.0 and XQuery 1.0 will return the same result in both
languages. Since these languages are so closely related, their
grammars and language descriptions are generated from a common
source to ensure consistency, and the editors of these
specifications work together closely.</p>
<p>XPath also depends on and is closely related to the following
specifications:</p>
<ul>
<li>
<p><a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model
(Second Edition)]</a> defines the data model that underlies all
XPath expressions.</p>
</li>
<li>
<p><a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0
Formal Semantics (Second Edition)]</a> defines the static semantics
of XPath and also contains a formal but non-normative description
of the dynamic semantics that may be useful for implementors and
others who require a formal definition.</p>
</li>
<li>
<p>The type system of XPath is based on <a href="#XMLSchema">[XML
Schema]</a>.</p>
</li>
<li>
<p>The built-in function library and the operators supported by
XPath are defined in <a href="#FunctionsAndOperators">[XQuery 1.0
and XPath 2.0 Functions and Operators (Second Edition)]</a>.</p>
</li>
</ul>
<p>This document specifies a grammar for XPath, using the same
basic EBNF notation used in <a href="#XML">[XML 1.0]</a>. Unless
otherwise noted (see <a href="#lexical-structure"><b>A.2 Lexical
structure</b></a>), whitespace is not significant in <span class=
"xpath"><span class="xpath">expressions</span></span>. Grammar
productions are introduced together with the features that they
describe, and a complete grammar is also presented in the appendix
[<a href="#nt-bnf"><b>A XPath Grammar</b></a>]. The appendix is the
normative version.</p>
<p>In the grammar productions in this document, named symbols are
underlined and literal text is enclosed in double quotes. For
example, the following production describes the syntax of a
function call:</p>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="fakeid_doc-xpath-FunctionCall" id=
"fakeid_doc-xpath-FunctionCall"></a>[48]&#160;&#160;&#160;</td>
<td><code>FunctionCall</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a> "(" (<a href=
"#doc-xpath-ExprSingle">ExprSingle</a> ("," <a href=
"#doc-xpath-ExprSingle">ExprSingle</a>)*)? ")"</code></td>
</tr>
</tbody>
</table>
<p>The production should be read as follows: A function call
consists of a QName followed by an open-parenthesis. The
open-parenthesis is followed by an optional argument list. The
argument list (if present) consists of one or more expressions,
separated by commas. The optional argument list is followed by a
close-parenthesis.</p>
<p>Certain aspects of language processing are described in this
specification as <b>implementation-defined</b> or
<b>implementation-dependent</b>.</p>
<ul>
<li>
<p>[<a name="dt-implementation-defined" id=
"dt-implementation-defined" title=
"implementation defined">Definition</a>:
<b>Implementation-defined</b> indicates an aspect that may differ
between implementations, but must be specified by the implementor
for each particular implementation.]</p>
</li>
<li>
<p>[<a name="dt-implementation-dependent" id=
"dt-implementation-dependent" title=
"implementation dependent">Definition</a>:
<b>Implementation-dependent</b> indicates an aspect that may differ
between implementations, is not specified by this or any W3C
specification, and is not required to be specified by the
implementor for any particular implementation.]</p>
</li>
</ul>
<div class="xpath">
<p class="xpath">A language aspect described in this specification
as <b>implementation-defined</b> or <b>implementation dependent</b>
may be further constrained by the specifications of a host language
in which XPath is embedded.</p>
</div>
<p>This document normatively defines the dynamic semantics of
XPath. The static semantics of XPath are normatively defined in
<a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal
Semantics (Second Edition)]</a>. In this document, examples and
material labeled as "Note" are provided for explanatory purposes
and are not normative.</p>
</div>
<div class="div1">
<h2><a name="id-basics" id="id-basics"></a>2 Basics</h2>
<p>The basic building block of XPath is the <b>expression</b>,
which is a string of <a href="#Unicode">[Unicode]</a> characters
(the version of Unicode to be used is <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.) The
language provides several kinds of expressions which may be
constructed from keywords, symbols, and operands. In general, the
operands of an expression are other expressions. XPath allows
expressions to be nested with full generality.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This specification contains no assumptions or requirements
regarding the character set encoding of strings of <a href=
"#Unicode">[Unicode]</a> characters.</p>
</div>
<p>Like XML, XPath is a case-sensitive language. Keywords in XPath
use lower-case characters and are not reserved—that is, names in
XPath expressions are allowed to be the same as language keywords,
except for certain unprefixed function-names listed in <a href=
"#id-reserved-fn-names"><b>A.3 Reserved Function Names</b></a>.</p>
<p>[<a name="dt-value" id="dt-value" title="value">Definition</a>:
In the <a title="data model" href="#dt-datamodel">data model</a>, a
<b>value</b> is always a <a title="sequence" href=
"#dt-sequence">sequence</a>.] [<a name="dt-sequence" id=
"dt-sequence" title="sequence">Definition</a>: A <b>sequence</b> is
an ordered collection of zero or more <a title="item" href=
"#dt-item">items</a>.] [<a name="dt-item" id="dt-item" title=
"item">Definition</a>: An <b>item</b> is either an <a title=
"atomic value" href="#dt-atomic-value">atomic value</a> or a
<a title="node" href="#dt-node">node</a>.] [<a name=
"dt-atomic-value" id="dt-atomic-value" title=
"atomic value">Definition</a>: An <b>atomic value</b> is a value in
the value space of an <b>atomic type</b>, as defined in <a href=
"#XMLSchema">[XML Schema]</a>.] [<a name="dt-node" id="dt-node"
title="node">Definition</a>: A <b>node</b> is an instance of one of
the <b>node kinds</b> defined in <a href="#datamodel">[XQuery 1.0
and XPath 2.0 Data Model (Second Edition)]</a>.] Each node has a
unique <b>node identity</b>, a <b>typed value</b>, and a <b>string
value</b>. In addition, some nodes have a <b>name</b>. The <b>typed
value</b> of a node is a sequence of zero or more atomic values.
The <b>string value</b> of a node is a value of type
<code>xs:string</code>. The <b>name</b> of a node is a value of
type <code>xs:QName</code>. [<a name="dt-undefined" id=
"dt-undefined" title="undefined">Definition</a>: In certain
situations a value is said to be <b>undefined</b> (for example, the
value of the context item, or the typed value of an element node).
This term indicates that the property in question has no value and
that any attempt to use its value results in an error.]</p>
<p>[<a name="dt-singleton" id="dt-singleton" title=
"singleton">Definition</a>: A sequence containing exactly one item
is called a <b>singleton</b>.] An item is identical to a singleton
sequence containing that item. Sequences are never nested—for
example, combining the values 1, (2, 3), and ( ) into a single
sequence results in the sequence (1, 2, 3). [<a name=
"dt-empty-sequence" id="dt-empty-sequence" title=
"empty sequence">Definition</a>: A sequence containing zero items
is called an <b>empty sequence</b>.]</p>
<p>[<a name="dt-data-model-instance" id="dt-data-model-instance"
title="XDM instance">Definition</a>: The term <b>XDM instance</b>
is used, synonymously with the term <b>value</b>, to denote an
unconstrained sequence of <a title="node" href="#dt-node">nodes</a>
and/or <a title="atomic value" href="#dt-atomic-value">atomic
values</a> in the <a title="data model" href="#dt-datamodel">data
model</a>.]</p>
<p>Names in XPath are called <b>QNames</b>, and conform to the
syntax in <a href="#XMLNAMES">[XML Names]</a>. [<a name="dt-qname"
id="dt-qname" title="QName">Definition</a>: Lexically, a
<b>QName</b> consists of an optional namespace prefix and a local
name. If the namespace prefix is present, it is separated from the
local name by a colon.] A lexical QName can be converted into an
<b>expanded QName</b> by resolving its namespace prefix to a
namespace URI, using the <a title="statically known namespaces"
href="#dt-static-namespaces">statically known namespaces</a>
[<a href="#ERRXPST0081" title="err:XPST0081">err:XPST0081</a>].
[<a name="dt-expanded-qname" id="dt-expanded-qname" title=
"expanded QName">Definition</a>: An <b>expanded QName</b> consists
of an optional namespace URI and a local name. An expanded QName
also retains its original namespace prefix (if any), to facilitate
casting the expanded QName into a string.] The namespace URI value
is whitespace normalized according to the rules for the
<code>xs:anyURI</code> type in <a href="#XMLSchema">[XML
Schema]</a>. Two expanded QNames are equal if their namespace URIs
are equal and their local names are equal (even if their namespace
prefixes are not equal). Namespace URIs and local names are
compared on a codepoint basis, without further normalization.</p>
<p><span class="xpath"><span class="xpath">This document uses the
following namespace prefixes to represent the namespace URIs with
which they are listed. Use of these namespace prefix bindings in
this document is not normative.</span></span></p>
<ul>
<li>
<p><code>xs = http://www.w3.org/2001/XMLSchema</code></p>
</li>
<li>
<p><code>fn = http://www.w3.org/2005/xpath-functions</code></p>
</li>
<li class="xpath">
<p><code>err = http://www.w3.org/2005/xqt-errors</code> (see
<a href="#id-identifying-errors"><b>2.3.2 Identifying and Reporting
Errors</b></a>).</p>
</li>
</ul>
<p>Element nodes have a property called <b>in-scope namespaces</b>.
[<a name="dt-in-scope-namespaces" id="dt-in-scope-namespaces"
title="in-scope namespaces">Definition</a>: The <b>in-scope
namespaces</b> property of an element node is a set of <b>namespace
bindings</b>, each of which associates a namespace prefix with a
URI, thus defining the set of namespace prefixes that are available
for interpreting QNames within the scope of the element. For a
given element, one namespace binding may have an empty prefix; the
URI of this namespace binding is the default namespace within the
scope of the element.]</p>
<div class="xpath">
<p class="xpath">In <a href="#XPath">[XPath 1.0]</a>, the in-scope
namespaces of an element node are represented by a collection of
<b>namespace nodes</b> arranged on a <b>namespace axis</b>. In
XPath Version 2.0, the namespace axis is deprecated and need not be
supported by a host language. A host language that does not support
the namespace axis need not represent namespace bindings in the
form of nodes.</p>
</div>
<p>[<a name="dt-URI" id="dt-URI" title="URI">Definition</a>: Within
this specification, the term <b>URI</b> refers to a Universal
Resource Identifier as defined in <a href="#RFC3986">[RFC3986]</a>
and extended in <a href="#RFC3987">[RFC3987]</a> with the new name
<b>IRI</b>.] The term URI has been retained in preference to IRI to
avoid introducing new names for concepts such as "Base URI" that
are defined or referenced across the whole family of XML
specifications.</p>
<div class="div2">
<h3><a name="context" id="context"></a>2.1 Expression Context</h3>
<p>[<a name="dt-expression-context" id="dt-expression-context"
title="expression context">Definition</a>: The <b>expression
context</b> for a given expression consists of all the information
that can affect the result of the expression.] This information is
organized into two categories called the <a title="static context"
href="#dt-static-context">static context</a> and the <a title=
"dynamic context" href="#dt-dynamic-context">dynamic
context</a>.</p>
<div class="div3">
<h4><a name="static_context" id="static_context"></a>2.1.1 Static
Context</h4>
<p>[<a name="dt-static-context" id="dt-static-context" title=
"static context">Definition</a>: The <b>static context</b> of an
expression is the information that is available during static
analysis of the expression, prior to its evaluation.] This
information can be used to decide whether the expression contains a
<a title="static error" href="#dt-static-error">static error</a>.
If analysis of an expression relies on some component of the
<a title="static context" href="#dt-static-context">static
context</a> that has not been assigned a value, a <a title=
"static error" href="#dt-static-error">static error</a> is raised
[<a href="#ERRXPST0001" title="err:XPST0001">err:XPST0001</a>].</p>
<p>The individual components of the <a title="static context" href=
"#dt-static-context">static context</a> are summarized below.
<span class="xpath"><span class="xpath">A default initial value for
each component may be specified by the host language. The scope of
each component is specified in <a href=
"#id-xp-static-context-components"><b>C.1 Static Context
Components</b></a>.</span></span></p>
<ul>
<li>
<p>[<a name="dt-xpath-compat-mode" id="dt-xpath-compat-mode" title=
"XPath 1.0 compatibility mode">Definition</a>: <b>XPath 1.0
compatibility mode.</b> <span class="xpath"><span class=
"xpath">This value is <code>true</code> if rules for backward
compatibility with XPath Version 1.0 are in effect; otherwise it is
<code>false</code>.</span></span>]</p>
</li>
<li>
<p>[<a name="dt-static-namespaces" id="dt-static-namespaces" title=
"statically known namespaces">Definition</a>: <b>Statically known
namespaces.</b> This is a set of (prefix, URI) pairs that define
all the namespaces that are known during static processing of a
given expression.] The URI value is whitespace normalized according
to the rules for the <code>xs:anyURI</code> type in <a href=
"#XMLSchema">[XML Schema]</a>. Note the difference between
<a title="in-scope namespaces" href=
"#dt-in-scope-namespaces">in-scope namespaces</a>, which is a
dynamic property of an element node, and <a title=
"statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>, which is a
static property of an expression.</p>
</li>
<li>
<p>[<a name="dt-def-elemtype-ns" id="dt-def-elemtype-ns" title=
"default element/type namespace">Definition</a>: <b>Default
element/type namespace.</b> This is a namespace URI or "none". The
namespace URI, if present, is used for any unprefixed QName
appearing in a position where an element or type name is expected.]
The URI value is whitespace normalized according to the rules for
the <code>xs:anyURI</code> type in <a href="#XMLSchema">[XML
Schema]</a>.</p>
</li>
<li>
<p>[<a name="dt-def-fn-ns" id="dt-def-fn-ns" title=
"default function namespace">Definition</a>: <b>Default function
namespace.</b> This is a namespace URI or "none". The namespace
URI, if present, is used for any unprefixed QName appearing in a
position where a function name is expected.] The URI value is
whitespace normalized according to the rules for the
<code>xs:anyURI</code> type in <a href="#XMLSchema">[XML
Schema]</a>.</p>
</li>
<li>
<p>[<a name="dt-issd" id="dt-issd" title=
"in-scope schema definitions">Definition</a>: <b>In-scope schema
definitions.</b> This is a generic term for all the element
declarations, attribute declarations, and schema type definitions
that are in scope during processing of an expression.] It includes
the following three parts:</p>
<ul>
<li>
<p>[<a name="dt-is-types" id="dt-is-types" title=
"in-scope schema type">Definition</a>: <b>In-scope schema
types.</b> Each schema type definition is identified either by an
<a title="expanded QName" href="#dt-expanded-qname">expanded
QName</a> (for a <b>named type</b>) or by an <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> type
identifier (for an <b>anonymous type</b>). The in-scope schema
types include the predefined schema types described in <a href=
"#id-predefined-types"><b>2.5.1 Predefined Schema Types</b></a>.
]</p>
</li>
<li>
<p>[<a name="dt-is-elems" id="dt-is-elems" title=
"in-scope element declarations">Definition</a>: <b>In-scope element
declarations.</b> Each element declaration is identified either by
an <a title="expanded QName" href="#dt-expanded-qname">expanded
QName</a> (for a top-level element declaration) or by an <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> element
identifier (for a local element declaration). ] An element
declaration includes information about the element's <a title=
"substitution group" href="#dt-substitution-group">substitution
group</a> affiliation.</p>
<p>[<a name="dt-substitution-group" id="dt-substitution-group"
title="substitution group">Definition</a>: <b>Substitution
groups</b> are defined in <a href="#XMLSchema">[XML Schema]</a>
Part 1, Section 2.2.2.2. Informally, the substitution group headed
by a given element (called the <b>head element</b>) consists of the
set of elements that can be substituted for the head element
without affecting the outcome of schema validation.]</p>
</li>
<li>
<p>[<a name="dt-is-attrs" id="dt-is-attrs" title=
"in-scope attribute declarations">Definition</a>: <b>In-scope
attribute declarations.</b> Each attribute declaration is
identified either by an <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> (for a top-level attribute
declaration) or by an <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>
attribute identifier (for a local attribute declaration). ]</p>
</li>
</ul>
</li>
<li>
<p>[<a name="dt-in-scope-variables" id="dt-in-scope-variables"
title="in-scope variables">Definition</a>: <b>In-scope
variables.</b> This is a set of (expanded QName, type) pairs. It
defines the set of variables that are available for reference
within an expression. The <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> is the name of the
variable, and the type is the <a title="static type" href=
"#dt-static-type">static type</a> of the variable.]</p>
<p>An expression that binds a variable (such as a <code>for</code>,
<code>some</code>, or <code>every</code> expression) extends the
<a title="in-scope variables" href=
"#dt-in-scope-variables">in-scope variables</a> of its
subexpressions with the new bound variable and its type.</p>
</li>
<li>
<p>[<a name="dt-context-item-static-type" id=
"dt-context-item-static-type" title=
"context item static type">Definition</a>: <b>Context item static
type.</b> This component defines the <a title="static type" href=
"#dt-static-type">static type</a> of the context item within the
scope of a given expression.]</p>
</li>
<li>
<p>[<a name="dt-function-signature" id="dt-function-signature"
title="function signature">Definition</a>: <b>Function
signatures.</b> This component defines the set of functions that
are available to be called from within an expression. Each function
is uniquely identified by its <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> and its arity (number of
parameters).] In addition to the name and arity, each function
signature specifies the <a title="static type" href=
"#dt-static-type">static types</a> of the function parameters and
result.</p>
<p>The <a title="function signature" href=
"#dt-function-signature">function signatures</a> include the
signatures of <a title="constructor function" href=
"#dt-constructor-function">constructor functions</a>, which are
discussed in <a href="#id-constructor-functions"><b>3.10.4
Constructor Functions</b></a>.</p>
</li>
<li>
<p>[<a name="dt-static-collations" id="dt-static-collations" title=
"statically known collations">Definition</a>: <b>Statically known
collations.</b> This is an <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> set of
(URI, collation) pairs. It defines the names of the collations that
are available for use in processing expressions.] [<a name=
"dt-collation" id="dt-collation" title="collation">Definition</a>:
A <b>collation</b> is a specification of the manner in which
strings and URIs are compared and, by extension, ordered. For a
more complete definition of collation, see <a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators (Second Edition)]</a>.]</p>
</li>
<li>
<p>[<a name="dt-def-collation" id="dt-def-collation" title=
"default collation">Definition</a>: <b>Default collation.</b> This
identifies one of the collations in <a title=
"statically known collations" href=
"#dt-static-collations">statically known collations</a> as the
collation to be used by functions and operators for comparing and
ordering values of type <code>xs:string</code> and
<code>xs:anyURI</code> (and types derived from them) when no
explicit collation is specified.]</p>
</li>
<li>
<p>[<a name="dt-base-uri" id="dt-base-uri" title=
"base URI">Definition</a>: <b>Base URI.</b> This is an absolute
URI, used when necessary in the resolution of relative URIs (for
example, by the <code>fn:resolve-uri</code> function.)] The URI
value is whitespace normalized according to the rules for the
<code>xs:anyURI</code> type in <a href="#XMLSchema">[XML
Schema]</a>.</p>
</li>
<li>
<p>[<a name="dt-known-docs" id="dt-known-docs" title=
"statically known documents">Definition</a>: <b>Statically known
documents.</b> This is a mapping from strings onto types. The
string represents the absolute URI of a resource that is
potentially available using the <code>fn:doc</code> function. The
type is the <a title="static type" href="#dt-static-type">static
type</a> of a call to <code>fn:doc</code> with the given URI as its
literal argument. ] If the argument to <code>fn:doc</code> is a
string literal that is not present in <b>statically known
documents</b>, then the <a title="static type" href=
"#dt-static-type">static type</a> of <code>fn:doc</code> is
<code>document-node()?</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The purpose of the <b>statically known documents</b> is to
provide static type information, not to determine which documents
are available. A URI need not be found in the <b>statically known
documents</b> to be accessed using <code>fn:doc</code>.</p>
</div>
</li>
<li>
<p>[<a name="dt-known-collections" id="dt-known-collections" title=
"statically known collections">Definition</a>: <b>Statically known
collections.</b> This is a mapping from strings onto types. The
string represents the absolute URI of a resource that is
potentially available using the <code>fn:collection</code>
function. The type is the type of the sequence of nodes that would
result from calling the <code>fn:collection</code> function with
this URI as its argument.] If the argument to
<code>fn:collection</code> is a string literal that is not present
in <b>statically known collections</b>, then the <a title=
"static type" href="#dt-static-type">static type</a> of
<code>fn:collection</code> is <code>node()*</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The purpose of the <b>statically known collections</b> is to
provide static type information, not to determine which collections
are available. A URI need not be found in the <b>statically known
collections</b> to be accessed using
<code>fn:collection</code>.</p>
</div>
</li>
<li>
<p>[<a name="dt-known-default-collection" id=
"dt-known-default-collection" title=
"statically known default collection type">Definition</a>:
<b>Statically known default collection type.</b> This is the type
of the sequence of nodes that would result from calling the
<code>fn:collection</code> function with no arguments.] Unless
initialized to some other value by an implementation, the value of
<b>statically known default collection type</b> is
<code>node()*</code>.</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="eval_context" id="eval_context"></a>2.1.2 Dynamic
Context</h4>
<p>[<a name="dt-dynamic-context" id="dt-dynamic-context" title=
"dynamic context">Definition</a>: The <b>dynamic context</b> of an
expression is defined as information that is available at the time
the expression is evaluated.] If evaluation of an expression relies
on some part of the <a title="dynamic context" href=
"#dt-dynamic-context">dynamic context</a> that has not been
assigned a value, a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> is raised [<a href=
"#ERRXPDY0002" title="err:XPDY0002">err:XPDY0002</a>].</p>
<p>The individual components of the <a title="dynamic context"
href="#dt-dynamic-context">dynamic context</a> are summarized
below. Further rules governing the semantics of these components
can be found in <a href=
"#id-xp-evaluation-context-components"><b>C.2 Dynamic Context
Components</b></a>.</p>
<p>The <a title="dynamic context" href=
"#dt-dynamic-context">dynamic context</a> consists of all the
components of the <a title="static context" href=
"#dt-static-context">static context</a>, and the additional
components listed below.</p>
<p>[<a name="dt-focus" id="dt-focus" title="focus">Definition</a>:
The first three components of the <a title="dynamic context" href=
"#dt-dynamic-context">dynamic context</a> (context item, context
position, and context size) are called the <b>focus</b> of the
expression. ] The focus enables the processor to keep track of
which items are being processed by the expression.</p>
<p>Certain language constructs, notably the <a title=
"path expression" href="#dt-path-expression">path expression</a>
<code>E1/E2</code> and the <a title="predicate" href=
"#dt-predicate">predicate</a> <code>E1[E2]</code>, create a new
focus for the evaluation of a sub-expression. In these constructs,
<code>E2</code> is evaluated once for each item in the sequence
that results from evaluating <code>E1</code>. Each time
<code>E2</code> is evaluated, it is evaluated with a different
focus. The focus for evaluating <code>E2</code> is referred to
below as the <b>inner focus</b>, while the focus for evaluating
<code>E1</code> is referred to as the <b>outer focus</b>. The inner
focus exists only while <code>E2</code> is being evaluated. When
this evaluation is complete, evaluation of the containing
expression continues with its original focus unchanged.</p>
<ul>
<li>
<p>[<a name="dt-context-item" id="dt-context-item" title=
"context item">Definition</a>: The <b>context item</b> is the item
currently being processed. An item is either an atomic value or a
node.][<a name="dt-context-node" id="dt-context-node" title=
"context node">Definition</a>: When the context item is a node, it
can also be referred to as the <b>context node</b>.] The context
item is returned by an expression consisting of a single dot
(<code>.</code>). When an expression <code>E1/E2</code> or
<code>E1[E2]</code> is evaluated, each item in the sequence
obtained by evaluating <code>E1</code> becomes the context item in
the inner focus for an evaluation of <code>E2</code>.</p>
</li>
<li>
<p>[<a name="dt-context-position" id="dt-context-position" title=
"context position">Definition</a>: The <b>context position</b> is
the position of the context item within the sequence of items
currently being processed.] It changes whenever the context item
changes. When the focus is defined, the value of the context
position is an integer greater than zero. The context position is
returned by the expression <code>fn:position()</code>. When an
expression <code>E1/E2</code> or <code>E1[E2]</code> is evaluated,
the context position in the inner focus for an evaluation of
<code>E2</code> is the position of the context item in the sequence
obtained by evaluating <code>E1</code>. The position of the first
item in a sequence is always 1 (one). The context position is
always less than or equal to the context size.</p>
</li>
<li>
<p>[<a name="dt-context-size" id="dt-context-size" title=
"context size">Definition</a>: The <b>context size</b> is the
number of items in the sequence of items currently being
processed.] Its value is always an integer greater than zero. The
context size is returned by the expression <code>fn:last()</code>.
When an expression <code>E1/E2</code> or <code>E1[E2]</code> is
evaluated, the context size in the inner focus for an evaluation of
<code>E2</code> is the number of items in the sequence obtained by
evaluating <code>E1</code>.</p>
</li>
<li>
<p>[<a name="dt-variable-values" id="dt-variable-values" title=
"variable values">Definition</a>: <b>Variable values</b>. This is a
set of (expanded QName, value) pairs. It contains the same
<a title="expanded QName" href="#dt-expanded-qname">expanded
QNames</a> as the <a title="in-scope variables" href=
"#dt-in-scope-variables">in-scope variables</a> in the <a title=
"static context" href="#dt-static-context">static context</a> for
the expression. The expanded QName is the name of the variable and
the value is the dynamic value of the variable, which includes its
<a title="dynamic type" href="#dt-dynamic-type">dynamic
type</a>.]</p>
</li>
<li>
<p>[<a name="dt-function-implementation" id=
"dt-function-implementation" title=
"function implementation">Definition</a>: <b>Function
implementations</b>. Each function in <a title="function signature"
href="#dt-function-signature">function signatures</a> has a
function implementation that enables the function to map instances
of its parameter types into an instance of its result type. ]</p>
</li>
<li>
<p>[<a name="dt-date-time" id="dt-date-time" title=
"current dateTime">Definition</a>: <b>Current dateTime.</b> This
information represents an <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> point
in time during the processing of <span class="xpath"><span class=
"xpath">an expression</span></span>, and includes an explicit
timezone. It can be retrieved by the
<code>fn:current-dateTime</code> function. If invoked multiple
times during the execution of <span class="xpath"><span class=
"xpath">an expression</span></span>, this function always returns
the same result.]</p>
</li>
<li>
<p>[<a name="dt-timezone" id="dt-timezone" title=
"implicit timezone">Definition</a>: <b>Implicit timezone.</b> This
is the timezone to be used when a date, time, or dateTime value
that does not have a timezone is used in a comparison or arithmetic
operation. The implicit timezone is an <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> value of
type <code>xs:dayTimeDuration</code>. See <a href="#XMLSchema">[XML
Schema]</a> for the range of legal values of a timezone.]</p>
</li>
<li>
<p>[<a name="dt-available-docs" id="dt-available-docs" title=
"available documents">Definition</a>: <b>Available documents.</b>
This is a mapping of strings onto document nodes. The string
represents the absolute URI of a resource. The document node is the
root of a tree that represents that resource using the <a title=
"data model" href="#dt-datamodel">data model</a>. The document node
is returned by the <code>fn:doc</code> function when applied to
that URI.] The set of available documents is not limited to the set
of <a title="statically known documents" href=
"#dt-known-docs">statically known documents</a>, and it may be
empty.</p>
<p>If there are one or more URIs in <a title="available documents"
href="#dt-available-docs">available documents</a> that map to a
document node <code>D</code>, then the document-uri property of
<code>D</code> must either be absent, or must be one of these
URIs.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This means that given a document node <code>$N</code>, the
result of <code>fn:doc(fn:document-uri($N)) is $N</code> will
always be True, unless <code>fn:document-uri($N)</code> is an empty
sequence.</p>
</div>
</li>
<li>
<p>[<a name="dt-available-collections" id=
"dt-available-collections" title=
"available collections">Definition</a>: <b>Available
collections.</b> This is a mapping of strings onto sequences of
nodes. The string represents the absolute URI of a resource. The
sequence of nodes represents the result of the
<code>fn:collection</code> function when that URI is supplied as
the argument. ] The set of available collections is not limited to
the set of <a title="statically known collections" href=
"#dt-known-collections">statically known collections</a>, and it
may be empty.</p>
<p>For every document node <code>D</code> that is in the target of
a mapping in <a title="available collections" href=
"#dt-available-collections">available collections</a>, or that is
the root of a tree containing such a node, the document-uri
property of <code>D</code> must either be absent, or must be a URI
<code>U</code> such that <a title="available documents" href=
"#dt-available-docs">available documents</a> contains a mapping
from <code>U</code> to <code>D</code>."</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This means that for any document node <code>$N</code> retrieved
using the <code>fn:collection</code> function, either directly or
by navigating to the root of a node that was returned, the result
of <code>fn:doc(fn:document-uri($N)) is $N</code> will always be
True, unless <code>fn:document-uri($N)</code> is an empty sequence.
This implies a requirement for the <code>fn:doc</code> and
<code>fn:collection</code> functions to be consistent in their
effect. If the implementation uses catalogs or user-supplied URI
resolvers to dereference URIs supplied to the <code>fn:doc</code>
function, the implementation of the <code>fn:collection</code>
function must take these mechanisms into account. For example, an
implementation might achieve this by mapping the collection URI to
a set of document URIs, which are then resolved using the same
catalog or URI resolver that is used by the <code>fn:doc</code>
function.</p>
</div>
</li>
<li>
<p>[<a name="dt-default-collection" id="dt-default-collection"
title="default collection">Definition</a>: <b>Default
collection.</b> This is the sequence of nodes that would result
from calling the <code>fn:collection</code> function with no
arguments.] The value of <b>default collection</b> may be
initialized by the implementation.</p>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="id-processing-model" id="id-processing-model"></a>2.2
Processing Model</h3>
<p>XPath is defined in terms of the <a title="data model" href=
"#dt-datamodel">data model</a> and the <a title=
"expression context" href="#dt-expression-context">expression
context</a>.</p>
<img src="ProcMod-XPath.gif" alt="Processing Model Overview" />
<p>Figure 1: Processing Model Overview</p>
<p>Figure 1 provides a schematic overview of the processing steps
that are discussed in detail below. Some of these steps are
completely outside the domain of XPath; in Figure 1, these are
depicted outside the line that represents the boundaries of the
language, an area labeled <b>external processing</b>. The external
processing domain includes generation of an <a title="XDM instance"
href="#dt-data-model-instance">XDM instance</a> that represents the
data to be queried (see <a href=
"#id-data-model-generation"><b>2.2.1 Data Model
Generation</b></a>), schema import processing (see <a href=
"#id-schema-import-processing"><b>2.2.2 Schema Import
Processing</b></a>) and serialization (see <a href=
"#id-serialization"><b>2.2.4 Serialization</b></a>). The area
inside the boundaries of the language is known as the <span class=
"xpath"><span class="xpath"><b>XPath processing
domain</b></span></span>, which includes the static analysis and
dynamic evaluation phases (see <a href=
"#id-expression-processing"><b>2.2.3 Expression
Processing</b></a>). Consistency constraints on the <span class=
"xpath"><span class="xpath">XPath</span></span> processing domain
are defined in <a href="#id-consistency-constraints"><b>2.2.5
Consistency Constraints</b></a>.</p>
<div class="div3">
<h4><a name="id-data-model-generation" id=
"id-data-model-generation"></a>2.2.1 Data Model Generation</h4>
<p>Before <span class="xpath"><span class="xpath">an
expression</span></span> can be processed, its input data must be
represented as an <a title="XDM instance" href=
"#dt-data-model-instance">XDM instance</a>. This process occurs
outside the domain of XPath, which is why Figure 1 represents it in
the external processing domain. Here are some steps by which an XML
document might be converted to an <a title="XDM instance" href=
"#dt-data-model-instance">XDM instance</a>:</p>
<ol class="enumar">
<li>
<p>A document may be parsed using an XML parser that generates an
<b>XML Information Set</b> (see <a href="#XINFO">[XML
Infoset]</a>). The parsed document may then be validated against
one or more schemas. This process, which is described in <a href=
"#XMLSchema">[XML Schema]</a>, results in an abstract information
structure called the <b>Post-Schema Validation Infoset</b> (PSVI).
If a document has no associated schema, its Information Set is
preserved. (See DM1 in Fig. 1.)</p>
</li>
<li>
<p>The Information Set or PSVI may be transformed into an <a title=
"XDM instance" href="#dt-data-model-instance">XDM instance</a> by a
process described in <a href="#datamodel">[XQuery 1.0 and XPath 2.0
Data Model (Second Edition)]</a>. (See DM2 in Fig. 1.)</p>
</li>
</ol>
<p>The above steps provide an example of how an <a title=
"XDM instance" href="#dt-data-model-instance">XDM instance</a>
might be constructed. An XDM instance might also be synthesized
directly from a relational database, or constructed in some other
way (see DM3 in Fig. 1.) XPath is defined in terms of the <a title=
"data model" href="#dt-datamodel">data model</a>, but it does not
place any constraints on how XDM instances are constructed.</p>
<p>[<a name="dt-type-annotation" id="dt-type-annotation" title=
"type annotation">Definition</a>: Each element node and attribute
node in an <a title="XDM instance" href=
"#dt-data-model-instance">XDM instance</a> has a <b>type
annotation</b> (referred to in <a href="#datamodel">[XQuery 1.0 and
XPath 2.0 Data Model (Second Edition)]</a> as its
<code>type-name</code> property.) The type annotation of a node is
a <a title="schema type" href="#dt-schema-type">schema type</a>
that describes the relationship between the <a title="string value"
href="#dt-string-value">string value</a> of the node and its
<a title="typed value" href="#dt-typed-value">typed value</a>.] If
the <a title="XDM instance" href="#dt-data-model-instance">XDM
instance</a> was derived from a validated XML document as described
in <a href=
"http://www.w3.org/TR/xpath-datamodel/#const-psvi">Section 3.3
Construction from a PSVI</a><sup><small>DM</small></sup>, the type
annotations of the element and attribute nodes are derived from
schema validation. XPath does not provide a way to directly access
the type annotation of an element or attribute node.</p>
<p>The value of an attribute is represented directly within the
attribute node. An attribute node whose type is unknown (such as
might occur in a schemaless document) is given the <a title=
"type annotation" href="#dt-type-annotation">type annotation</a>
<code>xs:untypedAtomic</code>.</p>
<p>The value of an element is represented by the children of the
element node, which may include text nodes and other element nodes.
The <a title="type annotation" href="#dt-type-annotation">type
annotation</a> of an element node indicates how the values in its
child text nodes are to be interpreted. An element that has not
been validated (such as might occur in a schemaless document) is
annotated with the schema type <code>xs:untyped</code>. An element
that has been validated and found to be partially valid is
annotated with the schema type <code>xs:anyType</code>. If an
element node is annotated as <code>xs:untyped</code>, all its
descendant element nodes are also annotated as
<code>xs:untyped</code>. However, if an element node is annotated
as <code>xs:anyType</code>, some of its descendant element nodes
may have a more specific <a title="type annotation" href=
"#dt-type-annotation">type annotation</a>.</p>
</div>
<div class="div3">
<h4><a name="id-schema-import-processing" id=
"id-schema-import-processing"></a>2.2.2 Schema Import
Processing</h4>
<div class="xpath">
<p class="xpath">The <a title="in-scope schema definitions" href=
"#dt-issd">in-scope schema definitions</a> in the <a title=
"static context" href="#dt-static-context">static context</a> are
provided by the host language (see step SI1 in Figure 1) and must
satisfy the consistency constraints defined in <a href=
"#id-consistency-constraints"><b>2.2.5 Consistency
Constraints</b></a>.</p>
</div>
</div>
<div class="div3">
<h4><a name="id-expression-processing" id=
"id-expression-processing"></a>2.2.3 Expression Processing</h4>
<p>XPath defines two phases of processing called the <a title=
"static analysis phase" href="#dt-static-analysis">static analysis
phase</a> and the <a title="dynamic evaluation phase" href=
"#dt-dynamic-evaluation">dynamic evaluation phase</a> (see Fig. 1).
During the static analysis phase, <a title="static error" href=
"#dt-static-error">static errors</a>, <a title="dynamic error"
href="#dt-dynamic-error">dynamic errors</a>, or <a title=
"type error" href="#dt-type-error">type errors</a> may be raised.
During the dynamic evaluation phase, only <a title="dynamic error"
href="#dt-dynamic-error">dynamic errors</a> or <a title=
"type error" href="#dt-type-error">type errors</a> may be raised.
These kinds of errors are defined in <a href=
"#id-kinds-of-errors"><b>2.3.1 Kinds of Errors</b></a>.</p>
<p>Within each phase, an implementation is free to use any strategy
or algorithm whose result conforms to the specifications in this
document.</p>
<div class="div4">
<h5><a name="id-static-analysis" id=
"id-static-analysis"></a>2.2.3.1 Static Analysis Phase</h5>
<p>[<a name="dt-static-analysis" id="dt-static-analysis" title=
"static analysis phase">Definition</a>: The <b>static analysis
phase</b> depends on the expression itself and on the <a title=
"static context" href="#dt-static-context">static context</a>. The
<b>static analysis phase</b> does not depend on input data (other
than schemas).]</p>
<p>During the static analysis phase, the <span class=
"xpath"><span class="xpath">XPath expression</span></span> is
parsed into an internal representation called the <b>operation
tree</b> (step SQ1 in Figure 1). A parse error is raised as a
<a title="static error" href="#dt-static-error">static error</a>
[<a href="#ERRXPST0003" title="err:XPST0003">err:XPST0003</a>]. The
<a title="static context" href="#dt-static-context">static
context</a> is initialized by the implementation (step SQ2). The
<a title="static context" href="#dt-static-context">static
context</a> is used to resolve schema type names, function names,
namespace prefixes, and variable names (step SQ4). If a name of one
of these kinds in the <b>operation tree</b> is not found in the
<a title="static context" href="#dt-static-context">static
context</a>, a <a title="static error" href=
"#dt-static-error">static error</a> ([<a href="#ERRXPST0008" title=
"err:XPST0008">err:XPST0008</a>] or [<a href="#ERRXPST0017" title=
"err:XPST0017">err:XPST0017</a>]) is raised (however, see
exceptions to this rule in <a href="#id-element-test"><b>2.5.4.3
Element Test</b></a> and <a href="#id-attribute-test"><b>2.5.4.5
Attribute Test</b></a>.)</p>
<p>The <b>operation tree</b> is then <b>normalized</b> by making
explicit the implicit operations such as <a title="atomization"
href="#dt-atomization">atomization</a> and extraction of <a title=
"effective boolean value" href="#dt-ebv">Effective Boolean
Values</a> (step SQ5). The normalization process is described in
<a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal
Semantics (Second Edition)]</a>.</p>
<p>Each expression is then assigned a <a title="static type" href=
"#dt-static-type">static type</a> (step SQ6). [<a name=
"dt-static-type" id="dt-static-type" title=
"static type">Definition</a>: The <b>static type</b> of an
expression is a type such that, when the expression is evaluated,
the resulting value will always conform to the static type.] If the
<a title="static typing feature" href=
"#dt-xpath-static-typing-feature">Static Typing Feature</a> is
supported, the <a title="static type" href="#dt-static-type">static
types</a> of various expressions are inferred according to the
rules described in <a href="#XQueryFormalSemantics">[XQuery 1.0 and
XPath 2.0 Formal Semantics (Second Edition)]</a>. If the <a title=
"static typing feature" href=
"#dt-xpath-static-typing-feature">Static Typing Feature</a> is not
supported, the static types that are assigned are <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
<p>During the <a title="static analysis phase" href=
"#dt-static-analysis">static analysis phase</a>, if the <a title=
"static typing feature" href=
"#dt-xpath-static-typing-feature">Static Typing Feature</a> is in
effect and an operand of an expression is found to have a <a title=
"static type" href="#dt-static-type">static type</a> that is not
appropriate for that operand, a <a title="type error" href=
"#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004"
title="err:XPTY0004">err:XPTY0004</a>]. If static type checking
raises no errors and assigns a <a title="static type" href=
"#dt-static-type">static type</a> T to an expression, then
execution of the expression on valid input data is guaranteed
either to produce a value of type T or to raise a <a title=
"dynamic error" href="#dt-dynamic-error">dynamic error</a>.</p>
<p>The purpose of the <a title="static typing feature" href=
"#dt-xpath-static-typing-feature">Static Typing Feature</a> is to
provide early detection of <a title="type error" href=
"#dt-type-error">type errors</a> and to infer type information that
may be useful in optimizing the evaluation of an expression.</p>
</div>
<div class="div4">
<h5><a name="id-dynamic-evaluation" id=
"id-dynamic-evaluation"></a>2.2.3.2 Dynamic Evaluation Phase</h5>
<p>[<a name="dt-dynamic-evaluation" id="dt-dynamic-evaluation"
title="dynamic evaluation phase">Definition</a>: The <b>dynamic
evaluation phase</b> is the phase during which the value of an
expression is computed.] It occurs after completion of the
<a title="static analysis phase" href="#dt-static-analysis">static
analysis phase</a>.</p>
<p>The dynamic evaluation phase can occur only if no errors were
detected during the <a title="static analysis phase" href=
"#dt-static-analysis">static analysis phase</a>. If the <a title=
"static typing feature" href=
"#dt-xpath-static-typing-feature">Static Typing Feature</a> is in
effect, all <a title="type error" href="#dt-type-error">type
errors</a> are detected during static analysis and serve to inhibit
the dynamic evaluation phase.</p>
<p>The dynamic evaluation phase depends on the <b>operation
tree</b> of the expression being evaluated (step DQ1), on the input
data (step DQ4), and on the <a title="dynamic context" href=
"#dt-dynamic-context">dynamic context</a> (step DQ5), which in turn
draws information from the external environment (step DQ3) and the
<a title="static context" href="#dt-static-context">static
context</a> (step DQ2). The dynamic evaluation phase may create new
data-model values (step DQ4) and it may extend the <a title=
"dynamic context" href="#dt-dynamic-context">dynamic context</a>
(step DQ5)—for example, by binding values to variables.</p>
<p>[<a name="dt-dynamic-type" id="dt-dynamic-type" title=
"dynamic type">Definition</a>: A <b>dynamic type</b> is associated
with each value as it is computed. The dynamic type of a value may
be more specific than the <a title="static type" href=
"#dt-static-type">static type</a> of the expression that computed
it (for example, the static type of an expression might be
<code>xs:integer*</code>, denoting a sequence of zero or more
integers, but at evaluation time its value may have the dynamic
type <code>xs:integer</code>, denoting exactly one integer.)]</p>
<p>If an operand of an expression is found to have a <a title=
"dynamic type" href="#dt-dynamic-type">dynamic type</a> that is not
appropriate for that operand, a <a title="type error" href=
"#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004"
title="err:XPTY0004">err:XPTY0004</a>].</p>
<p>Even though static typing can catch many <a title="type error"
href="#dt-type-error">type errors</a> before an expression is
executed, it is possible for an expression to raise an error during
evaluation that was not detected by static analysis. For example,
an expression may contain a cast of a string into an integer, which
is statically valid. However, if the actual value of the string at
run time cannot be cast into an integer, a <a title="dynamic error"
href="#dt-dynamic-error">dynamic error</a> will result. Similarly,
an expression may apply an arithmetic operator to a value whose
<a title="static type" href="#dt-static-type">static type</a> is
<code>xs:untypedAtomic</code>. This is not a <a title=
"static error" href="#dt-static-error">static error</a>, but at run
time, if the value cannot be successfully cast to a <a title=
"numeric" href="#dt-numeric">numeric</a> type, a <a title=
"dynamic error" href="#dt-dynamic-error">dynamic error</a> will be
raised.</p>
<p>When the <a title="static typing feature" href=
"#dt-xpath-static-typing-feature">Static Typing Feature</a> is in
effect, it is also possible for static analysis of an expression to
raise a <a title="type error" href="#dt-type-error">type error</a>,
even though execution of the expression on certain inputs would be
successful. For example, an expression might contain a function
that requires an element as its parameter, and the static analysis
phase might infer the <a title="static type" href=
"#dt-static-type">static type</a> of the function parameter to be
an optional element. This case is treated as a <a title=
"type error" href="#dt-type-error">type error</a> and inhibits
evaluation, even though the function call would have been
successful for input data in which the optional element is
present.</p>
</div>
</div>
<div class="div3">
<h4><a name="id-serialization" id="id-serialization"></a>2.2.4
Serialization</h4>
<p>[<a name="dt-serialization" id="dt-serialization" title=
"serialization">Definition</a>: <b>Serialization</b> is the process
of converting an <a title="XDM instance" href=
"#dt-data-model-instance">XDM instance</a> into a sequence of
octets (step DM4 in Figure 1.) ] The general framework for
serialization is described in <a href="#serialization">[XSLT 2.0
and XQuery 1.0 Serialization (Second Edition)]</a>.</p>
<div class="xpath">
<p class="xpath">The host language may provide a serialization
option.</p>
</div>
</div>
<div class="div3">
<h4><a name="id-consistency-constraints" id=
"id-consistency-constraints"></a>2.2.5 Consistency Constraints</h4>
<p>In order for XPath to be well defined, the input <a title=
"XDM instance" href="#dt-data-model-instance">XDM instance</a>, the
<a title="static context" href="#dt-static-context">static
context</a>, and the <a title="dynamic context" href=
"#dt-dynamic-context">dynamic context</a> must be mutually
consistent. The consistency constraints listed below are
prerequisites for correct functioning of an XPath implementation.
Enforcement of these consistency constraints is beyond the scope of
this specification. This specification does not define the result
of <span class="xpath"><span class="xpath">an
expression</span></span> under any condition in which one or more
of these constraints is not satisfied.</p>
<p>Some of the consistency constraints use the term <b>data model
schema</b>. [<a name="dt-data-model-schema" id=
"dt-data-model-schema" title="data model schema">Definition</a>:
For a given node in an <a title="XDM instance" href=
"#dt-data-model-instance">XDM instance</a>, the <b>data model
schema</b> is defined as the schema from which the <a title=
"type annotation" href="#dt-type-annotation">type annotation</a> of
that node was derived.] For a node that was constructed by some
process other than schema validation, the <b>data model schema</b>
consists simply of the schema type definition that is represented
by the <a title="type annotation" href="#dt-type-annotation">type
annotation</a> of the node.</p>
<ul>
<li>
<p>For every node that has a type annotation, if that type
annotation is found in the <a title="in-scope schema definitions"
href="#dt-issd">in-scope schema definitions</a> (ISSD), then its
definition in the ISSD must be equivalent to its definition in the
<a title="data model schema" href="#dt-data-model-schema">data
model schema</a>. Furthermore, all types that are derived by
extension from the given type in the <a title="data model schema"
href="#dt-data-model-schema">data model schema</a> must also be
known by equivalent definitions in the ISSD.</p>
</li>
<li>
<p>For every element name <em>EN</em> that is found both in an
<a title="XDM instance" href="#dt-data-model-instance">XDM
instance</a> and in the <a title="in-scope schema definitions"
href="#dt-issd">in-scope schema definitions</a> (ISSD), all
elements that are known in the <a title="data model schema" href=
"#dt-data-model-schema">data model schema</a> to be in the
<a title="substitution group" href=
"#dt-substitution-group">substitution group</a> headed by
<em>EN</em> must also be known in the ISSD to be in the <a title=
"substitution group" href="#dt-substitution-group">substitution
group</a> headed by <em>EN</em>.</p>
</li>
<li>
<p>Every element name, attribute name, or schema type name
referenced in <a title="in-scope variables" href=
"#dt-in-scope-variables">in-scope variables</a> or <a title=
"function signature" href="#dt-function-signature">function
signatures</a> must be in the <a title=
"in-scope schema definitions" href="#dt-issd">in-scope schema
definitions</a>, unless it is an element name referenced as part of
an <a href="#doc-xpath-ElementTest">ElementTest</a> or an attribute
name referenced as part of an <a href=
"#doc-xpath-AttributeTest">AttributeTest</a>.</p>
</li>
<li>
<p>Any reference to a global element, attribute, or type name in
the <a title="in-scope schema definitions" href="#dt-issd">in-scope
schema definitions</a> must have a corresponding element, attribute
or type definition in the <a title="in-scope schema definitions"
href="#dt-issd">in-scope schema definitions</a>.</p>
</li>
<li>
<p>For each mapping of a string to a document node in <a title=
"available documents" href="#dt-available-docs">available
documents</a>, if there exists a mapping of the same string to a
document type in <a title="statically known documents" href=
"#dt-known-docs">statically known documents</a>, the document node
must match the document type, using the matching rules in <a href=
"#id-sequencetype-matching"><b>2.5.4 SequenceType
Matching</b></a>.</p>
</li>
<li>
<p>For each mapping of a string to a sequence of nodes in <a title=
"available collections" href="#dt-available-collections">available
collections</a>, if there exists a mapping of the same string to a
type in <a title="statically known collections" href=
"#dt-known-collections">statically known collections</a>, the
sequence of nodes must match the type, using the matching rules in
<a href="#id-sequencetype-matching"><b>2.5.4 SequenceType
Matching</b></a>.</p>
</li>
<li>
<p>The sequence of nodes in the <a title="default collection" href=
"#dt-default-collection">default collection</a> must match the
<a title="statically known default collection type" href=
"#dt-known-default-collection">statically known default collection
type</a>, using the matching rules in <a href=
"#id-sequencetype-matching"><b>2.5.4 SequenceType
Matching</b></a>.</p>
</li>
<li>
<p>The value of the <a title="context item" href=
"#dt-context-item">context item</a> must match the <a title=
"context item static type" href=
"#dt-context-item-static-type">context item static type</a>, using
the matching rules in <a href="#id-sequencetype-matching"><b>2.5.4
SequenceType Matching</b></a>.</p>
</li>
<li>
<p>For each (variable, type) pair in <a title="in-scope variables"
href="#dt-in-scope-variables">in-scope variables</a> and the
corresponding (variable, value) pair in <a title="variable values"
href="#dt-variable-values">variable values</a> such that the
variable names are equal, the value must match the type, using the
matching rules in <a href="#id-sequencetype-matching"><b>2.5.4
SequenceType Matching</b></a>.</p>
</li>
<li>
<p>In the <a title="statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>, the prefix
<code>xml</code> must not be bound to any namespace URI other than
<code>http://www.w3.org/XML/1998/namespace</code>, and no prefix
other than <code>xml</code> may be bound to this namespace URI.</p>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="errors" id="errors"></a>2.3 Error Handling</h3>
<div class="div3">
<h4><a name="id-kinds-of-errors" id="id-kinds-of-errors"></a>2.3.1
Kinds of Errors</h4>
<p>As described in <a href="#id-expression-processing"><b>2.2.3
Expression Processing</b></a>, XPath defines a <a title=
"static analysis phase" href="#dt-static-analysis">static analysis
phase</a>, which does not depend on input data, and a <a title=
"dynamic evaluation phase" href="#dt-dynamic-evaluation">dynamic
evaluation phase</a>, which does depend on input data. Errors may
be raised during each phase.</p>
<p>[<a name="dt-static-error" id="dt-static-error" title=
"static error">Definition</a>: A <b>static error</b> is an error
that must be detected during the static analysis phase. A syntax
error is an example of a <a title="static error" href=
"#dt-static-error">static error</a>.]</p>
<p>[<a name="dt-dynamic-error" id="dt-dynamic-error" title=
"dynamic error">Definition</a>: A <b>dynamic error</b> is an error
that must be detected during the dynamic evaluation phase and may
be detected during the static analysis phase. Numeric overflow is
an example of a dynamic error. ]</p>
<p>[<a name="dt-type-error" id="dt-type-error" title=
"type error">Definition</a>: A <b>type error</b> may be raised
during the static analysis phase or the dynamic evaluation phase.
During the static analysis phase, a <a title="type error" href=
"#dt-type-error">type error</a> occurs when the <a title=
"static type" href="#dt-static-type">static type</a> of an
expression does not match the expected type of the context in which
the expression occurs. During the dynamic evaluation phase, a
<a title="type error" href="#dt-type-error">type error</a> occurs
when the <a title="dynamic type" href="#dt-dynamic-type">dynamic
type</a> of a value does not match the expected type of the context
in which the value occurs.]</p>
<p>The outcome of the <a title="static analysis phase" href=
"#dt-static-analysis">static analysis phase</a> is either success
or one or more <a title="type error" href="#dt-type-error">type
errors</a>, <a title="static error" href="#dt-static-error">static
errors</a>, or statically-detected <a title="dynamic error" href=
"#dt-dynamic-error">dynamic errors</a>. The result of the <a title=
"dynamic evaluation phase" href="#dt-dynamic-evaluation">dynamic
evaluation phase</a> is either a result value, a <a title=
"type error" href="#dt-type-error">type error</a>, or a <a title=
"dynamic error" href="#dt-dynamic-error">dynamic error</a>.</p>
<p>If more than one error is present, or if an error condition
comes within the scope of more than one error defined in this
specification, then any non-empty subset of these errors may be
reported.</p>
<p>During the <a title="static analysis phase" href=
"#dt-static-analysis">static analysis phase</a>, if the <a title=
"static typing feature" href=
"#dt-xpath-static-typing-feature">Static Typing Feature</a> is in
effect and the <a title="static type" href="#dt-static-type">static
type</a> assigned to an expression other than <code>()</code> or
<code>data(())</code> is <code>empty-sequence()</code>, a <a title=
"static error" href="#dt-static-error">static error</a> is raised
[<a href="#ERRXPST0005" title="err:XPST0005">err:XPST0005</a>].
This catches cases in which a query refers to an element or
attribute that is not present in the <a title=
"in-scope schema definitions" href="#dt-issd">in-scope schema
definitions</a>, possibly because of a spelling error.</p>
<p>Independently of whether the <a title="static typing feature"
href="#dt-xpath-static-typing-feature">Static Typing Feature</a> is
in effect, if an implementation can determine during the <a title=
"static analysis phase" href="#dt-static-analysis">static analysis
phase</a> that an expression, if evaluated, would necessarily raise
a <a title="type error" href="#dt-type-error">type error</a> or a
<a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a>, the implementation may (but is not required to) report
that error during the <a title="static analysis phase" href=
"#dt-static-analysis">static analysis phase</a>. However, the
<code>fn:error()</code> function must not be evaluated during the
<a title="static analysis phase" href="#dt-static-analysis">static
analysis phase</a>.</p>
<p>[<a name="dt-warning" id="dt-warning" title=
"warning">Definition</a>: In addition to <a title="static error"
href="#dt-static-error">static errors</a>, <a title="dynamic error"
href="#dt-dynamic-error">dynamic errors</a>, and <a title=
"type error" href="#dt-type-error">type errors</a>, an XPath
implementation may raise <b>warnings</b>, either during the
<a title="static analysis phase" href="#dt-static-analysis">static
analysis phase</a> or the <a title="dynamic evaluation phase" href=
"#dt-dynamic-evaluation">dynamic evaluation phase</a>. The
circumstances in which warnings are raised, and the ways in which
warnings are handled, are <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.]</p>
<p>In addition to the errors defined in this specification, an
implementation may raise a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> for a reason beyond the scope
of this specification. For example, limitations may exist on the
maximum numbers or sizes of various objects. Any such limitations,
and the consequences of exceeding them, are <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
</div>
<div class="div3">
<h4><a name="id-identifying-errors" id=
"id-identifying-errors"></a>2.3.2 Identifying and Reporting
Errors</h4>
<p>The errors defined in this specification are identified by
QNames that have the form <code>err:XPYYnnnn</code>, where:</p>
<ul>
<li>
<p><code>err</code> denotes the namespace for XPath and XQuery
errors, <code>http://www.w3.org/2005/xqt-errors</code>. This
binding of the namespace prefix <code>err</code> is used for
convenience in this document, and is not normative.</p>
</li>
<li class="xpath">
<p><code>XP</code> identifies the error as an XPath error.</p>
</li>
<li>
<p><code>YY</code> denotes the error category, using the following
encoding:</p>
<ul>
<li>
<p><code>ST</code> denotes a static error.</p>
</li>
<li>
<p><code>DY</code> denotes a dynamic error.</p>
</li>
<li>
<p><code>TY</code> denotes a type error.</p>
</li>
</ul>
</li>
<li>
<p><code>nnnn</code> is a unique numeric code.</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The namespace URI for XPath and XQuery errors is not expected to
change from one version of XPath to another. However, the contents
of this namespace may be extended to include additional error
definitions.</p>
</div>
<p>The method by which an XPath processor reports error information
to the external environment is <a title="implementation defined"
href="#dt-implementation-defined">implementation-defined</a>.</p>
<p>An error can be represented by a URI reference that is derived
from the error QName as follows: an error with namespace URI
<em><code>NS</code></em> and local part <em><code>LP</code></em>
can be represented as the URI reference
<em><code>NS</code></em><code>#</code><em><code>LP</code></em>. For
example, an error whose QName is <code>err:XPST0017</code> could be
represented as
<code>http://www.w3.org/2005/xqt-errors#XPST0017</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Along with a code identifying an error, implementations may wish
to return additional information, such as the location of the error
or the processing phase in which it was detected. If an
implementation chooses to do so, then the mechanism that it uses to
return this information is <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</div>
</div>
<div class="div3">
<h4><a name="id-handling-dynamic" id=
"id-handling-dynamic"></a>2.3.3 Handling Dynamic Errors</h4>
<p>Except as noted in this document, if any operand of an
expression raises a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a>, the expression also raises a
<a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a>. If an expression can validly return a value or raise a
dynamic error, the implementation may choose to return the value or
raise the dynamic error. For example, the logical expression
<code>expr1 and expr2</code> may return the value
<code>false</code> if either operand returns <code>false</code>, or
may raise a dynamic error if either operand raises a dynamic
error.</p>
<p>If more than one operand of an expression raises an error, the
implementation may choose which error is raised by the expression.
For example, in this expression:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
($x div $y) + xs:decimal($z)
</pre></div>
</div>
<p>both the sub-expressions <code>($x div $y)</code> and
<code>xs:decimal($z)</code> may raise an error. The implementation
may choose which error is raised by the "<code>+</code>"
expression. Once one operand raises an error, the implementation is
not required, but is permitted, to evaluate any other operands.</p>
<p>[<a name="dt-error-value" id="dt-error-value" title=
"error value">Definition</a>: In addition to its identifying QName,
a dynamic error may also carry a descriptive string and one or more
additional values called <b>error values</b>.] An implementation
may provide a mechanism whereby an application-defined error
handler can process error values and produce diagnostic
messages.</p>
<p>A dynamic error may be raised by a <a title="built-in function"
href="#dt-built-in-function">built-in function</a> or operator. For
example, the <code>div</code> operator raises an error if its
operands are <code>xs:decimal</code> values and its second operand
is equal to zero. Errors raised by built-in functions and operators
are defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and
XPath 2.0 Functions and Operators (Second Edition)]</a>.</p>
<p>A dynamic error can also be raised explicitly by calling the
<code>fn:error</code> function, which only raises an error and
never returns a value. This function is defined in <a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators (Second Edition)]</a>. For example, the following
function call raises a dynamic error, providing a QName that
identifies the error, a descriptive string, and a diagnostic value
(assuming that the prefix <code>app</code> is bound to a namespace
containing application-defined error codes):</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
fn:error(xs:QName("app:err057"), "Unexpected value", fn:string($v))
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="id-errors-and-opt" id="id-errors-and-opt"></a>2.3.4
Errors and Optimization</h4>
<p>Because different implementations may choose to evaluate or
optimize an expression in different ways, certain aspects of the
detection and reporting of <a title="dynamic error" href=
"#dt-dynamic-error">dynamic errors</a> are <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>, as
described in this section.</p>
<p>An implementation is always free to evaluate the operands of an
operator in any order.</p>
<p>In some cases, a processor can determine the result of an
expression without accessing all the data that would be implied by
the formal expression semantics. For example, the formal
description of <a title="filter expression" href=
"#dt-filter-expression">filter expressions</a> suggests that
<code>$s[1]</code> should be evaluated by examining all the items
in sequence <code>$s</code>, and selecting all those that satisfy
the predicate <code>position()=1</code>. In practice, many
implementations will recognize that they can evaluate this
expression by taking the first item in the sequence and then
exiting. If <code>$s</code> is defined by an expression such as
<code>//book[author eq 'Berners-Lee']</code>, then this strategy
may avoid a complete scan of a large document and may therefore
greatly improve performance. However, a consequence of this
strategy is that a dynamic error or type error that would be
detected if the expression semantics were followed literally might
not be detected at all if the evaluation exits early. In this
example, such an error might occur if there is a <code>book</code>
element in the input data with more than one <code>author</code>
subelement.</p>
<p>The extent to which a processor may optimize its access to data,
at the cost of not detecting errors, is defined by the following
rules.</p>
<p>Consider an expression <em>Q</em> that has an operand
(sub-expression) <em>E</em>. In general the value of <em>E</em> is
a sequence. At an intermediate stage during evaluation of the
sequence, some of its items will be known and others will be
unknown. If, at such an intermediate stage of evaluation, a
processor is able to establish that there are only two possible
outcomes of evaluating <em>Q</em>, namely the value <em>V</em> or
an error, then the processor may deliver the result <em>V</em>
without evaluating further items in the operand <em>E</em>. For
this purpose, two values are considered to represent the same
outcome if their items are pairwise the same, where nodes are the
same if they have the same identity, and values are the same if
they are equal and have exactly the same type.</p>
<p>There is an exception to this rule: If a processor evaluates an
operand <em>E</em> (wholly or in part), then it is required to
establish that the actual value of the operand <em>E</em> does not
violate any constraints on its cardinality. For example, the
expression <code>$e eq 0</code> results in a type error if the
value of <code>$e</code> contains two or more items. A processor is
not allowed to decide, after evaluating the first item in the value
of <code>$e</code> and finding it equal to zero, that the only
possible outcomes are the value <code>true</code> or a type error
caused by the cardinality violation. It must establish that the
value of <code>$e</code> contains no more than one item.</p>
<p>These rules apply to all the operands of an expression
considered in combination: thus if an expression has two operands
<em>E1</em> and <em>E2</em>, it may be evaluated using any samples
of the respective sequences that satisfy the above rules.</p>
<p>The rules cascade: if <em>A</em> is an operand of <em>B</em> and
<em>B</em> is an operand of <em>C</em>, then the processor needs to
evaluate only a sufficient sample of <em>B</em> to determine the
value of <em>C</em>, and needs to evaluate only a sufficient sample
of <em>A</em> to determine this sample of <em>B</em>.</p>
<p>The effect of these rules is that the processor is free to stop
examining further items in a sequence as soon as it can establish
that further items would not affect the result except possibly by
causing an error. For example, the processor may return
<code>true</code> as the result of the expression <code>S1 =
S2</code> as soon as it finds a pair of equal values from the two
sequences.</p>
<p>Another consequence of these rules is that where none of the
items in a sequence contributes to the result of an expression, the
processor is not obliged to evaluate any part of the sequence.
Again, however, the processor cannot dispense with a required
cardinality check: if an empty sequence is not permitted in the
relevant context, then the processor must ensure that the operand
is not an empty sequence.</p>
<p>Examples:</p>
<ul>
<li>
<p>If an implementation can find (for example, by using an index)
that at least one item returned by <code>$expr1</code> in the
following example has the value <code>47</code>, it is allowed to
return <code>true</code> as the result of the <code>some</code>
expression, without searching for another item returned by
<code>$expr1</code> that would raise an error if it were
evaluated.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
some $x in $expr1 satisfies $x = 47
</pre></div>
</div>
</li>
<li>
<p>In the following example, if an implementation can find (for
example, by using an index) the <code>product</code> element-nodes
that have an <code>id</code> child with the value <code>47</code>,
it is allowed to return these nodes as the result of the <a title=
"path expression" href="#dt-path-expression">path expression</a>,
without searching for another <code>product</code> node that would
raise an error because it has an <code>id</code> child whose value
is not an integer.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
//product[id = 47]
</pre></div>
</div>
</li>
</ul>
<p>For a variety of reasons, including optimization,
implementations may rewrite expressions into a different form.
There are a number of rules that limit the extent of this
freedom:</p>
<ul>
<li>
<p>Other than the raising or not raising of errors, the result of
evaluating a rewritten expression must conform to the semantics
defined in this specification for the original expression.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This allows an implementation to return a result in cases where
the original expression would have raised an error, or to raise an
error in cases where the original expression would have returned a
result. The main cases where this is likely to arise in practice
are (a) where a rewrite changes the order of evaluation, such that
a subexpression causing an error is evaluated when the expression
is written one way and is not evaluated when the expression is
written a different way, and (b) where intermediate results of the
evaluation cause overflow or other out-of-range conditions.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This rule does not mean that the result of the expression will
always be the same in non-error cases as if it had not been
rewritten, because there are many cases where the result of an
expression is to some degree <a title="implementation dependent"
href="#dt-implementation-dependent">implementation-dependent</a> or
<a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</div>
</li>
<li>
<p>Conditional and typeswitch expressions must not raise a dynamic
error in respect of subexpressions occurring in a branch that is
not selected, and must not return the value delivered by a branch
unless that branch is selected. Thus, the following example must
not raise a dynamic error if the document <code>abc.xml</code> does
not exist:</p>
<div class="exampleInner">
<pre>
if (doc-available('abc.xml')) then doc('abc.xml') else ()
</pre></div>
</li>
<li>
<p>As stated earlier, an expression must not be rewritten to
dispense with a required cardinality check: for example,
<code>string-length(//title)</code> must raise an error if the
document contains more than one title element.</p>
</li>
<li>
<p>Expressions must not be rewritten in such a way as to create or
remove static errors. For example, there is a rule that in casting
a string to a QName the operand must be a string literal. This rule
applies to the original expression and not to any rewritten form of
the expression.</p>
</li>
</ul>
<p>Expression rewrite is illustrated by the following examples.</p>
<ul>
<li>
<p>Consider the expression <code>//part[color eq "Red"]</code>. An
implementation might choose to rewrite this expression as
<code>//part[color = "Red"][color eq "Red"]</code>. The
implementation might then process the expression as follows: First
process the "<code>=</code>" predicate by probing an index on parts
by color to quickly find all the parts that have a Red color; then
process the "<code>eq</code>" predicate by checking each of these
parts to make sure it has only a single color. The result would be
as follows:</p>
<ul>
<li>
<p>Parts that have exactly one color that is Red are returned.</p>
</li>
<li>
<p>If some part has color Red together with some other color, an
error is raised.</p>
</li>
<li>
<p>The existence of some part that has no color Red but has
multiple non-Red colors does not trigger an error.</p>
</li>
</ul>
</li>
<li>
<p>The expression in the following example cannot raise a casting
error if it is evaluated exactly as written (i.e., left to right).
Since neither predicate depends on the context position, an
implementation might choose to reorder the predicates to achieve
better performance (for example, by taking advantage of an index).
This reordering could cause the expression to raise an error.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
$N[@x castable as xs:date][xs:date(@x) gt xs:date("2000-01-01")]
</pre></div>
</div>
<p>To avoid unexpected errors caused by expression rewrite, tests
that are designed to prevent dynamic errors should be expressed
using conditional expressions. For example, the above expression
can be written as follows:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
$N[if (@x castable as xs:date)
   then xs:date(@x) gt xs:date("2000-01-01")
   else false()]
</pre></div>
</div>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="id-important-concepts" id=
"id-important-concepts"></a>2.4 Concepts</h3>
<p>This section explains some concepts that are important to the
processing of XPath expressions.</p>
<div class="div3">
<h4><a name="id-document-order" id="id-document-order"></a>2.4.1
Document Order</h4>
<p>An ordering called <b>document order</b> is defined among all
the nodes accessible during processing of a given <span class=
"xpath"><span class="xpath">expression</span></span>, which may
consist of one or more <b>trees</b> (documents or fragments).
Document order is defined in <a href="#datamodel">[XQuery 1.0 and
XPath 2.0 Data Model (Second Edition)]</a>, and its definition is
repeated here for convenience. [<a name="dt-reverse-document-order"
id="dt-reverse-document-order" title=
"reverse document order">Definition</a>: The node ordering that is
the reverse of document order is called <b>reverse document
order</b>.]</p>
<p>Document order is a total ordering, although the relative order
of some nodes is <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>.
[<a name="dt-document-order" id="dt-document-order" title=
"document order">Definition</a>: Informally, <b>document order</b>
is the order in which nodes appear in the XML serialization of a
document.] [<a name="stable" id="stable" title=
"stable">Definition</a>: Document order is <b>stable</b>, which
means that the relative order of two nodes will not change during
the processing of a given <span class="xpath"><span class=
"xpath">expression</span></span>, even if this order is <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>.]</p>
<p>Within a tree, document order satisfies the following
constraints:</p>
<ol class="enumar">
<li>
<p>The root node is the first node.</p>
</li>
<li>
<p>Every node occurs before all of its children and
descendants.</p>
</li>
<li class="xpath">
<p>Namespace nodes immediately follow the element node with which
they are associated. The relative order of namespace nodes is
stable but <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
</li>
<li>
<p>Attribute nodes immediately follow the <span class=
"xpath"><span class="xpath">namespace nodes of the</span></span>
element node with which they are associated. The relative order of
attribute nodes is stable but <a title="implementation dependent"
href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
</li>
<li>
<p>The relative order of siblings is the order in which they occur
in the <code>children</code> property of their parent node.</p>
</li>
<li>
<p>Children and descendants occur before following siblings.</p>
</li>
</ol>
<p>The relative order of nodes in distinct trees is stable but
<a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>,
subject to the following constraint: If any node in a given tree T1
is before any node in a different tree T2, then all nodes in tree
T1 are before all nodes in tree T2.</p>
</div>
<div class="div3">
<h4><a name="id-atomization" id="id-atomization"></a>2.4.2
Atomization</h4>
<p>The semantics of some XPath operators depend on a process called
<a title="atomization" href="#dt-atomization">atomization</a>.
Atomization is applied to a value when the value is used in a
context in which a sequence of atomic values is required. The
result of atomization is either a sequence of atomic values or a
<a title="type error" href="#dt-type-error">type error</a>
[err:FOTY0012]. [<a name="dt-atomization" id="dt-atomization"
title="atomization">Definition</a>: <b>Atomization</b> of a
sequence is defined as the result of invoking the
<code>fn:data</code> function on the sequence, as defined in
<a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0
Functions and Operators (Second Edition)]</a>.]</p>
<p>The semantics of <code>fn:data</code> are repeated here for
convenience. The result of <code>fn:data</code> is the sequence of
atomic values produced by applying the following rules to each item
in the input sequence:</p>
<ul>
<li>
<p>If the item is an atomic value, it is returned.</p>
</li>
<li>
<p>If the item is a node, its <a title="typed value" href=
"#dt-typed-value">typed value</a> is returned (err:FOTY0012 is
raised if the node has no typed value.)</p>
</li>
</ul>
<p>Atomization is used in processing the following types of
expressions:</p>
<ul>
<li>
<p>Arithmetic expressions</p>
</li>
<li>
<p>Comparison expressions</p>
</li>
<li>
<p>Function calls and returns</p>
</li>
<li>
<p>Cast expressions</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-ebv" id="id-ebv"></a>2.4.3 Effective Boolean
Value</h4>
<p>Under certain circumstances (listed below), it is necessary to
find the <a title="effective boolean value" href=
"#dt-ebv">effective boolean value</a> of a value. [<a name="dt-ebv"
id="dt-ebv" title="effective boolean value">Definition</a>: The
<b>effective boolean value</b> of a value is defined as the result
of applying the <code>fn:boolean</code> function to the value, as
defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath
2.0 Functions and Operators (Second Edition)]</a>.]</p>
<p>The dynamic semantics of <code>fn:boolean</code> are repeated
here for convenience:</p>
<ol class="enumar">
<li>
<p>If its operand is an empty sequence, <code>fn:boolean</code>
returns <code>false</code>.</p>
</li>
<li>
<p>If its operand is a sequence whose first item is a node,
<code>fn:boolean</code> returns <code>true</code>.</p>
</li>
<li>
<p>If its operand is a <a title="singleton" href=
"#dt-singleton">singleton</a> value of type <code>xs:boolean</code>
or derived from <code>xs:boolean</code>, <code>fn:boolean</code>
returns the value of its operand unchanged.</p>
</li>
<li>
<p>If its operand is a <a title="singleton" href=
"#dt-singleton">singleton</a> value of type <code>xs:string</code>,
<code>xs:anyURI</code>, <code>xs:untypedAtomic</code>, or a type
derived from one of these, <code>fn:boolean</code> returns
<code>false</code> if the operand value has zero length; otherwise
it returns <code>true</code>.</p>
</li>
<li>
<p>If its operand is a <a title="singleton" href=
"#dt-singleton">singleton</a> value of any <a title="numeric" href=
"#dt-numeric">numeric</a> type or derived from a numeric type,
<code>fn:boolean</code> returns <code>false</code> if the operand
value is <code>NaN</code> or is numerically equal to zero;
otherwise it returns <code>true</code>.</p>
</li>
<li>
<p>In all other cases, <code>fn:boolean</code> raises a type error
[err:FORG0006].</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The static semantics of <code>fn:boolean</code> are defined in
<a href=
"http://www.w3.org/TR/xquery-semantics/#sec_fn_boolean">Section
7.2.4 The fn:boolean and fn:not
functions</a><sup><small>FS</small></sup>.</p>
</div>
<p>The <a title="effective boolean value" href="#dt-ebv">effective
boolean value</a> of a sequence is computed implicitly during
processing of the following types of expressions:</p>
<ul>
<li>
<p>Logical expressions (<code>and</code>, <code>or</code>)</p>
</li>
<li>
<p>The <code>fn:not</code> function</p>
</li>
<li>
<p>Certain types of <a title="predicate" href=
"#dt-predicate">predicates</a>, such as <code>a[b]</code></p>
</li>
<li>
<p>Conditional expressions (<code>if</code>)</p>
</li>
<li>
<p>Quantified expressions (<code>some</code>,
<code>every</code>)</p>
</li>
<li class="xpath">
<p>General comparisons, in <a title="XPath 1.0 compatibility mode"
href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a>.</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The definition of <a title="effective boolean value" href=
"#dt-ebv">effective boolean value</a> is <em>not</em> used when
casting a value to the type <code>xs:boolean</code>, for example in
a <code>cast</code> expression or when passing a value to a
function whose expected parameter is of type
<code>xs:boolean</code>.</p>
</div>
</div>
<div class="div3">
<h4><a name="id-input-sources" id="id-input-sources"></a>2.4.4
Input Sources</h4>
<p>XPath has a set of functions that provide access to input data.
These functions are of particular importance because they provide a
way in which an expression can reference a document or a collection
of documents. The input functions are described informally here;
they are defined in <a href="#FunctionsAndOperators">[XQuery 1.0
and XPath 2.0 Functions and Operators (Second Edition)]</a>.</p>
<p>An expression can access input data either by calling one of the
input functions or by referencing some part of the <a title=
"dynamic context" href="#dt-dynamic-context">dynamic context</a>
that is initialized by the external environment, such as a
<a title="variable values" href="#dt-variable-values">variable</a>
or <a title="context item" href="#dt-context-item">context
item</a>.</p>
<p>The input functions supported by XPath are as follows:</p>
<ul>
<li>
<p>The <code>fn:doc</code> function takes a string containing a
URI. If that URI is associated with a document in <a title=
"available documents" href="#dt-available-docs">available
documents</a>, <code>fn:doc</code> returns a document node whose
content is the <a title="data model" href="#dt-datamodel">data
model</a> representation of the given document; otherwise it raises
a <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a> (see <a href="#FunctionsAndOperators">[XQuery 1.0 and
XPath 2.0 Functions and Operators (Second Edition)]</a> for
details).</p>
</li>
<li>
<p>The <code>fn:collection</code> function with one argument takes
a string containing a URI. If that URI is associated with a
collection in <a title="available collections" href=
"#dt-available-collections">available collections</a>,
<code>fn:collection</code> returns the data model representation of
that collection; otherwise it raises a <a title="dynamic error"
href="#dt-dynamic-error">dynamic error</a> (see <a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators (Second Edition)]</a> for details). A collection may be
any sequence of nodes. For example, the expression
<code>fn:collection("http://example.org")//customer</code>
identifies all the <code>customer</code> elements that are
descendants of nodes found in the collection whose URI is
<code>http://example.org</code>.</p>
</li>
<li>
<p>The <code>fn:collection</code> function with zero arguments
returns the <a title="default collection" href=
"#dt-default-collection">default collection</a>, an <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>
sequence of nodes.</p>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="id-types" id="id-types"></a>2.5 Types</h3>
<p>The type system of XPath is based on <a href="#XMLSchema">[XML
Schema]</a>, and is formally defined in <a href=
"#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics
(Second Edition)]</a>.</p>
<p>[<a name="dt-sequence-type" id="dt-sequence-type" title=
"sequence type">Definition</a>: A <b>sequence type</b> is a type
that can be expressed using the <a href=
"#doc-xpath-SequenceType">SequenceType</a> syntax. Sequence types
are used whenever it is necessary to refer to a type in an XPath
expression. The term <b>sequence type</b> suggests that this syntax
is used to describe the type of an XPath value, which is always a
sequence.]</p>
<p>[<a name="dt-schema-type" id="dt-schema-type" title=
"schema type">Definition</a>: A <b>schema type</b> is a type that
is (or could be) defined using the facilities of <a href=
"#XMLSchema">[XML Schema]</a> (including the built-in types of
<a href="#XMLSchema">[XML Schema]</a>).] A schema type can be used
as a type annotation on an element or attribute node (unless it is
a non-instantiable type such as <code>xs:NOTATION</code> or
<code>xs:anyAtomicType</code>, in which case its derived types can
be so used). Every schema type is either a <b>complex type</b> or a
<b>simple type</b>; simple types are further subdivided into
<b>list types</b>, <b>union types</b>, and <b>atomic types</b> (see
<a href="#XMLSchema">[XML Schema]</a> for definitions and
explanations of these terms.)</p>
<p>Atomic types represent the intersection between the categories
of <a title="sequence type" href="#dt-sequence-type">sequence
type</a> and <a title="schema type" href="#dt-schema-type">schema
type</a>. An atomic type, such as <code>xs:integer</code> or
<code>my:hatsize</code>, is both a <a title="sequence type" href=
"#dt-sequence-type">sequence type</a> and a <a title="schema type"
href="#dt-schema-type">schema type</a>.</p>
<div class="div3">
<h4><a name="id-predefined-types" id=
"id-predefined-types"></a>2.5.1 Predefined Schema Types</h4>
<div class="xpath">
<p class="xpath">The <a title="in-scope schema type" href=
"#dt-is-types">in-scope schema types</a> in the <a title=
"static context" href="#dt-static-context">static context</a> are
initialized with a set of predefined schema types that is
determined by the host language. This set may include some or all
of the schema types in the namespace
<code>http://www.w3.org/2001/XMLSchema</code>, represented in this
document by the namespace prefix <code>xs</code>. The schema types
in this namespace are defined in <a href="#XMLSchema">[XML
Schema]</a> and augmented by additional types defined in <a href=
"#datamodel">[XQuery 1.0 and XPath 2.0 Data Model (Second
Edition)]</a>. The schema types defined in <a href=
"#datamodel">[XQuery 1.0 and XPath 2.0 Data Model (Second
Edition)]</a> are summarized below.</p>
</div>
<ol class="enumar">
<li>
<p>[<a name="dt-untyped" id="dt-untyped" title=
"xs:untyped">Definition</a>: <code>xs:untyped</code> is used as the
<a title="type annotation" href="#dt-type-annotation">type
annotation</a> of an element node that has not been validated, or
has been validated in <code>skip</code> mode.] No predefined schema
types are derived from <code>xs:untyped</code>.</p>
</li>
<li>
<p>[<a name="dt-untypedAtomic" id="dt-untypedAtomic" title=
"xs:untypedAtomic">Definition</a>: <code>xs:untypedAtomic</code> is
an atomic type that is used to denote untyped atomic data, such as
text that has not been assigned a more specific type.] An attribute
that has been validated in <code>skip</code> mode is represented in
the <a title="data model" href="#dt-datamodel">data model</a> by an
attribute node with the <a title="type annotation" href=
"#dt-type-annotation">type annotation</a>
<code>xs:untypedAtomic</code>. No predefined schema types are
derived from <code>xs:untypedAtomic</code>.</p>
</li>
<li>
<p>[<a name="dt-dayTimeDuration" id="dt-dayTimeDuration" title=
"xs:dayTimeDuration">Definition</a>:
<code>xs:dayTimeDuration</code> is derived by restriction from
<code>xs:duration</code>. The lexical representation of
<code>xs:dayTimeDuration</code> is restricted to contain only day,
hour, minute, and second components.]</p>
</li>
<li>
<p>[<a name="dt-yearMonthDuration" id="dt-yearMonthDuration" title=
"xs:yearMonthDuration">Definition</a>:
<code>xs:yearMonthDuration</code> is derived by restriction from
<code>xs:duration</code>. The lexical representation of
<code>xs:yearMonthDuration</code> is restricted to contain only
year and month components.]</p>
</li>
<li>
<p>[<a name="dt-anyAtomicType" id="dt-anyAtomicType" title=
"xs:anyAtomicType">Definition</a>: <code>xs:anyAtomicType</code> is
an atomic type that includes all atomic values (and no values that
are not atomic). Its base type is <code>xs:anySimpleType</code>
from which all simple types, including atomic, list, and union
types, are derived. All primitive atomic types, such as
<code>xs:decimal</code> and <code>xs:string</code>, have
<code>xs:anyAtomicType</code> as their base type.]</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p><code>xs:anyAtomicType</code> will not appear as the type of an
actual value in an <a title="XDM instance" href=
"#dt-data-model-instance">XDM instance</a>.</p>
</div>
</li>
</ol>
<p>The relationships among the schema types in the <code>xs</code>
namespace are illustrated in Figure 2. A more complete description
of the XPath type hierarchy can be found in <a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators (Second Edition)]</a>.</p>
<img src="types.jpg" alt="Type Hierarchy Diagram" />
<p>Figure 2: Hierarchy of Schema Types used in XPath</p>
</div>
<div class="div3">
<h4><a name="id-typed-value" id="id-typed-value"></a>2.5.2 Typed
Value and String Value</h4>
<p>Every node has a <b>typed value</b> and a <b>string value</b>.
[<a name="dt-typed-value" id="dt-typed-value" title=
"typed value">Definition</a>: The <b>typed value</b> of a node is a
sequence of atomic values and can be extracted by applying the
<code>fn:data</code> function to the node.] [<a name=
"dt-string-value" id="dt-string-value" title=
"string value">Definition</a>: The <b>string value</b> of a node is
a string and can be extracted by applying the
<code>fn:string</code> function to the node.] Definitions of
<code>fn:data</code> and <code>fn:string</code> can be found in
<a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0
Functions and Operators (Second Edition)]</a>.</p>
<p>An implementation may store both the <a title="typed value"
href="#dt-typed-value">typed value</a> and the <a title=
"string value" href="#dt-string-value">string value</a> of a node,
or it may store only one of these and derive the other as needed.
The string value of a node must be a valid lexical representation
of the typed value of the node, but the node is not required to
preserve the string representation from the original source
document. For example, if the typed value of a node is the
<code>xs:integer</code> value <code>30</code>, its string value
might be "<code>30</code>" or "<code>0030</code>".</p>
<div class="xpath">
<p class="xpath">The <a title="typed value" href=
"#dt-typed-value">typed value</a>, <a title="string value" href=
"#dt-string-value">string value</a>, and <a title="type annotation"
href="#dt-type-annotation">type annotation</a> of a node are
closely related. If the node was created by mapping from an Infoset
or PSVI, the relationships among these properties are defined by
rules in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model
(Second Edition)]</a>.</p>
</div>
<p>As a convenience to the reader, the relationship between
<a title="typed value" href="#dt-typed-value">typed value</a> and
<a title="string value" href="#dt-string-value">string value</a>
for various kinds of nodes is summarized and illustrated by
examples below.</p>
<ol class="enumar">
<li>
<p>For text and document nodes, the typed value of the node is the
same as its string value, as an instance of the type
<code>xs:untypedAtomic</code>. The string value of a document node
is formed by concatenating the string values of all its descendant
text nodes, in <a title="document order" href=
"#dt-document-order">document order</a>.</p>
</li>
<li>
<p>The typed value of a comment<span class="xpath"><span class=
"xpath">, namespace,</span></span> or processing instruction node
is the same as its string value. It is an instance of the type
<code>xs:string</code>.</p>
</li>
<li>
<p>The typed value of an attribute node with the <a title=
"type annotation" href="#dt-type-annotation">type annotation</a>
<code>xs:anySimpleType</code> or <code>xs:untypedAtomic</code> is
the same as its string value, as an instance of
<code>xs:untypedAtomic</code>. The typed value of an attribute node
with any other type annotation is derived from its string value and
type annotation using the lexical-to-value-space mapping defined in
<a href="#XMLSchema">[XML Schema]</a> Part 2 for the relevant
type.</p>
<p>Example: A1 is an attribute having string value
<code>"3.14E-2"</code> and type annotation <code>xs:double</code>.
The typed value of A1 is the <code>xs:double</code> value whose
lexical representation is <code>3.14E-2</code>.</p>
<p>Example: A2 is an attribute with type annotation
<code>xs:IDREFS</code>, which is a list datatype whose item type is
the atomic datatype <code>xs:IDREF</code>. Its string value is
"<code>bar baz faz</code>". The typed value of A2 is a sequence of
three atomic values ("<code>bar</code>", "<code>baz</code>",
"<code>faz</code>"), each of type <code>xs:IDREF</code>. The typed
value of a node is never treated as an instance of a named list
type. Instead, if the type annotation of a node is a list type
(such as <code>xs:IDREFS</code>), its typed value is treated as a
sequence of the atomic type from which it is derived (such as
<code>xs:IDREF</code>).</p>
</li>
<li>
<p>For an element node, the relationship between typed value and
string value depends on the node's <a title="type annotation" href=
"#dt-type-annotation">type annotation</a>, as follows:</p>
<ol class="enumla">
<li>
<p>If the type annotation is <code>xs:untyped</code> or
<code>xs:anySimpleType</code> or denotes a complex type with mixed
content (including <code>xs:anyType</code>), then the typed value
of the node is equal to its string value, as an instance of
<code>xs:untypedAtomic</code>. However, if the <code>nilled</code>
property of the node is <code>true</code>, then its typed value is
the empty sequence.</p>
<p>Example: E1 is an element node having type annotation
<code>xs:untyped</code> and string value "<code>1999-05-31</code>".
The typed value of E1 is "<code>1999-05-31</code>", as an instance
of <code>xs:untypedAtomic</code>.</p>
<p>Example: E2 is an element node with the type annotation
<code>formula</code>, which is a complex type with mixed content.
The content of E2 consists of the character "<code>H</code>", a
child element named <code>subscript</code> with string value
"<code>2</code>", and the character "<code>O</code>". The typed
value of E2 is "<code>H2O</code>" as an instance of
<code>xs:untypedAtomic</code>.</p>
</li>
<li>
<p>If the type annotation denotes a simple type or a complex type
with simple content, then the typed value of the node is derived
from its string value and its type annotation in a way that is
consistent with schema validation. However, if the
<code>nilled</code> property of the node is <code>true</code>, then
its typed value is the empty sequence.</p>
<p>Example: E3 is an element node with the type annotation
<code>cost</code>, which is a complex type that has several
attributes and a simple content type of <code>xs:decimal</code>.
The string value of E3 is "<code>74.95</code>". The typed value of
E3 is <code>74.95</code>, as an instance of
<code>xs:decimal</code>.</p>
<p>Example: E4 is an element node with the type annotation
<code>hatsizelist</code>, which is a simple type derived from the
atomic type <code>hatsize</code>, which in turn is derived from
<code>xs:integer</code>. The string value of E4 is "<code>7 8
9</code>". The typed value of E4 is a sequence of three values
(<code>7</code>, <code>8</code>, <code>9</code>), each of type
<code>hatsize</code>.</p>
<p>Example: E5 is an element node with the type annotation
<code>my:integer-or-string</code> which is a union type with member
types <code>xs:integer</code> and <code>xs:string</code>. The
string value of E5 is "<code>47</code>". The typed value of E5 is
<code>47</code> as an <code>xs:integer</code>, since
<code>xs:integer</code> is the member type that validated the
content of E5. In general, when the type annotation of a node is a
union type, the typed value of the node will be an instance of one
of the member types of the union.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If an implementation stores only the string value of a node, and
the type annotation of the node is a union type, the implementation
must be able to deliver the typed value of the node as an instance
of the appropriate member type.</p>
</div>
</li>
<li>
<p>If the type annotation denotes a complex type with empty
content, then the typed value of the node is the empty sequence and
its string value is the zero-length string.</p>
</li>
<li>
<p>If the type annotation denotes a complex type with element-only
content, then the typed value of the node is <a title="undefined"
href="#dt-undefined">undefined</a>. The <code>fn:data</code>
function raises a <a title="type error" href="#dt-type-error">type
error</a> [err:FOTY0012] when applied to such a node. The string
value of such a node is equal to the concatenated string values of
all its text node descendants, in document order.</p>
<p>Example: E6 is an element node with the type annotation
<code>weather</code>, which is a complex type whose content type
specifies <code>element-only</code>. E6 has two child elements
named <code>temperature</code> and <code>precipitation</code>. The
typed value of E6 is <a title="undefined" href=
"#dt-undefined">undefined</a>, and the <code>fn:data</code>
function applied to E6 raises an error.</p>
</li>
</ol>
</li>
</ol>
</div>
<div class="div3">
<h4><a name="id-sequencetype-syntax" id=
"id-sequencetype-syntax"></a>2.5.3 SequenceType Syntax</h4>
<p>Whenever it is necessary to refer to a type in an XPath
expression, the <a href="#doc-xpath-SequenceType">SequenceType</a>
syntax is used.</p>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-SequenceType" id=
"doc-xpath-SequenceType"></a>[50]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-SequenceType">SequenceType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("empty-sequence" "(" ")")<br />
| (<a href="#doc-xpath-ItemType">ItemType</a> <a href=
"#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-ItemType" id=
"doc-xpath-ItemType"></a>[52]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ItemType">ItemType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-KindTest">KindTest</a> | ("item" "("
")") | <a href="#doc-xpath-AtomicType">AtomicType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-OccurrenceIndicator" id=
"doc-xpath-OccurrenceIndicator"></a>[51]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-OccurrenceIndicator">OccurrenceIndicator</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"?" | "*" | "+"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-AtomicType" id=
"doc-xpath-AtomicType"></a>[53]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-AtomicType">AtomicType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-KindTest" id=
"doc-xpath-KindTest"></a>[54]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-KindTest">KindTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-DocumentTest">DocumentTest</a><br />
| <a href="#doc-xpath-ElementTest">ElementTest</a><br />
| <a href="#doc-xpath-AttributeTest">AttributeTest</a><br />
| <a href=
"#doc-xpath-SchemaElementTest">SchemaElementTest</a><br />
| <a href=
"#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</a><br />
| <a href="#doc-xpath-PITest">PITest</a><br />
| <a href="#doc-xpath-CommentTest">CommentTest</a><br />
| <a href="#doc-xpath-TextTest">TextTest</a><br />
| <a href="#doc-xpath-AnyKindTest">AnyKindTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-DocumentTest" id=
"doc-xpath-DocumentTest"></a>[56]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-DocumentTest">DocumentTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"document-node" "(" (<a href=
"#doc-xpath-ElementTest">ElementTest</a> | <a href=
"#doc-xpath-SchemaElementTest">SchemaElementTest</a>)?
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-ElementTest" id=
"doc-xpath-ElementTest"></a>[64]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-ElementTest">ElementTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"element" "(" (<a href=
"#doc-xpath-ElementNameOrWildcard">ElementNameOrWildcard</a> (","
<a href="#doc-xpath-TypeName">TypeName</a> "?"?)?)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-SchemaElementTest" id=
"doc-xpath-SchemaElementTest"></a>[66]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-SchemaElementTest">SchemaElementTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"schema-element" "(" <a href=
"#doc-xpath-ElementDeclaration">ElementDeclaration</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-ElementDeclaration" id=
"doc-xpath-ElementDeclaration"></a>[67]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-ElementDeclaration">ElementDeclaration</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-ElementName">ElementName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-AttributeTest" id=
"doc-xpath-AttributeTest"></a>[60]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-AttributeTest">AttributeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"attribute" "(" (<a href=
"#doc-xpath-AttribNameOrWildcard">AttribNameOrWildcard</a> (","
<a href="#doc-xpath-TypeName">TypeName</a>)?)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-SchemaAttributeTest" id=
"doc-xpath-SchemaAttributeTest"></a>[62]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-SchemaAttributeTest">SchemaAttributeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"schema-attribute" "(" <a href=
"#doc-xpath-AttributeDeclaration">AttributeDeclaration</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-AttributeDeclaration" id=
"doc-xpath-AttributeDeclaration"></a>[63]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-AttributeDeclaration">AttributeDeclaration</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-AttributeName">AttributeName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-ElementNameOrWildcard" id=
"doc-xpath-ElementNameOrWildcard"></a>[65]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-ElementNameOrWildcard">ElementNameOrWildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ElementName">ElementName</a> |
"*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-ElementName" id=
"doc-xpath-ElementName"></a>[69]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-ElementName">ElementName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-AttribNameOrWildcard" id=
"doc-xpath-AttribNameOrWildcard"></a>[61]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-AttribNameOrWildcard">AttribNameOrWildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AttributeName">AttributeName</a> |
"*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-AttributeName" id=
"doc-xpath-AttributeName"></a>[68]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-AttributeName">AttributeName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-TypeName" id=
"doc-xpath-TypeName"></a>[70]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-TypeName">TypeName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-PITest" id=
"doc-xpath-PITest"></a>[59]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-PITest">PITest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"processing-instruction" "(" (<a href=
"#prod-xpath-NCName">NCName</a> | <a href=
"#doc-xpath-StringLiteral">StringLiteral</a>)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-CommentTest" id=
"doc-xpath-CommentTest"></a>[58]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-CommentTest">CommentTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"comment" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-TextTest" id=
"doc-xpath-TextTest"></a>[57]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-TextTest">TextTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"text" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-AnyKindTest" id=
"doc-xpath-AnyKindTest"></a>[55]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-AnyKindTest">AnyKindTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"node" "(" ")"</code></td>
</tr>
</tbody>
</table>
<p>With the exception of the special type
<code>empty-sequence()</code>, a <a title="sequence type" href=
"#dt-sequence-type">sequence type</a> consists of an <b>item
type</b> that constrains the type of each item in the sequence, and
a <b>cardinality</b> that constrains the number of items in the
sequence. Apart from the item type <code>item()</code>, which
permits any kind of item, item types divide into <b>node types</b>
(such as <code>element()</code>) and <b>atomic types</b> (such as
<code>xs:integer</code>).</p>
<p>Item types representing element and attribute nodes may specify
the required <a title="type annotation" href=
"#dt-type-annotation">type annotations</a> of those nodes, in the
form of a <a title="schema type" href="#dt-schema-type">schema
type</a>. Thus the item type <code>element(*, us:address)</code>
denotes any element node whose type annotation is (or is derived
from) the schema type named <code>us:address</code>.</p>
<p>Here are some examples of <a title="sequence type" href=
"#dt-sequence-type">sequence types</a> that might be used in XPath
expressions:</p>
<ul>
<li>
<p><code>xs:date</code> refers to the built-in atomic schema type
named <code>xs:date</code></p>
</li>
<li>
<p><code>attribute()?</code> refers to an optional attribute
node</p>
</li>
<li>
<p><code>element()</code> refers to any element node</p>
</li>
<li>
<p><code>element(po:shipto, po:address)</code> refers to an element
node that has the name <code>po:shipto</code> and has the type
annotation <code>po:address</code> (or a schema type derived from
<code>po:address</code>)</p>
</li>
<li>
<p><code>element(*, po:address)</code> refers to an element node of
any name that has the type annotation <code>po:address</code> (or a
type derived from <code>po:address</code>)</p>
</li>
<li>
<p><code>element(customer)</code> refers to an element node named
<code>customer</code> with any type annotation</p>
</li>
<li>
<p><code>schema-element(customer)</code> refers to an element node
whose name is <code>customer</code> (or is in the substitution
group headed by <code>customer</code>) and whose type annotation
matches the schema type declared for a <code>customer</code>
element in the <a title="in-scope element declarations" href=
"#dt-is-elems">in-scope element declarations</a></p>
</li>
<li>
<p><code>node()*</code> refers to a sequence of zero or more nodes
of any kind</p>
</li>
<li>
<p><code>item()+</code> refers to a sequence of one or more nodes
or atomic values</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-sequencetype-matching" id=
"id-sequencetype-matching"></a>2.5.4 SequenceType Matching</h4>
<p>[<a name="dt-sequencetype-matching" id=
"dt-sequencetype-matching" title=
"SequenceType matching">Definition</a>: During evaluation of an
expression, it is sometimes necessary to determine whether a value
with a known <a title="dynamic type" href=
"#dt-dynamic-type">dynamic type</a> "matches" an expected <a title=
"sequence type" href="#dt-sequence-type">sequence type</a>. This
process is known as <b>SequenceType matching</b>.] For example, an
<code>instance of</code> expression returns <code>true</code> if
the <a title="dynamic type" href="#dt-dynamic-type">dynamic
type</a> of a given value matches a given <a title="sequence type"
href="#dt-sequence-type">sequence type</a>, or <code>false</code>
if it does not.</p>
<p>QNames appearing in a <a title="sequence type" href=
"#dt-sequence-type">sequence type</a> have their prefixes expanded
to namespace URIs by means of the <a title=
"statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a> and (where
applicable) the <a title="default element/type namespace" href=
"#dt-def-elemtype-ns">default element/type namespace</a>. An
unprefixed attribute QName is in no namespace. Equality of QNames
is defined by the <code>eq</code> operator.</p>
<p>The rules for <a title="SequenceType matching" href=
"#dt-sequencetype-matching">SequenceType matching</a> compare the
<a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> of
a value with an expected <a title="sequence type" href=
"#dt-sequence-type">sequence type</a>. These rules are a subset of
the formal rules that match a value with an expected type defined
in <a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0
Formal Semantics (Second Edition)]</a>, because the Formal
Semantics must be able to match values against types that are not
expressible using the <a href=
"#doc-xpath-SequenceType">SequenceType</a> syntax.</p>
<p>Some of the rules for <a title="SequenceType matching" href=
"#dt-sequencetype-matching">SequenceType matching</a> require
determining whether a given schema type is the same as or derived
from an expected schema type. The given schema type may be "known"
(defined in the <a title="in-scope schema definitions" href=
"#dt-issd">in-scope schema definitions</a>), or "unknown" (not
defined in the <a title="in-scope schema definitions" href=
"#dt-issd">in-scope schema definitions</a>). An unknown schema type
might be encountered, for example, if a source document has been
validated using a schema that was not imported into the <a title=
"static context" href="#dt-static-context">static context</a>. In
this case, an implementation is allowed (but is not required) to
provide an <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>
mechanism for determining whether the unknown schema type is
derived from the expected schema type. For example, an
implementation might maintain a data dictionary containing
information about type hierarchies.</p>
<p>[<a name="dt-subtype-substitution" id="dt-subtype-substitution"
title="subtype substitution">Definition</a>: The use of a value
whose <a title="dynamic type" href="#dt-dynamic-type">dynamic
type</a> is derived from an expected type is known as <b>subtype
substitution</b>.] Subtype substitution does not change the actual
type of a value. For example, if an <code>xs:integer</code> value
is used where an <code>xs:decimal</code> value is expected, the
value retains its type as <code>xs:integer</code>.</p>
<p>The definition of <a title="SequenceType matching" href=
"#dt-sequencetype-matching">SequenceType matching</a> relies on a
pseudo-function named <code>derives-from(</code><em>AT,
ET</em><code>)</code>, which takes an actual simple or complex
schema type <em>AT</em> and an expected simple or complex schema
type <em>ET</em>, and either returns a boolean value or raises a
<a title="type error" href="#dt-type-error">type error</a>
[<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]. The
pseudo-function <code>derives-from</code> is defined below and is
defined formally in <a href="#XQueryFormalSemantics">[XQuery 1.0
and XPath 2.0 Formal Semantics (Second Edition)]</a>.</p>
<ul>
<li>
<p><code>derives-from(</code><em>AT</em>, <em>ET</em><code>)</code>
returns <code>true</code> if <em>ET</em> is a known type and any of
the following three conditions is true:</p>
<ol class="enumar">
<li>
<p><em>AT</em> is a schema type found in the <a title=
"in-scope schema definitions" href="#dt-issd">in-scope schema
definitions</a>, and is the same as <em>ET</em> or is derived by
restriction or extension from <em>ET</em></p>
</li>
<li>
<p><em>AT</em> is a schema type not found in the <a title=
"in-scope schema definitions" href="#dt-issd">in-scope schema
definitions</a>, and an <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>
mechanism is able to determine that <em>AT</em> is derived by
restriction from <em>ET</em></p>
</li>
<li>
<p>There exists some schema type <em>IT</em> such that
<code>derives-from(</code><em>IT, ET</em><code>)</code> and
<code>derives-from(</code><em>AT, IT</em><code>)</code> are
true.</p>
</li>
</ol>
</li>
<li>
<p><code>derives-from(</code><em>AT</em>, <em>ET</em><code>)</code>
returns <code>false</code> if <em>ET</em> is a known type and
either the first and third or the second and third of the following
conditions are true:</p>
<ol class="enumar">
<li>
<p><em>AT</em> is a schema type found in the <a title=
"in-scope schema definitions" href="#dt-issd">in-scope schema
definitions</a>, and is not the same as <em>ET</em>, and is not
derived by restriction or extension from <em>ET</em></p>
</li>
<li>
<p><em>AT</em> is a schema type not found in the <a title=
"in-scope schema definitions" href="#dt-issd">in-scope schema
definitions</a>, and an <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>
mechanism is able to determine that <em>AT</em> is not derived by
restriction from <em>ET</em></p>
</li>
<li>
<p>No schema type <em>IT</em> exists such that
<code>derives-from(</code><em>IT, ET</em><code>)</code> and
<code>derives-from(</code><em>AT, IT</em><code>)</code> are
true.</p>
</li>
</ol>
</li>
<li>
<p><code>derives-from(</code><em>AT</em>, <em>ET</em><code>)</code>
raises a <a title="type error" href="#dt-type-error">type error</a>
[<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]
if:</p>
<ol class="enumar">
<li>
<p><em>ET</em> is an unknown type, or</p>
</li>
<li>
<p><em>AT</em> is an unknown type, and the implementation is not
able to determine whether <em>AT</em> is derived by restriction
from <em>ET</em>.</p>
</li>
</ol>
</li>
</ul>
<p>The rules for <a title="SequenceType matching" href=
"#dt-sequencetype-matching">SequenceType matching</a> are given
below, with examples (the examples are for purposes of
illustration, and do not cover all possible cases).</p>
<div class="div4">
<h5><a name="id-matching-value" id="id-matching-value"></a>2.5.4.1
Matching a SequenceType and a Value</h5>
<ul>
<li>
<p>The <a title="sequence type" href="#dt-sequence-type">sequence
type</a> <code>empty-sequence()</code> matches a value that is the
empty sequence.</p>
</li>
<li>
<p>An <a href="#doc-xpath-ItemType">ItemType</a> with no <a href=
"#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</a> matches
any value that contains exactly one item if the <a href=
"#doc-xpath-ItemType">ItemType</a> matches that item (see <a href=
"#id-matching-item"><b>2.5.4.2 Matching an ItemType and an
Item</b></a>).</p>
</li>
<li>
<p>An <a href="#doc-xpath-ItemType">ItemType</a> with an <a href=
"#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</a> matches a
value if the number of items in the value matches the <a href=
"#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</a> and the
<a href="#doc-xpath-ItemType">ItemType</a> matches each of the
items in the value.</p>
</li>
</ul>
<p>An <a href=
"#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</a> specifies
the number of items in a sequence, as follows:</p>
<ul>
<li>
<p><code>?</code> matches zero or one items</p>
</li>
<li>
<p><code>*</code> matches zero or more items</p>
</li>
<li>
<p><code>+</code> matches one or more items</p>
</li>
</ul>
<p>As a consequence of these rules, any <a title="sequence type"
href="#dt-sequence-type">sequence type</a> whose <a href=
"#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</a> is
<code>*</code> or <code>?</code> matches a value that is an empty
sequence.</p>
</div>
<div class="div4">
<h5><a name="id-matching-item" id="id-matching-item"></a>2.5.4.2
Matching an ItemType and an Item</h5>
<ul>
<li>
<p>An <a href="#doc-xpath-ItemType">ItemType</a> consisting simply
of a QName is interpreted as an <a href=
"#doc-xpath-AtomicType">AtomicType</a>. An AtomicType
<em>AtomicType</em> matches an atomic value whose actual type is
<em>AT</em> if <code>derives-from(</code><em>AT,
AtomicType</em><code>)</code> is <code>true</code>. If a QName that
is used as an <a href="#doc-xpath-AtomicType">AtomicType</a> is not
defined as an atomic type in the <a title="in-scope schema type"
href="#dt-is-types">in-scope schema types</a>, a <a title=
"static error" href="#dt-static-error">static error</a> is raised
[<a href="#ERRXPST0051" title="err:XPST0051">err:XPST0051</a>].</p>
<p>Example: The <a href="#doc-xpath-AtomicType">AtomicType</a>
<code>xs:decimal</code> matches the value <code>12.34</code> (a
decimal literal). <code>xs:decimal</code> also matches a value
whose type is <code>shoesize</code>, if <code>shoesize</code> is an
atomic type derived by restriction from
<code>xs:decimal</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The names of non-atomic types such as <code>xs:IDREFS</code> are
not accepted in this context, but can often be replaced by an
atomic type with an occurrence indicator, such as
<code>xs:IDREF+</code>.</p>
</div>
</li>
<li>
<p><code>item()</code> matches any single item.</p>
<p>Example: <code>item()</code> matches the atomic value
<code>1</code> or the element <code>&lt;a/&gt;</code>.</p>
</li>
<li>
<p><code>node()</code> matches any node.</p>
</li>
<li>
<p><code>text()</code> matches any text node.</p>
</li>
<li>
<p><code>processing-instruction()</code> matches any
processing-instruction node.</p>
</li>
<li>
<p><code>processing-instruction(</code><em>N</em><code>)</code>
matches any processing-instruction node whose PITarget is equal to
<code>fn:normalize-space(N)</code>. If
<code>fn:normalize-space(N)</code> is not in the lexical space of
NCName, a type error is raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>]</p>
<p>Example: <code>processing-instruction(xml-stylesheet)</code>
matches any processing instruction whose PITarget is
<code>xml-stylesheet</code>.</p>
<p>For backward compatibility with XPath 1.0, the PITarget of a
processing instruction may also be expressed as a string literal,
as in this example:
<code>processing-instruction("xml-stylesheet")</code>.</p>
</li>
<li>
<p><code>comment()</code> matches any comment node.</p>
</li>
<li>
<p><code>document-node()</code> matches any document node.</p>
</li>
<li>
<p><code>document-node(</code><em>E</em><code>)</code> matches any
document node that contains exactly one element node, optionally
accompanied by one or more comment and processing instruction
nodes, if <em>E</em> is an <a href=
"#doc-xpath-ElementTest">ElementTest</a> or <a href=
"#doc-xpath-SchemaElementTest">SchemaElementTest</a> that matches
the element node (see <a href="#id-element-test"><b>2.5.4.3 Element
Test</b></a> and <a href="#id-schema-element-test"><b>2.5.4.4
Schema Element Test</b></a>).</p>
<p>Example: <code>document-node(element(book))</code> matches a
document node containing exactly one element node that is matched
by the ElementTest <code>element(book)</code>.</p>
</li>
<li>
<p>An <a href="#doc-xpath-ItemType">ItemType</a> that is an
<a href="#doc-xpath-ElementTest">ElementTest</a>, <a href=
"#doc-xpath-SchemaElementTest">SchemaElementTest</a>, <a href=
"#doc-xpath-AttributeTest">AttributeTest</a>, or <a href=
"#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</a> matches an
element or attribute node as described in the following
sections.</p>
</li>
</ul>
</div>
<div class="div4">
<h5><a name="id-element-test" id="id-element-test"></a>2.5.4.3
Element Test</h5>
<p>An <a href="#doc-xpath-ElementTest">ElementTest</a> is used to
match an element node by its name and/or <a title="type annotation"
href="#dt-type-annotation">type annotation</a>. An <a href=
"#doc-xpath-ElementTest">ElementTest</a> may take any of the
following forms. In these forms, <a href=
"#doc-xpath-ElementName">ElementName</a> need not be present in the
<a title="in-scope element declarations" href=
"#dt-is-elems">in-scope element declarations</a>, but <a href=
"#doc-xpath-TypeName">TypeName</a> must be present in the <a title=
"in-scope schema type" href="#dt-is-types">in-scope schema
types</a> [<a href="#ERRXPST0008" title=
"err:XPST0008">err:XPST0008</a>]. Note that <a title=
"substitution group" href="#dt-substitution-group">substitution
groups</a> do not affect the semantics of <a href=
"#doc-xpath-ElementTest">ElementTest</a>.</p>
<ol class="enumar">
<li>
<p><code>element()</code> and <code>element(*)</code> match any
single element node, regardless of its name or type annotation.</p>
</li>
<li>
<p><code>element(</code><a href=
"#doc-xpath-ElementName">ElementName</a><code>)</code> matches any
element node whose name is <a href=
"#doc-xpath-ElementName">ElementName</a>, regardless of its type
annotation or <code>nilled</code> property.</p>
<p>Example: <code>element(person)</code> matches any element node
whose name is <code>person</code>.</p>
</li>
<li>
<p><code>element(</code><a href=
"#doc-xpath-ElementName">ElementName</a><code>,</code> <a href=
"#doc-xpath-TypeName">TypeName</a><code>)</code> matches an element
node whose name is <a href="#doc-xpath-ElementName">ElementName</a>
if <code>derives-from(</code><em>AT</em>, <a href=
"#doc-xpath-TypeName">TypeName</a> <code>)</code> is
<code>true</code>, where <em>AT</em> is the type annotation of the
element node, and the <code>nilled</code> property of the node is
<code>false</code>.</p>
<p>Example: <code>element(person, surgeon)</code> matches a
non-nilled element node whose name is <code>person</code> and whose
type annotation is <code>surgeon</code> (or is derived from
<code>surgeon</code>).</p>
</li>
<li>
<p><code>element(</code><a href=
"#doc-xpath-ElementName">ElementName</a>, <a href=
"#doc-xpath-TypeName">TypeName</a> <code>?)</code> matches an
element node whose name is <a href=
"#doc-xpath-ElementName">ElementName</a> if
<code>derives-from(</code><em>AT</em>, <a href=
"#doc-xpath-TypeName">TypeName</a><code>)</code> is
<code>true</code>, where <em>AT</em> is the type annotation of the
element node. The <code>nilled</code> property of the node may be
either <code>true</code> or <code>false</code>.</p>
<p>Example: <code>element(person, surgeon?)</code> matches a nilled
or non-nilled element node whose name is <code>person</code> and
whose type annotation is <code>surgeon</code> (or is derived from
<code>surgeon</code>).</p>
</li>
<li>
<p><code>element(*,</code> <a href=
"#doc-xpath-TypeName">TypeName</a><code>)</code> matches an element
node regardless of its name, if
<code>derives-from(</code><em>AT</em>, <a href=
"#doc-xpath-TypeName">TypeName</a> <code>)</code> is
<code>true</code>, where <em>AT</em> is the type annotation of the
element node, and the <code>nilled</code> property of the node is
<code>false</code>.</p>
<p>Example: <code>element(*, surgeon)</code> matches any non-nilled
element node whose type annotation is <code>surgeon</code> (or is
derived from <code>surgeon</code>), regardless of its name.</p>
</li>
<li>
<p><code>element(*,</code> <a href=
"#doc-xpath-TypeName">TypeName</a> <code>?)</code> matches an
element node regardless of its name, if
<code>derives-from(</code><em>AT</em>, <a href=
"#doc-xpath-TypeName">TypeName</a> <code>)</code> is
<code>true</code>, where <em>AT</em> is the type annotation of the
element node. The <code>nilled</code> property of the node may be
either <code>true</code> or <code>false</code>.</p>
<p>Example: <code>element(*, surgeon?)</code> matches any nilled or
non-nilled element node whose type annotation is
<code>surgeon</code> (or is derived from <code>surgeon</code>),
regardless of its name.</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="id-schema-element-test" id=
"id-schema-element-test"></a>2.5.4.4 Schema Element Test</h5>
<p>A <a href="#doc-xpath-SchemaElementTest">SchemaElementTest</a>
matches an element node against a corresponding element declaration
found in the <a title="in-scope element declarations" href=
"#dt-is-elems">in-scope element declarations</a>. It takes the
following form:</p>
<p><code>schema-element(</code><a href=
"#doc-xpath-ElementName">ElementName</a><code>)</code></p>
<p>If the <a href="#doc-xpath-ElementName">ElementName</a>
specified in the <a href=
"#doc-xpath-SchemaElementTest">SchemaElementTest</a> is not found
in the <a title="in-scope element declarations" href=
"#dt-is-elems">in-scope element declarations</a>, a <a title=
"static error" href="#dt-static-error">static error</a> is raised
[<a href="#ERRXPST0008" title="err:XPST0008">err:XPST0008</a>].</p>
<p>A <a href="#doc-xpath-SchemaElementTest">SchemaElementTest</a>
matches a candidate element node if all three of the following
conditions are satisfied:</p>
<ol class="enumar">
<li>
<p>The name of the candidate node matches the specified <a href=
"#doc-xpath-ElementName">ElementName</a> or matches the name of an
element in a <a title="substitution group" href=
"#dt-substitution-group">substitution group</a> headed by an
element named <a href="#doc-xpath-ElementName">ElementName</a>.</p>
</li>
<li>
<p><code>derives-from(</code><em>AT, ET</em><code>)</code> is
<code>true</code>, where <em>AT</em> is the type annotation of the
candidate node and <em>ET</em> is the schema type declared for
element <a href="#doc-xpath-ElementName">ElementName</a> in the
<a title="in-scope element declarations" href=
"#dt-is-elems">in-scope element declarations</a>.</p>
</li>
<li>
<p>If the element declaration for <a href=
"#doc-xpath-ElementName">ElementName</a> in the <a title=
"in-scope element declarations" href="#dt-is-elems">in-scope
element declarations</a> is not <code>nillable</code>, then the
<code>nilled</code> property of the candidate node is
<code>false</code>.</p>
</li>
</ol>
<p>Example: The <a href=
"#doc-xpath-SchemaElementTest">SchemaElementTest</a>
<code>schema-element(customer)</code> matches a candidate element
node if <code>customer</code> is a top-level element declaration in
the <a title="in-scope element declarations" href=
"#dt-is-elems">in-scope element declarations</a>, the name of the
candidate node is <code>customer</code> or is in a <a title=
"substitution group" href="#dt-substitution-group">substitution
group</a> headed by <code>customer</code>, the type annotation of
the candidate node is the same as or derived from the schema type
declared for the <code>customer</code> element, and either the
candidate node is not <code>nilled</code> or <code>customer</code>
is declared to be <code>nillable</code>.</p>
</div>
<div class="div4">
<h5><a name="id-attribute-test" id="id-attribute-test"></a>2.5.4.5
Attribute Test</h5>
<p>An <a href="#doc-xpath-AttributeTest">AttributeTest</a> is used
to match an attribute node by its name and/or <a title=
"type annotation" href="#dt-type-annotation">type annotation</a>.
An <a href="#doc-xpath-AttributeTest">AttributeTest</a> any take
any of the following forms. In these forms, <a href=
"#doc-xpath-AttributeName">AttributeName</a> need not be present in
the <a title="in-scope attribute declarations" href=
"#dt-is-attrs">in-scope attribute declarations</a>, but <a href=
"#doc-xpath-TypeName">TypeName</a> must be present in the <a title=
"in-scope schema type" href="#dt-is-types">in-scope schema
types</a> [<a href="#ERRXPST0008" title=
"err:XPST0008">err:XPST0008</a>].</p>
<ol class="enumar">
<li>
<p><code>attribute()</code> and <code>attribute(*)</code> match any
single attribute node, regardless of its name or type
annotation.</p>
</li>
<li>
<p><code>attribute(</code><a href=
"#doc-xpath-AttributeName">AttributeName</a><code>)</code> matches
any attribute node whose name is <a href=
"#doc-xpath-AttributeName">AttributeName</a>, regardless of its
type annotation.</p>
<p>Example: <code>attribute(price)</code> matches any attribute
node whose name is <code>price</code>.</p>
</li>
<li>
<p><code>attribute(</code><a href=
"#doc-xpath-AttributeName">AttributeName</a>, <a href=
"#doc-xpath-TypeName">TypeName</a><code>)</code> matches an
attribute node whose name is <a href=
"#doc-xpath-AttributeName">AttributeName</a> if
<code>derives-from(</code><em>AT</em>, <a href=
"#doc-xpath-TypeName">TypeName</a> <code>)</code> is
<code>true</code>, where <em>AT</em> is the type annotation of the
attribute node.</p>
<p>Example: <code>attribute(price, currency)</code> matches an
attribute node whose name is <code>price</code> and whose type
annotation is <code>currency</code> (or is derived from
<code>currency</code>).</p>
</li>
<li>
<p><code>attribute(*,</code> <a href=
"#doc-xpath-TypeName">TypeName</a><code>)</code> matches an
attribute node regardless of its name, if
<code>derives-from(</code><em>AT</em>, <a href=
"#doc-xpath-TypeName">TypeName</a><code>)</code> is
<code>true</code>, where <em>AT</em> is the type annotation of the
attribute node.</p>
<p>Example: <code>attribute(*, currency)</code> matches any
attribute node whose type annotation is <code>currency</code> (or
is derived from <code>currency</code>), regardless of its name.</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="id-schema-attribute-test" id=
"id-schema-attribute-test"></a>2.5.4.6 Schema Attribute Test</h5>
<p>A <a href=
"#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</a> matches an
attribute node against a corresponding attribute declaration found
in the <a title="in-scope attribute declarations" href=
"#dt-is-attrs">in-scope attribute declarations</a>. It takes the
following form:</p>
<p><code>schema-attribute(</code><a href=
"#doc-xpath-AttributeName">AttributeName</a><code>)</code></p>
<p>If the <a href="#doc-xpath-AttributeName">AttributeName</a>
specified in the <a href=
"#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</a> is not
found in the <a title="in-scope attribute declarations" href=
"#dt-is-attrs">in-scope attribute declarations</a>, a <a title=
"static error" href="#dt-static-error">static error</a> is raised
[<a href="#ERRXPST0008" title="err:XPST0008">err:XPST0008</a>].</p>
<p>A <a href=
"#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</a> matches a
candidate attribute node if both of the following conditions are
satisfied:</p>
<ol class="enumar">
<li>
<p>The name of the candidate node matches the specified <a href=
"#doc-xpath-AttributeName">AttributeName</a>.</p>
</li>
<li>
<p><code>derives-from(</code><em>AT, ET</em><code>)</code> is
<code>true</code>, where <em>AT</em> is the type annotation of the
candidate node and <em>ET</em> is the schema type declared for
attribute <a href="#doc-xpath-AttributeName">AttributeName</a> in
the <a title="in-scope attribute declarations" href=
"#dt-is-attrs">in-scope attribute declarations</a>.</p>
</li>
</ol>
<p>Example: The <a href=
"#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</a>
<code>schema-attribute(color)</code> matches a candidate attribute
node if <code>color</code> is a top-level attribute declaration in
the <a title="in-scope attribute declarations" href=
"#dt-is-attrs">in-scope attribute declarations</a>, the name of the
candidate node is <code>color</code>, and the type annotation of
the candidate node is the same as or derived from the schema type
declared for the <code>color</code> attribute.</p>
</div>
</div>
</div>
<div class="div2">
<h3><a name="comments" id="comments"></a>2.6 Comments</h3>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-Comment" id=
"doc-xpath-Comment"></a>[77]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-Comment">Comment</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(:" (<a href=
"#doc-xpath-CommentContents">CommentContents</a> | <a href=
"#doc-xpath-Comment">Comment</a>)* ":)"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-CommentContents" id=
"doc-xpath-CommentContents"></a>[82]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-CommentContents">CommentContents</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xpath-Char">Char</a>+ - (Char* ('(:' |
':)') Char*))</code></td>
</tr>
</tbody>
</table>
<p>Comments may be used to provide informative annotation for
<span class="xpath"><span class="xpath">an
expression</span></span>. Comments are lexical constructs only, and
do not affect <span class="xpath"><span class=
"xpath">expression</span></span> processing.</p>
<p>Comments are strings, delimited by the symbols <code>(:</code>
and <code>:)</code>. Comments may be nested.</p>
<p>A comment may be used anywhere <a title="ignorable whitespace"
href="#IgnorableWhitespace">ignorable whitespace</a> is allowed
(see <a href="#DefaultWhitespaceHandling"><b>A.2.4.1 Default
Whitespace Handling</b></a>).</p>
<p>The following is an example of a comment:</p>
<div class="exampleInner">
<pre>
(: Houston, we have a problem :)
</pre></div>
</div>
</div>
<div class="div1">
<h2><a name="id-expressions" id="id-expressions"></a>3
Expressions</h2>
<p>This section discusses each of the basic kinds of expression.
Each kind of expression has a name such as <code>PathExpr</code>,
which is introduced on the left side of the grammar production that
defines the expression. Since XPath is a composable language, each
kind of expression is defined in terms of other expressions whose
operators have a higher precedence. In this way, the precedence of
operators is represented explicitly in the grammar.</p>
<p>The order in which expressions are discussed in this document
does not reflect the order of operator precedence. In general, this
document introduces the simplest kinds of expressions first,
followed by more complex expressions. For the complete grammar, see
Appendix [<a href="#nt-bnf"><b>A XPath Grammar</b></a>].</p>
<p><span class="xpath"><span class="xpath">The highest-level symbol
in the XPath grammar is XPath.</span></span></p>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-XPath" id=
"doc-xpath-XPath"></a>[1]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-XPath">XPath</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-Expr">Expr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-Expr" id=
"doc-xpath-Expr"></a>[2]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-Expr">Expr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ExprSingle">ExprSingle</a> (","
<a href="#doc-xpath-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-ExprSingle" id=
"doc-xpath-ExprSingle"></a>[3]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-ExprSingle">ExprSingle</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ForExpr">ForExpr</a><br />
| <a href="#doc-xpath-QuantifiedExpr">QuantifiedExpr</a><br />
| <a href="#doc-xpath-IfExpr">IfExpr</a><br />
| <a href="#doc-xpath-OrExpr">OrExpr</a></code></td>
</tr>
</tbody>
</table>
<p>The XPath operator that has lowest precedence is the <a title=
"comma operator" href="#dt-comma-operator">comma operator</a>,
which is used to combine two operands to form a sequence. As shown
in the grammar, a general expression (<a href=
"#doc-xpath-Expr">Expr</a>) can consist of multiple <a href=
"#doc-xpath-ExprSingle">ExprSingle</a> operands, separated by
commas. The name <a href="#doc-xpath-ExprSingle">ExprSingle</a>
denotes an expression that does not contain a top-level <a title=
"comma operator" href="#dt-comma-operator">comma operator</a>
(despite its name, an <a href=
"#doc-xpath-ExprSingle">ExprSingle</a> may evaluate to a sequence
containing more than one item.)</p>
<p>The symbol <a href="#doc-xpath-ExprSingle">ExprSingle</a> is
used in various places in the grammar where an expression is not
allowed to contain a top-level comma. For example, each of the
arguments of a function call must be an <a href=
"#doc-xpath-ExprSingle">ExprSingle</a>, because commas are used to
separate the arguments of a function call.</p>
<p>After the comma, the expressions that have next lowest
precedence are <span class="xpath"><span class="xpath"><a href=
"#doc-xpath-ForExpr">ForExpr</a>,</span></span> <a href=
"#doc-xpath-QuantifiedExpr">QuantifiedExpr</a>, <a href=
"#doc-xpath-IfExpr">IfExpr</a>, and <a href=
"#doc-xpath-OrExpr">OrExpr</a>. Each of these expressions is
described in a separate section of this document.</p>
<div class="div2">
<h3><a name="id-primary-expressions" id=
"id-primary-expressions"></a>3.1 Primary Expressions</h3>
<p>[<a name="dt-primary-expression" id="dt-primary-expression"
title="primary expression">Definition</a>: <b>Primary
expressions</b> are the basic primitives of the language. They
include literals, variable references, context item expressions,
and function calls. A primary expression may also be created by
enclosing any expression in parentheses, which is sometimes helpful
in controlling the precedence of operators.]</p>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-PrimaryExpr" id=
"doc-xpath-PrimaryExpr"></a>[41]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-PrimaryExpr">PrimaryExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-Literal">Literal</a> | <a href=
"#doc-xpath-VarRef">VarRef</a> | <a href=
"#doc-xpath-ParenthesizedExpr">ParenthesizedExpr</a> | <a href=
"#doc-xpath-ContextItemExpr">ContextItemExpr</a> | <a href=
"#doc-xpath-FunctionCall">FunctionCall</a></code></td>
</tr>
</tbody>
</table>
<div class="div3">
<h4><a name="id-literals" id="id-literals"></a>3.1.1 Literals</h4>
<p>[<a name="dt-literal" id="dt-literal" title=
"literal">Definition</a>: A <b>literal</b> is a direct syntactic
representation of an atomic value.] XPath supports two kinds of
literals: numeric literals and string literals.</p>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-Literal" id=
"doc-xpath-Literal"></a>[42]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-Literal">Literal</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-NumericLiteral">NumericLiteral</a> |
<a href="#doc-xpath-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-NumericLiteral" id=
"doc-xpath-NumericLiteral"></a>[43]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-NumericLiteral">NumericLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-IntegerLiteral">IntegerLiteral</a> |
<a href="#doc-xpath-DecimalLiteral">DecimalLiteral</a> | <a href=
"#doc-xpath-DoubleLiteral">DoubleLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-IntegerLiteral" id=
"doc-xpath-IntegerLiteral"></a>[71]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-IntegerLiteral">IntegerLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-Digits">Digits</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-DecimalLiteral" id=
"doc-xpath-DecimalLiteral"></a>[72]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-DecimalLiteral">DecimalLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("." <a href="#doc-xpath-Digits">Digits</a>) | (<a href=
"#doc-xpath-Digits">Digits</a> "." [0-9]*)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-DoubleLiteral" id=
"doc-xpath-DoubleLiteral"></a>[73]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-DoubleLiteral">DoubleLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(("." <a href="#doc-xpath-Digits">Digits</a>) | (<a href=
"#doc-xpath-Digits">Digits</a> ("." [0-9]*)?)) [eE] [+-]? <a href=
"#doc-xpath-Digits">Digits</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-StringLiteral" id=
"doc-xpath-StringLiteral"></a>[74]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-StringLiteral">StringLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>('"' (<a href="#doc-xpath-EscapeQuot">EscapeQuot</a> |
[^"])* '"') | ("'" (<a href="#doc-xpath-EscapeApos">EscapeApos</a>
| [^'])* "'")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-EscapeQuot" id=
"doc-xpath-EscapeQuot"></a>[75]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-EscapeQuot">EscapeQuot</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>'""'</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-EscapeApos" id=
"doc-xpath-EscapeApos"></a>[76]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-EscapeApos">EscapeApos</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"''"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-Digits" id=
"doc-xpath-Digits"></a>[81]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-Digits">Digits</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>[0-9]+</code></td>
</tr>
</tbody>
</table>
<p>The value of a <b>numeric literal</b> containing no
"<code>.</code>" and no <code>e</code> or <code>E</code> character
is an atomic value of type <code>xs:integer</code>. The value of a
numeric literal containing "<code>.</code>" but no <code>e</code>
or <code>E</code> character is an atomic value of type
<code>xs:decimal</code>. The value of a numeric literal containing
an <code>e</code> or <code>E</code> character is an atomic value of
type <code>xs:double</code>. The value of the numeric literal is
determined by casting it to the appropriate type according to the
rules for casting from <code>xs:untypedAtomic</code> to a numeric
type as specified in <a href=
"http://www.w3.org/TR/xpath-functions/#casting-from-strings">Section
17.1.1 Casting from xs:string and
xs:untypedAtomic</a><sup><small>FO</small></sup>.</p>
<p>The value of a <b>string literal</b> is an atomic value whose
type is <code>xs:string</code> and whose value is the string
denoted by the characters between the delimiting apostrophes or
quotation marks. If the literal is delimited by apostrophes, two
adjacent apostrophes within the literal are interpreted as a single
apostrophe. Similarly, if the literal is delimited by quotation
marks, two adjacent quotation marks within the literal are
interpreted as one quotation mark.</p>
<p>Here are some examples of literal expressions:</p>
<ul>
<li>
<p><code>"12.5"</code> denotes the string containing the characters
'1', '2', '.', and '5'.</p>
</li>
<li>
<p><code>12</code> denotes the <code>xs:integer</code> value
twelve.</p>
</li>
<li>
<p><code>12.5</code> denotes the <code>xs:decimal</code> value
twelve and one half.</p>
</li>
<li>
<p><code>125E2</code> denotes the <code>xs:double</code> value
twelve thousand, five hundred.</p>
</li>
<li>
<p><code>"He said, ""I don't like it."""</code> denotes a string
containing two quotation marks and one apostrophe.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>When XPath expressions are embedded in contexts where quotation
marks have special significance, such as inside XML attributes,
additional escaping may be needed.</p>
</div>
</li>
</ul>
<p>The <code>xs:boolean</code> values <code>true</code> and
<code>false</code> can be represented by calls to the <a title=
"built-in function" href="#dt-built-in-function">built-in
functions</a> <code>fn:true()</code> and <code>fn:false()</code>,
respectively.</p>
<p>Values of other atomic types can be constructed by calling the
<a title="constructor function" href=
"#dt-constructor-function">constructor function</a> for the given
type. The constructor functions for XML Schema built-in types are
defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath
2.0 Functions and Operators (Second Edition)]</a>. In general, the
name of a constructor function for a given type is the same as the
name of the type (including its namespace). For example:</p>
<ul>
<li>
<p><code>xs:integer("12")</code> returns the integer value
twelve.</p>
</li>
<li>
<p><code>xs:date("2001-08-25")</code> returns an item whose type is
<code>xs:date</code> and whose value represents the date 25th
August 2001.</p>
</li>
<li>
<p><code>xs:dayTimeDuration("PT5H")</code> returns an item whose
type is <code>xs:dayTimeDuration</code> and whose value represents
a duration of five hours.</p>
</li>
</ul>
<p>Constructor functions can also be used to create special values
that have no literal representation, as in the following
examples:</p>
<ul>
<li>
<p><code>xs:float("NaN")</code> returns the special floating-point
value, "Not a Number."</p>
</li>
<li>
<p><code>xs:double("INF")</code> returns the special
double-precision value, "positive infinity."</p>
</li>
</ul>
<p>It is also possible to construct values of various types by
using a <code>cast</code> expression. For example:</p>
<ul>
<li>
<p><code>9 cast as hatsize</code> returns the atomic value
<code>9</code> whose type is <code>hatsize</code>.</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-variables" id="id-variables"></a>3.1.2 Variable
References</h4>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-VarRef" id=
"doc-xpath-VarRef"></a>[44]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-VarRef">VarRef</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href="#doc-xpath-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-VarName" id=
"doc-xpath-VarName"></a>[45]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-VarName">VarName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-variable-reference" id="dt-variable-reference"
title="variable reference">Definition</a>: A <b>variable
reference</b> is a QName preceded by a $-sign.] Two variable
references are equivalent if their local names are the same and
their namespace prefixes are bound to the same namespace URI in the
<a title="statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>. An
unprefixed variable reference is in no namespace.</p>
<p>Every variable reference must match a name in the <a title=
"in-scope variables" href="#dt-in-scope-variables">in-scope
variables</a>, which include variables from the following
sources:</p>
<ol class="enumar">
<li>
<p>The <a title="in-scope variables" href=
"#dt-in-scope-variables">in-scope variables</a> may be augmented by
<a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>
variables.</p>
</li>
<li>
<p>A variable may be bound by an XPath expression. <span class=
"xpath"><span class="xpath">The kinds of expressions that can bind
variables are <code>for</code> expressions (<a href=
"#id-for-expressions"><b>3.7 For Expressions</b></a>) and
quantified expressions (<a href="#id-quantified-expressions"><b>3.9
Quantified Expressions</b></a>).</span></span></p>
</li>
</ol>
<p>Every variable binding has a static scope. The scope defines
where references to the variable can validly occur. It is a
<a title="static error" href="#dt-static-error">static error</a>
[<a href="#ERRXPST0008" title="err:XPST0008">err:XPST0008</a>] to
reference a variable that is not in scope. If a variable is bound
in the <a title="static context" href="#dt-static-context">static
context</a> for an expression, that variable is in scope for the
entire expression.</p>
<p>If a variable reference matches two or more variable bindings
that are in scope, then the reference is taken as referring to the
inner binding, that is, the one whose scope is smaller. At
evaluation time, the value of a variable reference is the value of
the expression to which the relevant variable is bound. The scope
of a variable binding is defined separately for each kind of
expression that can bind variables.</p>
</div>
<div class="div3">
<h4><a name="id-paren-expressions" id=
"id-paren-expressions"></a>3.1.3 Parenthesized Expressions</h4>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-ParenthesizedExpr" id=
"doc-xpath-ParenthesizedExpr"></a>[46]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-ParenthesizedExpr">ParenthesizedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" <a href="#doc-xpath-Expr">Expr</a>? ")"</code></td>
</tr>
</tbody>
</table>
<p>Parentheses may be used to enforce a particular evaluation order
in expressions that contain multiple operators. For example, the
expression <code>(2 + 4) * 5</code> evaluates to thirty, since the
parenthesized expression <code>(2 + 4)</code> is evaluated first
and its result is multiplied by five. Without parentheses, the
expression <code>2 + 4 * 5</code> evaluates to twenty-two, because
the multiplication operator has higher precedence than the addition
operator.</p>
<p>Empty parentheses are used to denote an empty sequence, as
described in <a href="#construct_seq"><b>3.3.1 Constructing
Sequences</b></a>.</p>
</div>
<div class="div3">
<h4><a name="id-context-item-expression" id=
"id-context-item-expression"></a>3.1.4 Context Item Expression</h4>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-ContextItemExpr" id=
"doc-xpath-ContextItemExpr"></a>[47]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-ContextItemExpr">ContextItemExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"."</code></td>
</tr>
</tbody>
</table>
<p>A <b>context item expression</b> evaluates to the <a title=
"context item" href="#dt-context-item">context item</a>, which may
be either a node (as in the expression
<code>fn:doc("bib.xml")/books/book[fn:count(./author)&gt;1]</code>)
or an atomic value (as in the expression <code>(1 to 100)[. mod 5
eq 0]</code>).</p>
<p>If the <a title="context item" href="#dt-context-item">context
item</a> is <a title="undefined" href=
"#dt-undefined">undefined</a>, a context item expression raises a
dynamic error [<a href="#ERRXPDY0002" title=
"err:XPDY0002">err:XPDY0002</a>].</p>
</div>
<div class="div3">
<h4><a name="id-function-calls" id="id-function-calls"></a>3.1.5
Function Calls</h4>
<p>[<a name="dt-built-in-function" id="dt-built-in-function" title=
"built-in function">Definition</a>: The <b>built-in functions</b>
supported by XPath are defined in <a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators (Second Edition)]</a>.] <span class="xpath"><span class=
"xpath">Additional functions may be provided in the <a title=
"static context" href="#dt-static-context">static context</a>.
XPath per se does not provide a way to declare functions, but a
host language may provide such a mechanism.</span></span></p>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-FunctionCall" id=
"doc-xpath-FunctionCall"></a>[48]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-FunctionCall">FunctionCall</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a> "(" (<a href=
"#doc-xpath-ExprSingle">ExprSingle</a> ("," <a href=
"#doc-xpath-ExprSingle">ExprSingle</a>)*)? ")"</code></td>
</tr>
</tbody>
</table>
<p>A <b>function call</b> consists of a QName followed by a
parenthesized list of zero or more expressions, called
<b>arguments</b>. If the QName in the function call has no
namespace prefix, it is considered to be in the <a title=
"default function namespace" href="#dt-def-fn-ns">default function
namespace.</a></p>
<p>If the <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> and number of arguments in
a function call do not match the name and arity of a <a title=
"function signature" href="#dt-function-signature">function
signature</a> in the <a title="static context" href=
"#dt-static-context">static context</a>, a <a title="static error"
href="#dt-static-error">static error</a> is raised [<a href=
"#ERRXPST0017" title="err:XPST0017">err:XPST0017</a>].</p>
<p>A function call is evaluated as follows:</p>
<ol class="enumar">
<li>
<p>Argument expressions are evaluated, producing argument values.
The order of argument evaluation is <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> and a
function need not evaluate an argument if the function can evaluate
its body without evaluating that argument.</p>
</li>
<li>
<p>Each argument value is converted by applying the function
conversion rules listed below.</p>
</li>
<li class="xpath">
<p>The function is evaluated using the converted argument values.
The result is either an instance of the function's declared return
type or a dynamic error. The <a title="dynamic type" href=
"#dt-dynamic-type">dynamic type</a> of a function result may be a
type that is derived from the declared return type. Errors raised
by functions are defined in <a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators (Second Edition)]</a>.</p>
</li>
</ol>
<p>The <b>function conversion rules</b> are used to convert an
argument value to its expected type; that is, to the declared type
of the function <span class="xpath"><span class=
"xpath">parameter.</span></span> The expected type is expressed as
a <a title="sequence type" href="#dt-sequence-type">sequence
type</a>. The function conversion rules are applied to a given
value as follows:</p>
<ul>
<li class="xpath">
<p>If <a title="XPath 1.0 compatibility mode" href=
"#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is
<code>true</code> and an argument is not of the expected type, then
the following conversions are applied sequentially to the argument
value V:</p>
<ol class="enumar">
<li>
<p>If the expected type calls for a single item or optional single
item (examples: <code>xs:string</code>, <code>xs:string?</code>,
<code>xs:untypedAtomic</code>, <code>xs:untypedAtomic?</code>,
<code>node()</code>, <code>node()?</code>, <code>item()</code>,
<code>item()?</code>), then the value V is effectively replaced by
V[1].</p>
</li>
<li>
<p>If the expected type is <code>xs:string</code> or
<code>xs:string?</code>, then the value <code>V</code> is
effectively replaced by <code>fn:string(V)</code>.</p>
</li>
<li>
<p>If the expected type is <code>xs:double</code> or
<code>xs:double?</code>, then the value <code>V</code> is
effectively replaced by <code>fn:number(V)</code>.</p>
</li>
</ol>
</li>
<li>
<p>If the expected type is a sequence of an atomic type (possibly
with an occurrence indicator <code>*</code>, <code>+</code>, or
<code>?</code>), the following conversions are applied:</p>
<ol class="enumar">
<li>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is
applied to the given value, resulting in a sequence of atomic
values.</p>
</li>
<li>
<p>Each item in the atomic sequence that is of type
<code>xs:untypedAtomic</code> is cast to the expected atomic type.
For <a title="built-in function" href=
"#dt-built-in-function">built-in functions</a> where the expected
type is specified as <a title="numeric" href=
"#dt-numeric">numeric</a>, arguments of type
<code>xs:untypedAtomic</code> are cast to
<code>xs:double</code>.</p>
</li>
<li>
<p>For each <a title="numeric" href="#dt-numeric">numeric</a> item
in the atomic sequence that can be <a title="type promotion" href=
"#dt-type-promotion">promoted</a> to the expected atomic type using
numeric promotion as described in <a href="#promotion"><b>B.1 Type
Promotion</b></a>, the promotion is done.</p>
</li>
<li>
<p>For each item of type <code>xs:anyURI</code> in the atomic
sequence that can be <a title="type promotion" href=
"#dt-type-promotion">promoted</a> to the expected atomic type using
URI promotion as described in <a href="#promotion"><b>B.1 Type
Promotion</b></a>, the promotion is done.</p>
</li>
</ol>
</li>
<li>
<p>If, after the above conversions, the resulting value does not
match the expected type according to the rules for <a title=
"SequenceType matching" href=
"#dt-sequencetype-matching">SequenceType Matching</a>, a <a title=
"type error" href="#dt-type-error">type error</a> is raised
[<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].
Note that the rules for <a title="SequenceType matching" href=
"#dt-sequencetype-matching">SequenceType Matching</a> permit a
value of a derived type to be substituted for a value of its base
type.</p>
</li>
</ul>
<p>Since the arguments of a function call are separated by commas,
any argument expression that contains a top-level <a title=
"comma operator" href="#dt-comma-operator">comma operator</a> must
be enclosed in parentheses. Here are some illustrative examples of
function calls:</p>
<ul>
<li>
<p><code>my:three-argument-function(1, 2, 3)</code> denotes a
function call with three arguments.</p>
</li>
<li>
<p><code>my:two-argument-function((1, 2), 3)</code> denotes a
function call with two arguments, the first of which is a sequence
of two values.</p>
</li>
<li>
<p><code>my:two-argument-function(1, ())</code> denotes a function
call with two arguments, the second of which is an empty
sequence.</p>
</li>
<li>
<p><code>my:one-argument-function((1, 2, 3))</code> denotes a
function call with one argument that is a sequence of three
values.</p>
</li>
<li>
<p><code>my:one-argument-function(( ))</code> denotes a function
call with one argument that is an empty sequence.</p>
</li>
<li>
<p><code>my:zero-argument-function( )</code> denotes a function
call with zero arguments.</p>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="id-path-expressions" id="id-path-expressions"></a>3.2
Path Expressions</h3>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-PathExpr" id=
"doc-xpath-PathExpr"></a>[25]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-PathExpr">PathExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("/" <a href=
"#doc-xpath-RelativePathExpr">RelativePathExpr</a>?)<br />
| ("//" <a href=
"#doc-xpath-RelativePathExpr">RelativePathExpr</a>)<br />
| <a href=
"#doc-xpath-RelativePathExpr">RelativePathExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-RelativePathExpr" id=
"doc-xpath-RelativePathExpr"></a>[26]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-RelativePathExpr">RelativePathExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-StepExpr">StepExpr</a> (("/" | "//")
<a href="#doc-xpath-StepExpr">StepExpr</a>)*</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-path-expression" id="dt-path-expression" title=
"path expression">Definition</a>: A <b>path expression</b> can be
used to locate nodes within trees. A path expression consists of a
series of one or more <a title="step" href="#dt-step">steps</a>,
separated by "<code>/</code>" or "<code>//</code>", and optionally
beginning with "<code>/</code>" or "<code>//</code>".] An initial
"<code>/</code>" or "<code>//</code>" is an abbreviation for one or
more initial steps that are implicitly added to the beginning of
the path expression, as described below.</p>
<p>A path expression consisting of a single step is evaluated as
described in <a href="#id-steps"><b>3.2.1 Steps</b></a>.</p>
<p>A "<code>/</code>" at the beginning of a path expression is an
abbreviation for the initial step
<code><span>(fn:root(self::node()) treat as
document-node())</span>/</code> (however, if the "<code>/</code>"
is the entire path expression, the trailing "<code>/</code>" is
omitted from the expansion.) The effect of this initial step is to
begin the path at the root node of the tree that contains the
context node. If the context item is not a node, a <a title=
"type error" href="#dt-type-error">type error</a> is raised
[<a href="#ERRXPTY0020" title="err:XPTY0020">err:XPTY0020</a>]. At
evaluation time, if the root node above the context node is not a
document node, a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> is raised [<a href=
"#ERRXPDY0050" title="err:XPDY0050">err:XPDY0050</a>].</p>
<p>A "<code>//</code>" at the beginning of a path expression is an
abbreviation for the initial steps
<code><span>(fn:root(self::node()) treat as
document-node())</span>/descendant-or-self::node()/</code>
(however, "<code>//</code>" by itself is not a valid path
expression [<a href="#ERRXPST0003" title=
"err:XPST0003">err:XPST0003</a>].) The effect of these initial
steps is to establish an initial node sequence that contains the
root of the tree in which the context node is found, plus all nodes
descended from this root. This node sequence is used as the input
to subsequent steps in the path expression. If the context item is
not a node, a <a title="type error" href="#dt-type-error">type
error</a> is raised [<a href="#ERRXPTY0020" title=
"err:XPTY0020">err:XPTY0020</a>]. At evaluation time, if the root
node above the context node is not a document node, a <a title=
"dynamic error" href="#dt-dynamic-error">dynamic error</a> is
raised [<a href="#ERRXPDY0050" title=
"err:XPDY0050">err:XPDY0050</a>].</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The descendants of a node do not include attribute nodes
<span class="xpath"><span class="xpath">or namespace
nodes</span></span>.</p>
</div>
<p>Each non-initial occurrence of "<code>//</code>" in a path
expression is expanded as described in <a href="#abbrev"><b>3.2.4
Abbreviated Syntax</b></a>, leaving a sequence of steps separated
by "<code>/</code>". This sequence of steps is then evaluated from
left to right. Each operation <code>E1/E2</code> is evaluated as
follows: Expression <code>E1</code> is evaluated, and if the result
is not a (possibly empty) sequence of nodes, a <a title=
"type error" href="#dt-type-error">type error</a> is raised
[<a href="#ERRXPTY0019" title="err:XPTY0019">err:XPTY0019</a>].
Each node resulting from the evaluation of <code>E1</code> then
serves in turn to provide an <b>inner focus</b> for an evaluation
of <code>E2</code>, as described in <a href=
"#eval_context"><b>2.1.2 Dynamic Context</b></a>. The sequences
resulting from all the evaluations of <code>E2</code> are combined
as follows:</p>
<ol class="enumar">
<li>
<p>If every evaluation of <code>E2</code> returns a (possibly
empty) sequence of nodes, these sequences are combined, and
duplicate nodes are eliminated based on node identity. <span class=
"xpath"><span class="xpath">The resulting node sequence is returned
in <a title="document order" href="#dt-document-order">document
order</a>.</span></span></p>
</li>
<li>
<p>If every evaluation of <code>E2</code> returns a (possibly
empty) sequence of atomic values, these sequences are
concatenated<span class="xpath"><span class="xpath">, in
order,</span></span> and returned.</p>
</li>
<li>
<p>If the multiple evaluations of <code>E2</code> return at least
one node and at least one atomic value, a <a title="type error"
href="#dt-type-error">type error</a> is raised [<a href=
"#ERRXPTY0018" title="err:XPTY0018">err:XPTY0018</a>].</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Since each step in a path provides context nodes for the
following step, in effect, only the last step in a path is allowed
to return a sequence of atomic values.</p>
</div>
<p>As an example of a path expression,
<code>child::div1/child::para</code> selects the <code>para</code>
element children of the <code>div1</code> element children of the
context node, or, in other words, the <code>para</code> element
grandchildren of the context node that have <code>div1</code>
parents.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p id="Chg-slash-note">The "<code>/</code>" character can be used
either as a complete path expression or as the beginning of a
longer path expression such as "<code>/*</code>". Also,
"<code>*</code>" is both the multiply operator and a wildcard in
path expressions. This can cause parsing difficulties when
"<code>/</code>" appears on the left hand side of "<code>*</code>".
This is resolved using the <a href=
"#parse-note-leading-lone-slash">leading-lone-slash</a> constraint.
For example, "<code>/*</code>" and "<code>/ *</code>" are valid
path expressions containing wildcards, but "<code>/*5</code>" and
"<code>/ * 5</code>" raise syntax errors. Parentheses must be used
when "<code>/</code>" is used on the left hand side of an operator,
as in "<code>(/) * 5</code>". Similarly, "<code>4 + / * 5</code>"
raises a syntax error, but "<code>4 + (/) * 5</code>" is a valid
expression. The expression "<code>4 + /</code>" is also valid,
because <code>/</code> does not occur on the left hand side of the
operator.</p>
</div>
<div class="div3">
<h4><a name="id-steps" id="id-steps"></a>3.2.1 Steps</h4>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-StepExpr" id=
"doc-xpath-StepExpr"></a>[27]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-StepExpr">StepExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-FilterExpr">FilterExpr</a> | <a href=
"#doc-xpath-AxisStep">AxisStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-AxisStep" id=
"doc-xpath-AxisStep"></a>[28]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AxisStep">AxisStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#doc-xpath-ReverseStep">ReverseStep</a> |
<a href="#doc-xpath-ForwardStep">ForwardStep</a>) <a href=
"#doc-xpath-PredicateList">PredicateList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-ForwardStep" id=
"doc-xpath-ForwardStep"></a>[29]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-ForwardStep">ForwardStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#doc-xpath-ForwardAxis">ForwardAxis</a>
<a href="#doc-xpath-NodeTest">NodeTest</a>) | <a href=
"#doc-xpath-AbbrevForwardStep">AbbrevForwardStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-ReverseStep" id=
"doc-xpath-ReverseStep"></a>[32]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-ReverseStep">ReverseStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#doc-xpath-ReverseAxis">ReverseAxis</a>
<a href="#doc-xpath-NodeTest">NodeTest</a>) | <a href=
"#doc-xpath-AbbrevReverseStep">AbbrevReverseStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-PredicateList" id=
"doc-xpath-PredicateList"></a>[39]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-PredicateList">PredicateList</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-Predicate">Predicate</a>*</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-step" id="dt-step" title="step">Definition</a>: A
<b>step</b> is a part of a <a title="path expression" href=
"#dt-path-expression">path expression</a> that generates a sequence
of items and then filters the sequence by zero or more <a title=
"predicate" href="#dt-predicate">predicates</a>. The value of the
step consists of those items that satisfy the predicates, working
from left to right. A step may be either an <a title="axis step"
href="#dt-axis-step">axis step</a> or a <a title=
"filter expression" href="#dt-filter-expression">filter
expression</a>.] Filter expressions are described in <a href=
"#id-filter-expr"><b>3.3.2 Filter Expressions</b></a>.</p>
<p>[<a name="dt-axis-step" id="dt-axis-step" title=
"axis step">Definition</a>: An <b>axis step</b> returns a sequence
of nodes that are reachable from the context node via a specified
axis. Such a step has two parts: an <b>axis</b>, which defines the
"direction of movement" for the step, and a <a title="node test"
href="#dt-node-test">node test</a>, which selects nodes based on
their kind, name, and/or <a title="type annotation" href=
"#dt-type-annotation">type annotation</a>.] If the context item is
a node, an axis step returns a sequence of zero or more nodes;
otherwise, a <a title="type error" href="#dt-type-error">type
error</a> is raised [<a href="#ERRXPTY0020" title=
"err:XPTY0020">err:XPTY0020</a>]. <span class="xpath"><span class=
"xpath">The resulting node sequence is returned in <a title=
"document order" href="#dt-document-order">document
order</a>.</span></span> An axis step may be either a <b>forward
step</b> or a <b>reverse step</b>, followed by zero or more
<a title="predicate" href="#dt-predicate">predicates</a>.</p>
<p>In the <b>abbreviated syntax</b> for a step, the axis can be
omitted and other shorthand notations can be used as described in
<a href="#abbrev"><b>3.2.4 Abbreviated Syntax</b></a>.</p>
<p>The unabbreviated syntax for an axis step consists of the axis
name and node test separated by a double colon. The result of the
step consists of the nodes reachable from the context node via the
specified axis that have the node kind, name, and/or <a title=
"type annotation" href="#dt-type-annotation">type annotation</a>
specified by the node test. For example, the step
<code>child::para</code> selects the <code>para</code> element
children of the context node: <code>child</code> is the name of the
axis, and <code>para</code> is the name of the element nodes to be
selected on this axis. The available axes are described in <a href=
"#axes"><b>3.2.1.1 Axes</b></a>. The available node tests are
described in <a href="#node-tests"><b>3.2.1.2 Node Tests</b></a>.
Examples of steps are provided in <a href="#unabbrev"><b>3.2.3
Unabbreviated Syntax</b></a> and <a href="#abbrev"><b>3.2.4
Abbreviated Syntax</b></a>.</p>
<div class="div4">
<h5><a name="axes" id="axes"></a>3.2.1.1 Axes</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-ForwardAxis" id=
"doc-xpath-ForwardAxis"></a>[30]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-ForwardAxis">ForwardAxis</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("child" "::")<br />
| ("descendant" "::")<br />
| ("attribute" "::")<br />
| ("self" "::")<br />
| ("descendant-or-self" "::")<br />
| ("following-sibling" "::")<br />
| ("following" "::")<br />
| ("namespace" "::")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-ReverseAxis" id=
"doc-xpath-ReverseAxis"></a>[33]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-ReverseAxis">ReverseAxis</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("parent" "::")<br />
| ("ancestor" "::")<br />
| ("preceding-sibling" "::")<br />
| ("preceding" "::")<br />
| ("ancestor-or-self" "::")</code></td>
</tr>
</tbody>
</table>
<div class="xpath">
<p class="xpath">XPath defines a full set of <b>axes</b> for
traversing documents, but a <b>host language</b> may define a
subset of these axes. The following axes are defined:</p>
</div>
<ul>
<li>
<p>The <code>child</code> axis contains the children of the context
node, which are the nodes returned by the <code>dm:children</code>
accessor in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data
Model (Second Edition)]</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Only document nodes and element nodes have children. If the
context node is any other kind of node, or if the context node is
an empty document or element node, then the child axis is an empty
sequence. The children of a document node or element node may be
element, processing instruction, comment, or text nodes.
Attribute<span class="xpath"><span class="xpath">,
namespace,</span></span> and document nodes can never appear as
children.</p>
</div>
</li>
<li>
<p>the <code>descendant</code> axis is defined as the transitive
closure of the child axis; it contains the descendants of the
context node (the children, the children of the children, and so
on)</p>
</li>
<li>
<p>the <code>parent</code> axis contains the sequence returned by
the <code>dm:parent</code> accessor in <a href="#datamodel">[XQuery
1.0 and XPath 2.0 Data Model (Second Edition)]</a>, which returns
the parent of the context node, or an empty sequence if the context
node has no parent</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>An attribute node may have an element node as its parent, even
though the attribute node is not a child of the element node.</p>
</div>
</li>
<li>
<p>the <code>ancestor</code> axis is defined as the transitive
closure of the parent axis; it contains the ancestors of the
context node (the parent, the parent of the parent, and so on)</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The ancestor axis includes the root node of the tree in which
the context node is found, unless the context node is the root
node.</p>
</div>
</li>
<li>
<p>the <code>following-sibling</code> axis contains the context
node's following siblings, those children of the context node's
parent that occur after the context node in <a title=
"document order" href="#dt-document-order">document order</a>; if
the context node is an attribute <span class="xpath"><span class=
"xpath">or namespace</span></span> node, the
<code>following-sibling</code> axis is empty</p>
</li>
<li>
<p>the <code>preceding-sibling</code> axis contains the context
node's preceding siblings, those children of the context node's
parent that occur before the context node in <a title=
"document order" href="#dt-document-order">document order</a>; if
the context node is an attribute <span class="xpath"><span class=
"xpath">or namespace</span></span> node, the
<code>preceding-sibling</code> axis is empty</p>
</li>
<li>
<p>the <code>following</code> axis contains all nodes that are
descendants of the root of the tree in which the context node is
found, are not descendants of the context node, and occur after the
context node in <a title="document order" href=
"#dt-document-order">document order</a></p>
</li>
<li>
<p>the <code>preceding</code> axis contains all nodes that are
descendants of the root of the tree in which the context node is
found, are not ancestors of the context node, and occur before the
context node in <a title="document order" href=
"#dt-document-order">document order</a></p>
</li>
<li>
<p>the <code>attribute</code> axis contains the attributes of the
context node, which are the nodes returned by the
<code>dm:attributes</code> accessor in <a href="#datamodel">[XQuery
1.0 and XPath 2.0 Data Model (Second Edition)]</a>; the axis will
be empty unless the context node is an element</p>
</li>
<li>
<p>the <code>self</code> axis contains just the context node
itself</p>
</li>
<li>
<p>the <code>descendant-or-self</code> axis contains the context
node and the descendants of the context node</p>
</li>
<li>
<p>the <code>ancestor-or-self</code> axis contains the context node
and the ancestors of the context node; thus, the ancestor-or-self
axis will always include the root node</p>
</li>
<li class="xpath">
<p>the <code>namespace</code> axis contains the namespace nodes of
the context node, which are the nodes returned by the
<code>dm:namespace-nodes</code> accessor in <a href=
"#datamodel">[XQuery 1.0 and XPath 2.0 Data Model (Second
Edition)]</a>; this axis is empty unless the context node is an
element node. The <code>namespace</code> axis is deprecated in
XPath 2.0. If <a title="XPath 1.0 compatibility mode" href=
"#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is
<code>true</code>, the <code>namespace</code> axis must be
supported. If <a title="XPath 1.0 compatibility mode" href=
"#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is
<code>false</code>, then support for the <code>namespace</code>
axis is <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>. An
implementation that does not support the <code>namespace</code>
axis when <a title="XPath 1.0 compatibility mode" href=
"#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is
<code>false</code> must raise a <a title="static error" href=
"#dt-static-error">static error</a> [<a href="#ERRXPST0010" title=
"err:XPST0010">err:XPST0010</a>] if it is used. Applications
needing information about the <a title="in-scope namespaces" href=
"#dt-in-scope-namespaces">in-scope namespaces</a> of an element
should use the functions <code>fn:in-scope-prefixes</code> and
<code>fn:namespace-uri-for-prefix</code> defined in <a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators (Second Edition)]</a>.</p>
</li>
</ul>
<p>Axes can be categorized as <b>forward axes</b> and <b>reverse
axes</b>. An axis that only ever contains the context node or nodes
that are after the context node in <a title="document order" href=
"#dt-document-order">document order</a> is a forward axis. An axis
that only ever contains the context node or nodes that are before
the context node in <a title="document order" href=
"#dt-document-order">document order</a> is a reverse axis.</p>
<p>The <code>parent</code>, <code>ancestor</code>,
<code>ancestor-or-self</code>, <code>preceding</code>, and
<code>preceding-sibling</code> axes are reverse axes; all other
axes are forward axes. The <code>ancestor</code>,
<code>descendant</code>, <code>following</code>,
<code>preceding</code> and <code>self</code> axes partition a
document (ignoring attribute <span class="xpath"><span class=
"xpath">and namespace</span></span> nodes): they do not overlap and
together they contain all the nodes in the document.</p>
<p>[<a name="dt-principal-node-kind" id="dt-principal-node-kind"
title="principal node kind">Definition</a>: Every axis has a
<b>principal node kind</b>. If an axis can contain elements, then
the principal node kind is element; otherwise, it is the kind of
nodes that the axis can contain.] Thus:</p>
<ul>
<li>
<p>For the attribute axis, the principal node kind is
attribute.</p>
</li>
<li class="xpath">
<p>For the namespace axis, the principal node kind is
namespace.</p>
</li>
<li>
<p>For all other axes, the principal node kind is element.</p>
</li>
</ul>
</div>
<div class="div4">
<h5><a name="node-tests" id="node-tests"></a>3.2.1.2 Node
Tests</h5>
<p>[<a name="dt-node-test" id="dt-node-test" title=
"node test">Definition</a>: A <b>node test</b> is a condition that
must be true for each node selected by a <a title="step" href=
"#dt-step">step</a>.] The condition may be based on the kind of the
node (element, attribute, text, document, comment, or processing
instruction), the name of the node, or (in the case of element,
attribute, and document nodes), the <a title="type annotation"
href="#dt-type-annotation">type annotation</a> of the node.</p>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-NodeTest" id=
"doc-xpath-NodeTest"></a>[35]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-NodeTest">NodeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-KindTest">KindTest</a> | <a href=
"#doc-xpath-NameTest">NameTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-NameTest" id=
"doc-xpath-NameTest"></a>[36]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-NameTest">NameTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a> | <a href=
"#doc-xpath-Wildcard">Wildcard</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-Wildcard" id=
"doc-xpath-Wildcard"></a>[37]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-Wildcard">Wildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"*"<br />
| (<a href="#prod-xpath-NCName">NCName</a> ":" "*")<br />
| ("*" ":" <a href="#prod-xpath-NCName">NCName</a>)</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-name-test" id="dt-name-test" title=
"name test">Definition</a>: A node test that consists only of a
QName or a Wildcard is called a <b>name test</b>.] A name test is
true if and only if the <b>kind</b> of the node is the <a title=
"principal node kind" href="#dt-principal-node-kind">principal node
kind</a> for the step axis and the <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> of the node is equal (as
defined by the <code>eq</code> operator) to the <a title=
"expanded QName" href="#dt-expanded-qname">expanded QName</a>
specified by the name test. For example, <code>child::para</code>
selects the <code>para</code> element children of the context node;
if the context node has no <code>para</code> children, it selects
an empty set of nodes. <code>attribute::abc:href</code> selects the
attribute of the context node with the QName <code>abc:href</code>;
if the context node has no such attribute, it selects an empty set
of nodes.</p>
<p>A QName in a name test is resolved into an <a title=
"expanded QName" href="#dt-expanded-qname">expanded QName</a> using
the <a title="statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a> in the
expression context. It is a <a title="static error" href=
"#dt-static-error">static error</a> [<a href="#ERRXPST0081" title=
"err:XPST0081">err:XPST0081</a>] if the QName has a prefix that
does not correspond to any statically known namespace. An
unprefixed QName, when used as a name test on an axis whose
<a title="principal node kind" href=
"#dt-principal-node-kind">principal node kind</a> is element, has
the namespace URI of the <a title="default element/type namespace"
href="#dt-def-elemtype-ns">default element/type namespace</a> in
the expression context; otherwise, it has no namespace URI.</p>
<p>A name test is not satisfied by an element node whose name does
not match the <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> of the name test, even if
it is in a <a title="substitution group" href=
"#dt-substitution-group">substitution group</a> whose head is the
named element.</p>
<p>A node test <code>*</code> is true for any node of the <a title=
"principal node kind" href="#dt-principal-node-kind">principal node
kind</a> of the step axis. For example, <code>child::*</code> will
select all element children of the context node, and
<code>attribute::*</code> will select all attributes of the context
node.</p>
<p>A node test can have the form <code>NCName:*</code>. In this
case, the prefix is expanded in the same way as with a QName, using
the <a title="statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a> in the
<a title="static context" href="#dt-static-context">static
context</a>. If the prefix is not found in the statically known
namespaces, a <a title="static error" href=
"#dt-static-error">static error</a> is raised [<a href=
"#ERRXPST0081" title="err:XPST0081">err:XPST0081</a>]. The node
test is true for any node of the <a title="principal node kind"
href="#dt-principal-node-kind">principal node kind</a> of the step
axis whose <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> has the namespace URI to
which the prefix is bound, regardless of the local part of the
name.</p>
<p>A node test can also have the form <code>*:NCName</code>. In
this case, the node test is true for any node of the <a title=
"principal node kind" href="#dt-principal-node-kind">principal node
kind</a> of the step axis whose local name matches the given
NCName, regardless of its namespace or lack of a namespace.</p>
<p>[<a name="dt-kind-test" id="dt-kind-test" title=
"kind test">Definition</a>: An alternative form of a node test
called a <b>kind test</b> can select nodes based on their kind,
name, and <a title="type annotation" href=
"#dt-type-annotation">type annotation</a>.] The syntax and
semantics of a kind test are described in <a href=
"#id-sequencetype-syntax"><b>2.5.3 SequenceType Syntax</b></a> and
<a href="#id-sequencetype-matching"><b>2.5.4 SequenceType
Matching</b></a>. When a kind test is used in a <a title=
"node test" href="#dt-node-test">node test</a>, only those nodes on
the designated axis that match the kind test are selected. Shown
below are several examples of kind tests that might be used in path
expressions:</p>
<ul>
<li>
<p><code>node()</code> matches any node.</p>
</li>
<li>
<p><code>text()</code> matches any text node.</p>
</li>
<li>
<p><code>comment()</code> matches any comment node.</p>
</li>
<li>
<p><code>element()</code> matches any element node.</p>
</li>
<li>
<p><code>schema-element(person)</code> matches any element node
whose name is <code>person</code> (or is in the <a title=
"substitution group" href="#dt-substitution-group">substitution
group</a> headed by <code>person</code>), and whose type annotation
is the same as (or is derived from) the declared type of the
<code>person</code> element in the <a title=
"in-scope element declarations" href="#dt-is-elems">in-scope
element declarations</a>.</p>
</li>
<li>
<p><code>element(person)</code> matches any element node whose name
is <code>person</code>, regardless of its type annotation.</p>
</li>
<li>
<p><code>element(person, surgeon)</code> matches any non-nilled
element node whose name is <code>person</code>, and whose type
annotation is <code>surgeon</code> or is derived from
<code>surgeon</code>.</p>
</li>
<li>
<p><code>element(*, surgeon)</code> matches any non-nilled element
node whose type annotation is <code>surgeon</code> (or is derived
from <code>surgeon</code>), regardless of its name.</p>
</li>
<li>
<p><code>attribute()</code> matches any attribute node.</p>
</li>
<li>
<p><code>attribute(price)</code> matches any attribute whose name
is <code>price</code>, regardless of its type annotation.</p>
</li>
<li>
<p><code>attribute(*, xs:decimal)</code> matches any attribute
whose type annotation is <code>xs:decimal</code> (or is derived
from <code>xs:decimal</code>), regardless of its name.</p>
</li>
<li>
<p><code>document-node()</code> matches any document node.</p>
</li>
<li>
<p><code>document-node(element(book))</code> matches any document
node whose content consists of a single element node that satisfies
the <a title="kind test" href="#dt-kind-test">kind test</a>
<code>element(book)</code>, interleaved with zero or more comments
and processing instructions.</p>
</li>
</ul>
</div>
</div>
<div class="div3">
<h4><a name="id-predicates" id="id-predicates"></a>3.2.2
Predicates</h4>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-Predicate" id=
"doc-xpath-Predicate"></a>[40]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-Predicate">Predicate</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"[" <a href="#doc-xpath-Expr">Expr</a> "]"</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-predicate" id="dt-predicate" title=
"predicate">Definition</a>: A <b>predicate</b> consists of an
expression, called a <b>predicate expression</b>, enclosed in
square brackets. A predicate serves to filter a sequence, retaining
some items and discarding others.] In the case of multiple adjacent
predicates, the predicates are applied from left to right, and the
result of applying each predicate serves as the input sequence for
the following predicate.</p>
<p>For each item in the input sequence, the predicate expression is
evaluated using an <b>inner focus</b>, defined as follows: The
context item is the item currently being tested against the
predicate. The context size is the number of items in the input
sequence. The context position is the position of the context item
within the input sequence. For the purpose of evaluating the
context position within a predicate, the input sequence is
considered to be sorted as follows: into document order if the
predicate is in a forward-axis step, into reverse document order if
the predicate is in a reverse-axis step, or in its original order
if the predicate is not in a step.</p>
<p>For each item in the input sequence, the result of the predicate
expression is coerced to an <code>xs:boolean</code> value, called
the <b>predicate truth value</b>, as described below. Those items
for which the predicate truth value is <code>true</code> are
retained, and those for which the predicate truth value is
<code>false</code> are discarded.</p>
<p>The predicate truth value is derived by applying the following
rules, in order:</p>
<ol class="enumar">
<li>
<p>If the value of the predicate expression is a <a title=
"singleton" href="#dt-singleton">singleton</a> atomic value of a
<a title="numeric" href="#dt-numeric">numeric</a> type or derived
from a <a title="numeric" href="#dt-numeric">numeric</a> type, the
predicate truth value is <code>true</code> if the value of the
predicate expression is equal (by the <code>eq</code> operator) to
the <b>context position</b>, and is <code>false</code> otherwise.
[<a name="dt-numeric-predicate" id="dt-numeric-predicate" title=
"numeric predicate">Definition</a>: A predicate whose predicate
expression returns a numeric type is called a <b>numeric
predicate</b>.]</p>
</li>
<li>
<p>Otherwise, the predicate truth value is the <a title=
"effective boolean value" href="#dt-ebv">effective boolean
value</a> of the predicate expression.</p>
</li>
</ol>
<p>Here are some examples of <a title="axis step" href=
"#dt-axis-step">axis steps</a> that contain predicates:</p>
<ul>
<li>
<p>This example selects the second <code>chapter</code> element
that is a child of the context node:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
child::chapter[2]
</pre></div>
</div>
</li>
<li>
<p>This example selects all the descendants of the context node
that are elements named <code>"toy"</code> and whose
<code>color</code> attribute has the value <code>"red"</code>:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
descendant::toy[attribute::color = "red"]
</pre></div>
</div>
</li>
<li>
<p>This example selects all the <code>employee</code> children of
the context node that have both a <code>secretary</code> child
element and an <code>assistant</code> child element:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
child::employee[secretary][assistant]
</pre></div>
</div>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>When using <a title="predicate" href=
"#dt-predicate">predicates</a> with a sequence of nodes selected
using a <b>reverse axis</b>, it is important to remember that the
the context positions for such a sequence are assigned in <a title=
"reverse document order" href="#dt-reverse-document-order">reverse
document order</a>. For example, <code>preceding::foo[1]</code>
returns the first qualifying <code>foo</code> element in <a title=
"reverse document order" href="#dt-reverse-document-order">reverse
document order</a>, because the predicate is part of an <a title=
"axis step" href="#dt-axis-step">axis step</a> using a reverse
axis. By contrast, <code>(preceding::foo)[1]</code> returns the
first qualifying <code>foo</code> element in <a title=
"document order" href="#dt-document-order">document order</a>,
because the parentheses cause <code>(preceding::foo)</code> to be
parsed as a <a title="primary expression" href=
"#dt-primary-expression">primary expression</a> in which context
positions are assigned in document order. Similarly,
<code>ancestor::*[1]</code> returns the nearest ancestor element,
because the <code>ancestor</code> axis is a reverse axis, whereas
<code>(ancestor::*)[1]</code> returns the root element (first
ancestor in document order).</p>
<p>The fact that a reverse-axis step assigns context positions in
reverse document order for the purpose of evaluating predicates
does not alter the fact that the final result of the step is always
in document order.</p>
</div>
</div>
<div class="div3">
<h4><a name="unabbrev" id="unabbrev"></a>3.2.3 Unabbreviated
Syntax</h4>
<p>This section provides a number of examples of path expressions
in which the axis is explicitly specified in each <a title="step"
href="#dt-step">step</a>. The syntax used in these examples is
called the <b>unabbreviated syntax</b>. In many common cases, it is
possible to write path expressions more concisely using an
<b>abbreviated syntax</b>, as explained in <a href=
"#abbrev"><b>3.2.4 Abbreviated Syntax</b></a>.</p>
<ul>
<li>
<p><code>child::para</code> selects the <code>para</code> element
children of the context node</p>
</li>
<li>
<p><code>child::*</code> selects all element children of the
context node</p>
</li>
<li>
<p><code>child::text()</code> selects all text node children of the
context node</p>
</li>
<li>
<p><code>child::node()</code> selects all the children of the
context node. Note that no attribute nodes are returned, because
attributes are not children.</p>
</li>
<li>
<p><code>attribute::name</code> selects the <code>name</code>
attribute of the context node</p>
</li>
<li>
<p><code>attribute::*</code> selects all the attributes of the
context node</p>
</li>
<li>
<p><code>parent::node()</code> selects the parent of the context
node. If the context node is an attribute node, this expression
returns the element node (if any) to which the attribute node is
attached.</p>
</li>
<li>
<p><code>descendant::para</code> selects the <code>para</code>
element descendants of the context node</p>
</li>
<li>
<p><code>ancestor::div</code> selects all <code>div</code>
ancestors of the context node</p>
</li>
<li>
<p><code>ancestor-or-self::div</code> selects the <code>div</code>
ancestors of the context node and, if the context node is a
<code>div</code> element, the context node as well</p>
</li>
<li>
<p><code>descendant-or-self::para</code> selects the
<code>para</code> element descendants of the context node and, if
the context node is a <code>para</code> element, the context node
as well</p>
</li>
<li>
<p><code>self::para</code> selects the context node if it is a
<code>para</code> element, and otherwise returns an empty
sequence</p>
</li>
<li>
<p><code>child::chapter/descendant::para</code> selects the
<code>para</code> element descendants of the <code>chapter</code>
element children of the context node</p>
</li>
<li>
<p><code>child::*/child::para</code> selects all <code>para</code>
grandchildren of the context node</p>
</li>
<li>
<p><code>/</code> selects the root of the tree that contains the
context node, but raises a dynamic error if this root is not a
document node</p>
</li>
<li>
<p><code>/descendant::para</code> selects all the <code>para</code>
elements in the same document as the context node</p>
</li>
<li>
<p><code>/descendant::list/child::member</code> selects all the
<code>member</code> elements that have a <code>list</code> parent
and that are in the same document as the context node</p>
</li>
<li>
<p><code>child::para[fn:position() = 1]</code> selects the first
<code>para</code> child of the context node</p>
</li>
<li>
<p><code>child::para[fn:position() = fn:last()]</code> selects the
last <code>para</code> child of the context node</p>
</li>
<li>
<p><code>child::para[fn:position() = fn:last()-1]</code> selects
the last but one <code>para</code> child of the context node</p>
</li>
<li>
<p><code>child::para[fn:position() &gt; 1]</code> selects all the
<code>para</code> children of the context node other than the first
<code>para</code> child of the context node</p>
</li>
<li>
<p><code>following-sibling::chapter[fn:position() =
1]</code>selects the next <code>chapter</code> sibling of the
context node</p>
</li>
<li>
<p><code>preceding-sibling::chapter[fn:position() =
1]</code>selects the previous <code>chapter</code> sibling of the
context node</p>
</li>
<li>
<p><code>/descendant::figure[fn:position() = 42]</code> selects the
forty-second <code>figure</code> element in the document containing
the context node</p>
</li>
<li>
<p><code>/child::book/child::chapter[fn:position() =
5]/child::section[fn:position() = 2]</code> selects the second
<code>section</code> of the fifth <code>chapter</code> of the
<code>book</code> whose parent is the document node that contains
the context node</p>
</li>
<li>
<p><code>child::para[attribute::type eq "warning"]</code>selects
all <code>para</code> children of the context node that have a
<code>type</code> attribute with value <code>warning</code></p>
</li>
<li>
<p><code>child::para[attribute::type eq 'warning'][fn:position() =
5]</code>selects the fifth <code>para</code> child of the context
node that has a <code>type</code> attribute with value
<code>warning</code></p>
</li>
<li>
<p><code>child::para[fn:position() = 5][attribute::type eq
"warning"]</code>selects the fifth <code>para</code> child of the
context node if that child has a <code>type</code> attribute with
value <code>warning</code></p>
</li>
<li>
<p><code>child::chapter[child::title =
'Introduction']</code>selects the <code>chapter</code> children of
the context node that have one or more <code>title</code> children
whose <a title="typed value" href="#dt-typed-value">typed value</a>
is equal to the string <code>Introduction</code></p>
</li>
<li>
<p><code>child::chapter[child::title]</code> selects the
<code>chapter</code> children of the context node that have one or
more <code>title</code> children</p>
</li>
<li>
<p><code>child::*[self::chapter or self::appendix]</code> selects
the <code>chapter</code> and <code>appendix</code> children of the
context node</p>
</li>
<li>
<p><code>child::*[self::chapter or self::appendix][fn:position() =
fn:last()]</code> selects the last <code>chapter</code> or
<code>appendix</code> child of the context node</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="abbrev" id="abbrev"></a>3.2.4 Abbreviated Syntax</h4>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-AbbrevForwardStep" id=
"doc-xpath-AbbrevForwardStep"></a>[31]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-AbbrevForwardStep">AbbrevForwardStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"@"? <a href=
"#doc-xpath-NodeTest">NodeTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-AbbrevReverseStep" id=
"doc-xpath-AbbrevReverseStep"></a>[34]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-AbbrevReverseStep">AbbrevReverseStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>".."</code></td>
</tr>
</tbody>
</table>
<p>The abbreviated syntax permits the following abbreviations:</p>
<ol class="enumar">
<li>
<p>The attribute axis <code>attribute::</code> can be abbreviated
by <code>@</code>. For example, a path expression
<code>para[@type="warning"]</code> is short for
<code>child::para[attribute::type="warning"]</code> and so selects
<code>para</code> children with a <code>type</code> attribute with
value equal to <code>warning</code>.</p>
</li>
<li>
<p>If the axis name is omitted from an <a title="axis step" href=
"#dt-axis-step">axis step</a>, the default axis is
<code>child</code> unless the axis step contains an <a href=
"#doc-xpath-AttributeTest">AttributeTest</a> or <a href=
"#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</a>; in that
case, the default axis is <code>attribute</code>. For example, the
path expression <code>section/para</code> is an abbreviation for
<code>child::section/child::para</code>, and the path expression
<code>section/@id</code> is an abbreviation for
<code>child::section/attribute::id</code>. Similarly,
<code>section/attribute(id)</code> is an abbreviation for
<code>child::section/attribute::attribute(id)</code>. Note that the
latter expression contains both an axis specification and a
<a title="node test" href="#dt-node-test">node test</a>.</p>
</li>
<li>
<p>Each non-initial occurrence of <code>//</code> is effectively
replaced by <code>/descendant-or-self::node()/</code> during
processing of a path expression. For example,
<code>div1//para</code> is short for
<code>child::div1/descendant-or-self::node()/child::para</code> and
so will select all <code>para</code> descendants of
<code>div1</code> children.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The path expression <code>//para[1]</code> does <em>not</em>
mean the same as the path expression
<code>/descendant::para[1]</code>. The latter selects the first
descendant <code>para</code> element; the former selects all
descendant <code>para</code> elements that are the first
<code>para</code> children of their respective parents.</p>
</div>
</li>
<li>
<p>A step consisting of <code>..</code> is short for
<code>parent::node()</code>. For example, <code>../title</code> is
short for <code>parent::node()/child::title</code> and so will
select the <code>title</code> children of the parent of the context
node.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The expression <code>.</code>, known as a <b>context item
expression</b>, is a <a title="primary expression" href=
"#dt-primary-expression">primary expression</a>, and is described
in <a href="#id-context-item-expression"><b>3.1.4 Context Item
Expression</b></a>.</p>
</div>
</li>
</ol>
<p>Here are some examples of path expressions that use the
abbreviated syntax:</p>
<ul>
<li>
<p><code>para</code> selects the <code>para</code> element children
of the context node</p>
</li>
<li>
<p><code>*</code> selects all element children of the context
node</p>
</li>
<li>
<p><code>text()</code> selects all text node children of the
context node</p>
</li>
<li>
<p><code>@name</code> selects the <code>name</code> attribute of
the context node</p>
</li>
<li>
<p><code>@*</code> selects all the attributes of the context
node</p>
</li>
<li>
<p><code>para[1]</code> selects the first <code>para</code> child
of the context node</p>
</li>
<li>
<p><code>para[fn:last()]</code> selects the last <code>para</code>
child of the context node</p>
</li>
<li>
<p><code>*/para</code> selects all <code>para</code> grandchildren
of the context node</p>
</li>
<li>
<p><code>/book/chapter[5]/section[2]</code> selects the second
<code>section</code> of the fifth <code>chapter</code> of the
<code>book</code> whose parent is the document node that contains
the context node</p>
</li>
<li>
<p><code>chapter//para</code> selects the <code>para</code> element
descendants of the <code>chapter</code> element children of the
context node</p>
</li>
<li>
<p><code>//para</code> selects all the <code>para</code>
descendants of the root document node and thus selects all
<code>para</code> elements in the same document as the context
node</p>
</li>
<li>
<p><code>//@version</code> selects all the <code>version</code>
attribute nodes that are in the same document as the context
node</p>
</li>
<li>
<p><code>//list/member</code> selects all the <code>member</code>
elements in the same document as the context node that have a
<code>list</code> parent</p>
</li>
<li>
<p><code>.//para</code> selects the <code>para</code> element
descendants of the context node</p>
</li>
<li>
<p><code>..</code> selects the parent of the context node</p>
</li>
<li>
<p><code>../@lang</code> selects the <code>lang</code> attribute of
the parent of the context node</p>
</li>
<li>
<p><code>para[@type="warning"]</code> selects all <code>para</code>
children of the context node that have a <code>type</code>
attribute with value <code>warning</code></p>
</li>
<li>
<p><code>para[@type="warning"][5]</code> selects the fifth
<code>para</code> child of the context node that has a
<code>type</code> attribute with value <code>warning</code></p>
</li>
<li>
<p><code>para[5][@type="warning"]</code> selects the fifth
<code>para</code> child of the context node if that child has a
<code>type</code> attribute with value <code>warning</code></p>
</li>
<li>
<p><code>chapter[title="Introduction"]</code> selects the
<code>chapter</code> children of the context node that have one or
more <code>title</code> children whose <a title="typed value" href=
"#dt-typed-value">typed value</a> is equal to the string
<code>Introduction</code></p>
</li>
<li>
<p><code>chapter[title]</code> selects the <code>chapter</code>
children of the context node that have one or more
<code>title</code> children</p>
</li>
<li>
<p><code>employee[@secretary and @assistant]</code> selects all the
<code>employee</code> children of the context node that have both a
<code>secretary</code> attribute and an <code>assistant</code>
attribute</p>
</li>
<li>
<p><code>book/(chapter|appendix)/section</code> selects every
<code>section</code> element that has a parent that is either a
<code>chapter</code> or an <code>appendix</code> element, that in
turn is a child of a <code>book</code> element that is a child of
the context node.</p>
</li>
<li>
<p>If <code>E</code> is any expression that returns a sequence of
nodes, then the expression <code>E/.</code> returns the same nodes
in <a title="document order" href="#dt-document-order">document
order</a>, with duplicates eliminated based on node identity.</p>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="id-sequence-expressions" id=
"id-sequence-expressions"></a>3.3 Sequence Expressions</h3>
<p>XPath supports operators to construct, filter, and combine
<a title="sequence" href="#dt-sequence">sequences</a> of <a title=
"item" href="#dt-item">items</a>. Sequences are never nested—for
example, combining the values <code>1</code>, <code>(2, 3)</code>,
and <code>( )</code> into a single sequence results in the sequence
<code>(1, 2, 3)</code>.</p>
<div class="div3">
<h4><a name="construct_seq" id="construct_seq"></a>3.3.1
Constructing Sequences</h4>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="noid_d2e8430.doc-xpath-Expr" id=
"noid_d2e8430.doc-xpath-Expr"></a>[2]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-Expr">Expr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ExprSingle">ExprSingle</a> (","
<a href="#doc-xpath-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-RangeExpr" id=
"doc-xpath-RangeExpr"></a>[11]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-RangeExpr">RangeExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AdditiveExpr">AdditiveExpr</a> ( "to"
<a href="#doc-xpath-AdditiveExpr">AdditiveExpr</a> )?</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-comma-operator" id="dt-comma-operator" title=
"comma operator">Definition</a>: One way to construct a sequence is
by using the <b>comma operator</b>, which evaluates each of its
operands and concatenates the resulting sequences, in order, into a
single result sequence.] Empty parentheses can be used to denote an
empty sequence.</p>
<p>A sequence may contain duplicate atomic values or nodes, but a
sequence is never an item in another sequence. When a new sequence
is created by concatenating two or more input sequences, the new
sequence contains all the items of the input sequences and its
length is the sum of the lengths of the input sequences.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In places where the grammar calls for <a href=
"#doc-xpath-ExprSingle">ExprSingle</a>, such as the arguments of a
function call, any expression that contains a top-level comma
operator must be enclosed in parentheses.</p>
</div>
<p>Here are some examples of expressions that construct
sequences:</p>
<ul>
<li>
<p>The result of this expression is a sequence of five
integers:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
(10, 1, 2, 3, 4)
</pre></div>
</div>
</li>
<li>
<p>This expression combines four sequences of length one, two,
zero, and two, respectively, into a single sequence of length five.
The result of this expression is the sequence <code>10, 1, 2, 3,
4</code>.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
(10, (1, 2), (), (3, 4))
</pre></div>
</div>
</li>
<li>
<p>The result of this expression is a sequence containing all
<code>salary</code> children of the context node followed by all
<code>bonus</code> children.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
(salary, bonus)
</pre></div>
</div>
</li>
<li>
<p>Assuming that <code>$price</code> is bound to the value
<code>10.50</code>, the result of this expression is the sequence
<code>10.50, 10.50</code>.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
($price, $price)
</pre></div>
</div>
</li>
</ul>
<p>A <b>range expression</b> can be used to construct a sequence of
consecutive integers. Each of the operands of the <code>to</code>
operator is converted as though it was an argument of a function
with the expected parameter type <code>xs:integer?</code>. If
either operand is an empty sequence, or if the integer derived from
the first operand is greater than the integer derived from the
second operand, the result of the range expression is an empty
sequence. If the two operands convert to the same integer, the
result of the range expression is that integer. Otherwise, the
result is a sequence containing the two integer operands and every
integer between the two operands, in increasing order.</p>
<ul>
<li>
<p>This example uses a range expression as one operand in
constructing a sequence. It evaluates to the sequence <code>10, 1,
2, 3, 4</code>.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
(10, 1 to 4)
</pre></div>
</div>
</li>
<li>
<p>This example constructs a sequence of length one containing the
single integer <code>10</code>.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
10 to 10
</pre></div>
</div>
</li>
<li>
<p>The result of this example is a sequence of length zero.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
15 to 10
</pre></div>
</div>
</li>
<li>
<p>This example uses the <code>fn:reverse</code> function to
construct a sequence of six integers in decreasing order. It
evaluates to the sequence <code>15, 14, 13, 12, 11, 10</code>.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
fn:reverse(10 to 15)
</pre></div>
</div>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-filter-expr" id="id-filter-expr"></a>3.3.2 Filter
Expressions</h4>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-FilterExpr" id=
"doc-xpath-FilterExpr"></a>[38]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-FilterExpr">FilterExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-PrimaryExpr">PrimaryExpr</a> <a href=
"#doc-xpath-PredicateList">PredicateList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d2e8538.doc-xpath-PredicateList" id=
"noid_d2e8538.doc-xpath-PredicateList"></a>[39]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-PredicateList">PredicateList</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-Predicate">Predicate</a>*</code></td>
</tr>
</tbody>
</table>
<p>[<a name="dt-filter-expression" id="dt-filter-expression" title=
"filter expression">Definition</a>: A <b>filter expression</b>
consists simply of a <b>primary expression</b> followed by zero or
more <a title="predicate" href="#dt-predicate">predicates</a>. The
result of the filter expression consists of the items returned by
the primary expression, filtered by applying each predicate in
turn, working from left to right.] If no predicates are specified,
the result is simply the result of the primary expression. The
ordering of the items returned by a filter expression is the same
as their order in the result of the primary expression. Context
positions are assigned to items based on their ordinal position in
the result sequence. The first context position is 1.</p>
<p>Here are some examples of filter expressions:</p>
<ul>
<li>
<p>Given a sequence of products in a variable, return only those
products whose price is greater than 100.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
$products[price gt 100]
</pre></div>
</div>
</li>
<li>
<p>List all the integers from 1 to 100 that are divisible by 5.
(See <a href="#construct_seq"><b>3.3.1 Constructing
Sequences</b></a> for an explanation of the <code>to</code>
operator.)</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
(1 to 100)[. mod 5 eq 0]
</pre></div>
</div>
</li>
<li>
<p>The result of the following expression is the integer 25:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
(21 to 29)[5]
</pre></div>
</div>
</li>
<li>
<p>The following example returns the fifth through ninth items in
the sequence bound to variable <code>$orders</code>.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
$orders[fn:position() = (5 to 9)]
</pre></div>
</div>
</li>
<li>
<p>The following example illustrates the use of a filter expression
as a <a title="step" href="#dt-step">step</a> in a <a title=
"path expression" href="#dt-path-expression">path expression</a>.
It returns the last chapter or appendix within the book bound to
variable <code>$book</code>:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
$book/(chapter | appendix)[fn:last()]
</pre></div>
</div>
</li>
<li>
<p>The following example also illustrates the use of a filter
expression as a <a title="step" href="#dt-step">step</a> in a
<a title="path expression" href="#dt-path-expression">path
expression</a>. It returns the element node within the specified
document whose ID value is <code>tiger</code>:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
fn:doc("zoo.xml")/fn:id('tiger')
</pre></div>
</div>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="combining_seq" id="combining_seq"></a>3.3.3 Combining
Node Sequences</h4>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-UnionExpr" id=
"doc-xpath-UnionExpr"></a>[14]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-UnionExpr">UnionExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-IntersectExceptExpr">IntersectExceptExpr</a> ( ("union"
| "|") <a href=
"#doc-xpath-IntersectExceptExpr">IntersectExceptExpr</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-IntersectExceptExpr" id=
"doc-xpath-IntersectExceptExpr"></a>[15]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-IntersectExceptExpr">IntersectExceptExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-InstanceofExpr">InstanceofExpr</a> (
("intersect" | "except") <a href=
"#doc-xpath-InstanceofExpr">InstanceofExpr</a> )*</code></td>
</tr>
</tbody>
</table>
<p>XPath provides the following operators for combining sequences
of nodes:</p>
<ul>
<li>
<p>The <code>union</code> and <code>|</code> operators are
equivalent. They take two node sequences as operands and return a
sequence containing all the nodes that occur in either of the
operands.</p>
</li>
<li>
<p>The <code>intersect</code> operator takes two node sequences as
operands and returns a sequence containing all the nodes that occur
in both operands.</p>
</li>
<li>
<p>The <code>except</code> operator takes two node sequences as
operands and returns a sequence containing all the nodes that occur
in the first operand but not in the second operand.</p>
</li>
</ul>
<p>All these operators eliminate duplicate nodes from their result
sequences based on node identity. <span class="xpath"><span class=
"xpath">The resulting sequence is returned in <a title=
"document order" href="#dt-document-order">document
order</a>.</span></span></p>
<p>If an operand of <code>union</code>, <code>intersect</code>, or
<code>except</code> contains an item that is not a node, a
<a title="type error" href="#dt-type-error">type error</a> is
raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>].</p>
<p>Here are some examples of expressions that combine sequences.
Assume the existence of three element nodes that we will refer to
by symbolic names A, B, and C. Assume that the variables
<code>$seq1</code>, <code>$seq2</code> and <code>$seq3</code> are
bound to the following sequences of these nodes:</p>
<ul>
<li>
<p><code>$seq1</code> is bound to (A, B)</p>
</li>
<li>
<p><code>$seq2</code> is bound to (A, B)</p>
</li>
<li>
<p><code>$seq3</code> is bound to (B, C)</p>
</li>
</ul>
<p>Then:</p>
<ul>
<li>
<p><code>$seq1 union $seq2</code> evaluates to the sequence (A,
B).</p>
</li>
<li>
<p><code>$seq2 union $seq3</code> evaluates to the sequence (A, B,
C).</p>
</li>
<li>
<p><code>$seq1 intersect $seq2</code> evaluates to the sequence (A,
B).</p>
</li>
<li>
<p><code>$seq2 intersect $seq3</code> evaluates to the sequence
containing B only.</p>
</li>
<li>
<p><code>$seq1 except $seq2</code> evaluates to the empty
sequence.</p>
</li>
<li>
<p><code>$seq2 except $seq3</code> evaluates to the sequence
containing A only.</p>
</li>
</ul>
<p>In addition to the sequence operators described here, <a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators (Second Edition)]</a> includes functions for indexed
access to items or sub-sequences of a sequence, for indexed
insertion or removal of items in a sequence, and for removing
duplicate items from a sequence.</p>
</div>
</div>
<div class="div2">
<h3><a name="id-arithmetic" id="id-arithmetic"></a>3.4 Arithmetic
Expressions</h3>
<p>XPath provides arithmetic operators for addition, subtraction,
multiplication, division, and modulus, in their usual binary and
unary forms.</p>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-AdditiveExpr" id=
"doc-xpath-AdditiveExpr"></a>[12]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-AdditiveExpr">AdditiveExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-MultiplicativeExpr">MultiplicativeExpr</a> ( ("+" |
"-") <a href="#doc-xpath-MultiplicativeExpr">MultiplicativeExpr</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-MultiplicativeExpr" id=
"doc-xpath-MultiplicativeExpr"></a>[13]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-MultiplicativeExpr">MultiplicativeExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-UnionExpr">UnionExpr</a> ( ("*" |
"div" | "idiv" | "mod") <a href=
"#doc-xpath-UnionExpr">UnionExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-UnaryExpr" id=
"doc-xpath-UnaryExpr"></a>[20]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-UnaryExpr">UnaryExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("-" | "+")* <a href=
"#doc-xpath-ValueExpr">ValueExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-ValueExpr" id=
"doc-xpath-ValueExpr"></a>[21]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ValueExpr">ValueExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-PathExpr">PathExpr</a></code></td>
</tr>
</tbody>
</table>
<p>A subtraction operator must be preceded by whitespace if it
could otherwise be interpreted as part of the previous token. For
example, <code>a-b</code> will be interpreted as a name, but
<code>a - b</code> and <code>a -b</code> will be interpreted as
arithmetic expressions. (See <a href="#whitespace-rules"><b>A.2.4
Whitespace Rules</b></a> for further details on whitespace
handling.)</p>
<p>The first step in evaluating an arithmetic expression is to
evaluate its operands. The order in which the operands are
evaluated is <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
<div class="xpath">
<p class="xpath">If <a title="XPath 1.0 compatibility mode" href=
"#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is
<code>true</code>, each operand is evaluated by applying the
following steps, in order:</p>
</div>
<div class="xpath">
<ol class="enumar">
<li>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is
applied to the operand. The result of this operation is called the
<b>atomized operand</b>.</p>
</li>
<li>
<p>If the atomized operand is an empty sequence, the result of the
arithmetic expression is the <code>xs:double</code> value
<code>NaN</code>, and the implementation need not evaluate the
other operand or apply the operator. However, an implementation may
choose to evaluate the other operand in order to determine whether
it raises an error.</p>
</li>
<li>
<p>If the atomized operand is a sequence of length greater than
one, any items after the first item in the sequence are
discarded.</p>
</li>
<li>
<p>If the atomized operand is now an instance of type
<code>xs:boolean</code>, <code>xs:string</code>,
<code>xs:decimal</code> (including <code>xs:integer</code>),
<code>xs:float</code>, or <code>xs:untypedAtomic</code>, then it is
converted to the type <code>xs:double</code> by applying the
<code>fn:number</code> function. (Note that <code>fn:number</code>
returns the value <code>NaN</code> if its operand cannot be
converted to a number.)</p>
</li>
</ol>
</div>
<p><span class="xpath"><span class="xpath">If <a title=
"XPath 1.0 compatibility mode" href="#dt-xpath-compat-mode">XPath
1.0 compatibility mode</a> is <code>false</code>,
each</span></span> operand is evaluated by applying the following
steps, in order:</p>
<ol class="enumar">
<li>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is
applied to the operand. The result of this operation is called the
<b>atomized operand</b>.</p>
</li>
<li>
<p>If the atomized operand is an empty sequence, the result of the
arithmetic expression is an empty sequence, and the implementation
need not evaluate the other operand or apply the operator. However,
an implementation may choose to evaluate the other operand in order
to determine whether it raises an error.</p>
</li>
<li>
<p>If the atomized operand is a sequence of length greater than
one, a <a title="type error" href="#dt-type-error">type error</a>
is raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>].</p>
</li>
<li>
<p>If the atomized operand is of type
<code>xs:untypedAtomic</code>, it is cast to
<code>xs:double</code>. If the cast fails, a <a title=
"dynamic error" href="#dt-dynamic-error">dynamic error</a> is
raised. [err:FORG0001]</p>
</li>
</ol>
<p>After evaluation of the operands, if the types of the operands
are a valid combination for the given arithmetic operator, the
operator is applied to the operands, resulting in an atomic value
or a <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a> (for example, an error might result from dividing by
zero.) The combinations of atomic types that are accepted by the
various arithmetic operators, and their respective result types,
are listed in <a href="#mapping"><b>B.2 Operator Mapping</b></a>
together with the <a title="operator function" href=
"#dt-operator-function">operator functions</a> that define the
semantics of the operator for each type combination, including the
dynamic errors that can be raised by the operator. The definitions
of the operator functions are found in <a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators (Second Edition)]</a>.</p>
<p>If the types of the operands, after evaluation, are not a valid
combination for the given operator, according to the rules in
<a href="#mapping"><b>B.2 Operator Mapping</b></a>, a <a title=
"type error" href="#dt-type-error">type error</a> is raised
[<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p>
<p>XPath supports two division operators named <code>div</code> and
<code>idiv</code>. Each of these operators accepts two operands of
any <a title="numeric" href="#dt-numeric">numeric</a> type. As
described in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath
2.0 Functions and Operators (Second Edition)]</a>, <code>$arg1 idiv
$arg2</code> is equivalent to <code>($arg1 div $arg2) cast as
xs:integer?</code> except for error cases.</p>
<p>Here are some examples of arithmetic expressions:</p>
<ul>
<li>
<p>The first expression below returns the <code>xs:decimal</code>
value <code>-1.5</code>, and the second expression returns the
<code>xs:integer</code> value <code>-1</code>:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
-3 div 2
-3 idiv 2
</pre></div>
</div>
</li>
<li>
<p>Subtraction of two date values results in a value of type
<code>xs:dayTimeDuration</code>:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
$emp/hiredate - $emp/birthdate
</pre></div>
</div>
</li>
<li>
<p>This example illustrates the difference between a subtraction
operator and a hyphen:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
$unit-price - $unit-discount
</pre></div>
</div>
</li>
<li>
<p>Unary operators have higher precedence than binary operators,
subject of course to the use of parentheses. Therefore, the
following two examples have different meanings:</p>
<div class="exampleInner">
<pre>
-$bellcost + $whistlecost
-($bellcost + $whistlecost)
</pre></div>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p id="note-consecutive-unary-ops">Multiple consecutive unary
arithmetic operators are permitted by XPath for compatibility with
<a href="#XPath">[XPath 1.0]</a>.</p>
</div>
</div>
<div class="div2">
<h3><a name="id-comparisons" id="id-comparisons"></a>3.5 Comparison
Expressions</h3>
<p>Comparison expressions allow two values to be compared. XPath
provides three kinds of comparison expressions, called value
comparisons, general comparisons, and node comparisons.</p>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-ComparisonExpr" id=
"doc-xpath-ComparisonExpr"></a>[10]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-ComparisonExpr">ComparisonExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-RangeExpr">RangeExpr</a> ( (<a href=
"#doc-xpath-ValueComp">ValueComp</a><br />
| <a href="#doc-xpath-GeneralComp">GeneralComp</a><br />
| <a href="#doc-xpath-NodeComp">NodeComp</a>) <a href=
"#doc-xpath-RangeExpr">RangeExpr</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-ValueComp" id=
"doc-xpath-ValueComp"></a>[23]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ValueComp">ValueComp</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"eq" | "ne" | "lt" | "le" | "gt" | "ge"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-GeneralComp" id=
"doc-xpath-GeneralComp"></a>[22]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-GeneralComp">GeneralComp</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"=" | "!=" | "&lt;" | "&lt;=" | "&gt;" |
"&gt;="</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-NodeComp" id=
"doc-xpath-NodeComp"></a>[24]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-NodeComp">NodeComp</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"is" | "&lt;&lt;" | "&gt;&gt;"</code></td>
</tr>
</tbody>
</table>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<div class="xpath">
<p class="xpath">When an XPath expression is written within an XML
document, the XML escaping rules for special characters must be
followed; thus "<code>&lt;</code>" must be written as
"<code>&amp;lt;</code>".</p>
</div>
</div>
<div class="div3">
<h4><a name="id-value-comparisons" id=
"id-value-comparisons"></a>3.5.1 Value Comparisons</h4>
<p>The value comparison operators are <code>eq</code>,
<code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>,
and <code>ge</code>. Value comparisons are used for comparing
single values.</p>
<p>The first step in evaluating a value comparison is to evaluate
its operands. The order in which the operands are evaluated is
<a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>. Each
operand is evaluated by applying the following steps, in order:</p>
<ol class="enumar">
<li>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is
applied to the operand. The result of this operation is called the
<b>atomized operand</b>.</p>
</li>
<li>
<p>If the atomized operand is an empty sequence, the result of the
value comparison is an empty sequence, and the implementation need
not evaluate the other operand or apply the operator. However, an
implementation may choose to evaluate the other operand in order to
determine whether it raises an error.</p>
</li>
<li>
<p>If the atomized operand is a sequence of length greater than
one, a <a title="type error" href="#dt-type-error">type error</a>
is raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>].</p>
</li>
<li>
<p>If the atomized operand is of type
<code>xs:untypedAtomic</code>, it is cast to
<code>xs:string</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The purpose of this rule is to make value comparisons
transitive. Users should be aware that the general comparison
operators have a different rule for casting of
<code>xs:untypedAtomic</code> operands. Users should also be aware
that transitivity of value comparisons may be compromised by loss
of precision during type conversion (for example, two
<code>xs:integer</code> values that differ slightly may both be
considered equal to the same <code>xs:float</code> value because
<code>xs:float</code> has less precision than
<code>xs:integer</code>).</p>
</div>
</li>
</ol>
<p>Next, if possible, the two operands are converted to their least
common type by a combination of <a title="type promotion" href=
"#dt-type-promotion">type promotion</a> and <a title=
"subtype substitution" href="#dt-subtype-substitution">subtype
substitution</a>. For example, if the operands are of type
<code>hatsize</code> (derived from <code>xs:integer</code>) and
<code>shoesize</code> (derived from <code>xs:float</code>), their
least common type is <code>xs:float</code>.</p>
<p>Finally, if the types of the operands are a valid combination
for the given operator, the operator is applied to the operands.
The combinations of atomic types that are accepted by the various
value comparison operators, and their respective result types, are
listed in <a href="#mapping"><b>B.2 Operator Mapping</b></a>
together with the <a title="operator function" href=
"#dt-operator-function">operator functions</a> that define the
semantics of the operator for each type combination. The
definitions of the operator functions are found in <a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators (Second Edition)]</a>.</p>
<p>Informally, if both atomized operands consist of exactly one
atomic value, then the result of the comparison is
<code>true</code> if the value of the first operand is (equal, not
equal, less than, less than or equal, greater than, greater than or
equal) to the value of the second operand; otherwise the result of
the comparison is <code>false</code>.</p>
<p>If the types of the operands, after evaluation, are not a valid
combination for the given operator, according to the rules in
<a href="#mapping"><b>B.2 Operator Mapping</b></a>, a <a title=
"type error" href="#dt-type-error">type error</a> is raised
[<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p>
<p>Here are some examples of value comparisons:</p>
<ul>
<li>
<p>The following comparison atomizes the node(s) that are returned
by the expression <code>$book/author</code>. The comparison is true
only if the result of atomization is the value "Kennedy" as an
instance of <code>xs:string</code> or
<code>xs:untypedAtomic</code>. If the result of atomization is an
empty sequence, the result of the comparison is an empty sequence.
If the result of atomization is a sequence containing more than one
value, a <a title="type error" href="#dt-type-error">type error</a>
is raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>].</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
$book1/author eq "Kennedy"
</pre></div>
</div>
</li>
<li>
<p>The following <a title="path expression" href=
"#dt-path-expression">path expression</a> contains a predicate that
selects products whose weight is greater than 100. For any product
that does not have a <code>weight</code> subelement, the value of
the predicate is the empty sequence, and the product is not
selected. This example assumes that <code>weight</code> is a
validated element with a numeric type.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
//product[weight gt 100]
</pre></div>
</div>
</li>
<li>
<p>The following comparison is true if <code>my:hatsize</code> and
<code>my:shoesize</code> are both user-defined types that are
derived by restriction from a primitive <a title="numeric" href=
"#dt-numeric">numeric</a> type:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
my:hatsize(5) eq my:shoesize(5)
</pre></div>
</div>
</li>
<li>
<p>The following comparison is true. The <code>eq</code> operator
compares two QNames by performing codepoint-comparisons of their
namespace URIs and their local names, ignoring their namespace
prefixes.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
fn:QName("http://example.com/ns1", "this:color")
   eq fn:QName("http://example.com/ns1", "that:color")
</pre></div>
</div>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-general-comparisons" id=
"id-general-comparisons"></a>3.5.2 General Comparisons</h4>
<p>The general comparison operators are <code>=</code>,
<code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>,
<code>&gt;</code>, and <code>&gt;=</code>. General comparisons are
existentially quantified comparisons that may be applied to operand
sequences of any length. The result of a general comparison that
does not raise an error is always <code>true</code> or
<code>false</code>.</p>
<div class="xpath">
<p class="xpath">If <a title="XPath 1.0 compatibility mode" href=
"#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is
<code>true</code>, a general comparison is evaluated by applying
the following rules, in order:</p>
</div>
<div class="xpath">
<ol class="enumar">
<li>
<p>If either operand is a single atomic value that is an instance
of <code>xs:boolean</code>, then the other operand is converted to
<code>xs:boolean</code> by taking its <a title=
"effective boolean value" href="#dt-ebv">effective boolean
value</a>.</p>
</li>
<li>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is
applied to each operand. After atomization, each operand is a
sequence of atomic values.</p>
</li>
<li>
<p>If the comparison operator is <code>&lt;</code>,
<code>&lt;=</code>, <code>&gt;</code>, or <code>&gt;=</code>, then
each item in both of the operand sequences is converted to the type
<code>xs:double</code> by applying the <code>fn:number</code>
function. (Note that <code>fn:number</code> returns the value
<code>NaN</code> if its operand cannot be converted to a
number.)</p>
</li>
<li>
<p>The result of the comparison is <code>true</code> if and only if
there is a pair of atomic values, one in the first operand sequence
and the other in the second operand sequence, that have the
required <b>magnitude relationship</b>. Otherwise the result of the
comparison is <code>false</code>. The <b>magnitude relationship</b>
between two atomic values is determined by applying the following
rules. If a <code>cast</code> operation called for by these rules
is not successful, a dynamic error is raised. [err:FORG0001]</p>
<ol class="enumla">
<li>
<p>If at least one of the two atomic values is an instance of a
<a title="numeric" href="#dt-numeric">numeric</a> type, then both
atomic values are converted to the type <code>xs:double</code> by
applying the <code>fn:number</code> function.</p>
</li>
<li>
<p>If both atomic values are instances of
<code>xs:untypedAtomic</code>, then the values are cast to the type
<code>xs:string</code>.</p>
</li>
<li>
<p>If exactly one of the atomic values is an instance of
<code>xs:untypedAtomic</code>, and the previous rule does not apply
(that is, the other value is not numeric), then it is cast to a
type depending on the other value's dynamic type T according to the
following rules, in which V denotes the value to be cast:</p>
<ol class="enumlr">
<li>
<p>If T is <code>xs:dayTimeDuration</code> or is derived from
<code>xs:dayTimeDuration</code>, then V is cast to
<code>xs:dayTimeDuration</code>.</p>
</li>
<li>
<p>If T is <code>xs:yearMonthDuration</code> or is derived from
<code>xs:yearMonthDuration</code>, then V is cast to
<code>xs:yearMonthDuration</code>.</p>
</li>
<li>
<p>In all other cases, V is cast to the primitive base type of
T.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The special treatment of the duration types is required to avoid
errors that may arise when comparing the primitive type
<code>xs:duration</code> with any duration type.</p>
</div>
</li>
<li>
<p>After performing the conversions described above, the atomic
values are compared using one of the value comparison operators
<code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>,
<code>gt</code>, or <code>ge</code>, depending on whether the
general comparison operator was <code>=</code>, <code>!=</code>,
<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, or
<code>&gt;=</code>. The values have the required <b>magnitude
relationship</b> if and only if the result of this value comparison
is <code>true</code>.</p>
</li>
</ol>
</li>
</ol>
</div>
<p><span class="xpath"><span class="xpath">If <a title=
"XPath 1.0 compatibility mode" href="#dt-xpath-compat-mode">XPath
1.0 compatibility mode</a> is <code>false</code>, a</span></span>
general comparison is evaluated by applying the following rules, in
order:</p>
<ol class="enumar">
<li>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is
applied to each operand. After atomization, each operand is a
sequence of atomic values.</p>
</li>
<li>
<p>The result of the comparison is <code>true</code> if and only if
there is a pair of atomic values, one in the first operand sequence
and the other in the second operand sequence, that have the
required <b>magnitude relationship</b>. Otherwise the result of the
comparison is <code>false</code>. The <b>magnitude relationship</b>
between two atomic values is determined by applying the following
rules. If a <code>cast</code> operation called for by these rules
is not successful, a dynamic error is raised. [err:FORG0001]</p>
<ol class="enumla">
<li>
<p>If both atomic values are instances of
<code>xs:untypedAtomic</code>, then the values are cast to the type
<code>xs:string</code>.</p>
</li>
<li>
<p>If exactly one of the atomic values is an instance of
<code>xs:untypedAtomic</code>, it is cast to a type depending on
the other value's dynamic type T according to the following rules,
in which V denotes the value to be cast:</p>
<ol class="enumlr">
<li>
<p>If T is a numeric type or is derived from a numeric type, then V
is cast to <code>xs:double</code>.</p>
</li>
<li>
<p>If T is <code>xs:dayTimeDuration</code> or is derived from
<code>xs:dayTimeDuration</code>, then V is cast to
<code>xs:dayTimeDuration</code>.</p>
</li>
<li>
<p>If T is <code>xs:yearMonthDuration</code> or is derived from
<code>xs:yearMonthDuration</code>, then V is cast to
<code>xs:yearMonthDuration</code>.</p>
</li>
<li>
<p>In all other cases, V is cast to the primitive base type of
T.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The special treatment of the duration types is required to avoid
errors that may arise when comparing the primitive type
<code>xs:duration</code> with any duration type.</p>
</div>
</li>
<li>
<p>After performing the conversions described above, the atomic
values are compared using one of the value comparison operators
<code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>,
<code>gt</code>, or <code>ge</code>, depending on whether the
general comparison operator was <code>=</code>, <code>!=</code>,
<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, or
<code>&gt;=</code>. The values have the required <b>magnitude
relationship</b> if and only if the result of this value comparison
is <code>true</code>.</p>
</li>
</ol>
</li>
</ol>
<p>When evaluating a general comparison in which either operand is
a sequence of items, an implementation may return <code>true</code>
as soon as it finds an item in the first operand and an item in the
second operand that have the required <b>magnitude
relationship</b>. Similarly, a general comparison may raise a
<a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
as soon as it encounters an error in evaluating either operand, or
in comparing a pair of items from the two operands. As a result of
these rules, the result of a general comparison is not
deterministic in the presence of errors.</p>
<p>Here are some examples of general comparisons:</p>
<ul>
<li>
<p>The following comparison is true if the <a title="typed value"
href="#dt-typed-value">typed value</a> of any <code>author</code>
subelement of <code>$book1</code> is "Kennedy" as an instance of
<code>xs:string</code> or <code>xs:untypedAtomic</code>:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
$book1/author = "Kennedy"
</pre></div>
</div>
</li>
<li>
<p>The following example contains three general comparisons. The
value of the first two comparisons is <code>true</code>, and the
value of the third comparison is <code>false</code>. This example
illustrates the fact that general comparisons are not
transitive.</p>
<div class="exampleInner">
<pre>
(1, 2) = (2, 3)
(2, 3) = (3, 4)
(1, 2) = (3, 4)
</pre></div>
</li>
<li>
<p>The following example contains two general comparisons, both of
which are <code>true</code>. This example illustrates the fact that
the <code>=</code> and <code>!=</code> operators are not inverses
of each other.</p>
<div class="exampleInner">
<pre>
(1, 2) = (2, 3)
(1, 2) != (2, 3)
</pre></div>
</li>
<li>
<p>Suppose that <code>$a</code>, <code>$b</code>, and
<code>$c</code> are bound to element nodes with type annotation
<code>xs:untypedAtomic</code>, with <a title="string value" href=
"#dt-string-value">string values</a> "<code>1</code>",
"<code>2</code>", and "<code>2.0</code>" respectively. Then
<code>($a, $b) = ($c, 3.0)</code> returns <code>false</code>,
because <code>$b</code> and <code>$c</code> are compared as
strings. However, <code>($a, $b) = ($c, 2.0)</code> returns
<code>true</code>, because <code>$b</code> and <code>2.0</code> are
compared as numbers.</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-node-comparisons" id=
"id-node-comparisons"></a>3.5.3 Node Comparisons</h4>
<p>Node comparisons are used to compare two nodes, by their
identity or by their <a title="document order" href=
"#dt-document-order">document order</a>. The result of a node
comparison is defined by the following rules:</p>
<ol class="enumar">
<li>
<p>The operands of a node comparison are evaluated in <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>
order.</p>
</li>
<li>
<p>If either operand is an empty sequence, the result of the
comparison is an empty sequence, and the implementation need not
evaluate the other operand or apply the operator. However, an
implementation may choose to evaluate the other operand in order to
determine whether it raises an error.</p>
</li>
<li>
<p>Each operand must be either a single node or an empty sequence;
otherwise a <a title="type error" href="#dt-type-error">type
error</a> is raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>].</p>
</li>
<li>
<p>A comparison with the <code>is</code> operator is
<code>true</code> if the two operand nodes have the same identity,
and are thus the same node; otherwise it is <code>false</code>. See
<a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model (Second
Edition)]</a> for a definition of node identity.</p>
</li>
<li>
<p>A comparison with the <code>&lt;&lt;</code> operator returns
<code>true</code> if the left operand node precedes the right
operand node in <a title="document order" href=
"#dt-document-order">document order</a>; otherwise it returns
<code>false</code>.</p>
</li>
<li>
<p>A comparison with the <code>&gt;&gt;</code> operator returns
<code>true</code> if the left operand node follows the right
operand node in <a title="document order" href=
"#dt-document-order">document order</a>; otherwise it returns
<code>false</code>.</p>
</li>
</ol>
<p>Here are some examples of node comparisons:</p>
<ul>
<li>
<p>The following comparison is true only if the left and right
sides each evaluate to exactly the same single node:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
/books/book[isbn="1558604820"] is /books/book[call="QA76.9 C3845"]
</pre></div>
</div>
</li>
<li>
<p>The following comparison is true only if the node identified by
the left side occurs before the node identified by the right side
in document order:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
/transactions/purchase[parcel="28-451"] 
   &lt;&lt; /transactions/sale[parcel="33-870"]
</pre></div>
</div>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="id-logical-expressions" id=
"id-logical-expressions"></a>3.6 Logical Expressions</h3>
<p>A <b>logical expression</b> is either an <b>and-expression</b>
or an <b>or-expression</b>. If a logical expression does not raise
an error, its value is always one of the boolean values
<code>true</code> or <code>false</code>.</p>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-OrExpr" id=
"doc-xpath-OrExpr"></a>[8]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-OrExpr">OrExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AndExpr">AndExpr</a> ( "or" <a href=
"#doc-xpath-AndExpr">AndExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-AndExpr" id=
"doc-xpath-AndExpr"></a>[9]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AndExpr">AndExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ComparisonExpr">ComparisonExpr</a> (
"and" <a href="#doc-xpath-ComparisonExpr">ComparisonExpr</a>
)*</code></td>
</tr>
</tbody>
</table>
<p>The first step in evaluating a logical expression is to find the
<a title="effective boolean value" href="#dt-ebv">effective boolean
value</a> of each of its operands (see <a href="#id-ebv"><b>2.4.3
Effective Boolean Value</b></a>).</p>
<p>The value of an and-expression is determined by the effective
boolean values (EBV's) of its operands, as shown in the following
table:</p>
<table border="1" cellpadding="4" cellspacing="1" width="80%"
summary="AND EBV">
<tbody>
<tr>
<td>AND:</td>
<td>EBV<sub>2</sub> = <code>true</code></td>
<td>EBV<sub>2</sub> = <code>false</code></td>
<td>error in EBV<sub>2</sub></td>
</tr>
<tr>
<td>EBV<sub>1</sub> = <code>true</code></td>
<td><code>true</code></td>
<td><code>false</code></td>
<td>error</td>
</tr>
<tr>
<td>EBV<sub>1</sub> = <code>false</code></td>
<td><code>false</code></td>
<td><code>false</code></td>
<td><span class="xpath"><span class="xpath">if <a title=
"XPath 1.0 compatibility mode" href="#dt-xpath-compat-mode">XPath
1.0 compatibility mode</a> is <code>true</code>, then
<code>false</code>; otherwise either <code>false</code> or
error.</span></span></td>
</tr>
<tr>
<td>error in EBV<sub>1</sub></td>
<td>error</td>
<td><span class="xpath"><span class="xpath">if <a title=
"XPath 1.0 compatibility mode" href="#dt-xpath-compat-mode">XPath
1.0 compatibility mode</a> is <code>true</code>, then error;
otherwise either <code>false</code> or error.</span></span></td>
<td>error</td>
</tr>
</tbody>
</table>
<p>The value of an or-expression is determined by the effective
boolean values (EBV's) of its operands, as shown in the following
table:</p>
<table border="1" cellpadding="4" cellspacing="1" width="80%"
summary="OR EBV">
<tbody>
<tr>
<td>OR:</td>
<td>EBV<sub>2</sub> = <code>true</code></td>
<td>EBV<sub>2</sub> = <code>false</code></td>
<td>error in EBV<sub>2</sub></td>
</tr>
<tr>
<td>EBV<sub>1</sub> = <code>true</code></td>
<td><code>true</code></td>
<td><code>true</code></td>
<td><span class="xpath"><span class="xpath">if <a title=
"XPath 1.0 compatibility mode" href="#dt-xpath-compat-mode">XPath
1.0 compatibility mode</a> is <code>true</code>, then
<code>true</code>; otherwise either <code>true</code> or
error.</span></span></td>
</tr>
<tr>
<td>EBV<sub>1</sub> = <code>false</code></td>
<td><code>true</code></td>
<td><code>false</code></td>
<td>error</td>
</tr>
<tr>
<td>error in EBV<sub>1</sub></td>
<td><span class="xpath"><span class="xpath">if <a title=
"XPath 1.0 compatibility mode" href="#dt-xpath-compat-mode">XPath
1.0 compatibility mode</a> is <code>true</code>, then error;
otherwise either <code>true</code> or error.</span></span></td>
<td>error</td>
<td>error</td>
</tr>
</tbody>
</table>
<div class="xpath">
<p class="xpath">If <a title="XPath 1.0 compatibility mode" href=
"#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is
<code>true</code>, the order in which the operands of a logical
expression are evaluated is effectively prescribed. Specifically,
it is defined that when there is no need to evaluate the second
operand in order to determine the result, then no error can occur
as a result of evaluating the second operand.</p>
</div>
<p><span class="xpath"><span class="xpath">If <a title=
"XPath 1.0 compatibility mode" href="#dt-xpath-compat-mode">XPath
1.0 compatibility mode</a> is <code>false</code>, the order in
which the operands of a logical expression are evaluated is
<a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>. In
this case,</span></span> an or-expression can return
<code>true</code> if the first expression evaluated is true, and it
can raise an error if evaluation of the first expression raises an
error. Similarly, an and-expression can return <code>false</code>
if the first expression evaluated is false, and it can raise an
error if evaluation of the first expression raises an error. As a
result of these rules, a logical expression is not deterministic in
the presence of errors, as illustrated in the examples below.</p>
<p>Here are some examples of logical expressions:</p>
<ul>
<li>
<p>The following expressions return <code>true</code>:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
1 eq 1 and 2 eq 2
</pre></div>
</div>
<div class="parse-test">
<div class="exampleInner">
<pre>
1 eq 1 or 2 eq 3
</pre></div>
</div>
</li>
<li>
<p>The following expression may return either <code>false</code> or
raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a> <span class="xpath"><span class="xpath">(in <a title=
"XPath 1.0 compatibility mode" href="#dt-xpath-compat-mode">XPath
1.0 compatibility mode</a>, the result must be
<code>false</code>)</span></span>:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
1 eq 2 and 3 idiv 0 = 1
</pre></div>
</div>
</li>
<li>
<p>The following expression may return either <code>true</code> or
raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a> <span class="xpath"><span class="xpath">(in <a title=
"XPath 1.0 compatibility mode" href="#dt-xpath-compat-mode">XPath
1.0 compatibility mode</a>, the result must be
<code>true</code>)</span></span>:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
1 eq 1 or 3 idiv 0 = 1
</pre></div>
</div>
</li>
<li>
<p>The following expression must raise a <a title="dynamic error"
href="#dt-dynamic-error">dynamic error</a>:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
1 eq 1 and 3 idiv 0 = 1
</pre></div>
</div>
</li>
</ul>
<p>In addition to and- and or-expressions, XPath provides a
function named <code>fn:not</code> that takes a general sequence as
parameter and returns a boolean value. The <code>fn:not</code>
function is defined in <a href="#FunctionsAndOperators">[XQuery 1.0
and XPath 2.0 Functions and Operators (Second Edition)]</a>. The
<code>fn:not</code> function reduces its parameter to an <a title=
"effective boolean value" href="#dt-ebv">effective boolean
value</a>. It then returns <code>true</code> if the effective
boolean value of its parameter is <code>false</code>, and
<code>false</code> if the effective boolean value of its parameter
is <code>true</code>. If an error is encountered in finding the
effective boolean value of its operand, <code>fn:not</code> raises
the same error.</p>
</div>
<div class="xpath">
<div class="div2">
<h3><a name="id-for-expressions" id="id-for-expressions"></a>3.7
For Expressions</h3>
<p>XPath provides an iteration facility called a <b>for
expression</b>.</p>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-ForExpr" id=
"doc-xpath-ForExpr"></a>[4]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ForExpr" class=
"xpath">ForExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-SimpleForClause">SimpleForClause</a>
"return" <a href="#doc-xpath-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-SimpleForClause" id=
"doc-xpath-SimpleForClause"></a>[5]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-SimpleForClause" class=
"xpath">SimpleForClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"for" "$" <a href="#doc-xpath-VarName">VarName</a> "in"
<a href="#doc-xpath-ExprSingle">ExprSingle</a> ("," "$" <a href=
"#doc-xpath-VarName">VarName</a> "in" <a href=
"#doc-xpath-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
</table>
<p>A <code>for</code> expression is evaluated as follows:</p>
<ol class="enumar">
<li>
<p>If the <code>for</code> expression uses multiple variables, it
is first expanded to a set of nested <code>for</code> expressions,
each of which uses only one variable. For example, the expression
<code>for $x in X, $y in Y return $x + $y</code> is expanded to
<code>for $x in X return for $y in Y return $x + $y</code>.</p>
</li>
<li>
<p>In a single-variable <code>for</code> expression, the variable
is called the <b>range variable</b>, the value of the expression
that follows the <code>in</code> keyword is called the <b>binding
sequence</b>, and the expression that follows the
<code>return</code> keyword is called the <b>return expression</b>.
The result of the <code>for</code> expression is obtained by
evaluating the <code>return</code> expression once for each item in
the binding sequence, with the range variable bound to that item.
The resulting sequences are concatenated (as if by the <a title=
"comma operator" href="#dt-comma-operator">comma operator</a>) in
the order of the items in the binding sequence from which they were
derived.</p>
</li>
</ol>
<div class="xpath">
<p class="xpath">The following example illustrates the use of a
<code>for</code> expression in restructuring an input document. The
example is based on the following input:</p>
</div>
<div class="exampleInner">
<pre>
&lt;bib&gt;
  &lt;book&gt;
    &lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Advanced Programming in the Unix Environment&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Data on the Web&lt;/title&gt;
    &lt;author&gt;Abiteboul&lt;/author&gt;
    &lt;author&gt;Buneman&lt;/author&gt;
    &lt;author&gt;Suciu&lt;/author&gt;
  &lt;/book&gt;
&lt;/bib&gt;
</pre></div>
<p>The following example transforms the input document into a list
in which each author's name appears only once, followed by a list
of titles of books written by that author. This example assumes
that the context item is the <code>bib</code> element in the input
document.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
<span class="parse-test"><span class=
"parse-test">for $a in fn:distinct-values(book/author)
return (book/author[. = $a][1], book[author = $a]/title)</span></span>
</pre></div>
</div>
<p>The result of the above expression consists of the following
sequence of elements. The titles of books written by a given author
are listed after the name of the author. The ordering of
<code>author</code> elements in the result is <a title=
"implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> due to
the semantics of the <code>fn:distinct-values</code> function.</p>
<div class="exampleInner">
<pre>
&lt;author&gt;Stevens&lt;/author&gt; 
&lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
&lt;title&gt;Advanced Programming in the Unix environment&lt;/title&gt;
&lt;author&gt;Abiteboul&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
&lt;author&gt;Buneman&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
&lt;author&gt;Suciu&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
</pre></div>
<p>The following example illustrates a <code>for</code> expression
containing more than one variable:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
<span class="parse-test"><span class=
"parse-test">for $i in (10, 20),
    $j in (1, 2)
return ($i + $j)</span></span>
</pre></div>
</div>
<p>The result of the above expression, expressed as a sequence of
numbers, is as follows: <code>11, 12, 21, 22</code></p>
<p>The scope of a variable bound in a <code>for</code> expression
comprises all subexpressions of the <code>for</code> expression
that appear after the variable binding. The scope does not include
the expression to which the variable is bound. The following
example illustrates how a variable binding may reference another
variable bound earlier in the same <code>for</code> expression:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
<span class="parse-test"><span class=
"parse-test">for $x in $z, $y in f($x)
return g($x, $y)</span></span>
</pre></div>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The focus for evaluation of the <code>return</code> clause of a
<code>for</code> expression is the same as the focus for evaluation
of the <code>for</code> expression itself. The following example,
which attempts to find the total value of a set of order-items, is
therefore incorrect:</p>
<div class="error">
<div class="exampleInner">
<pre>
fn:sum(for $i in order-item return @price *
@qty)
</pre></div>
</div>
<p>Instead, the expression must be written to use the variable
bound in the <code>for</code> clause:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
fn:sum(for $i in order-item
    return $i/@price * $i/@qty)
</pre></div>
</div>
</div>
</div>
</div>
<div class="div2">
<h3><a name="id-conditionals" id="id-conditionals"></a>3.8
Conditional Expressions</h3>
<p>XPath supports a conditional expression based on the keywords
<code>if</code>, <code>then</code>, and <code>else</code>.</p>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-IfExpr" id=
"doc-xpath-IfExpr"></a>[7]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-IfExpr">IfExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"if" "(" <a href="#doc-xpath-Expr">Expr</a> ")" "then"
<a href="#doc-xpath-ExprSingle">ExprSingle</a> "else" <a href=
"#doc-xpath-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
</table>
<p>The expression following the <code>if</code> keyword is called
the <b>test expression</b>, and the expressions following the
<code>then</code> and <code>else</code> keywords are called the
<b>then-expression</b> and <b>else-expression</b>,
respectively.</p>
<p>The first step in processing a conditional expression is to find
the <a title="effective boolean value" href="#dt-ebv">effective
boolean value</a> of the test expression, as defined in <a href=
"#id-ebv"><b>2.4.3 Effective Boolean Value</b></a>.</p>
<p>The value of a conditional expression is defined as follows: If
the effective boolean value of the test expression is
<code>true</code>, the value of the then-expression is returned. If
the effective boolean value of the test expression is
<code>false</code>, the value of the else-expression is
returned.</p>
<p>Conditional expressions have a special rule for propagating
<a title="dynamic error" href="#dt-dynamic-error">dynamic
errors</a>. If the effective value of the test expression is
<code>true</code>, the conditional expression ignores (does not
raise) any dynamic errors encountered in the else-expression. In
this case, since the else-expression can have no observable effect,
it need not be evaluated. Similarly, if the effective value of the
test expression is <code>false</code>, the conditional expression
ignores any <a title="dynamic error" href=
"#dt-dynamic-error">dynamic errors</a> encountered in the
then-expression, and the then-expression need not be evaluated.</p>
<p>Here are some examples of conditional expressions:</p>
<ul>
<li>
<p>In this example, the test expression is a comparison
expression:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
if ($widget1/unit-cost &lt; $widget2/unit-cost) 
  then $widget1
  else $widget2
</pre></div>
</div>
</li>
<li>
<p>In this example, the test expression tests for the existence of
an attribute named <code>discounted</code>, independently of its
value:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
if ($part/@discounted) 
  then $part/wholesale 
  else $part/retail
</pre></div>
</div>
</li>
</ul>
</div>
<div class="div2">
<h3><a name="id-quantified-expressions" id=
"id-quantified-expressions"></a>3.9 Quantified Expressions</h3>
<p>Quantified expressions support existential and universal
quantification. The value of a quantified expression is always
<code>true</code> or <code>false</code>.</p>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-QuantifiedExpr" id=
"doc-xpath-QuantifiedExpr"></a>[6]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-QuantifiedExpr">QuantifiedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("some" | "every") "$" <a href=
"#doc-xpath-VarName">VarName</a> "in" <a href=
"#doc-xpath-ExprSingle">ExprSingle</a> ("," "$" <a href=
"#doc-xpath-VarName">VarName</a> "in" <a href=
"#doc-xpath-ExprSingle">ExprSingle</a>)* "satisfies" <a href=
"#doc-xpath-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
</table>
<p>A <b>quantified expression</b> begins with a <b>quantifier</b>,
which is the keyword <code>some</code> or <code>every</code>,
followed by one or more in-clauses that are used to bind variables,
followed by the keyword <code>satisfies</code> and a test
expression. Each in-clause associates a variable with an expression
that returns a sequence of items, called the <b>binding
sequence</b> for that variable. The in-clauses generate tuples of
variable bindings, including a tuple for each combination of items
in the binding sequences of the respective variables. Conceptually,
the test expression is evaluated for each tuple of variable
bindings. Results depend on the <a title="effective boolean value"
href="#dt-ebv">effective boolean value</a> of the test expressions,
as defined in <a href="#id-ebv"><b>2.4.3 Effective Boolean
Value</b></a>. The value of the quantified expression is defined by
the following rules:</p>
<ol class="enumar">
<li>
<p>If the quantifier is <code>some</code>, the quantified
expression is <code>true</code> if at least one evaluation of the
test expression has the <a title="effective boolean value" href=
"#dt-ebv">effective boolean value</a> <code>true</code>; otherwise
the quantified expression is <code>false</code>. This rule implies
that, if the in-clauses generate zero binding tuples, the value of
the quantified expression is <code>false</code>.</p>
</li>
<li>
<p>If the quantifier is <code>every</code>, the quantified
expression is <code>true</code> if every evaluation of the test
expression has the <a title="effective boolean value" href=
"#dt-ebv">effective boolean value</a> <code>true</code>; otherwise
the quantified expression is <code>false</code>. This rule implies
that, if the in-clauses generate zero binding tuples, the value of
the quantified expression is <code>true</code>.</p>
</li>
</ol>
<p>The scope of a variable bound in a quantified expression
comprises all subexpressions of the quantified expression that
appear after the variable binding. The scope does not include the
expression to which the variable is bound.</p>
<p>The order in which test expressions are evaluated for the
various binding tuples is <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>. If the
quantifier is <code>some</code>, an implementation may return
<code>true</code> as soon as it finds one binding tuple for which
the test expression has an <a title="effective boolean value" href=
"#dt-ebv">effective boolean value</a> of <code>true</code>, and it
may raise a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> as soon as it finds one
binding tuple for which the test expression raises an error.
Similarly, if the quantifier is <code>every</code>, an
implementation may return <code>false</code> as soon as it finds
one binding tuple for which the test expression has an <a title=
"effective boolean value" href="#dt-ebv">effective boolean
value</a> of <code>false</code>, and it may raise a <a title=
"dynamic error" href="#dt-dynamic-error">dynamic error</a> as soon
as it finds one binding tuple for which the test expression raises
an error. As a result of these rules, the value of a quantified
expression is not deterministic in the presence of errors, as
illustrated in the examples below.</p>
<p>Here are some examples of quantified expressions:</p>
<ul>
<li>
<p>This expression is <code>true</code> if every <code>part</code>
element has a <code>discounted</code> attribute (regardless of the
values of these attributes):</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
every $part in /parts/part satisfies $part/@discounted
</pre></div>
</div>
</li>
<li>
<p>This expression is <code>true</code> if at least one
<code>employee</code> element satisfies the given comparison
expression:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
some $emp in /emps/employee satisfies 
     ($emp/bonus &gt; 0.25 * $emp/salary)
</pre></div>
</div>
</li>
<li>
<p>In the following examples, each quantified expression evaluates
its test expression over nine tuples of variable bindings, formed
from the Cartesian product of the sequences <code>(1, 2, 3)</code>
and <code>(2, 3, 4)</code>. The expression beginning with
<code>some</code> evaluates to <code>true</code>, and the
expression beginning with <code>every</code> evaluates to
<code>false</code>.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
<span class="parse-test"><span class=
"parse-test">some $x in (1, 2, 3), $y in (2, 3, 4) 
     satisfies $x + $y = 4</span></span>
</pre></div>
</div>
<div class="parse-test">
<div class="exampleInner">
<pre>
<span class="parse-test"><span class=
"parse-test">every $x in (1, 2, 3), $y in (2, 3, 4) 
     satisfies $x + $y = 4</span></span>
</pre></div>
</div>
</li>
<li>
<p>This quantified expression may either return <code>true</code>
or raise a <a title="type error" href="#dt-type-error">type
error</a>, since its test expression returns <code>true</code> for
one variable binding and raises a <a title="type error" href=
"#dt-type-error">type error</a> for another:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
some $x in (1, 2, "cat") satisfies $x * 2 = 4
</pre></div>
</div>
</li>
<li>
<p>This quantified expression may either return <code>false</code>
or raise a <a title="type error" href="#dt-type-error">type
error</a>, since its test expression returns <code>false</code> for
one variable binding and raises a <a title="type error" href=
"#dt-type-error">type error</a> for another:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
every $x in (1, 2, "cat") satisfies $x * 2 = 4
</pre></div>
</div>
</li>
</ul>
</div>
<div class="div2">
<h3><a name="id-expressions-on-datatypes" id=
"id-expressions-on-datatypes"></a>3.10 Expressions on
SequenceTypes</h3>
<p><a title="sequence type" href="#dt-sequence-type">sequence
types</a> are used in <code>instance of</code>, <code>cast</code>,
<code>castable</code>, and <code>treat</code> expressions.</p>
<div class="div3">
<h4><a name="id-instance-of" id="id-instance-of"></a>3.10.1
Instance Of</h4>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-InstanceofExpr" id=
"doc-xpath-InstanceofExpr"></a>[16]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-InstanceofExpr">InstanceofExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-TreatExpr">TreatExpr</a> ( "instance"
"of" <a href="#doc-xpath-SequenceType">SequenceType</a>
)?</code></td>
</tr>
</tbody>
</table>
<p>The boolean operator <code>instance of</code> returns
<code>true</code> if the value of its first operand matches the
<a href="#doc-xpath-SequenceType">SequenceType</a> in its second
operand, according to the rules for <a title=
"SequenceType matching" href=
"#dt-sequencetype-matching">SequenceType matching</a>; otherwise it
returns <code>false</code>. For example:</p>
<ul>
<li>
<p><code>5 instance of xs:integer</code></p>
<p>This example returns <code>true</code> because the given value
is an instance of the given type.</p>
</li>
<li>
<p><code>5 instance of xs:decimal</code></p>
<p>This example returns <code>true</code> because the given value
is an integer literal, and <code>xs:integer</code> is derived by
restriction from <code>xs:decimal</code>.</p>
</li>
<li>
<p><code>(5, 6) instance of xs:integer+</code></p>
<p>This example returns <code>true</code> because the given
sequence contains two integers, and is a valid instance of the
specified type.</p>
</li>
<li>
<p><code>. instance of element()</code></p>
<p>This example returns <code>true</code> if the context item is an
element node or <code>false</code> if the context item is defined
but is not an element node. If the context item is <a title=
"undefined" href="#dt-undefined">undefined</a>, a <a title=
"dynamic error" href="#dt-dynamic-error">dynamic error</a> is
raised [<a href="#ERRXPDY0002" title=
"err:XPDY0002">err:XPDY0002</a>].</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="id-cast" id="id-cast"></a>3.10.2 Cast</h4>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-CastExpr" id=
"doc-xpath-CastExpr"></a>[19]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-CastExpr">CastExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-UnaryExpr">UnaryExpr</a> ( "cast"
"as" <a href="#doc-xpath-SingleType">SingleType</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-SingleType" id=
"doc-xpath-SingleType"></a>[49]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-SingleType">SingleType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AtomicType">AtomicType</a>
"?"?</code></td>
</tr>
</tbody>
</table>
<p>Occasionally it is necessary to convert a value to a specific
datatype. For this purpose, XPath provides a <code>cast</code>
expression that creates a new value of a specific type based on an
existing value. A <code>cast</code> expression takes two operands:
an <b>input expression</b> and a <b>target type</b>. The type of
the input expression is called the <b>input type</b>. The target
type must be an atomic type that is in the <a title=
"in-scope schema type" href="#dt-is-types">in-scope schema
types</a> [<a href="#ERRXPST0051" title=
"err:XPST0051">err:XPST0051</a>]. In addition, the target type
cannot be <code>xs:NOTATION</code> or <code>xs:anyAtomicType</code>
[<a href="#ERRXPST0080" title="err:XPST0080">err:XPST0080</a>]. The
optional occurrence indicator "<code>?</code>" denotes that an
empty sequence is permitted. If the target type has no namespace
prefix, it is considered to be in the <a title=
"default element/type namespace" href="#dt-def-elemtype-ns">default
element/type namespace</a>. The semantics of the <code>cast</code>
expression are as follows:</p>
<ol class="enumar">
<li>
<p><a title="atomization" href="#dt-atomization">Atomization</a> is
performed on the input expression.</p>
</li>
<li>
<p>If the result of atomization is a sequence of more than one
atomic value, a <a title="type error" href="#dt-type-error">type
error</a> is raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>].</p>
</li>
<li>
<p>If the result of atomization is an empty sequence:</p>
<ol class="enumla">
<li>
<p>If <code>?</code> is specified after the target type, the result
of the <code>cast</code> expression is an empty sequence.</p>
</li>
<li>
<p>If <code>?</code> is not specified after the target type, a
<a title="type error" href="#dt-type-error">type error</a> is
raised [<a href="#ERRXPTY0004" title=
"err:XPTY0004">err:XPTY0004</a>].</p>
</li>
</ol>
</li>
<li>
<p>If the result of atomization is a single atomic value, the
result of the cast expression depends on the input type and the
target type. In general, the cast expression attempts to create a
new value of the target type based on the input value. Only certain
combinations of input type and target type are supported. A summary
of the rules are listed below— the normative definition of these
rules is given in <a href="#FunctionsAndOperators">[XQuery 1.0 and
XPath 2.0 Functions and Operators (Second Edition)]</a>. For the
purpose of these rules, an implementation may determine that one
type is derived by restriction from another type either by
examining the <a title="in-scope schema definitions" href=
"#dt-issd">in-scope schema definitions</a> or by using an
alternative, <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>
mechanism such as a data dictionary.</p>
<ol class="enumla">
<li>
<p><code>cast</code> is supported for the combinations of input
type and target type listed in <a href=
"http://www.w3.org/TR/xpath-functions/#casting-from-primitive-to-primitive">
Section 17.1 Casting from primitive types to primitive
types</a><sup><small>FO</small></sup>. For each of these
combinations, both the input type and the target type are primitive
<a title="schema type" href="#dt-schema-type">schema types</a>. For
example, a value of type <code>xs:string</code> can be cast into
the schema type <code>xs:decimal</code>. For each of these built-in
combinations, the semantics of casting are specified in <a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators (Second Edition)]</a>.</p>
<p>If the target type of a <code>cast</code> expression is
<code>xs:QName</code>, or is a type that is derived from
<code>xs:QName</code> or <code>xs:NOTATION</code>, and if the base
type of the input is not the same as the base type of the target
type, then the input expression must be a string literal [<a href=
"#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The reason for this rule is that construction of an instance of
one of these target types from a string requires knowledge about
namespace bindings. If the input expression is a non-literal
string, it might be derived from an input document whose namespace
bindings are different from the <a title=
"statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>.</p>
</div>
</li>
<li>
<p><code>cast</code> is supported if the input type is a
non-primitive atomic type that is derived by restriction from the
target type. In this case, the input value is mapped into the value
space of the target type, unchanged except for its type. For
example, if <code>shoesize</code> is derived by restriction from
<code>xs:integer</code>, a value of type <code>shoesize</code> can
be cast into the schema type <code>xs:integer</code>.</p>
</li>
<li>
<p><code>cast</code> is supported if the target type is a
non-primitive atomic type and the input type is
<code>xs:string</code> or <code>xs:untypedAtomic</code>. The input
value is first converted to a value in the lexical space of the
target type by applying the whitespace normalization rules for the
target type (as defined in <a href="#XMLSchema">[XML Schema]</a>).
The lexical value is then converted to the value space of the
target type using the schema-defined rules for the target type. If
the input value fails to satisfy some facet of the target type, a
<a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
may be raised as specified in <a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators (Second Edition)]</a>.</p>
</li>
<li>
<p><code>cast</code> is supported if the target type is a
non-primitive atomic type that is derived by restriction from the
input type. The input value must satisfy all the facets of the
target type (in the case of the pattern facet, this is checked by
generating a string representation of the input value, using the
rules for casting to <code>xs:string</code>). The resulting value
is the same as the input value, but with a different <a title=
"dynamic type" href="#dt-dynamic-type">dynamic type</a>.</p>
</li>
<li>
<p>If a primitive type P1 can be cast into a primitive type P2,
then any type derived by restriction from P1 can be cast into any
type derived by restriction from P2, provided that the facets of
the target type are satisfied. First the input value is cast to P1
using rule (b) above. Next, the value of type P1 is cast to the
type P2, using rule (a) above. Finally, the value of type P2 is
cast to the target type, using rule (d) above.</p>
</li>
<li>
<p>For any combination of input type and target type that is not in
the above list, a <code>cast</code> expression raises a <a title=
"type error" href="#dt-type-error">type error</a> [<a href=
"#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p>
</li>
</ol>
</li>
</ol>
<p>If casting from the input type to the target type is supported
but nevertheless it is not possible to cast the input value into
the value space of the target type, a <a title="dynamic error"
href="#dt-dynamic-error">dynamic error</a> is raised.
[err:FORG0001] This includes the case when any facet of the target
type is not satisfied. For example, the expression
<code>"2003-02-31" cast as xs:date</code> would raise a <a title=
"dynamic error" href="#dt-dynamic-error">dynamic error</a>.</p>
</div>
<div class="div3">
<h4><a name="id-castable" id="id-castable"></a>3.10.3 Castable</h4>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-CastableExpr" id=
"doc-xpath-CastableExpr"></a>[18]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-CastableExpr">CastableExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-CastExpr">CastExpr</a> ( "castable"
"as" <a href="#doc-xpath-SingleType">SingleType</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="noid_d2e15164.doc-xpath-SingleType" id=
"noid_d2e15164.doc-xpath-SingleType"></a>[49]&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-SingleType">SingleType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AtomicType">AtomicType</a>
"?"?</code></td>
</tr>
</tbody>
</table>
<p>XPath provides an expression that tests whether a given value is
castable into a given target type. The target type must be an
atomic type that is in the <a title="in-scope schema type" href=
"#dt-is-types">in-scope schema types</a> [<a href="#ERRXPST0051"
title="err:XPST0051">err:XPST0051</a>]. In addition, the target
type cannot be <code>xs:NOTATION</code> or
<code>xs:anyAtomicType</code> [<a href="#ERRXPST0080" title=
"err:XPST0080">err:XPST0080</a>]. The optional occurrence indicator
"<code>?</code>" denotes that an empty sequence is permitted.</p>
<p>The expression <code>E castable as T</code> returns
<code>true</code> if the result of evaluating <code>E</code> can be
successfully cast into the target type <code>T</code> by using a
<code>cast</code> expression; otherwise it returns
<code>false</code>. If evaluation of <code>E</code> fails with a
dynamic error, the <code>castable</code> expression as a whole
fails. The <code>castable</code> expression can be used as a
<a title="predicate" href="#dt-predicate">predicate</a> to avoid
errors at evaluation time. It can also be used to select an
appropriate type for processing of a given value, as illustrated in
the following example:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
if ($x castable as hatsize) 
   then $x cast as hatsize 
   else if ($x castable as IQ) 
   then $x cast as IQ 
   else $x cast as xs:string
</pre></div>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If the target type of a <code>castable</code> expression is
<code>xs:QName</code>, or is a type that is derived from
<code>xs:QName</code> or <code>xs:NOTATION</code>, and the input
argument of the expression is of type <code>xs:string</code> but it
is not a literal string, the result of the <code>castable</code>
expression is <code>false</code>.</p>
</div>
</div>
<div class="div3">
<h4><a name="id-constructor-functions" id=
"id-constructor-functions"></a>3.10.4 Constructor Functions</h4>
<p>For every atomic type in the <a title="in-scope schema type"
href="#dt-is-types">in-scope schema types</a> (except
<code>xs:NOTATION</code> and <code>xs:anyAtomicType</code>, which
are not instantiable), a <b>constructor function</b> is implicitly
defined. In each case, the name of the constructor function is the
same as the name of its target type (including namespace). The
signature of the constructor function for type <em>T</em> is as
follows:</p>
<div class="exampleInner">
<pre>
<em>T</em>($arg as xs:anyAtomicType?) as <em>T?</em>
</pre></div>
<p>[<a name="dt-constructor-function" id="dt-constructor-function"
title="constructor function">Definition</a>: The <b>constructor
function</b> for a given type is used to convert instances of other
atomic types into the given type. The semantics of the constructor
function call <code>T($arg)</code> are defined to be equivalent to
the expression <code>(($arg) cast as T?)</code>.]</p>
<p>The constructor functions for <code>xs:QName</code> and for
types derived from <code>xs:QName</code> and
<code>xs:NOTATION</code> require their arguments to be string
literals or to have a base type that is the same as the base type
of the target type; otherwise a type error [<a href="#ERRXPTY0004"
title="err:XPTY0004">err:XPTY0004</a>] is raised. This rule is
consistent with the semantics of <code>cast</code> expressions for
these types, as defined in <a href="#id-cast"><b>3.10.2
Cast</b></a>.</p>
<p>The following examples illustrate the use of constructor
functions:</p>
<ul>
<li>
<p>This example is equivalent to <code>("2000-01-01" cast as
xs:date?)</code>.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
xs:date("2000-01-01")
</pre></div>
</div>
</li>
<li>
<p>This example is equivalent to <code>(($floatvalue * 0.2E-5) cast
as xs:decimal?)</code>.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
xs:decimal($floatvalue * 0.2E-5)
</pre></div>
</div>
</li>
<li>
<p>This example returns a <code>xs:dayTimeDuration</code> value
equal to 21 days. It is equivalent to <code>("P21D" cast as
xs:dayTimeDuration?)</code>.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
xs:dayTimeDuration("P21D")
</pre></div>
</div>
</li>
<li>
<p>If <code>usa:zipcode</code> is a user-defined atomic type in the
<a title="in-scope schema type" href="#dt-is-types">in-scope schema
types</a>, then the following expression is equivalent to the
expression <code>("12345" cast as usa:zipcode?)</code>.</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
usa:zipcode("12345")
</pre></div>
</div>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>An instance of an atomic type that is not in a namespace can be
constructed in either of the following ways:</p>
<ul>
<li>
<p>By using a <code>cast</code> expression, if the <a title=
"default element/type namespace" href="#dt-def-elemtype-ns">default
element/type namespace</a> is "none".</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
17 cast as apple
</pre></div>
</div>
</li>
<li>
<p>By using a constructor function, if the <a title=
"default function namespace" href="#dt-def-fn-ns">default function
namespace</a> is "none".</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
apple(17)
</pre></div>
</div>
</li>
</ul>
</div>
</div>
<div class="div3">
<h4><a name="id-treat" id="id-treat"></a>3.10.5 Treat</h4>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xpath-TreatExpr" id=
"doc-xpath-TreatExpr"></a>[17]&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-TreatExpr">TreatExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-CastableExpr">CastableExpr</a> (
"treat" "as" <a href="#doc-xpath-SequenceType">SequenceType</a>
)?</code></td>
</tr>
</tbody>
</table>
<p>XPath provides an expression called <code>treat</code> that can
be used to modify the <a title="static type" href=
"#dt-static-type">static type</a> of its operand.</p>
<p>Like <code>cast</code>, the <code>treat</code> expression takes
two operands: an expression and a <a href=
"#doc-xpath-SequenceType">SequenceType</a>. Unlike
<code>cast</code>, however, <code>treat</code> does not change the
<a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> or
value of its operand. Instead, the purpose of <code>treat</code> is
to ensure that an expression has an expected dynamic type at
evaluation time.</p>
<p>The semantics of <em><code>expr1</code></em> <code>treat
as</code> <em><code>type1</code></em> are as follows:</p>
<ul>
<li>
<p>During static analysis:</p>
<p>The <a title="static type" href="#dt-static-type">static
type</a> of the <code>treat</code> expression is
<em><code>type1</code></em>. This enables the expression to be used
as an argument of a function that requires a parameter of
<em><code>type1</code></em>.</p>
</li>
<li>
<p>During expression evaluation:</p>
<p>If <em><code>expr1</code></em> matches
<em><code>type1</code></em>, using the rules for <a title=
"SequenceType matching" href=
"#dt-sequencetype-matching">SequenceType matching</a>, the
<code>treat</code> expression returns the value of
<em><code>expr1</code></em>; otherwise, it raises a <a title=
"dynamic error" href="#dt-dynamic-error">dynamic error</a>
[<a href="#ERRXPDY0050" title="err:XPDY0050">err:XPDY0050</a>]. If
the value of <em><code>expr1</code></em> is returned, its identity
is preserved. The <code>treat</code> expression ensures that the
value of its expression operand conforms to the expected type at
run-time.</p>
</li>
<li>
<p>Example:</p>
<div class="parse-test">
<div class="exampleInner">
<pre>
$myaddress treat as element(*, USAddress)
</pre></div>
</div>
<p>The <a title="static type" href="#dt-static-type">static
type</a> of <code>$myaddress</code> may be <code>element(*,
Address)</code>, a less specific type than <code>element(*,
USAddress)</code>. However, at run-time, the value of
<code>$myaddress</code> must match the type <code>element(*,
USAddress)</code> using rules for <a title="SequenceType matching"
href="#dt-sequencetype-matching">SequenceType matching</a>;
otherwise a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> is raised [<a href=
"#ERRXPDY0050" title="err:XPDY0050">err:XPDY0050</a>].</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="back">
<div class="div1">
<h2><a name="nt-bnf" id="nt-bnf"></a>A XPath Grammar</h2>
<div class="div2">
<h3><a name="id-grammar" id="id-grammar"></a>A.1 EBNF</h3>
<p>The grammar of XPath uses the same simple Extended Backus-Naur
Form (EBNF) notation as <a href="#XML">[XML 1.0]</a> with the
following minor differences.</p>
<ul>
<li>
<p>All named symbols have a name that begins with an uppercase
letter.</p>
</li>
<li>
<p>It adds a notation for referring to productions in external
specs.</p>
</li>
<li>
<p>Comments or extra-grammatical constraints on grammar productions
are between '/*' and '*/' symbols.</p>
<ul>
<li>
<p>A 'xgc:' prefix is an extra-grammatical constraint, the details
of which are explained in <a href=
"#extra-grammatical-constraints"><b>A.1.2 Extra-grammatical
Constraints</b></a></p>
</li>
<li>
<p>A 'ws:' prefix explains the whitespace rules for the production,
the details of which are explained in <a href=
"#whitespace-rules"><b>A.2.4 Whitespace Rules</b></a></p>
</li>
<li>
<p>A 'gn:' prefix means a 'Grammar Note', and is meant as a
clarification for parsing rules, and is explained in <a href=
"#notes-on-parsing"><b>A.1.3 Grammar Notes</b></a>. These notes are
not normative.</p>
</li>
</ul>
</li>
</ul>
<p>The terminal symbols for this grammar include the quoted strings
used in the production rules below, and the terminal symbols
defined in section <a href="#terminal-symbols"><b>A.2.1 Terminal
Symbols</b></a>.</p>
<p>The EBNF notation is described in more detail in <a href=
"#EBNFNotation"><b>A.1.1 Notation</b></a>.</p>
<p>To increase readability, the EBNF in the main body of this
document omits some of these notational features. This appendix is
the normative version of the EBNF.</p>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-XPath" id=
"prod-xpath-XPath"></a>[1]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-XPath">XPath</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-Expr">Expr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-Expr" id=
"prod-xpath-Expr"></a>[2]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-Expr">Expr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ExprSingle">ExprSingle</a> (","
<a href="#prod-xpath-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-ExprSingle" id=
"prod-xpath-ExprSingle"></a>[3]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-ExprSingle">ExprSingle</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ForExpr">ForExpr</a><br />
| <a href="#prod-xpath-QuantifiedExpr">QuantifiedExpr</a><br />
| <a href="#prod-xpath-IfExpr">IfExpr</a><br />
| <a href="#prod-xpath-OrExpr">OrExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-ForExpr" id=
"prod-xpath-ForExpr"></a>[4]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ForExpr">ForExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-SimpleForClause">SimpleForClause</a>
"return" <a href=
"#prod-xpath-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-SimpleForClause" id=
"prod-xpath-SimpleForClause"></a>[5]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-SimpleForClause">SimpleForClause</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"for" "$" <a href="#prod-xpath-VarName">VarName</a> "in"
<a href="#prod-xpath-ExprSingle">ExprSingle</a> ("," "$" <a href=
"#prod-xpath-VarName">VarName</a> "in" <a href=
"#prod-xpath-ExprSingle">ExprSingle</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-QuantifiedExpr" id=
"prod-xpath-QuantifiedExpr"></a>[6]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-QuantifiedExpr">QuantifiedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("some" | "every") "$" <a href=
"#prod-xpath-VarName">VarName</a> "in" <a href=
"#prod-xpath-ExprSingle">ExprSingle</a> ("," "$" <a href=
"#prod-xpath-VarName">VarName</a> "in" <a href=
"#prod-xpath-ExprSingle">ExprSingle</a>)* "satisfies" <a href=
"#prod-xpath-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-IfExpr" id=
"prod-xpath-IfExpr"></a>[7]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-IfExpr">IfExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"if" "(" <a href="#prod-xpath-Expr">Expr</a> ")" "then"
<a href="#prod-xpath-ExprSingle">ExprSingle</a> "else" <a href=
"#prod-xpath-ExprSingle">ExprSingle</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-OrExpr" id=
"prod-xpath-OrExpr"></a>[8]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-OrExpr">OrExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AndExpr">AndExpr</a> ( "or" <a href=
"#prod-xpath-AndExpr">AndExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-AndExpr" id=
"prod-xpath-AndExpr"></a>[9]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AndExpr">AndExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ComparisonExpr">ComparisonExpr</a> (
"and" <a href="#prod-xpath-ComparisonExpr">ComparisonExpr</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-ComparisonExpr" id=
"prod-xpath-ComparisonExpr"></a>[10]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-ComparisonExpr">ComparisonExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-RangeExpr">RangeExpr</a> ( (<a href=
"#prod-xpath-ValueComp">ValueComp</a><br />
| <a href="#prod-xpath-GeneralComp">GeneralComp</a><br />
| <a href="#prod-xpath-NodeComp">NodeComp</a>) <a href=
"#prod-xpath-RangeExpr">RangeExpr</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-RangeExpr" id=
"prod-xpath-RangeExpr"></a>[11]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-RangeExpr">RangeExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AdditiveExpr">AdditiveExpr</a> (
"to" <a href="#prod-xpath-AdditiveExpr">AdditiveExpr</a>
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-AdditiveExpr" id=
"prod-xpath-AdditiveExpr"></a>[12]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-AdditiveExpr">AdditiveExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-MultiplicativeExpr">MultiplicativeExpr</a> ( ("+" |
"-") <a href=
"#prod-xpath-MultiplicativeExpr">MultiplicativeExpr</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-MultiplicativeExpr" id=
"prod-xpath-MultiplicativeExpr"></a>[13]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-MultiplicativeExpr">MultiplicativeExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-UnionExpr">UnionExpr</a> ( ("*" |
"div" | "idiv" | "mod") <a href=
"#prod-xpath-UnionExpr">UnionExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-UnionExpr" id=
"prod-xpath-UnionExpr"></a>[14]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-UnionExpr">UnionExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-IntersectExceptExpr">IntersectExceptExpr</a> (
("union" | "|") <a href=
"#prod-xpath-IntersectExceptExpr">IntersectExceptExpr</a>
)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-IntersectExceptExpr" id=
"prod-xpath-IntersectExceptExpr"></a>[15]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-IntersectExceptExpr">IntersectExceptExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-InstanceofExpr">InstanceofExpr</a> (
("intersect" | "except") <a href=
"#prod-xpath-InstanceofExpr">InstanceofExpr</a> )*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-InstanceofExpr" id=
"prod-xpath-InstanceofExpr"></a>[16]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-InstanceofExpr">InstanceofExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-TreatExpr">TreatExpr</a> (
"instance" "of" <a href="#prod-xpath-SequenceType">SequenceType</a>
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-TreatExpr" id=
"prod-xpath-TreatExpr"></a>[17]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-TreatExpr">TreatExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-CastableExpr">CastableExpr</a> (
"treat" "as" <a href="#prod-xpath-SequenceType">SequenceType</a>
)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-CastableExpr" id=
"prod-xpath-CastableExpr"></a>[18]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-CastableExpr">CastableExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-CastExpr">CastExpr</a> ( "castable"
"as" <a href="#prod-xpath-SingleType">SingleType</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-CastExpr" id=
"prod-xpath-CastExpr"></a>[19]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-CastExpr">CastExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-UnaryExpr">UnaryExpr</a> ( "cast"
"as" <a href="#prod-xpath-SingleType">SingleType</a> )?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-UnaryExpr" id=
"prod-xpath-UnaryExpr"></a>[20]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-UnaryExpr">UnaryExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("-" | "+")* <a href=
"#prod-xpath-ValueExpr">ValueExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-ValueExpr" id=
"prod-xpath-ValueExpr"></a>[21]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ValueExpr">ValueExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-PathExpr">PathExpr</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-GeneralComp" id=
"prod-xpath-GeneralComp"></a>[22]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-GeneralComp">GeneralComp</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"=" | "!=" | "&lt;" | "&lt;=" | "&gt;" |
"&gt;="</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-ValueComp" id=
"prod-xpath-ValueComp"></a>[23]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ValueComp">ValueComp</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"eq" | "ne" | "lt" | "le" | "gt" | "ge"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-NodeComp" id=
"prod-xpath-NodeComp"></a>[24]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-NodeComp">NodeComp</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"is" | "&lt;&lt;" | "&gt;&gt;"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-PathExpr" id=
"prod-xpath-PathExpr"></a>[25]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-PathExpr">PathExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("/" <a href=
"#prod-xpath-RelativePathExpr">RelativePathExpr</a>?)<br />
| ("//" <a href=
"#prod-xpath-RelativePathExpr">RelativePathExpr</a>)<br />
| <a href=
"#prod-xpath-RelativePathExpr">RelativePathExpr</a></code></td>
<td><i>/* <a href="#parse-note-leading-lone-slash">xgs:
leading-lone-slash</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-RelativePathExpr" id=
"prod-xpath-RelativePathExpr"></a>[26]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-RelativePathExpr">RelativePathExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-StepExpr">StepExpr</a> (("/" | "//")
<a href="#prod-xpath-StepExpr">StepExpr</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-StepExpr" id=
"prod-xpath-StepExpr"></a>[27]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-StepExpr">StepExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-FilterExpr">FilterExpr</a> |
<a href="#prod-xpath-AxisStep">AxisStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-AxisStep" id=
"prod-xpath-AxisStep"></a>[28]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-AxisStep">AxisStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xpath-ReverseStep">ReverseStep</a> |
<a href="#prod-xpath-ForwardStep">ForwardStep</a>) <a href=
"#prod-xpath-PredicateList">PredicateList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-ForwardStep" id=
"prod-xpath-ForwardStep"></a>[29]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-ForwardStep">ForwardStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xpath-ForwardAxis">ForwardAxis</a>
<a href="#prod-xpath-NodeTest">NodeTest</a>) | <a href=
"#prod-xpath-AbbrevForwardStep">AbbrevForwardStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-ForwardAxis" id=
"prod-xpath-ForwardAxis"></a>[30]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-ForwardAxis">ForwardAxis</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("child" "::")<br />
| ("descendant" "::")<br />
| ("attribute" "::")<br />
| ("self" "::")<br />
| ("descendant-or-self" "::")<br />
| ("following-sibling" "::")<br />
| ("following" "::")<br />
| ("namespace" "::")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-AbbrevForwardStep" id=
"prod-xpath-AbbrevForwardStep"></a>[31]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-AbbrevForwardStep">AbbrevForwardStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"@"? <a href=
"#prod-xpath-NodeTest">NodeTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-ReverseStep" id=
"prod-xpath-ReverseStep"></a>[32]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-ReverseStep">ReverseStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xpath-ReverseAxis">ReverseAxis</a>
<a href="#prod-xpath-NodeTest">NodeTest</a>) | <a href=
"#prod-xpath-AbbrevReverseStep">AbbrevReverseStep</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-ReverseAxis" id=
"prod-xpath-ReverseAxis"></a>[33]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-ReverseAxis">ReverseAxis</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("parent" "::")<br />
| ("ancestor" "::")<br />
| ("preceding-sibling" "::")<br />
| ("preceding" "::")<br />
| ("ancestor-or-self" "::")</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-AbbrevReverseStep" id=
"prod-xpath-AbbrevReverseStep"></a>[34]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-AbbrevReverseStep">AbbrevReverseStep</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>".."</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-NodeTest" id=
"prod-xpath-NodeTest"></a>[35]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-NodeTest">NodeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-KindTest">KindTest</a> | <a href=
"#prod-xpath-NameTest">NameTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-NameTest" id=
"prod-xpath-NameTest"></a>[36]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-NameTest">NameTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a> | <a href=
"#prod-xpath-Wildcard">Wildcard</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-Wildcard" id=
"prod-xpath-Wildcard"></a>[37]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-Wildcard">Wildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"*"<br />
| (<a href="#prod-xpath-NCName">NCName</a> ":" "*")<br />
| ("*" ":" <a href="#prod-xpath-NCName">NCName</a>)</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-FilterExpr" id=
"prod-xpath-FilterExpr"></a>[38]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-FilterExpr">FilterExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-PrimaryExpr">PrimaryExpr</a>
<a href="#prod-xpath-PredicateList">PredicateList</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-PredicateList" id=
"prod-xpath-PredicateList"></a>[39]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-PredicateList">PredicateList</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-Predicate">Predicate</a>*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-Predicate" id=
"prod-xpath-Predicate"></a>[40]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-Predicate">Predicate</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"[" <a href="#prod-xpath-Expr">Expr</a> "]"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-PrimaryExpr" id=
"prod-xpath-PrimaryExpr"></a>[41]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-PrimaryExpr">PrimaryExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-Literal">Literal</a> | <a href=
"#prod-xpath-VarRef">VarRef</a> | <a href=
"#prod-xpath-ParenthesizedExpr">ParenthesizedExpr</a> | <a href=
"#prod-xpath-ContextItemExpr">ContextItemExpr</a> | <a href=
"#prod-xpath-FunctionCall">FunctionCall</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-Literal" id=
"prod-xpath-Literal"></a>[42]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-Literal">Literal</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-NumericLiteral">NumericLiteral</a> |
<a href="#prod-xpath-StringLiteral">StringLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-NumericLiteral" id=
"prod-xpath-NumericLiteral"></a>[43]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-NumericLiteral">NumericLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-IntegerLiteral">IntegerLiteral</a> |
<a href="#prod-xpath-DecimalLiteral">DecimalLiteral</a> | <a href=
"#prod-xpath-DoubleLiteral">DoubleLiteral</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-VarRef" id=
"prod-xpath-VarRef"></a>[44]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-VarRef">VarRef</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"$" <a href="#prod-xpath-VarName">VarName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-VarName" id=
"prod-xpath-VarName"></a>[45]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-VarName">VarName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-ParenthesizedExpr" id=
"prod-xpath-ParenthesizedExpr"></a>[46]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-ParenthesizedExpr">ParenthesizedExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" <a href="#prod-xpath-Expr">Expr</a>? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-ContextItemExpr" id=
"prod-xpath-ContextItemExpr"></a>[47]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-ContextItemExpr">ContextItemExpr</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"."</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-FunctionCall" id=
"prod-xpath-FunctionCall"></a>[48]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-FunctionCall">FunctionCall</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a> "(" (<a href=
"#prod-xpath-ExprSingle">ExprSingle</a> ("," <a href=
"#prod-xpath-ExprSingle">ExprSingle</a>)*)? ")"</code></td>
<td><i>/* <a href="#parse-note-reserved-function-names">xgs:
reserved-function-names</a> */</i></td>
</tr>
<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td></td>
<td><i>/* <a href="#parse-note-parens">gn: parens</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-SingleType" id=
"prod-xpath-SingleType"></a>[49]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-SingleType">SingleType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AtomicType">AtomicType</a>
"?"?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-SequenceType" id=
"prod-xpath-SequenceType"></a>[50]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-SequenceType">SequenceType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("empty-sequence" "(" ")")<br />
| (<a href="#prod-xpath-ItemType">ItemType</a> <a href=
"#prod-xpath-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-OccurrenceIndicator" id=
"prod-xpath-OccurrenceIndicator"></a>[51]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"?" | "*" | "+"</code></td>
<td><i>/* <a href="#parse-note-occurrence-indicators">xgs:
occurrence-indicators</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-ItemType" id=
"prod-xpath-ItemType"></a>[52]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-ItemType">ItemType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-KindTest">KindTest</a> | ("item" "("
")") | <a href="#prod-xpath-AtomicType">AtomicType</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-AtomicType" id=
"prod-xpath-AtomicType"></a>[53]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-AtomicType">AtomicType</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-KindTest" id=
"prod-xpath-KindTest"></a>[54]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-KindTest">KindTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-DocumentTest">DocumentTest</a><br />
| <a href="#prod-xpath-ElementTest">ElementTest</a><br />
| <a href="#prod-xpath-AttributeTest">AttributeTest</a><br />
| <a href=
"#prod-xpath-SchemaElementTest">SchemaElementTest</a><br />
| <a href=
"#prod-xpath-SchemaAttributeTest">SchemaAttributeTest</a><br />
| <a href="#prod-xpath-PITest">PITest</a><br />
| <a href="#prod-xpath-CommentTest">CommentTest</a><br />
| <a href="#prod-xpath-TextTest">TextTest</a><br />
| <a href="#prod-xpath-AnyKindTest">AnyKindTest</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-AnyKindTest" id=
"prod-xpath-AnyKindTest"></a>[55]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-AnyKindTest">AnyKindTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"node" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-DocumentTest" id=
"prod-xpath-DocumentTest"></a>[56]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-DocumentTest">DocumentTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"document-node" "(" (<a href=
"#prod-xpath-ElementTest">ElementTest</a> | <a href=
"#prod-xpath-SchemaElementTest">SchemaElementTest</a>)?
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-TextTest" id=
"prod-xpath-TextTest"></a>[57]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-TextTest">TextTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"text" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-CommentTest" id=
"prod-xpath-CommentTest"></a>[58]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-CommentTest">CommentTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"comment" "(" ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-PITest" id=
"prod-xpath-PITest"></a>[59]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-PITest">PITest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"processing-instruction" "(" (<a href=
"#prod-xpath-NCName">NCName</a> | <a href=
"#prod-xpath-StringLiteral">StringLiteral</a>)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-AttributeTest" id=
"prod-xpath-AttributeTest"></a>[60]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-AttributeTest">AttributeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"attribute" "(" (<a href=
"#prod-xpath-AttribNameOrWildcard">AttribNameOrWildcard</a> (","
<a href="#prod-xpath-TypeName">TypeName</a>)?)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-AttribNameOrWildcard" id=
"prod-xpath-AttribNameOrWildcard"></a>[61]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-AttribNameOrWildcard">AttribNameOrWildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-AttributeName">AttributeName</a> |
"*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-SchemaAttributeTest" id=
"prod-xpath-SchemaAttributeTest"></a>[62]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"schema-attribute" "(" <a href=
"#prod-xpath-AttributeDeclaration">AttributeDeclaration</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-AttributeDeclaration" id=
"prod-xpath-AttributeDeclaration"></a>[63]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-AttributeDeclaration">AttributeDeclaration</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-AttributeName">AttributeName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-ElementTest" id=
"prod-xpath-ElementTest"></a>[64]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-ElementTest">ElementTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"element" "(" (<a href=
"#prod-xpath-ElementNameOrWildcard">ElementNameOrWildcard</a> (","
<a href="#prod-xpath-TypeName">TypeName</a> "?"?)?)?
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-ElementNameOrWildcard" id=
"prod-xpath-ElementNameOrWildcard"></a>[65]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-ElementNameOrWildcard">ElementNameOrWildcard</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-ElementName">ElementName</a> |
"*"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-SchemaElementTest" id=
"prod-xpath-SchemaElementTest"></a>[66]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-SchemaElementTest">SchemaElementTest</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"schema-element" "(" <a href=
"#prod-xpath-ElementDeclaration">ElementDeclaration</a>
")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-ElementDeclaration" id=
"prod-xpath-ElementDeclaration"></a>[67]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-ElementDeclaration">ElementDeclaration</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#prod-xpath-ElementName">ElementName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-AttributeName" id=
"prod-xpath-AttributeName"></a>[68]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-AttributeName">AttributeName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-ElementName" id=
"prod-xpath-ElementName"></a>[69]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-ElementName">ElementName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-TypeName" id=
"prod-xpath-TypeName"></a>[70]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-TypeName">TypeName</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-QName">QName</a></code></td>
</tr>
</tbody>
</table>
<div class="div3">
<h4><a name="EBNFNotation" id="EBNFNotation"></a>A.1.1
Notation</h4>
<p>The following definitions will be helpful in defining precisely
this exposition.</p>
<p>[<a name="symbol" id="symbol" title="symbol">Definition</a>:
Each rule in the grammar defines one <b>symbol</b>, using the
following format:</p>
<div class="exampleInner">
<pre>
symbol ::= expression
</pre></div>
<p>]</p>
<p>[<a name="terminal" id="terminal" title=
"terminal">Definition</a>: A <b>terminal</b> is a symbol or string
or pattern that can appear in the right-hand side of a rule, but
never appears on the left hand side in the main grammar, although
it may appear on the left-hand side of a rule in the grammar for
terminals.] The following constructs are used to match strings of
one or more characters in a terminal:</p>
<dl>
<dt class="label">[a-zA-Z]</dt>
<dd>
<p>matches any <a href="#prod-xpath-Char">Char</a> with a value in
the range(s) indicated (inclusive).</p>
</dd>
<dt class="label">[abc]</dt>
<dd>
<p>matches any <a href="#prod-xpath-Char">Char</a> with a value
among the characters enumerated.</p>
</dd>
<dt class="label">[^abc]</dt>
<dd>
<p>matches any <a href="#prod-xpath-Char">Char</a> with a value not
among the characters given.</p>
</dd>
<dt class="label">"string"</dt>
<dd>
<p>matches the sequence of characters that appear inside the double
quotes.</p>
</dd>
<dt class="label">'string'</dt>
<dd>
<p>matches the sequence of characters that appear inside the single
quotes.</p>
</dd>
<dt class="label">
[http://www.w3.org/TR/REC-example/#NT-Example]</dt>
<dd>
<p>matches any string matched by the production defined in the
external specification as per the provided reference.</p>
</dd>
</dl>
<p>Patterns (including the above constructs) can be combined with
grammatical operators to form more complex patterns, matching more
complex sets of character strings. In the examples that follow, A
and B represent (sub-)patterns.</p>
<dl>
<dt class="label">(A)</dt>
<dd>
<p><code>A</code> is treated as a unit and may be combined as
described in this list.</p>
</dd>
<dt class="label">A?</dt>
<dd>
<p>matches <code>A</code> or nothing; optional <code>A</code>.</p>
</dd>
<dt class="label">A B</dt>
<dd>
<p>matches <code>A</code> followed by <code>B</code>. This operator
has higher precedence than alternation; thus <code>A B | C D</code>
is identical to <code>(A B) | (C D)</code>.</p>
</dd>
<dt class="label">A | B</dt>
<dd>
<p>matches <code>A</code> or <code>B</code> but not both.</p>
</dd>
<dt class="label">A - B</dt>
<dd>
<p>matches any string that matches <code>A</code> but does not
match <code>B</code>.</p>
</dd>
<dt class="label">A+</dt>
<dd>
<p>matches one or more occurrences of <code>A</code>. Concatenation
has higher precedence than alternation; thus <code>A+ | B+</code>
is identical to <code>(A+) | (B+)</code>.</p>
</dd>
</dl>
<dl>
<dt class="label">A*</dt>
<dd>
<p>matches zero or more occurrences of <code>A</code>.
Concatenation has higher precedence than alternation; thus <code>A*
| B*</code> is identical to <code>(A*) | (B*)</code></p>
</dd>
</dl>
</div>
<div class="div3">
<h4><a name="extra-grammatical-constraints" id=
"extra-grammatical-constraints"></a>A.1.2 Extra-grammatical
Constraints</h4>
<p>This section contains constraints on the EBNF productions, which
are required to parse legal sentences. The notes below are
referenced from the right side of the production, with the
notation: <em>/* xgc: &lt;id&gt; */</em>.</p>
<div class="constraint">
<p class="prefix"><a name="parse-note-leading-lone-slash" id=
"parse-note-leading-lone-slash"></a><b>Constraint:
leading-lone-slash</b></p>
<p>A single slash may appear either as a complete path expression
or as the first part of a path expression in which it is followed
by a <a href="#doc-xpath-RelativePathExpr">RelativePathExpr</a>. In
some cases, the next token after the slash is insufficient to allow
a parser to distinguish these two possibilities: the <code>*</code>
token and keywords like <code>union</code> could be either an
operator or a <a href="#doc-xpath-NameTest">NameTest</a> . For
example, without lookahead the first part of the expression <code>/
* 5</code> is easily taken to be a complete expression, <code>/
*</code>, which has a very different interpretation (the child
nodes of <code>/</code>).</p>
<p>Therefore to reduce the need for lookahead, if the token
immediately following a slash can form the start of a <a href=
"#doc-xpath-RelativePathExpr">RelativePathExpr</a>, then the slash
must be the beginning of a <a href=
"#doc-xpath-PathExpr">PathExpr</a>, not the entirety of it.</p>
<p>A single slash may be used as the left-hand argument of an
operator by parenthesizing it: <code>(/) * 5</code>. The expression
<code>5 * /</code>, on the other hand, is legal without
parentheses.</p>
</div>
<div class="constraint">
<p class="prefix"><a name="parse-note-xml-version" id=
"parse-note-xml-version"></a><b>Constraint: xml-version</b></p>
<p>An implementation's choice to support the <a href="#XML">[XML
1.0]</a> and <a href="#XMLNAMES">[XML Names]</a>, or <a href=
"#XML1.1">[XML 1.1]</a> and <a href="#XMLNAMES11">[XML Names
1.1]</a> lexical specification determines the external document
from which to obtain the definition for this production. The EBNF
only has references to the 1.0 versions. In some cases, the XML 1.0
and XML 1.1 definitions may be exactly the same. Also please note
that these external productions follow the whitespace rules of
their respective specifications, and not the rules of this
specification, in particular <a href=
"#DefaultWhitespaceHandling"><b>A.2.4.1 Default Whitespace
Handling</b></a>. Thus <code>prefix : localname</code> is not a
valid QName for purposes of this specification, just as it is not
permitted in a XML document. Also, comments are not permissible on
either side of the colon. Also extra-grammatical constraints such
as well-formedness constraints must be taken into account.</p>
</div>
<div class="constraint">
<p class="prefix"><a name="parse-note-reserved-function-names" id=
"parse-note-reserved-function-names"></a><b>Constraint:
reserved-function-names</b></p>
<p>Unprefixed function names spelled the same way as language
keywords could make the language harder to recognize. For instance,
<code>if(foo)</code> could be taken either as a <a href=
"#doc-xpath-FunctionCall">FunctionCall</a> or as the beginning of
an <a href="#doc-xpath-IfExpr">IfExpr</a>. Therefore it is not
legal syntax for a user to invoke functions with unprefixed names
which match any of the names in <a href=
"#id-reserved-fn-names"><b>A.3 Reserved Function Names</b></a>.</p>
<p>A function named "if" can be called by binding its namespace to
a prefix and using the prefixed form: "library:if(foo)" instead of
"if(foo)".</p>
</div>
<div class="constraint">
<p class="prefix"><a name="parse-note-occurrence-indicators" id=
"parse-note-occurrence-indicators"></a><b>Constraint:
occurrence-indicators</b></p>
<p>As written, the grammar in <a href="#nt-bnf"><b>A XPath
Grammar</b></a> is ambiguous for some forms using the '+' and '*'
Kleene operators. The ambiguity is resolved as follows: these
operators are tightly bound to the <a href=
"#doc-xpath-SequenceType">SequenceType</a> expression, and have
higher precedence than other uses of these symbols. Any occurrence
of '+' and '*', as well as '?', following a sequence type is
assumed to be an occurrence indicator. That is, a "+", "*", or "?"
immediately following an <a href="#doc-xpath-ItemType">ItemType</a>
must be an <a href=
"#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</a>. Thus,
<code>4 treat as item() + - 5</code> must be interpreted as
<code>(4 treat as item()+) - 5</code>, taking the '+' as an
OccurrenceIndicator and the '-' as a subtraction operator. To force
the interpretation of "+" as an addition operator (and the
corresponding interpretation of the "-" as a unary minus),
parentheses may be used: the form <code>(4 treat as item()) +
-5</code> surrounds the <a href=
"#doc-xpath-SequenceType">SequenceType</a> expression with
parentheses and leads to the desired interpretation.</p>
<p>This rule has as a consequence that certain forms which would
otherwise be legal and unambiguous are not recognized: in "4 treat
as item() + 5", the "+" is taken as an <a href=
"#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</a>, and not
as an operator, which means this is not a legal expression.</p>
</div>
</div>
<div class="div3">
<h4><a name="notes-on-parsing" id="notes-on-parsing"></a>A.1.3
Grammar Notes</h4>
<p>This section contains general notes on the EBNF productions,
which may be helpful in understanding how to interpret and
implement the EBNF. These notes are not normative. The notes below
are referenced from the right side of the production, with the
notation: <em>/* gn: &lt;id&gt; */</em>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<dl>
<dt class="label"><a name="parse-note-parens" id=
"parse-note-parens"></a>grammar-note: parens</dt>
<dd>
<p>Look-ahead is required to distinguish <a href=
"#doc-xpath-FunctionCall">FunctionCall</a> from a QName or keyword
followed by a <a href="#doc-xpath-Comment">Comment</a>. For
example: <code>address (: this may be empty :)</code> may be
mistaken for a call to a function named "address" unless this
lookahead is employed. Another example is <code>for (: whom the
bell :) $tolls in 3 return $tolls</code>, where the keyword "for"
must not be mistaken for a function name.</p>
</dd>
<dt class="label"><a name="parse-note-comments" id=
"parse-note-comments"></a>grammar-note: comments</dt>
<dd>
<p>Comments are allowed everywhere that <a title=
"ignorable whitespace" href="#IgnorableWhitespace">ignorable
whitespace</a> is allowed, and the <a href=
"#doc-xpath-Comment">Comment</a> symbol does not explicitly appear
on the right-hand side of the grammar (except in its own
production). See <a href="#DefaultWhitespaceHandling"><b>A.2.4.1
Default Whitespace Handling</b></a>.</p>
<p>A comment can contain nested comments, as long as all "(:" and
":)" patterns are balanced, no matter where they occur within the
outer comment.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Lexical analysis may typically handle nested comments by
incrementing a counter for each "(:" pattern, and decrementing the
counter for each ":)" pattern. The comment does not terminate until
the counter is back to zero.</p>
</div>
<p>Some illustrative examples:</p>
<ul>
<li>
<p><code>(: commenting out a (: comment :) may be confusing, but
often helpful :)</code> is a legal Comment, since balanced nesting
of comments is allowed.</p>
</li>
<li>
<p><code>"this is just a string :)"</code> is a legal expression.
However, <code>(: "this is just a string :)" :)</code> will cause a
syntax error. Likewise, <code>"this is another string (:"</code> is
a legal expression, but <code>(: "this is another string (:"
:)</code> will cause a syntax error. It is a limitation of nested
comments that literal content can cause unbalanced nesting of
comments.</p>
</li>
<li>
<p><code>for (: set up loop :) $i in $x return $i</code> is
syntactically legal, ignoring the comment.</p>
</li>
<li>
<p><code>5 instance (: strange place for a comment :) of
xs:integer</code> is also syntactically valid.</p>
</li>
</ul>
</dd>
</dl>
</div>
</div>
</div>
<div class="div2">
<h3><a name="lexical-structure" id="lexical-structure"></a>A.2
Lexical structure</h3>
<p>The terminal symbols assumed by the grammar above are described
in this section.</p>
<p>Quoted strings appearing in production rules are terminal
symbols.</p>
<p>Other terminal symbols are defined in <a href=
"#terminal-symbols"><b>A.2.1 Terminal Symbols</b></a>.</p>
<div class="xpath">
<p class="xpath">A <b>host language</b> may choose whether the
lexical rules of <a href="#XML">[XML 1.0]</a> and <a href=
"#XMLNAMES">[XML Names]</a> are followed, or alternatively, the
lexical rules of <a href="#XML1.1">[XML 1.1]</a> and <a href=
"#XMLNAMES11">[XML Names 1.1]</a> are followed.</p>
</div>
<p>When tokenizing, the longest possible match that is valid in the
current context is used.</p>
<p>All keywords are case sensitive. Keywords are not reserved—that
is, any QName may duplicate a keyword except as noted in <a href=
"#id-reserved-fn-names"><b>A.3 Reserved Function Names</b></a>.</p>
<div class="div3">
<h4><a name="terminal-symbols" id="terminal-symbols"></a>A.2.1
Terminal Symbols</h4>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-IntegerLiteral" id=
"prod-xpath-IntegerLiteral"></a>[71]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-IntegerLiteral">IntegerLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#prod-xpath-Digits">Digits</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-DecimalLiteral" id=
"prod-xpath-DecimalLiteral"></a>[72]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-DecimalLiteral">DecimalLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("." <a href="#prod-xpath-Digits">Digits</a>) | (<a href=
"#prod-xpath-Digits">Digits</a> "." [0-9]*)</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-DoubleLiteral" id=
"prod-xpath-DoubleLiteral"></a>[73]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-DoubleLiteral">DoubleLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(("." <a href="#prod-xpath-Digits">Digits</a>) |
(<a href="#prod-xpath-Digits">Digits</a> ("." [0-9]*)?)) [eE] [+-]?
<a href="#prod-xpath-Digits">Digits</a></code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-StringLiteral" id=
"prod-xpath-StringLiteral"></a>[74]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-StringLiteral">StringLiteral</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>('"' (<a href="#prod-xpath-EscapeQuot">EscapeQuot</a> |
[^"])* '"') | ("'" (<a href="#prod-xpath-EscapeApos">EscapeApos</a>
| [^'])* "'")</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-EscapeQuot" id=
"prod-xpath-EscapeQuot"></a>[75]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-EscapeQuot">EscapeQuot</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>'""'</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-EscapeApos" id=
"prod-xpath-EscapeApos"></a>[76]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-EscapeApos">EscapeApos</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"''"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-Comment" id=
"prod-xpath-Comment"></a>[77]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-Comment">Comment</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(:" (<a href=
"#prod-xpath-CommentContents">CommentContents</a> | <a href=
"#prod-xpath-Comment">Comment</a>)* ":)"</code></td>
<td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td>
</tr>
<tr valign="baseline">
<td></td>
<td></td>
<td></td>
<td></td>
<td><i>/* <a href="#parse-note-comments">gn: comments</a>
*/</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-QName" id=
"prod-xpath-QName"></a>[78]&#160;&#160;&#160;</td>
<td><code>QName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml-names/#NT-QName">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</a><sup><small>Names</small></sup></code></td>
<td><i>/* <a href="#parse-note-xml-version">xgs: xml-version</a>
*/</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-NCName" id=
"prod-xpath-NCName"></a>[79]&#160;&#160;&#160;</td>
<td><code>NCName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml-names/#NT-NCName">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</a><sup><small>Names</small></sup></code></td>
<td><i>/* <a href="#parse-note-xml-version">xgs: xml-version</a>
*/</i></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-Char" id=
"prod-xpath-Char"></a>[80]&#160;&#160;&#160;</td>
<td><code>Char</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/REC-xml/#NT-Char">[http://www.w3.org/TR/REC-xml#NT-Char]</a><sup><small>XML</small></sup></code></td>
<td><i>/* <a href="#parse-note-xml-version">xgs: xml-version</a>
*/</i></td>
</tr>
</tbody>
</table>
<p>The following symbols are used only in the definition of
terminal symbols; they are not terminal symbols in the grammar of
<a href="#id-grammar"><b>A.1 EBNF</b></a>.</p>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-Digits" id=
"prod-xpath-Digits"></a>[81]&#160;&#160;&#160;</td>
<td><code><a href="#doc-xpath-Digits">Digits</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>[0-9]+</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="prod-xpath-CommentContents" id=
"prod-xpath-CommentContents"></a>[82]&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xpath-CommentContents">CommentContents</a></code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href="#prod-xpath-Char">Char</a>+ - (Char* ('(:' |
':)') Char*))</code></td>
</tr>
</tbody>
</table>
</div>
<div class="div3">
<h4><a name="id-terminal-delimitation" id=
"id-terminal-delimitation"></a>A.2.2 Terminal Delimitation</h4>
<p>XPath 2.0 expressions consist of <a href=
"#terminal-symbols">terminal symbols</a> and <a title=
"symbol separators" href="#symbolseparators">symbol
separators</a>.</p>
<p>Terminal symbols that are not used exclusively in <a href=
"#ws-explicit">/* ws: explicit */</a> productions are of two kinds:
delimiting and non-delimiting.</p>
<p>[<a name="delimiting-token" id="delimiting-token" title=
"delimiting terminal symbol">Definition</a>: The <b>delimiting
terminal symbols</b> are: "!=", <a href=
"#prod-xpath-StringLiteral">StringLiteral</a>, "$", "(", ")", "*",
"+", (comma), "-", (dot), "..", "/", "//", (colon), "::", "&lt;",
"&lt;&lt;", "&lt;=", "=", "&gt;", "&gt;=", "&gt;&gt;", "?", "@",
"[", "]", "|"]</p>
<p>[<a name="non-delimiting-token" id="non-delimiting-token" title=
"non-delimiting terminal symbol">Definition</a>: The
<b>non-delimiting terminal symbols</b> are: <a href=
"#prod-xpath-IntegerLiteral">IntegerLiteral</a>, <a href=
"#prod-xpath-NCName">NCName</a>, <a href=
"#prod-xpath-DecimalLiteral">DecimalLiteral</a>, <a href=
"#prod-xpath-DoubleLiteral">DoubleLiteral</a>, <a href=
"#prod-xpath-QName">QName</a>, "ancestor", "ancestor-or-self",
"and", "as", "attribute", "cast", "castable", "child", "comment",
"descendant", "descendant-or-self", "div", "document-node",
"element", "else", "empty-sequence", "eq", "every", "except",
"external", "following", "following-sibling", "for", "ge", "gt",
"idiv", "if", "in", "instance", "intersect", "is", "item", "le",
"lt", "mod", "namespace", "ne", "node", "of", "or", "parent",
"preceding", "preceding-sibling", "processing-instruction",
"return", "satisfies", "schema-attribute", "schema-element",
"self", "some", "text", "then", "to", "treat", "union"]</p>
<p>[<a name="symbolseparators" id="symbolseparators" title=
"symbol separators">Definition</a>: <a title="whitespace" href=
"#Whitespace">Whitespace</a> and <a href=
"#doc-xpath-Comment">Comments</a> function as <b>symbol
separators</b>. For the most part, they are not mentioned in the
grammar, and may occur between any two terminal symbols mentioned
in the grammar, except where that is forbidden by the <a href=
"#ws-explicit">/* ws: explicit */</a> annotation in the EBNF, or by
the <a href="#parse-note-xml-version">/* xgs: xml-version */</a>
annotation. ]</p>
<p>It is customary to separate consecutive terminal symbols by
<a title="whitespace" href="#Whitespace">whitespace</a> and
<a href="#doc-xpath-Comment">Comments</a>, but this is required
only when otherwise two non-delimiting symbols would be adjacent to
each other. There are two exceptions to this, that of "." and "-",
which do require a <a title="symbol separators" href=
"#symbolseparators">symbol separator</a> if they follow a QName or
NCName. Also, "." requires a separator if it precedes or follows a
numeric literal.</p>
</div>
<div class="div3">
<h4><a name="id-eol-handling" id="id-eol-handling"></a>A.2.3
End-of-Line Handling</h4>
<p>The XPath processor must behave as if it normalized all line
breaks on input, before parsing. The normalization should be done
according to the choice to support either <a href="#XML">[XML
1.0]</a> or <a href="#XML1.1">[XML 1.1]</a> lexical processing.</p>
<div class="div4">
<h5><a name="id-xml10-eol-handling" id=
"id-xml10-eol-handling"></a>A.2.3.1 XML 1.0 End-of-Line
Handling</h5>
<p>For <a href="#XML">[XML 1.0]</a> processing, all of the
following must be translated to a single #xA character:</p>
<ol class="enumar">
<li>
<p>the two-character sequence #xD #xA</p>
</li>
<li>
<p>any #xD character that is not immediately followed by #xA.</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="id-xml11-eol-handling" id=
"id-xml11-eol-handling"></a>A.2.3.2 XML 1.1 End-of-Line
Handling</h5>
<p>For <a href="#XML1.1">[XML 1.1]</a> processing, all of the
following must be translated to a single #xA character:</p>
<ol class="enumar">
<li>
<p>the two-character sequence #xD #xA</p>
</li>
<li>
<p>the two-character sequence #xD #x85</p>
</li>
<li>
<p>the single character #x85</p>
</li>
<li>
<p>the single character #x2028</p>
</li>
<li>
<p>any #xD character that is not immediately followed by #xA or
#x85.</p>
</li>
</ol>
</div>
</div>
<div class="div3">
<h4><a name="whitespace-rules" id="whitespace-rules"></a>A.2.4
Whitespace Rules</h4>
<div class="div4">
<h5><a name="DefaultWhitespaceHandling" id=
"DefaultWhitespaceHandling"></a>A.2.4.1 Default Whitespace
Handling</h5>
<p>[<a name="Whitespace" id="Whitespace" title=
"whitespace">Definition</a>: A <b>whitespace</b> character is any
of the characters defined by <a href=
"http://www.w3.org/TR/REC-xml/#NT-S">[http://www.w3.org/TR/REC-xml/#NT-S]</a>.]</p>
<p>[<a name="IgnorableWhitespace" id="IgnorableWhitespace" title=
"ignorable whitespace">Definition</a>: <b>Ignorable whitespace</b>
consists of any <a title="whitespace" href=
"#Whitespace">whitespace</a> characters that may occur between
<a title="terminal" href="#terminal">terminals</a>, unless these
characters occur in the context of a production marked with a
<a href="#ExplicitWhitespaceHandling">ws:explicit</a> annotation,
in which case they can occur only where explicitly specified (see
<a href="#ExplicitWhitespaceHandling"><b>A.2.4.2 Explicit
Whitespace Handling</b></a>).] Ignorable whitespace characters are
not significant to the semantics of an expression. Whitespace is
allowed before the first terminal and after the last terminal of a
module. Whitespace is allowed between any two <a title="terminal"
href="#terminal">terminals</a>. <a href=
"#doc-xpath-Comment">Comments</a> may also act as "whitespace" to
prevent two adjacent terminals from being recognized as one. Some
illustrative examples are as follows:</p>
<ul>
<li>
<p><code>foo- foo</code> results in a syntax error. "foo-" would be
recognized as a QName.</p>
</li>
<li>
<p><code>foo -foo</code> is syntactically equivalent to <code>foo -
foo</code>, two QNames separated by a subtraction operator.</p>
</li>
<li>
<p><code>foo(: This is a comment :)- foo</code> is syntactically
equivalent to <code>foo - foo</code>. This is because the comment
prevents the two adjacent terminals from being recognized as
one.</p>
</li>
<li>
<p><code>foo-foo</code> is syntactically equivalent to single
QName. This is because "-" is a valid character in a QName. When
used as an operator after the characters of a name, the "-" must be
separated from the name, e.g. by using whitespace or
parentheses.</p>
</li>
<li>
<p><code>10div 3</code> results in a syntax error.</p>
</li>
<li>
<p><code>10 div3</code> also results in a syntax error.</p>
</li>
<li>
<p><code>10div3</code> also results in a syntax error.</p>
</li>
</ul>
</div>
<div class="div4">
<h5><a name="ExplicitWhitespaceHandling" id=
"ExplicitWhitespaceHandling"></a>A.2.4.2 Explicit Whitespace
Handling</h5>
<p>Explicit whitespace notation is specified with the EBNF
productions, when it is different from the default rules, using the
notation shown below. This notation is not inherited. In other
words, if an EBNF rule is marked as /* ws: explicit */, the
notation does not automatically apply to all the 'child' EBNF
productions of that rule.</p>
<dl>
<dt class="label"><a name="ws-explicit" id="ws-explicit"></a>ws:
explicit</dt>
<dd>
<p>/* ws: explicit */ means that the EBNF notation explicitly
notates, with <code>S</code> or otherwise, where <a title=
"whitespace" href="#Whitespace">whitespace characters</a> are
allowed. In productions with the /* ws: explicit */ annotation,
<a href="#DefaultWhitespaceHandling"><b>A.2.4.1 Default Whitespace
Handling</b></a> does not apply. <a href=
"#doc-xpath-Comment">Comments</a> are also not allowed in these
productions.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="div2">
<h3><a name="id-reserved-fn-names" id=
"id-reserved-fn-names"></a>A.3 Reserved Function Names</h3>
<p>The following names are not allowed as function names in an
unprefixed form because expression syntax takes precedence.</p>
<ul>
<li>
<p><code>attribute</code></p>
</li>
<li>
<p><code>comment</code></p>
</li>
<li>
<p><code>document-node</code></p>
</li>
<li>
<p><code>element</code></p>
</li>
<li>
<p><code>empty-sequence</code></p>
</li>
<li>
<p><code>if</code></p>
</li>
<li>
<p><code>item</code></p>
</li>
<li>
<p><code>node</code></p>
</li>
<li>
<p><code>processing-instruction</code></p>
</li>
<li>
<p><code>schema-attribute</code></p>
</li>
<li>
<p><code>schema-element</code></p>
</li>
<li>
<p><code>text</code></p>
</li>
<li>
<p><code>typeswitch</code></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Although the keyword <code>typeswitch</code> is not used in
XPath, it is considered a reserved function name for compatibility
with XQuery.</p>
</div>
</li>
</ul>
</div>
<div class="div2">
<h3><a name="id-precedence-order" id="id-precedence-order"></a>A.4
Precedence Order</h3>
<p>The grammar in <a href="#id-grammar"><b>A.1 EBNF</b></a>
normatively defines built-in precedence among the operators of
XPath. These operators are summarized here to make clear the order
of their precedence from lowest to highest. The associativity
column indicates the order in which operators of equal precedence
in an expression are applied.</p>
<table border="1">
<tbody>
<tr>
<th>#</th>
<th>Operator</th>
<th>Associativity</th>
</tr>
<tr>
<td>1</td>
<td>, (comma)</td>
<td>left-to-right</td>
</tr>
<tr>
<td>3</td>
<td><span class="xpath"><span class="xpath"><a href=
"#doc-xpath-ForExpr">for</a>,</span></span> <a href=
"#doc-xpath-QuantifiedExpr">some, every</a>, <a href=
"#doc-xpath-IfExpr">if</a></td>
<td>left-to-right</td>
</tr>
<tr>
<td>4</td>
<td><a href="#doc-xpath-OrExpr">or</a></td>
<td>left-to-right</td>
</tr>
<tr>
<td>5</td>
<td><a href="#doc-xpath-AndExpr">and</a></td>
<td>left-to-right</td>
</tr>
<tr>
<td>6</td>
<td><a href="#doc-xpath-ValueComp">eq, ne, lt, le, gt, ge</a>,
<a href="#doc-xpath-GeneralComp">=, !=, &lt;, &lt;=, &gt;,
&gt;=</a>, <a href="#doc-xpath-NodeComp">is</a>, <a href=
"#doc-xpath-NodeComp">&lt;&lt;, &gt;&gt;</a></td>
<td>left-to-right</td>
</tr>
<tr>
<td>7</td>
<td><a href="#doc-xpath-RangeExpr">to</a></td>
<td>left-to-right</td>
</tr>
<tr>
<td>8</td>
<td><a href="#doc-xpath-AdditiveExpr">+, -</a></td>
<td>left-to-right</td>
</tr>
<tr>
<td>9</td>
<td><a href="#doc-xpath-MultiplicativeExpr">*, div, idiv,
mod</a></td>
<td>left-to-right</td>
</tr>
<tr>
<td>10</td>
<td><a href="#doc-xpath-UnionExpr">union, |</a></td>
<td>left-to-right</td>
</tr>
<tr>
<td>11</td>
<td><a href="#doc-xpath-IntersectExceptExpr">intersect,
except</a></td>
<td>left-to-right</td>
</tr>
<tr>
<td>12</td>
<td><a href="#doc-xpath-InstanceofExpr">instance of</a></td>
<td>left-to-right</td>
</tr>
<tr>
<td>13</td>
<td><a href="#doc-xpath-TreatExpr">treat</a></td>
<td>left-to-right</td>
</tr>
<tr>
<td>14</td>
<td><a href="#doc-xpath-CastableExpr">castable</a></td>
<td>left-to-right</td>
</tr>
<tr>
<td>15</td>
<td><a href="#doc-xpath-CastExpr">cast</a></td>
<td>left-to-right</td>
</tr>
<tr>
<td>16</td>
<td><a href="#doc-xpath-UnaryExpr">-(unary), +(unary)</a></td>
<td>right-to-left</td>
</tr>
<tr>
<td>17</td>
<td><a href="#doc-xpath-OccurrenceIndicator">?,
*(OccurrenceIndicator), +(OccurrenceIndicator)</a></td>
<td>left-to-right</td>
</tr>
<tr>
<td>18</td>
<td><a href="#doc-xpath-PathExpr">/, //</a></td>
<td>left-to-right</td>
</tr>
<tr class="diff-chg" title="XQ.E26 and XP.E18">
<td>19</td>
<td><a href="#doc-xpath-Predicate">[ ]</a></td>
<td>left-to-right</td>
</tr>
</tbody>
</table>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Parentheses can be used to override the operator precedence in
the usual way. Square brackets in an expression such as A[B] serve
two roles: they act as an operator causing B to be evaluated once
for each item in the value of A, and they act as parentheses
enclosing the expression B.</p>
</div>
</div>
</div>
<div class="div1">
<h2><a name="id-type-promotion-and-operator-mapping" id=
"id-type-promotion-and-operator-mapping"></a>B Type Promotion and
Operator Mapping</h2>
<div class="div2">
<h3><a name="promotion" id="promotion"></a>B.1 Type Promotion</h3>
<p>[<a name="dt-type-promotion" id="dt-type-promotion" title=
"type promotion">Definition</a>: Under certain circumstances, an
atomic value can be promoted from one type to another. <b>Type
promotion</b> is used in evaluating function calls (see <a href=
"#id-function-calls"><b>3.1.5 Function Calls</b></a>) and operators
that accept numeric or string operands (see <a href=
"#mapping"><b>B.2 Operator Mapping</b></a>).] The following type
promotions are permitted:</p>
<ol class="enumar">
<li>
<p>Numeric type promotion:</p>
<ol class="enumla">
<li>
<p>A value of type <code>xs:float</code> (or any type derived by
restriction from <code>xs:float</code>) can be promoted to the type
<code>xs:double</code>. The result is the <code>xs:double</code>
value that is the same as the original value.</p>
</li>
<li>
<p>A value of type <code>xs:decimal</code> (or any type derived by
restriction from <code>xs:decimal</code>) can be promoted to either
of the types <code>xs:float</code> or <code>xs:double</code>. The
result of this promotion is created by casting the original value
to the required type. This kind of promotion may cause loss of
precision.</p>
</li>
</ol>
</li>
<li>
<p>URI type promotion: A value of type <code>xs:anyURI</code> (or
any type derived by restriction from <code>xs:anyURI</code>) can be
promoted to the type <code>xs:string</code>. The result of this
promotion is created by casting the original value to the type
<code>xs:string</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Since <code>xs:anyURI</code> values can be promoted to
<code>xs:string</code>, functions and operators that compare
strings using the <a title="default collation" href=
"#dt-def-collation">default collation</a> also compare
<code>xs:anyURI</code> values using the <a title=
"default collation" href="#dt-def-collation">default collation</a>.
This ensures that orderings that include strings,
<code>xs:anyURI</code> values, or any combination of the two types
are consistent and well-defined.</p>
</div>
</li>
</ol>
<p>Note that <a title="type promotion" href=
"#dt-type-promotion">type promotion</a> is different from <a title=
"subtype substitution" href="#dt-subtype-substitution">subtype
substitution</a>. For example:</p>
<ul>
<li>
<p>A function that expects a parameter <code>$p</code> of type
<code>xs:float</code> can be invoked with a value of type
<code>xs:decimal</code>. This is an example of <a title=
"type promotion" href="#dt-type-promotion">type promotion</a>. The
value is actually converted to the expected type. Within the body
of the function, <code>$p instance of xs:decimal</code> returns
<code>false</code>.</p>
</li>
<li>
<p>A function that expects a parameter <code>$p</code> of type
<code>xs:decimal</code> can be invoked with a value of type
<code>xs:integer</code>. This is an example of <a title=
"subtype substitution" href="#dt-subtype-substitution">subtype
substitution</a>. The value retains its original type. Within the
body of the function, <code>$p instance of xs:integer</code>
returns <code>true</code>.</p>
</li>
</ul>
</div>
<div class="div2">
<h3><a name="mapping" id="mapping"></a>B.2 Operator Mapping</h3>
<p>The operator mapping tables in this section list the
combinations of types for which the various operators of XPath are
defined. [<a name="dt-operator-function" id="dt-operator-function"
title="operator function">Definition</a>: For each operator and
valid combination of operand types, the operator mapping tables
specify a result type and an <b>operator function</b> that
implements the semantics of the operator for the given types.] The
definitions of the operator functions are given in <a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators (Second Edition)]</a>. The result of an operator may be
the raising of an error by its operator function, as defined in
<a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0
Functions and Operators (Second Edition)]</a>. In some cases, the
operator function does not implement the full semantics of a given
operator. For the definition of each operator (including its
behavior for empty sequences or sequences of length greater than
one), see the descriptive material in the main part of this
document.</p>
<p>The <code>and</code> and <code>or</code> operators are defined
directly in the main body of this document, and do not occur in the
operator mapping tables.</p>
<p>If an operator in the operator mapping tables expects an operand
of type <em>ET</em>, that operator can be applied to an operand of
type <em>AT</em> if type <em>AT</em> can be converted to type
<em>ET</em> by a combination of <a title="type promotion" href=
"#dt-type-promotion">type promotion</a> and <a title=
"subtype substitution" href="#dt-subtype-substitution">subtype
substitution</a>. For example, a table entry indicates that the
<code>gt</code> operator may be applied to two <code>xs:date</code>
operands, returning <code>xs:boolean</code>. Therefore, the
<code>gt</code> operator may also be applied to two (possibly
different) subtypes of <code>xs:date</code>, also returning
<code>xs:boolean</code>.</p>
<p>[<a name="dt-numeric" id="dt-numeric" title=
"numeric">Definition</a>: When referring to a type, the term
<b>numeric</b> denotes the types <code>xs:integer</code>,
<code>xs:decimal</code>, <code>xs:float</code>, and
<code>xs:double</code>.] An operator whose operands and result are
designated as <a title="numeric" href="#dt-numeric">numeric</a>
might be thought of as representing four operators, one for each of
the numeric types. For example, the numeric <code>+</code> operator
might be thought of as representing the following four
operators:</p>
<table width="80%" border="1" summary="Operators">
<tbody>
<tr>
<td align="center">Operator</td>
<td align="center">First operand type</td>
<td align="center">Second operand type</td>
<td align="center">Result type</td>
</tr>
<tr>
<td align="center"><code>+</code></td>
<td align="center"><code>xs:integer</code></td>
<td align="center"><code>xs:integer</code></td>
<td align="center"><code>xs:integer</code></td>
</tr>
<tr>
<td align="center"><code>+</code></td>
<td align="center"><code>xs:decimal</code></td>
<td align="center"><code>xs:decimal</code></td>
<td align="center"><code>xs:decimal</code></td>
</tr>
<tr>
<td align="center"><code>+</code></td>
<td align="center"><code>xs:float</code></td>
<td align="center"><code>xs:float</code></td>
<td align="center"><code>xs:float</code></td>
</tr>
<tr>
<td align="center"><code>+</code></td>
<td align="center"><code>xs:double</code></td>
<td align="center"><code>xs:double</code></td>
<td align="center"><code>xs:double</code></td>
</tr>
</tbody>
</table>
<p>A numeric operator may be validly applied to an operand of type
<em>AT</em> if type <em>AT</em> can be converted to any of the four
numeric types by a combination of <a title="type promotion" href=
"#dt-type-promotion">type promotion</a> and <a title=
"subtype substitution" href="#dt-subtype-substitution">subtype
substitution</a>. If the result type of an operator is listed as
numeric, it means "the first type in the ordered list
<code>(xs:integer, xs:decimal, xs:float, xs:double)</code> into
which all operands can be converted by <a title=
"subtype substitution" href="#dt-subtype-substitution">subtype
substitution</a> and <a title="type promotion" href=
"#dt-type-promotion">type promotion</a>." As an example, suppose
that the type <code>hatsize</code> is derived from
<code>xs:integer</code> and the type <code>shoesize</code> is
derived from <code>xs:float</code>. Then if the <code>+</code>
operator is invoked with operands of type <code>hatsize</code> and
<code>shoesize</code>, it returns a result of type
<code>xs:float</code>. Similarly, if <code>+</code> is invoked with
two operands of type <code>hatsize</code> it returns a result of
type <code>xs:integer</code>.</p>
<p>[<a name="dt-gregorian" id="dt-gregorian" title=
"Gregorian">Definition</a>: In the operator mapping tables, the
term <b>Gregorian</b> refers to the types
<code>xs:gYearMonth</code>, <code>xs:gYear</code>,
<code>xs:gMonthDay</code>, <code>xs:gDay</code>, and
<code>xs:gMonth</code>.] For binary operators that accept two
Gregorian-type operands, both operands must have the same type (for
example, if one operand is of type <code>xs:gDay</code>, the other
operand must be of type <code>xs:gDay</code>.)</p>
<div class="small">
<table border="1" summary="Binary operators" class="small">
<caption>Binary Operators</caption>
<tbody>
<tr>
<th>Operator</th>
<th>Type(A)</th>
<th>Type(B)</th>
<th>Function</th>
<th>Result type</th>
</tr>
<tr>
<td>A + B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-add(A, B)</td>
<td>numeric</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:date</td>
<td>xs:yearMonthDuration</td>
<td>op:add-yearMonthDuration-to-date(A, B)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:yearMonthDuration</td>
<td>xs:date</td>
<td>op:add-yearMonthDuration-to-date(B, A)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:date</td>
<td>xs:dayTimeDuration</td>
<td>op:add-dayTimeDuration-to-date(A, B)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:dayTimeDuration</td>
<td>xs:date</td>
<td>op:add-dayTimeDuration-to-date(B, A)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:time</td>
<td>xs:dayTimeDuration</td>
<td>op:add-dayTimeDuration-to-time(A, B)</td>
<td>xs:time</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:dayTimeDuration</td>
<td>xs:time</td>
<td>op:add-dayTimeDuration-to-time(B, A)</td>
<td>xs:time</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:dateTime</td>
<td>xs:yearMonthDuration</td>
<td>op:add-yearMonthDuration-to-dateTime(A, B)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:yearMonthDuration</td>
<td>xs:dateTime</td>
<td>op:add-yearMonthDuration-to-dateTime(B, A)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:dateTime</td>
<td>xs:dayTimeDuration</td>
<td>op:add-dayTimeDuration-to-dateTime(A, B)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dateTime</td>
<td>op:add-dayTimeDuration-to-dateTime(B, A)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>op:add-yearMonthDurations(A, B)</td>
<td>xs:yearMonthDuration</td>
</tr>
<tr>
<td>A + B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>op:add-dayTimeDurations(A, B)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A - B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-subtract(A, B)</td>
<td>numeric</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>op:subtract-dates(A, B)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:date</td>
<td>xs:yearMonthDuration</td>
<td>op:subtract-yearMonthDuration-from-date(A, B)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:date</td>
<td>xs:dayTimeDuration</td>
<td>op:subtract-dayTimeDuration-from-date(A, B)</td>
<td>xs:date</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>op:subtract-times(A, B)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:time</td>
<td>xs:dayTimeDuration</td>
<td>op:subtract-dayTimeDuration-from-time(A, B)</td>
<td>xs:time</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>op:subtract-dateTimes(A, B)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:dateTime</td>
<td>xs:yearMonthDuration</td>
<td>op:subtract-yearMonthDuration-from-dateTime(A, B)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:dateTime</td>
<td>xs:dayTimeDuration</td>
<td>op:subtract-dayTimeDuration-from-dateTime(A, B)</td>
<td>xs:dateTime</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>op:subtract-yearMonthDurations(A, B)</td>
<td>xs:yearMonthDuration</td>
</tr>
<tr>
<td>A - B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>op:subtract-dayTimeDurations(A, B)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A * B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-multiply(A, B)</td>
<td>numeric</td>
</tr>
<tr>
<td>A * B</td>
<td>xs:yearMonthDuration</td>
<td>numeric</td>
<td>op:multiply-yearMonthDuration(A, B)</td>
<td>xs:yearMonthDuration</td>
</tr>
<tr>
<td>A * B</td>
<td>numeric</td>
<td>xs:yearMonthDuration</td>
<td>op:multiply-yearMonthDuration(B, A)</td>
<td>xs:yearMonthDuration</td>
</tr>
<tr>
<td>A * B</td>
<td>xs:dayTimeDuration</td>
<td>numeric</td>
<td>op:multiply-dayTimeDuration(A, B)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A * B</td>
<td>numeric</td>
<td>xs:dayTimeDuration</td>
<td>op:multiply-dayTimeDuration(B, A)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A idiv B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-integer-divide(A, B)</td>
<td>xs:integer</td>
</tr>
<tr>
<td>A div B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-divide(A, B)</td>
<td>numeric; but xs:decimal if both operands are xs:integer</td>
</tr>
<tr>
<td>A div B</td>
<td>xs:yearMonthDuration</td>
<td>numeric</td>
<td>op:divide-yearMonthDuration(A, B)</td>
<td>xs:yearMonthDuration</td>
</tr>
<tr>
<td>A div B</td>
<td>xs:dayTimeDuration</td>
<td>numeric</td>
<td>op:divide-dayTimeDuration(A, B)</td>
<td>xs:dayTimeDuration</td>
</tr>
<tr>
<td>A div B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>op:divide-yearMonthDuration-by-yearMonthDuration (A, B)</td>
<td>xs:decimal</td>
</tr>
<tr>
<td>A div B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>op:divide-dayTimeDuration-by-dayTimeDuration (A, B)</td>
<td>xs:decimal</td>
</tr>
<tr>
<td>A mod B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-mod(A, B)</td>
<td>numeric</td>
</tr>
<tr>
<td>A eq B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>op:boolean-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>op:numeric-equal(fn:compare(A, B), 0)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>op:date-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>op:time-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>op:dateTime-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:duration</td>
<td>xs:duration</td>
<td>op:duration-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>Gregorian</td>
<td>Gregorian</td>
<td>op:gYear-equal(A, B) etc.</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:hexBinary</td>
<td>xs:hexBinary</td>
<td>op:hex-binary-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:base64Binary</td>
<td>xs:base64Binary</td>
<td>op:base64-binary-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:anyURI</td>
<td>xs:anyURI</td>
<td>op:numeric-equal(fn:compare(A, B), 0)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:QName</td>
<td>xs:QName</td>
<td>op:QName-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A eq B</td>
<td>xs:NOTATION</td>
<td>xs:NOTATION</td>
<td>op:NOTATION-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>numeric</td>
<td>numeric</td>
<td>fn:not(op:numeric-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>fn:not(op:boolean-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>fn:not(op:numeric-equal(fn:compare(A, B), 0))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>fn:not(op:date-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>fn:not(op:time-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>fn:not(op:dateTime-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:duration</td>
<td>xs:duration</td>
<td>fn:not(op:duration-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>Gregorian</td>
<td>Gregorian</td>
<td>fn:not(op:gYear-equal(A, B)) etc.</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:hexBinary</td>
<td>xs:hexBinary</td>
<td>fn:not(op:hex-binary-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:base64Binary</td>
<td>xs:base64Binary</td>
<td>fn:not(op:base64-binary-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:anyURI</td>
<td>xs:anyURI</td>
<td>fn:not(op:numeric-equal(fn:compare(A, B), 0))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:QName</td>
<td>xs:QName</td>
<td>fn:not(op:QName-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ne B</td>
<td>xs:NOTATION</td>
<td>xs:NOTATION</td>
<td>fn:not(op:NOTATION-equal(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>op:boolean-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>op:numeric-greater-than(fn:compare(A, B), 0)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>op:date-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>op:time-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>op:dateTime-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>op:yearMonthDuration-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>op:dayTimeDuration-greater-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A gt B</td>
<td>xs:anyURI</td>
<td>xs:anyURI</td>
<td>op:numeric-greater-than(fn:compare(A, B), 0)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>op:boolean-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>op:numeric-less-than(fn:compare(A, B), 0)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>op:date-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>op:time-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>op:dateTime-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>op:yearMonthDuration-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>op:dayTimeDuration-less-than(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A lt B</td>
<td>xs:anyURI</td>
<td>xs:anyURI</td>
<td>op:numeric-less-than(fn:compare(A, B), 0)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-greater-than(A, B) or op:numeric-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>fn:not(op:boolean-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>op:numeric-greater-than(fn:compare(A, B), -1)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>fn:not(op:date-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>fn:not(op:time-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>fn:not(op:dateTime-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>fn:not(op:yearMonthDuration-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>fn:not(op:dayTimeDuration-less-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A ge B</td>
<td>xs:anyURI</td>
<td>xs:anyURI</td>
<td>op:numeric-greater-than(fn:compare(A, B), -1)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>numeric</td>
<td>numeric</td>
<td>op:numeric-less-than(A, B) or op:numeric-equal(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:boolean</td>
<td>xs:boolean</td>
<td>fn:not(op:boolean-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:string</td>
<td>xs:string</td>
<td>op:numeric-less-than(fn:compare(A, B), 1)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:date</td>
<td>xs:date</td>
<td>fn:not(op:date-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:time</td>
<td>xs:time</td>
<td>fn:not(op:time-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:dateTime</td>
<td>xs:dateTime</td>
<td>fn:not(op:dateTime-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:yearMonthDuration</td>
<td>xs:yearMonthDuration</td>
<td>fn:not(op:yearMonthDuration-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:dayTimeDuration</td>
<td>xs:dayTimeDuration</td>
<td>fn:not(op:dayTimeDuration-greater-than(A, B))</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A le B</td>
<td>xs:anyURI</td>
<td>xs:anyURI</td>
<td>op:numeric-less-than(fn:compare(A, B), 1)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A is B</td>
<td>node()</td>
<td>node()</td>
<td>op:is-same-node(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A &lt;&lt; B</td>
<td>node()</td>
<td>node()</td>
<td>op:node-before(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A &gt;&gt; B</td>
<td>node()</td>
<td>node()</td>
<td>op:node-after(A, B)</td>
<td>xs:boolean</td>
</tr>
<tr>
<td>A union B</td>
<td>node()*</td>
<td>node()*</td>
<td>op:union(A, B)</td>
<td>node()*</td>
</tr>
<tr>
<td>A | B</td>
<td>node()*</td>
<td>node()*</td>
<td>op:union(A, B)</td>
<td>node()*</td>
</tr>
<tr>
<td>A intersect B</td>
<td>node()*</td>
<td>node()*</td>
<td>op:intersect(A, B)</td>
<td>node()*</td>
</tr>
<tr>
<td>A except B</td>
<td>node()*</td>
<td>node()*</td>
<td>op:except(A, B)</td>
<td>node()*</td>
</tr>
<tr>
<td>A to B</td>
<td>xs:integer</td>
<td>xs:integer</td>
<td>op:to(A, B)</td>
<td>xs:integer*</td>
</tr>
<tr>
<td>A , B</td>
<td>item()*</td>
<td>item()*</td>
<td>op:concatenate(A, B)</td>
<td>item()*</td>
</tr>
</tbody>
</table>
</div>
<div class="small">
<table border="1" summary="Unary operators" class="small">
<caption>Unary Operators</caption>
<tbody>
<tr>
<th>Operator</th>
<th>Operand type</th>
<th>Function</th>
<th>Result type</th>
</tr>
<tr>
<td>+ A</td>
<td>numeric</td>
<td>op:numeric-unary-plus(A)</td>
<td>numeric</td>
</tr>
<tr>
<td>- A</td>
<td>numeric</td>
<td>op:numeric-unary-minus(A)</td>
<td>numeric</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="xpath">
<div class="div1">
<h2><a name="id-xp-context-components" id=
"id-xp-context-components"></a>C Context Components</h2>
<p>The tables in this section describe the scope (range of
applicability) of the various components in the static context and
dynamic context.</p>
<div class="div2">
<h3><a name="id-xp-static-context-components" id=
"id-xp-static-context-components"></a>C.1 Static Context
Components</h3>
<p>The following table describes the components of the <b>static
context</b>. For each component, "global" indicates that the value
of the component applies throughout an XPath expression, whereas
"lexical" indicates that the value of the component applies only
within the subexpression in which it is defined.</p>
<div class="small">
<table width="60%" border="1" summary="Static Context" class=
"small">
<caption>Static Context Components</caption>
<tbody>
<tr>
<th>Component</th>
<th>Scope</th>
</tr>
<tr>
<td>XPath 1.0 Compatibility Mode</td>
<td>global</td>
</tr>
<tr>
<td>Statically known namespaces</td>
<td>global</td>
</tr>
<tr>
<td>Default element/type namespace</td>
<td>global</td>
</tr>
<tr>
<td>Default function namespace</td>
<td>global</td>
</tr>
<tr>
<td>In-scope schema types</td>
<td>global</td>
</tr>
<tr>
<td>In-scope element declarations</td>
<td>global</td>
</tr>
<tr>
<td>In-scope attribute declarations</td>
<td>global</td>
</tr>
<tr>
<td>In-scope variables</td>
<td>lexical; for-expressions and quantified expressions can bind
new variables</td>
</tr>
<tr>
<td>Context item static type</td>
<td>lexical</td>
</tr>
<tr>
<td>Function signatures</td>
<td>global</td>
</tr>
<tr>
<td>Statically known collations</td>
<td>global</td>
</tr>
<tr>
<td>Default collation</td>
<td>global</td>
</tr>
<tr>
<td>Base URI</td>
<td>global</td>
</tr>
<tr>
<td>Statically known documents</td>
<td>global</td>
</tr>
<tr>
<td>Statically known collections</td>
<td>global</td>
</tr>
<tr>
<td>Statically known default collection type</td>
<td>global</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="div2">
<h3><a name="id-xp-evaluation-context-components" id=
"id-xp-evaluation-context-components"></a>C.2 Dynamic Context
Components</h3>
<p>The following table describes how values are assigned to the
various components of the <b>dynamic context</b>. All these
components are initialized by mechanisms defined by the host
language. For each component, "global" indicates that the value of
the component remains constant throughout evaluation of the XPath
expression, whereas "dynamic" indicates that the value of the
component can be modified by the evaluation of subexpressions.</p>
<div class="small">
<table width="60%" border="1" summary="Static Context" class=
"small">
<caption>Dynamic Context Components</caption>
<tbody>
<tr>
<th>Component</th>
<th>Scope</th>
</tr>
<tr>
<td>Context item</td>
<td>dynamic; changes during evaluation of path expressions and
predicates</td>
</tr>
<tr>
<td>Context position</td>
<td>dynamic; changes during evaluation of path expressions and
predicates</td>
</tr>
<tr>
<td>Context size</td>
<td>dynamic; changes during evaluation of path expressions and
predicates</td>
</tr>
<tr>
<td>Variable values</td>
<td>dynamic; for-expressions and quantified expressions can bind
new variables</td>
</tr>
<tr>
<td>Current date and time</td>
<td>global; must be initialized by implementation</td>
</tr>
<tr>
<td>Implicit timezone</td>
<td>global; must be initialized by implementation</td>
</tr>
<tr>
<td>Available documents</td>
<td>global; must be initialized by implementation</td>
</tr>
<tr>
<td>Available collections</td>
<td>global; must be initialized by implementation</td>
</tr>
<tr>
<td>Default collection</td>
<td>global; overwriteable by implementation</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="id-impl-defined-items" id=
"id-impl-defined-items"></a>D Implementation-Defined Items</h2>
<p>The following items in this specification are <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>:</p>
<ol class="enumar">
<li>
<p>The version of Unicode that is used to construct
expressions.</p>
</li>
<li>
<p>The <a title="statically known collations" href=
"#dt-static-collations">statically-known collations</a>.</p>
</li>
<li>
<p>The <a title="implicit timezone" href="#dt-timezone">implicit
timezone</a>.</p>
</li>
<li>
<p>The circumstances in which <a title="warning" href=
"#dt-warning">warnings</a> are raised, and the ways in which
warnings are handled.</p>
</li>
<li>
<p>The method by which errors are reported to the external
processing environment.</p>
</li>
<li>
<p>Whether the implementation is based on the rules of <a href=
"#XML">[XML 1.0]</a> and <a href="#XMLNAMES">[XML Names]</a> or the
rules of <a href="#XML1.1">[XML 1.1]</a> and <a href=
"#XMLNAMES11">[XML Names 1.1]</a>. One of these sets of rules must
be applied consistently by all aspects of the implementation. If
the implementation is based on the rules of <a href="#XML">[XML
1.0]</a>, the edition used must be at least Third Edition; the
edition used is <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>, but we
recommend that implementations use the latest version.</p>
</li>
<li class="xpath">
<p>Whether the implementation supports the namespace axis.</p>
</li>
<li class="xpath">
<p>Any <a title="static typing extension" href=
"#dt-xpath-static-typing-extension">static typing extensions</a>
supported by the implementation, if the <a title=
"static typing feature" href=
"#dt-xpath-static-typing-feature">Static Typing Feature</a> is
supported.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Additional <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> items are
listed in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model
(Second Edition)]</a> and <a href="#FunctionsAndOperators">[XQuery
1.0 and XPath 2.0 Functions and Operators (Second
Edition)]</a>.</p>
</div>
</div>
<div class="div1">
<h2><a name="id-references" id="id-references"></a>E
References</h2>
<div class="div2">
<h3><a name="id-normative-references" id=
"id-normative-references"></a>E.1 Normative References</h3>
<dl>
<dt class="label"><span><a name="RFC2119" id="RFC2119"></a>RFC
2119</span></dt>
<dd>
<div>S. Bradner. <em>Key Words for use in RFCs to Indicate
Requirement Levels.</em> IETF RFC 2119. See <a href=
"http://www.ietf.org/rfc/rfc2119.txt">http://www.ietf.org/rfc/rfc2119.txt</a>.</div>
</dd>
<dt class="label"><span><a name="RFC3986" id=
"RFC3986"></a>RFC3986</span></dt>
<dd>
<div>T. Berners-Lee, R. Fielding, and L. Masinter. <em>Uniform
Resource Identifiers (URI): Generic Syntax</em>. IETF RFC 3986. See
<a href=
"http://www.ietf.org/rfc/rfc3986.txt">http://www.ietf.org/rfc/rfc3986.txt</a>.</div>
</dd>
<dt class="label"><span><a name="RFC3987" id=
"RFC3987"></a>RFC3987</span></dt>
<dd>
<div>M. Duerst and M. Suignard. <em>Internationalized Resource
Identifiers (IRIs)</em>. IETF RFC 3987. See <a href=
"http://www.ietf.org/rfc/rfc3987.txt">http://www.ietf.org/rfc/rfc3987.txt</a>.</div>
</dd>
<dt class="label"><span><a name="ISO10646" id=
"ISO10646"></a>ISO/IEC 10646</span></dt>
<dd>
<div>ISO (International Organization for Standardization).
<em>ISO/IEC 10646:2003. Information technology—Universal
Multiple-Octet Coded Character Set (UCS)</em>, as, from time to
time, amended, replaced by a new edition, or expanded by the
addition of new parts. [Geneva]: International Organization for
Standardization. (See <a href=
"http://www.iso.org">http://www.iso.org</a> for the latest
version.)</div>
</dd>
<dt class="label"><span><a name="Unicode" id=
"Unicode"></a>Unicode</span></dt>
<dd>
<div>The Unicode Consortium. <em>The Unicode Standard</em> Reading,
Mass.: Addison-Wesley, 2003, as updated from time to time by the
publication of new versions. See <a href=
"http://www.unicode.org/standard/versions/">http://www.unicode.org/standard/versions/</a>
for the latest version and additional information on versions of
the standard and of the Unicode Character Database. The version of
Unicode to be used is <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>, but
implementations are recommended to use the latest Unicode
version.</div>
</dd>
<dt class="label"><a name="XML" id="XML"></a>XML 1.0</dt>
<dd>World Wide Web Consortium. <em>Extensible Markup Language (XML)
1.0.</em> W3C Recommendation. See <a href=
"http://www.w3.org/TR/REC-xml/">http://www.w3.org/TR/REC-xml/</a>.
The edition of XML 1.0 must be no earlier than the Third Edition;
the edition used is <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>, but we
recommend that implementations use the latest version.</dd>
<dt class="label"><span><a name="XML1.1" id="XML1.1"></a>XML
1.1</span></dt>
<dd>
<div>World Wide Web Consortium. <em>Extensible Markup Language
(XML) 1.1.</em> W3C Recommendation. See <a href=
"http://www.w3.org/TR/xml11/">http://www.w3.org/TR/xml11/</a></div>
</dd>
<dt class="label"><span><a name="XMLBASE" id="XMLBASE"></a>XML
Base</span></dt>
<dd>
<div>World Wide Web Consortium. <em>XML Base.</em> W3C
Recommendation. See <a href=
"http://www.w3.org/TR/xmlbase/">http://www.w3.org/TR/xmlbase/</a></div>
</dd>
<dt class="label"><span><a name="XMLNAMES" id="XMLNAMES"></a>XML
Names</span></dt>
<dd>
<div>World Wide Web Consortium. <em>Namespaces in XML.</em> W3C
Recommendation. See <a href=
"http://www.w3.org/TR/REC-xml-names/">http://www.w3.org/TR/REC-xml-names/</a></div>
</dd>
<dt class="label"><span><a name="XMLNAMES11" id=
"XMLNAMES11"></a>XML Names 1.1</span></dt>
<dd>
<div>World Wide Web Consortium. <em>Namespaces in XML 1.1.</em> W3C
Recommendation. See <a href=
"http://www.w3.org/TR/xml-names11/">http://www.w3.org/TR/xml-names11/</a></div>
</dd>
<dt class="label"><span><a name="XMLID" id="XMLID"></a>XML
ID</span></dt>
<dd>
<div>World Wide Web Consortium. <em>xml:id Version 1.0.</em> W3C
Recommendation. See <a href=
"http://www.w3.org/TR/xml-id/">http://www.w3.org/TR/xml-id/</a></div>
</dd>
<dt class="label"><span><a name="XMLSchema" id="XMLSchema"></a>XML
Schema</span></dt>
<dd>
<div>World Wide Web Consortium. <em>XML Schema, Parts 0, 1, and 2
(Second Edition)</em>. W3C Recommendation, 28 October 2004. See
<a href=
"http://www.w3.org/TR/xmlschema-0/">http://www.w3.org/TR/xmlschema-0/</a>,
<a href=
"http://www.w3.org/TR/xmlschema-1/">http://www.w3.org/TR/xmlschema-1/</a>,
and <a href=
"http://www.w3.org/TR/xmlschema-2/">http://www.w3.org/TR/xmlschema-2/</a>.</div>
</dd>
<dt class="label"><a name="datamodel" id="datamodel"></a>XQuery 1.0
and XPath 2.0 Data Model (Second Edition)</dt>
<dd>World Wide Web Consortium. <em>XQuery 1.0 and XPath 2.0 Data
Model (XDM) (Second Edition)</em>. W3C Recommendation, 14 December
2010. See <a href=
"http://www.w3.org/TR/xpath-datamodel/">http://www.w3.org/TR/xpath-datamodel/</a>.</dd>
<dt class="label"><a name="XQueryFormalSemantics" id=
"XQueryFormalSemantics"></a>XQuery 1.0 and XPath 2.0 Formal
Semantics (Second Edition)</dt>
<dd>World Wide Web Consortium. <em>XQuery 1.0 and XPath 2.0 Formal
Semantics (Second Edition)</em>. W3C Recommendation, 14 December
2010. See <a href=
"http://www.w3.org/TR/xquery-semantics/">http://www.w3.org/TR/xquery-semantics/</a>.</dd>
<dt class="label"><a name="FunctionsAndOperators" id=
"FunctionsAndOperators"></a>XQuery 1.0 and XPath 2.0 Functions and
Operators (Second Edition)</dt>
<dd>World Wide Web Consortium. <em>XQuery 1.0 and XPath 2.0
Functions and Operators (Second Edition)</em> W3C Recommendation,
14 December 2010. See <a href=
"http://www.w3.org/TR/xquery-operators/">http://www.w3.org/TR/xpath-functions/</a>.</dd>
<dt class="label"><a name="serialization" id=
"serialization"></a>XSLT 2.0 and XQuery 1.0 Serialization (Second
Edition)</dt>
<dd>World Wide Web Consortium. <em>XSLT 2.0 and XQuery 1.0
Serialization (Second Edition)</em>. W3C Recommendation, 14
December 2010. See <a href=
"http://www.w3.org/TR/xslt-xquery-serialization/">http://www.w3.org/TR/xslt-xquery-serialization/</a>.</dd>
</dl>
</div>
<div class="div2">
<h3><a name="id-non-normative-references" id=
"id-non-normative-references"></a>E.2 Non-normative References</h3>
<dl>
<dt class="label"><span class="xpath"><a name="XPath-Requirements"
id="XPath-Requirements"></a>XPath 2.0 Requirements</span></dt>
<dd>
<div class="xpath">World Wide Web Consortium. <em>XPath
Requirements Version 2.0</em>. W3C Working Draft 22 August 2003.
See <a href=
"http://www.w3.org/TR/xpath20req/">http://www.w3.org/TR/xpath20req/</a>.</div>
</dd>
<dt class="label"><a name="xquery" id="xquery"></a>XQuery 1.0: An
XML Query Language (Second Edition)</dt>
<dd>World Wide Web Consortium. <em>XQuery 1.0: An XML Query
Language (Second Edition)</em>. W3C Recommendation, 14 December
2010. See <a href=
"http://www.w3.org/TR/xquery/">http://www.w3.org/TR/xquery/</a>.</dd>
<dt class="label"><a name="XSLT" id="XSLT"></a>XSL Transformations
(XSLT) Version 2.0 (Second Edition)</dt>
<dd>World Wide Web Consortium. <em>XSL Transformations (XSLT) 2.0
(Second Edition)</em> W3C Recommendation, 14 December 2010. See
<a href=
"http://www.w3.org/TR/xslt20/">http://www.w3.org/TR/xslt20/</a></dd>
<dt class="label"><span><a name="DOM" id="DOM"></a>Document Object
Model</span></dt>
<dd>
<div>World Wide Web Consortium. <em>Document Object Model (DOM)
Level 3 Core Specification.</em> W3C Recommendation, April 7, 2004.
See <a href=
"http://www.w3.org/TR/DOM-Level-3-Core/">http://www.w3.org/TR/DOM-Level-3-Core/</a>.</div>
</dd>
<dt class="label"><span><a name="XINFO" id="XINFO"></a>XML
Infoset</span></dt>
<dd>
<div>World Wide Web Consortium. <em>XML Information Set.</em> W3C
Recommendation 24 October 2001. See <a href=
"http://www.w3.org/TR/xml-infoset/">http://www.w3.org/TR/xml-infoset/</a></div>
</dd>
<dt class="label"><span><a name="XPath" id="XPath"></a>XPath
1.0</span></dt>
<dd>
<div>World Wide Web Consortium. <em>XML Path Language (XPath)
Version 1.0</em>. W3C Recommendation, Nov. 16, 1999. See <a href=
"http://www.w3.org/TR/xpath/">http://www.w3.org/TR/xpath/</a></div>
</dd>
<dt class="label"><span><a name="XPTR" id=
"XPTR"></a>XPointer</span></dt>
<dd>
<div>World Wide Web Consortium. <em>XML Pointer Language
(XPointer).</em> W3C Last Call Working Draft 8 January 2001. See
<a href=
"http://www.w3.org/TR/WD-xptr">http://www.w3.org/TR/WD-xptr</a></div>
</dd>
</dl>
</div>
<div class="div2">
<h3><a name="id-background-material" id=
"id-background-material"></a>E.3 Background Material</h3>
<dl>
<dt class="label"><span><a name="CHARMOD" id=
"CHARMOD"></a>Character Model</span></dt>
<dd>
<div>World Wide Web Consortium. <em>Character Model for the World
Wide Web.</em> W3C Working Draft. See <a href=
"http://www.w3.org/TR/charmod/">http://www.w3.org/TR/charmod/</a>.</div>
</dd>
<dt class="label"><span><a name="XSLT1" id="XSLT1"></a>XSLT
1.0</span></dt>
<dd>
<div>World Wide Web Consortium. <em>XSL Transformations (XSLT)
1.0.</em> W3C Recommendation. See <a href=
"http://www.w3.org/TR/xslt">http://www.w3.org/TR/xslt</a></div>
</dd>
</dl>
</div>
</div>
<div class="xpath">
<div class="div1">
<h2><a name="id-xpath-conformance" id="id-xpath-conformance"></a>F
Conformance</h2>
<p>XPath is intended primarily as a component that can be used by
other specifications. Therefore, XPath relies on specifications
that use it (such as <a href="#XPTR">[XPointer]</a> and <a href=
"#XSLT">[XSL Transformations (XSLT) Version 2.0 (Second
Edition)]</a>) to specify conformance criteria for XPath in their
respective environments. Specifications that set conformance
criteria for their use of XPath must not change the syntactic or
semantic definitions of XPath as given in this specification,
except by subsetting and/or compatible extensions.</p>
<p>The specification of such a language may describe it as an
extension of XPath provided that every expression that conforms to
the XPath grammar behaves as described in this specification.</p>
<div class="div2">
<h3><a name="id-xpath-static-typing" id=
"id-xpath-static-typing"></a>F.1 Static Typing Feature</h3>
<p>[<a name="dt-xpath-static-typing-feature" id=
"dt-xpath-static-typing-feature" title=
"static typing feature">Definition</a>: The <b>Static Typing
Feature</b> is an optional feature of XPath that provides support
for the static semantics defined in <a href=
"#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics
(Second Edition)]</a>, and requires implementations to detect and
report <a title="type error" href="#dt-type-error">type errors</a>
during the <a title="static analysis phase" href=
"#dt-static-analysis">static analysis phase</a>.] Specifications
that use XPath may specify conformance criteria for use of the
Static Typing Feature.</p>
<p>If an implementation does not support the <a title=
"static typing feature" href=
"#dt-xpath-static-typing-feature">Static Typing Feature</a>, but
can nevertheless determine during the static analysis phase that an
expression will necessarily raise a type error if evaluated at run
time, the implementation may raise that error during the static
analysis phase. The choice of whether to raise such an error at
analysis time is <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation dependent</a>.</p>
<div class="div3">
<h4><a name="id-xpath-static-extensions" id=
"id-xpath-static-extensions"></a>F.1.1 Static Typing
Extensions</h4>
<p>In some cases, the static typing rules defined in <a href=
"#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics
(Second Edition)]</a> are not very precise (see, for example, the
type inference rules for the ancestor axes—parent, ancestor, and
ancestor-or-self—and for the function <code>fn:root</code>). Some
implementations may wish to support more precise static typing
rules.</p>
<p>A conforming implementation that implements the <a title=
"static typing feature" href=
"#dt-xpath-static-typing-feature">Static Typing Feature</a> may
also provide one or more <b>static typing extensions</b>. [<a name=
"dt-xpath-static-typing-extension" id=
"dt-xpath-static-typing-extension" title=
"static typing extension">Definition</a>: A <b>static typing
extension</b> is an <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> type
inference rule that infers a more precise static type than that
inferred by the type inference rules in <a href=
"#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics
(Second Edition)]</a>.] See <a href=
"http://www.w3.org/TR/xquery-semantics/#id-static-extensions">Section
6.1.1 Static Typing Extensions</a><sup><small>FS</small></sup> for
a formal definition of the constraints on static typing
extensions.</p>
</div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="id-errors" id="id-errors"></a>G Error Conditions</h2>
<dl>
<dt><a name="ERRXPST0001" id="ERRXPST0001"></a>err:XPST0001</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if analysis of an expression relies on some component of
the <a title="static context" href="#dt-static-context">static
context</a> that has not been assigned a value.</p>
</dd>
<dt><a name="ERRXPDY0002" id="ERRXPDY0002"></a>err:XPDY0002</dt>
<dd>
<p>It is a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> if evaluation of an
expression relies on some part of the <a title="dynamic context"
href="#dt-dynamic-context">dynamic context</a> that has not been
assigned a value.</p>
</dd>
<dt><a name="ERRXPST0003" id="ERRXPST0003"></a>err:XPST0003</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if an expression is not a valid instance of the grammar
defined in <a href="#id-grammar"><b>A.1 EBNF</b></a>.</p>
</dd>
<dt><a name="ERRXPTY0004" id="ERRXPTY0004"></a>err:XPTY0004</dt>
<dd>
<p>It is a <a title="type error" href="#dt-type-error">type
error</a> if, during the <a title="static analysis phase" href=
"#dt-static-analysis">static analysis phase</a>, an expression is
found to have a <a title="static type" href=
"#dt-static-type">static type</a> that is not appropriate for the
context in which the expression occurs, or during the <a title=
"dynamic evaluation phase" href="#dt-dynamic-evaluation">dynamic
evaluation phase</a>, the <a title="dynamic type" href=
"#dt-dynamic-type">dynamic type</a> of a value does not match a
required type as specified by the matching rules in <a href=
"#id-sequencetype-matching"><b>2.5.4 SequenceType
Matching</b></a>.</p>
</dd>
<dt><a name="ERRXPST0005" id="ERRXPST0005"></a>err:XPST0005</dt>
<dd>
<p>During the analysis phase, it is a <a title="static error" href=
"#dt-static-error">static error</a> if the <a title="static type"
href="#dt-static-type">static type</a> assigned to an expression
other than the expression <code>()</code> or <code>data(())</code>
is <code>empty-sequence()</code>.</p>
</dd>
<dt><a name="ERRXPTY0006" id="ERRXPTY0006"></a>err:XPTY0006</dt>
<dd>
<p>(Not currently used.)</p>
</dd>
<dt><a name="ERRXPTY0007" id="ERRXPTY0007"></a>err:XPTY0007</dt>
<dd>
<p>(Not currently used.)</p>
</dd>
<dt><a name="ERRXPST0008" id="ERRXPST0008"></a>err:XPST0008</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if an expression refers to an element name, attribute
name, schema type name, namespace prefix, or variable name that is
not defined in the <a title="static context" href=
"#dt-static-context">static context</a>, except for an ElementName
in an <a href="#doc-xpath-ElementTest">ElementTest</a> or an
AttributeName in an <a href=
"#doc-xpath-AttributeTest">AttributeTest</a>.</p>
</dd>
<dt><a name="ERRXPST0010" id="ERRXPST0010"></a>err:XPST0010</dt>
<dd>
<p>An implementation must raise a <a title="static error" href=
"#dt-static-error">static error</a> if it encounters a reference to
an axis that it does not support.</p>
</dd>
<dt><a name="ERRXPST0017" id="ERRXPST0017"></a>err:XPST0017</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if the expanded QName and number of arguments in a
function call do not match the name and arity of a <a title=
"function signature" href="#dt-function-signature">function
signature</a> in the <a title="static context" href=
"#dt-static-context">static context</a>.</p>
</dd>
<dt><a name="ERRXPTY0018" id="ERRXPTY0018"></a>err:XPTY0018</dt>
<dd>
<p>It is a <a title="type error" href="#dt-type-error">type
error</a> if the result of the last step in a path expression
contains both nodes and atomic values.</p>
</dd>
<dt><a name="ERRXPTY0019" id="ERRXPTY0019"></a>err:XPTY0019</dt>
<dd>
<p>It is a <a title="type error" href="#dt-type-error">type
error</a> if the result of a step (other than the last step) in a
path expression contains an atomic value.</p>
</dd>
<dt><a name="ERRXPTY0020" id="ERRXPTY0020"></a>err:XPTY0020</dt>
<dd>
<p>It is a <a title="type error" href="#dt-type-error">type
error</a> if, in an axis step, the context item is not a node.</p>
</dd>
<dt><a name="ERRXPDY0021" id="ERRXPDY0021"></a>err:XPDY0021</dt>
<dd>
<p>(Not currently used.)</p>
</dd>
<dt><a name="ERRXPDY0050" id="ERRXPDY0050"></a>err:XPDY0050</dt>
<dd>
<p>It is a <a title="dynamic error" href=
"#dt-dynamic-error">dynamic error</a> if the <a title=
"dynamic type" href="#dt-dynamic-type">dynamic type</a> of the
operand of a <code>treat</code> expression does not match the
<a title="sequence type" href="#dt-sequence-type">sequence type</a>
specified by the <code>treat</code> expression. This error might
also be raised by a path expression beginning with "<code>/</code>"
or "<code>//</code>" if the context node is not in a tree that is
rooted at a document node. This is because a leading
"<code>/</code>" or "<code>//</code>" in a path expression is an
abbreviation for an initial step that includes the clause
<code>treat as document-node()</code>.</p>
</dd>
<dt><a name="ERRXPST0051" id="ERRXPST0051"></a>err:XPST0051</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if a QName that is used as an <a href=
"#doc-xpath-AtomicType">AtomicType</a> in a <a href=
"#doc-xpath-SequenceType">SequenceType</a> is not defined in the
<a title="in-scope schema type" href="#dt-is-types">in-scope schema
types</a> as an atomic type.</p>
</dd>
<dt><a name="ERRXPST0080" id="ERRXPST0080"></a>err:XPST0080</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if the target type of a <code>cast</code> or
<code>castable</code> expression is <code>xs:NOTATION</code> or
<code>xs:anyAtomicType</code>.</p>
</dd>
<dt><a name="ERRXPST0081" id="ERRXPST0081"></a>err:XPST0081</dt>
<dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> if a QName used in <span class="xpath"><span class=
"xpath">an expression</span></span> contains a namespace prefix
that cannot be expanded into a namespace URI by using the <a title=
"statically known namespaces" href=
"#dt-static-namespaces">statically known namespaces</a>.</p>
</dd>
<dt><a name="ERRXPST0083" id="ERRXPST0083"></a>err:XPST0083</dt>
<dd>
<p>(Not currently used.)</p>
</dd>
</dl>
</div>
<div class="div1">
<h2><a name="id-glossary" id="id-glossary"></a>H Glossary
(Non-Normative)</h2>
<dl>
<dt><a name="GLdt-gregorian" id="GLdt-gregorian"></a>Gregorian</dt>
<dd>
<p>In the operator mapping tables, the term <b>Gregorian</b> refers
to the types <code>xs:gYearMonth</code>, <code>xs:gYear</code>,
<code>xs:gMonthDay</code>, <code>xs:gDay</code>, and
<code>xs:gMonth</code>.</p>
</dd>
<dt><a name="GLdt-qname" id="GLdt-qname"></a>QName</dt>
<dd>
<p>Lexically, a <b>QName</b> consists of an optional namespace
prefix and a local name. If the namespace prefix is present, it is
separated from the local name by a colon.</p>
</dd>
<dt><a name="GLdt-sequencetype-matching" id=
"GLdt-sequencetype-matching"></a>SequenceType matching</dt>
<dd>
<p>During evaluation of an expression, it is sometimes necessary to
determine whether a value with a known <a title="dynamic type"
href="#dt-dynamic-type">dynamic type</a> "matches" an expected
<a title="sequence type" href="#dt-sequence-type">sequence
type</a>. This process is known as <b>SequenceType
matching</b>.</p>
</dd>
<dt><a name="GLdt-URI" id="GLdt-URI"></a>URI</dt>
<dd>
<p>Within this specification, the term <b>URI</b> refers to a
Universal Resource Identifier as defined in <a href=
"#RFC3986">[RFC3986]</a> and extended in <a href=
"#RFC3987">[RFC3987]</a> with the new name <b>IRI</b>.</p>
</dd>
<dt><a name="GLdt-data-model-instance" id=
"GLdt-data-model-instance"></a>XDM instance</dt>
<dd>
<p>The term <b>XDM instance</b> is used, synonymously with the term
<b>value</b>, to denote an unconstrained sequence of <a title=
"node" href="#dt-node">nodes</a> and/or <a title="atomic value"
href="#dt-atomic-value">atomic values</a> in the <a title=
"data model" href="#dt-datamodel">data model</a>.</p>
</dd>
<dt><a name="GLdt-xpath-compat-mode" id=
"GLdt-xpath-compat-mode"></a>XPath 1.0 compatibility mode</dt>
<dd>
<p><b>XPath 1.0 compatibility mode.</b> <span class=
"xpath"><span class="xpath">This value is <code>true</code> if
rules for backward compatibility with XPath Version 1.0 are in
effect; otherwise it is <code>false</code>.</span></span></p>
</dd>
<dt><a name="GLdt-atomic-value" id="GLdt-atomic-value"></a>atomic
value</dt>
<dd>
<p>An <b>atomic value</b> is a value in the value space of an
<b>atomic type</b>, as defined in <a href="#XMLSchema">[XML
Schema]</a>.</p>
</dd>
<dt><a name="GLdt-atomization" id=
"GLdt-atomization"></a>atomization</dt>
<dd>
<p><b>Atomization</b> of a sequence is defined as the result of
invoking the <code>fn:data</code> function on the sequence, as
defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath
2.0 Functions and Operators (Second Edition)]</a>.</p>
</dd>
<dt><a name="GLdt-available-collections" id=
"GLdt-available-collections"></a>available collections</dt>
<dd>
<p><b>Available collections.</b> This is a mapping of strings onto
sequences of nodes. The string represents the absolute URI of a
resource. The sequence of nodes represents the result of the
<code>fn:collection</code> function when that URI is supplied as
the argument.</p>
</dd>
<dt><a name="GLdt-available-docs" id=
"GLdt-available-docs"></a>available documents</dt>
<dd>
<p><b>Available documents.</b> This is a mapping of strings onto
document nodes. The string represents the absolute URI of a
resource. The document node is the root of a tree that represents
that resource using the <a title="data model" href=
"#dt-datamodel">data model</a>. The document node is returned by
the <code>fn:doc</code> function when applied to that URI.</p>
</dd>
<dt><a name="GLdt-axis-step" id="GLdt-axis-step"></a>axis step</dt>
<dd>
<p>An <b>axis step</b> returns a sequence of nodes that are
reachable from the context node via a specified axis. Such a step
has two parts: an <b>axis</b>, which defines the "direction of
movement" for the step, and a <a title="node test" href=
"#dt-node-test">node test</a>, which selects nodes based on their
kind, name, and/or <a title="type annotation" href=
"#dt-type-annotation">type annotation</a>.</p>
</dd>
<dt><a name="GLdt-base-uri" id="GLdt-base-uri"></a>base URI</dt>
<dd>
<p><b>Base URI.</b> This is an absolute URI, used when necessary in
the resolution of relative URIs (for example, by the
<code>fn:resolve-uri</code> function.)</p>
</dd>
<dt><a name="GLdt-built-in-function" id=
"GLdt-built-in-function"></a>built-in function</dt>
<dd>
<p>The <b>built-in functions</b> supported by XPath are defined in
<a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0
Functions and Operators (Second Edition)]</a>.</p>
</dd>
<dt><a name="GLdt-collation" id="GLdt-collation"></a>collation</dt>
<dd>
<p>A <b>collation</b> is a specification of the manner in which
strings and URIs are compared and, by extension, ordered. For a
more complete definition of collation, see <a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators (Second Edition)]</a>.</p>
</dd>
<dt><a name="GLdt-comma-operator" id=
"GLdt-comma-operator"></a>comma operator</dt>
<dd>
<p>One way to construct a sequence is by using the <b>comma
operator</b>, which evaluates each of its operands and concatenates
the resulting sequences, in order, into a single result
sequence.</p>
</dd>
<dt><a name="GLdt-constructor-function" id=
"GLdt-constructor-function"></a>constructor function</dt>
<dd>
<p>The <b>constructor function</b> for a given type is used to
convert instances of other atomic types into the given type. The
semantics of the constructor function call <code>T($arg)</code> are
defined to be equivalent to the expression <code>(($arg) cast as
T?)</code>.</p>
</dd>
<dt><a name="GLdt-context-item" id="GLdt-context-item"></a>context
item</dt>
<dd>
<p>The <b>context item</b> is the item currently being processed.
An item is either an atomic value or a node.</p>
</dd>
<dt><a name="GLdt-context-item-static-type" id=
"GLdt-context-item-static-type"></a>context item static type</dt>
<dd>
<p><b>Context item static type.</b> This component defines the
<a title="static type" href="#dt-static-type">static type</a> of
the context item within the scope of a given expression.</p>
</dd>
<dt><a name="GLdt-context-node" id="GLdt-context-node"></a>context
node</dt>
<dd>
<p>When the context item is a node, it can also be referred to as
the <b>context node</b>.</p>
</dd>
<dt><a name="GLdt-context-position" id=
"GLdt-context-position"></a>context position</dt>
<dd>
<p>The <b>context position</b> is the position of the context item
within the sequence of items currently being processed.</p>
</dd>
<dt><a name="GLdt-context-size" id="GLdt-context-size"></a>context
size</dt>
<dd>
<p>The <b>context size</b> is the number of items in the sequence
of items currently being processed.</p>
</dd>
<dt><a name="GLdt-date-time" id="GLdt-date-time"></a>current
dateTime</dt>
<dd>
<p><b>Current dateTime.</b> This information represents an
<a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> point
in time during the processing of <span class="xpath"><span class=
"xpath">an expression</span></span>, and includes an explicit
timezone. It can be retrieved by the
<code>fn:current-dateTime</code> function. If invoked multiple
times during the execution of <span class="xpath"><span class=
"xpath">an expression</span></span>, this function always returns
the same result.</p>
</dd>
<dt><a name="GLdt-datamodel" id="GLdt-datamodel"></a>data
model</dt>
<dd>
<p>XPath operates on the abstract, logical structure of an XML
document, rather than its surface syntax. This logical structure,
known as the <b>data model</b>, is defined in <a href=
"#datamodel">[XQuery 1.0 and XPath 2.0 Data Model (Second
Edition)]</a>.</p>
</dd>
<dt><a name="GLdt-data-model-schema" id=
"GLdt-data-model-schema"></a>data model schema</dt>
<dd>
<p>For a given node in an <a title="XDM instance" href=
"#dt-data-model-instance">XDM instance</a>, the <b>data model
schema</b> is defined as the schema from which the <a title=
"type annotation" href="#dt-type-annotation">type annotation</a> of
that node was derived.</p>
</dd>
<dt><a name="GLdt-def-collation" id=
"GLdt-def-collation"></a>default collation</dt>
<dd>
<p><b>Default collation.</b> This identifies one of the collations
in <a title="statically known collations" href=
"#dt-static-collations">statically known collations</a> as the
collation to be used by functions and operators for comparing and
ordering values of type <code>xs:string</code> and
<code>xs:anyURI</code> (and types derived from them) when no
explicit collation is specified.</p>
</dd>
<dt><a name="GLdt-default-collection" id=
"GLdt-default-collection"></a>default collection</dt>
<dd>
<p><b>Default collection.</b> This is the sequence of nodes that
would result from calling the <code>fn:collection</code> function
with no arguments.</p>
</dd>
<dt><a name="GLdt-def-elemtype-ns" id=
"GLdt-def-elemtype-ns"></a>default element/type namespace</dt>
<dd>
<p><b>Default element/type namespace.</b> This is a namespace URI
or "none". The namespace URI, if present, is used for any
unprefixed QName appearing in a position where an element or type
name is expected.</p>
</dd>
<dt><a name="GLdt-def-fn-ns" id="GLdt-def-fn-ns"></a>default
function namespace</dt>
<dd>
<p><b>Default function namespace.</b> This is a namespace URI or
"none". The namespace URI, if present, is used for any unprefixed
QName appearing in a position where a function name is
expected.</p>
</dd>
<dt><a name="GLdelimiting-token" id=
"GLdelimiting-token"></a>delimiting terminal symbol</dt>
<dd>
<p>The <b>delimiting terminal symbols</b> are: "!=", <a href=
"#prod-xpath-StringLiteral">StringLiteral</a>, "$", "(", ")", "*",
"+", (comma), "-", (dot), "..", "/", "//", (colon), "::", "&lt;",
"&lt;&lt;", "&lt;=", "=", "&gt;", "&gt;=", "&gt;&gt;", "?", "@",
"[", "]", "|"</p>
</dd>
<dt><a name="GLdt-document-order" id=
"GLdt-document-order"></a>document order</dt>
<dd>
<p>Informally, <b>document order</b> is the order in which nodes
appear in the XML serialization of a document.</p>
</dd>
<dt><a name="GLdt-dynamic-context" id=
"GLdt-dynamic-context"></a>dynamic context</dt>
<dd>
<p>The <b>dynamic context</b> of an expression is defined as
information that is available at the time the expression is
evaluated.</p>
</dd>
<dt><a name="GLdt-dynamic-error" id=
"GLdt-dynamic-error"></a>dynamic error</dt>
<dd>
<p>A <b>dynamic error</b> is an error that must be detected during
the dynamic evaluation phase and may be detected during the static
analysis phase. Numeric overflow is an example of a dynamic
error.</p>
</dd>
<dt><a name="GLdt-dynamic-evaluation" id=
"GLdt-dynamic-evaluation"></a>dynamic evaluation phase</dt>
<dd>
<p>The <b>dynamic evaluation phase</b> is the phase during which
the value of an expression is computed.</p>
</dd>
<dt><a name="GLdt-dynamic-type" id="GLdt-dynamic-type"></a>dynamic
type</dt>
<dd>
<p>A <b>dynamic type</b> is associated with each value as it is
computed. The dynamic type of a value may be more specific than the
<a title="static type" href="#dt-static-type">static type</a> of
the expression that computed it (for example, the static type of an
expression might be <code>xs:integer*</code>, denoting a sequence
of zero or more integers, but at evaluation time its value may have
the dynamic type <code>xs:integer</code>, denoting exactly one
integer.)</p>
</dd>
<dt><a name="GLdt-ebv" id="GLdt-ebv"></a>effective boolean
value</dt>
<dd>
<p>The <b>effective boolean value</b> of a value is defined as the
result of applying the <code>fn:boolean</code> function to the
value, as defined in <a href="#FunctionsAndOperators">[XQuery 1.0
and XPath 2.0 Functions and Operators (Second Edition)]</a>.</p>
</dd>
<dt><a name="GLdt-empty-sequence" id=
"GLdt-empty-sequence"></a>empty sequence</dt>
<dd>
<p>A sequence containing zero items is called an <b>empty
sequence</b>.</p>
</dd>
<dt><a name="GLdt-error-value" id="GLdt-error-value"></a>error
value</dt>
<dd>
<p>In addition to its identifying QName, a dynamic error may also
carry a descriptive string and one or more additional values called
<b>error values</b>.</p>
</dd>
<dt><a name="GLdt-expanded-qname" id=
"GLdt-expanded-qname"></a>expanded QName</dt>
<dd>
<p>An <b>expanded QName</b> consists of an optional namespace URI
and a local name. An expanded QName also retains its original
namespace prefix (if any), to facilitate casting the expanded QName
into a string.</p>
</dd>
<dt><a name="GLdt-expression-context" id=
"GLdt-expression-context"></a>expression context</dt>
<dd>
<p>The <b>expression context</b> for a given expression consists of
all the information that can affect the result of the
expression.</p>
</dd>
<dt><a name="GLdt-filter-expression" id=
"GLdt-filter-expression"></a>filter expression</dt>
<dd>
<p>A <b>filter expression</b> consists simply of a <b>primary
expression</b> followed by zero or more <a title="predicate" href=
"#dt-predicate">predicates</a>. The result of the filter expression
consists of the items returned by the primary expression, filtered
by applying each predicate in turn, working from left to right.</p>
</dd>
<dt><a name="GLdt-focus" id="GLdt-focus"></a>focus</dt>
<dd>
<p>The first three components of the <a title="dynamic context"
href="#dt-dynamic-context">dynamic context</a> (context item,
context position, and context size) are called the <b>focus</b> of
the expression.</p>
</dd>
<dt><a name="GLdt-function-implementation" id=
"GLdt-function-implementation"></a>function implementation</dt>
<dd>
<p><b>Function implementations</b>. Each function in <a title=
"function signature" href="#dt-function-signature">function
signatures</a> has a function implementation that enables the
function to map instances of its parameter types into an instance
of its result type.</p>
</dd>
<dt><a name="GLdt-function-signature" id=
"GLdt-function-signature"></a>function signature</dt>
<dd>
<p><b>Function signatures.</b> This component defines the set of
functions that are available to be called from within an
expression. Each function is uniquely identified by its <a title=
"expanded QName" href="#dt-expanded-qname">expanded QName</a> and
its arity (number of parameters).</p>
</dd>
<dt><a name="GLIgnorableWhitespace" id=
"GLIgnorableWhitespace"></a>ignorable whitespace</dt>
<dd>
<p><b>Ignorable whitespace</b> consists of any <a title=
"whitespace" href="#Whitespace">whitespace</a> characters that may
occur between <a title="terminal" href="#terminal">terminals</a>,
unless these characters occur in the context of a production marked
with a <a href="#ExplicitWhitespaceHandling">ws:explicit</a>
annotation, in which case they can occur only where explicitly
specified (see <a href="#ExplicitWhitespaceHandling"><b>A.2.4.2
Explicit Whitespace Handling</b></a>).</p>
</dd>
<dt><a name="GLdt-implementation-dependent" id=
"GLdt-implementation-dependent"></a>implementation dependent</dt>
<dd>
<p><b>Implementation-dependent</b> indicates an aspect that may
differ between implementations, is not specified by this or any W3C
specification, and is not required to be specified by the
implementor for any particular implementation.</p>
</dd>
<dt><a name="GLdt-implementation-defined" id=
"GLdt-implementation-defined"></a>implementation defined</dt>
<dd>
<p><b>Implementation-defined</b> indicates an aspect that may
differ between implementations, but must be specified by the
implementor for each particular implementation.</p>
</dd>
<dt><a name="GLdt-timezone" id="GLdt-timezone"></a>implicit
timezone</dt>
<dd>
<p><b>Implicit timezone.</b> This is the timezone to be used when a
date, time, or dateTime value that does not have a timezone is used
in a comparison or arithmetic operation. The implicit timezone is
an <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> value of
type <code>xs:dayTimeDuration</code>. See <a href="#XMLSchema">[XML
Schema]</a> for the range of legal values of a timezone.</p>
</dd>
<dt><a name="GLdt-is-attrs" id="GLdt-is-attrs"></a>in-scope
attribute declarations</dt>
<dd>
<p><b>In-scope attribute declarations.</b> Each attribute
declaration is identified either by an <a title="expanded QName"
href="#dt-expanded-qname">expanded QName</a> (for a top-level
attribute declaration) or by an <a title="implementation dependent"
href="#dt-implementation-dependent">implementation-dependent</a>
attribute identifier (for a local attribute declaration).</p>
</dd>
<dt><a name="GLdt-is-elems" id="GLdt-is-elems"></a>in-scope element
declarations</dt>
<dd>
<p><b>In-scope element declarations.</b> Each element declaration
is identified either by an <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> (for a top-level element
declaration) or by an <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> element
identifier (for a local element declaration).</p>
</dd>
<dt><a name="GLdt-in-scope-namespaces" id=
"GLdt-in-scope-namespaces"></a>in-scope namespaces</dt>
<dd>
<p>The <b>in-scope namespaces</b> property of an element node is a
set of <b>namespace bindings</b>, each of which associates a
namespace prefix with a URI, thus defining the set of namespace
prefixes that are available for interpreting QNames within the
scope of the element. For a given element, one namespace binding
may have an empty prefix; the URI of this namespace binding is the
default namespace within the scope of the element.</p>
</dd>
<dt><a name="GLdt-issd" id="GLdt-issd"></a>in-scope schema
definitions</dt>
<dd>
<p><b>In-scope schema definitions.</b> This is a generic term for
all the element declarations, attribute declarations, and schema
type definitions that are in scope during processing of an
expression.</p>
</dd>
<dt><a name="GLdt-is-types" id="GLdt-is-types"></a>in-scope schema
type</dt>
<dd>
<p><b>In-scope schema types.</b> Each schema type definition is
identified either by an <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> (for a <b>named type</b>)
or by an <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a> type
identifier (for an <b>anonymous type</b>). The in-scope schema
types include the predefined schema types described in <a href=
"#id-predefined-types"><b>2.5.1 Predefined Schema
Types</b></a>.</p>
</dd>
<dt><a name="GLdt-in-scope-variables" id=
"GLdt-in-scope-variables"></a>in-scope variables</dt>
<dd>
<p><b>In-scope variables.</b> This is a set of (expanded QName,
type) pairs. It defines the set of variables that are available for
reference within an expression. The <a title="expanded QName" href=
"#dt-expanded-qname">expanded QName</a> is the name of the
variable, and the type is the <a title="static type" href=
"#dt-static-type">static type</a> of the variable.</p>
</dd>
<dt><a name="GLdt-item" id="GLdt-item"></a>item</dt>
<dd>
<p>An <b>item</b> is either an <a title="atomic value" href=
"#dt-atomic-value">atomic value</a> or a <a title="node" href=
"#dt-node">node</a>.</p>
</dd>
<dt><a name="GLdt-kind-test" id="GLdt-kind-test"></a>kind test</dt>
<dd>
<p>An alternative form of a node test called a <b>kind test</b> can
select nodes based on their kind, name, and <a title=
"type annotation" href="#dt-type-annotation">type
annotation</a>.</p>
</dd>
<dt><a name="GLdt-literal" id="GLdt-literal"></a>literal</dt>
<dd>
<p>A <b>literal</b> is a direct syntactic representation of an
atomic value.</p>
</dd>
<dt><a name="GLdt-name-test" id="GLdt-name-test"></a>name test</dt>
<dd>
<p>A node test that consists only of a QName or a Wildcard is
called a <b>name test</b>.</p>
</dd>
<dt><a name="GLdt-node" id="GLdt-node"></a>node</dt>
<dd>
<p>A <b>node</b> is an instance of one of the <b>node kinds</b>
defined in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data
Model (Second Edition)]</a>.</p>
</dd>
<dt><a name="GLdt-node-test" id="GLdt-node-test"></a>node test</dt>
<dd>
<p>A <b>node test</b> is a condition that must be true for each
node selected by a <a title="step" href="#dt-step">step</a>.</p>
</dd>
<dt><a name="GLnon-delimiting-token" id=
"GLnon-delimiting-token"></a>non-delimiting terminal symbol</dt>
<dd>
<p>The <b>non-delimiting terminal symbols</b> are: <a href=
"#prod-xpath-IntegerLiteral">IntegerLiteral</a>, <a href=
"#prod-xpath-NCName">NCName</a>, <a href=
"#prod-xpath-DecimalLiteral">DecimalLiteral</a>, <a href=
"#prod-xpath-DoubleLiteral">DoubleLiteral</a>, <a href=
"#prod-xpath-QName">QName</a>, "ancestor", "ancestor-or-self",
"and", "as", "attribute", "cast", "castable", "child", "comment",
"descendant", "descendant-or-self", "div", "document-node",
"element", "else", "empty-sequence", "eq", "every", "except",
"external", "following", "following-sibling", "for", "ge", "gt",
"idiv", "if", "in", "instance", "intersect", "is", "item", "le",
"lt", "mod", "namespace", "ne", "node", "of", "or", "parent",
"preceding", "preceding-sibling", "processing-instruction",
"return", "satisfies", "schema-attribute", "schema-element",
"self", "some", "text", "then", "to", "treat", "union"</p>
</dd>
<dt><a name="GLdt-numeric" id="GLdt-numeric"></a>numeric</dt>
<dd>
<p>When referring to a type, the term <b>numeric</b> denotes the
types <code>xs:integer</code>, <code>xs:decimal</code>,
<code>xs:float</code>, and <code>xs:double</code>.</p>
</dd>
<dt><a name="GLdt-numeric-predicate" id=
"GLdt-numeric-predicate"></a>numeric predicate</dt>
<dd>
<p>A predicate whose predicate expression returns a numeric type is
called a <b>numeric predicate</b>.</p>
</dd>
<dt><a name="GLdt-operator-function" id=
"GLdt-operator-function"></a>operator function</dt>
<dd>
<p>For each operator and valid combination of operand types, the
operator mapping tables specify a result type and an <b>operator
function</b> that implements the semantics of the operator for the
given types.</p>
</dd>
<dt><a name="GLdt-path-expression" id=
"GLdt-path-expression"></a>path expression</dt>
<dd>
<p>A <b>path expression</b> can be used to locate nodes within
trees. A path expression consists of a series of one or more
<a title="step" href="#dt-step">steps</a>, separated by
"<code>/</code>" or "<code>//</code>", and optionally beginning
with "<code>/</code>" or "<code>//</code>".</p>
</dd>
<dt><a name="GLdt-predicate" id="GLdt-predicate"></a>predicate</dt>
<dd>
<p>A <b>predicate</b> consists of an expression, called a
<b>predicate expression</b>, enclosed in square brackets. A
predicate serves to filter a sequence, retaining some items and
discarding others.</p>
</dd>
<dt><a name="GLdt-primary-expression" id=
"GLdt-primary-expression"></a>primary expression</dt>
<dd>
<p><b>Primary expressions</b> are the basic primitives of the
language. They include literals, variable references, context item
expressions, and function calls. A primary expression may also be
created by enclosing any expression in parentheses, which is
sometimes helpful in controlling the precedence of operators.</p>
</dd>
<dt><a name="GLdt-principal-node-kind" id=
"GLdt-principal-node-kind"></a>principal node kind</dt>
<dd>
<p>Every axis has a <b>principal node kind</b>. If an axis can
contain elements, then the principal node kind is element;
otherwise, it is the kind of nodes that the axis can contain.</p>
</dd>
<dt><a name="GLdt-reverse-document-order" id=
"GLdt-reverse-document-order"></a>reverse document order</dt>
<dd>
<p>The node ordering that is the reverse of document order is
called <b>reverse document order</b>.</p>
</dd>
<dt><a name="GLdt-schema-type" id="GLdt-schema-type"></a>schema
type</dt>
<dd>
<p>A <b>schema type</b> is a type that is (or could be) defined
using the facilities of <a href="#XMLSchema">[XML Schema]</a>
(including the built-in types of <a href="#XMLSchema">[XML
Schema]</a>).</p>
</dd>
<dt><a name="GLdt-sequence" id="GLdt-sequence"></a>sequence</dt>
<dd>
<p>A <b>sequence</b> is an ordered collection of zero or more
<a title="item" href="#dt-item">items</a>.</p>
</dd>
<dt><a name="GLdt-sequence-type" id=
"GLdt-sequence-type"></a>sequence type</dt>
<dd>
<p>A <b>sequence type</b> is a type that can be expressed using the
<a href="#doc-xpath-SequenceType">SequenceType</a> syntax. Sequence
types are used whenever it is necessary to refer to a type in an
XPath expression. The term <b>sequence type</b> suggests that this
syntax is used to describe the type of an XPath value, which is
always a sequence.</p>
</dd>
<dt><a name="GLdt-serialization" id=
"GLdt-serialization"></a>serialization</dt>
<dd>
<p><b>Serialization</b> is the process of converting an <a title=
"XDM instance" href="#dt-data-model-instance">XDM instance</a> into
a sequence of octets (step DM4 in Figure 1.)</p>
</dd>
<dt><a name="GLdt-singleton" id="GLdt-singleton"></a>singleton</dt>
<dd>
<p>A sequence containing exactly one item is called a
<b>singleton</b>.</p>
</dd>
<dt><a name="GLstable" id="GLstable"></a>stable</dt>
<dd>
<p>Document order is <b>stable</b>, which means that the relative
order of two nodes will not change during the processing of a given
<span class="xpath"><span class="xpath">expression</span></span>,
even if this order is <a title="implementation dependent" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
</dd>
<dt><a name="GLdt-static-analysis" id=
"GLdt-static-analysis"></a>static analysis phase</dt>
<dd>
<p>The <b>static analysis phase</b> depends on the expression
itself and on the <a title="static context" href=
"#dt-static-context">static context</a>. The <b>static analysis
phase</b> does not depend on input data (other than schemas).</p>
</dd>
<dt><a name="GLdt-static-context" id=
"GLdt-static-context"></a>static context</dt>
<dd>
<p>The <b>static context</b> of an expression is the information
that is available during static analysis of the expression, prior
to its evaluation.</p>
</dd>
<dt><a name="GLdt-static-error" id="GLdt-static-error"></a>static
error</dt>
<dd>
<p>A <b>static error</b> is an error that must be detected during
the static analysis phase. A syntax error is an example of a
<a title="static error" href="#dt-static-error">static
error</a>.</p>
</dd>
<dt><a name="GLdt-static-type" id="GLdt-static-type"></a>static
type</dt>
<dd>
<p>The <b>static type</b> of an expression is a type such that,
when the expression is evaluated, the resulting value will always
conform to the static type.</p>
</dd>
<dt><a name="GLdt-xpath-static-typing-extension" id=
"GLdt-xpath-static-typing-extension"></a>static typing
extension</dt>
<dd>
<p>A <b>static typing extension</b> is an <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> type
inference rule that infers a more precise static type than that
inferred by the type inference rules in <a href=
"#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics
(Second Edition)]</a>.</p>
</dd>
<dt><a name="GLdt-xpath-static-typing-feature" id=
"GLdt-xpath-static-typing-feature"></a>static typing feature</dt>
<dd>
<p>The <b>Static Typing Feature</b> is an optional feature of XPath
that provides support for the static semantics defined in <a href=
"#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics
(Second Edition)]</a>, and requires implementations to detect and
report <a title="type error" href="#dt-type-error">type errors</a>
during the <a title="static analysis phase" href=
"#dt-static-analysis">static analysis phase</a>.</p>
</dd>
<dt><a name="GLdt-known-collections" id=
"GLdt-known-collections"></a>statically known collections</dt>
<dd>
<p><b>Statically known collections.</b> This is a mapping from
strings onto types. The string represents the absolute URI of a
resource that is potentially available using the
<code>fn:collection</code> function. The type is the type of the
sequence of nodes that would result from calling the
<code>fn:collection</code> function with this URI as its
argument.</p>
</dd>
<dt><a name="GLdt-known-docs" id="GLdt-known-docs"></a>statically
known documents</dt>
<dd>
<p><b>Statically known documents.</b> This is a mapping from
strings onto types. The string represents the absolute URI of a
resource that is potentially available using the
<code>fn:doc</code> function. The type is the <a title=
"static type" href="#dt-static-type">static type</a> of a call to
<code>fn:doc</code> with the given URI as its literal argument.</p>
</dd>
<dt><a name="GLdt-static-collations" id=
"GLdt-static-collations"></a>statically known collations</dt>
<dd>
<p><b>Statically known collations.</b> This is an <a title=
"implementation defined" href=
"#dt-implementation-defined">implementation-defined</a> set of
(URI, collation) pairs. It defines the names of the collations that
are available for use in processing expressions.</p>
</dd>
<dt><a name="GLdt-known-default-collection" id=
"GLdt-known-default-collection"></a>statically known default
collection type</dt>
<dd>
<p><b>Statically known default collection type.</b> This is the
type of the sequence of nodes that would result from calling the
<code>fn:collection</code> function with no arguments.</p>
</dd>
<dt><a name="GLdt-static-namespaces" id=
"GLdt-static-namespaces"></a>statically known namespaces</dt>
<dd>
<p><b>Statically known namespaces.</b> This is a set of (prefix,
URI) pairs that define all the namespaces that are known during
static processing of a given expression.</p>
</dd>
<dt><a name="GLdt-step" id="GLdt-step"></a>step</dt>
<dd>
<p>A <b>step</b> is a part of a <a title="path expression" href=
"#dt-path-expression">path expression</a> that generates a sequence
of items and then filters the sequence by zero or more <a title=
"predicate" href="#dt-predicate">predicates</a>. The value of the
step consists of those items that satisfy the predicates, working
from left to right. A step may be either an <a title="axis step"
href="#dt-axis-step">axis step</a> or a <a title=
"filter expression" href="#dt-filter-expression">filter
expression</a>.</p>
</dd>
<dt><a name="GLdt-string-value" id="GLdt-string-value"></a>string
value</dt>
<dd>
<p>The <b>string value</b> of a node is a string and can be
extracted by applying the <code>fn:string</code> function to the
node.</p>
</dd>
<dt><a name="GLdt-substitution-group" id=
"GLdt-substitution-group"></a>substitution group</dt>
<dd>
<p><b>Substitution groups</b> are defined in <a href=
"#XMLSchema">[XML Schema]</a> Part 1, Section 2.2.2.2. Informally,
the substitution group headed by a given element (called the
<b>head element</b>) consists of the set of elements that can be
substituted for the head element without affecting the outcome of
schema validation.</p>
</dd>
<dt><a name="GLdt-subtype-substitution" id=
"GLdt-subtype-substitution"></a>subtype substitution</dt>
<dd>
<p>The use of a value whose <a title="dynamic type" href=
"#dt-dynamic-type">dynamic type</a> is derived from an expected
type is known as <b>subtype substitution</b>.</p>
</dd>
<dt><a name="GLsymbol" id="GLsymbol"></a>symbol</dt>
<dd>
<p>Each rule in the grammar defines one <b>symbol</b>, using the
following format:</p>
<div class="exampleInner">
<pre>
symbol ::= expression
</pre></div>
</dd>
<dt><a name="GLsymbolseparators" id="GLsymbolseparators"></a>symbol
separators</dt>
<dd>
<p><a title="whitespace" href="#Whitespace">Whitespace</a> and
<a href="#doc-xpath-Comment">Comments</a> function as <b>symbol
separators</b>. For the most part, they are not mentioned in the
grammar, and may occur between any two terminal symbols mentioned
in the grammar, except where that is forbidden by the <a href=
"#ws-explicit">/* ws: explicit */</a> annotation in the EBNF, or by
the <a href="#parse-note-xml-version">/* xgs: xml-version */</a>
annotation.</p>
</dd>
<dt><a name="GLterminal" id="GLterminal"></a>terminal</dt>
<dd>
<p>A <b>terminal</b> is a symbol or string or pattern that can
appear in the right-hand side of a rule, but never appears on the
left hand side in the main grammar, although it may appear on the
left-hand side of a rule in the grammar for terminals.</p>
</dd>
<dt><a name="GLdt-type-annotation" id=
"GLdt-type-annotation"></a>type annotation</dt>
<dd>
<p>Each element node and attribute node in an <a title=
"XDM instance" href="#dt-data-model-instance">XDM instance</a> has
a <b>type annotation</b> (referred to in <a href=
"#datamodel">[XQuery 1.0 and XPath 2.0 Data Model (Second
Edition)]</a> as its <code>type-name</code> property.) The type
annotation of a node is a <a title="schema type" href=
"#dt-schema-type">schema type</a> that describes the relationship
between the <a title="string value" href="#dt-string-value">string
value</a> of the node and its <a title="typed value" href=
"#dt-typed-value">typed value</a>.</p>
</dd>
<dt><a name="GLdt-type-error" id="GLdt-type-error"></a>type
error</dt>
<dd>
<p>A <b>type error</b> may be raised during the static analysis
phase or the dynamic evaluation phase. During the static analysis
phase, a <a title="type error" href="#dt-type-error">type error</a>
occurs when the <a title="static type" href=
"#dt-static-type">static type</a> of an expression does not match
the expected type of the context in which the expression occurs.
During the dynamic evaluation phase, a <a title="type error" href=
"#dt-type-error">type error</a> occurs when the <a title=
"dynamic type" href="#dt-dynamic-type">dynamic type</a> of a value
does not match the expected type of the context in which the value
occurs.</p>
</dd>
<dt><a name="GLdt-type-promotion" id="GLdt-type-promotion"></a>type
promotion</dt>
<dd>
<p>Under certain circumstances, an atomic value can be promoted
from one type to another. <b>Type promotion</b> is used in
evaluating function calls (see <a href=
"#id-function-calls"><b>3.1.5 Function Calls</b></a>) and operators
that accept numeric or string operands (see <a href=
"#mapping"><b>B.2 Operator Mapping</b></a>).</p>
</dd>
<dt><a name="GLdt-typed-value" id="GLdt-typed-value"></a>typed
value</dt>
<dd>
<p>The <b>typed value</b> of a node is a sequence of atomic values
and can be extracted by applying the <code>fn:data</code> function
to the node.</p>
</dd>
<dt><a name="GLdt-undefined" id="GLdt-undefined"></a>undefined</dt>
<dd>
<p>In certain situations a value is said to be <b>undefined</b>
(for example, the value of the context item, or the typed value of
an element node). This term indicates that the property in question
has no value and that any attempt to use its value results in an
error.</p>
</dd>
<dt><a name="GLdt-value" id="GLdt-value"></a>value</dt>
<dd>
<p>In the <a title="data model" href="#dt-datamodel">data
model</a>, a <b>value</b> is always a <a title="sequence" href=
"#dt-sequence">sequence</a>.</p>
</dd>
<dt><a name="GLdt-variable-reference" id=
"GLdt-variable-reference"></a>variable reference</dt>
<dd>
<p>A <b>variable reference</b> is a QName preceded by a $-sign.</p>
</dd>
<dt><a name="GLdt-variable-values" id=
"GLdt-variable-values"></a>variable values</dt>
<dd>
<p><b>Variable values</b>. This is a set of (expanded QName, value)
pairs. It contains the same <a title="expanded QName" href=
"#dt-expanded-qname">expanded QNames</a> as the <a title=
"in-scope variables" href="#dt-in-scope-variables">in-scope
variables</a> in the <a title="static context" href=
"#dt-static-context">static context</a> for the expression. The
expanded QName is the name of the variable and the value is the
dynamic value of the variable, which includes its <a title=
"dynamic type" href="#dt-dynamic-type">dynamic type</a>.</p>
</dd>
<dt><a name="GLdt-warning" id="GLdt-warning"></a>warning</dt>
<dd>
<p>In addition to <a title="static error" href=
"#dt-static-error">static errors</a>, <a title="dynamic error"
href="#dt-dynamic-error">dynamic errors</a>, and <a title=
"type error" href="#dt-type-error">type errors</a>, an XPath
implementation may raise <b>warnings</b>, either during the
<a title="static analysis phase" href="#dt-static-analysis">static
analysis phase</a> or the <a title="dynamic evaluation phase" href=
"#dt-dynamic-evaluation">dynamic evaluation phase</a>. The
circumstances in which warnings are raised, and the ways in which
warnings are handled, are <a title="implementation defined" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</dd>
<dt><a name="GLWhitespace" id="GLWhitespace"></a>whitespace</dt>
<dd>
<p>A <b>whitespace</b> character is any of the characters defined
by <a href=
"http://www.w3.org/TR/REC-xml/#NT-S">[http://www.w3.org/TR/REC-xml/#NT-S]</a>.</p>
</dd>
<dt><a name="GLdt-anyAtomicType" id=
"GLdt-anyAtomicType"></a>xs:anyAtomicType</dt>
<dd>
<p><code>xs:anyAtomicType</code> is an atomic type that includes
all atomic values (and no values that are not atomic). Its base
type is <code>xs:anySimpleType</code> from which all simple types,
including atomic, list, and union types, are derived. All primitive
atomic types, such as <code>xs:decimal</code> and
<code>xs:string</code>, have <code>xs:anyAtomicType</code> as their
base type.</p>
</dd>
<dt><a name="GLdt-dayTimeDuration" id=
"GLdt-dayTimeDuration"></a>xs:dayTimeDuration</dt>
<dd>
<p><code>xs:dayTimeDuration</code> is derived by restriction from
<code>xs:duration</code>. The lexical representation of
<code>xs:dayTimeDuration</code> is restricted to contain only day,
hour, minute, and second components.</p>
</dd>
<dt><a name="GLdt-untyped" id="GLdt-untyped"></a>xs:untyped</dt>
<dd>
<p><code>xs:untyped</code> is used as the <a title=
"type annotation" href="#dt-type-annotation">type annotation</a> of
an element node that has not been validated, or has been validated
in <code>skip</code> mode.</p>
</dd>
<dt><a name="GLdt-untypedAtomic" id=
"GLdt-untypedAtomic"></a>xs:untypedAtomic</dt>
<dd>
<p><code>xs:untypedAtomic</code> is an atomic type that is used to
denote untyped atomic data, such as text that has not been assigned
a more specific type.</p>
</dd>
<dt><a name="GLdt-yearMonthDuration" id=
"GLdt-yearMonthDuration"></a>xs:yearMonthDuration</dt>
<dd>
<p><code>xs:yearMonthDuration</code> is derived by restriction from
<code>xs:duration</code>. The lexical representation of
<code>xs:yearMonthDuration</code> is restricted to contain only
year and month components.</p>
</dd>
</dl>
</div>
<div class="xpath">
<div class="div1">
<h2><a name="id-backwards-compatibility" id=
"id-backwards-compatibility"></a>I Backwards Compatibility with
XPath 1.0 (Non-Normative)</h2>
<p>This appendix provides a summary of the areas of incompatibility
between XPath 2.0 and <a href="#XPath">[XPath 1.0]</a>.</p>
<p>Three separate cases are considered:</p>
<ol class="enumar">
<li>
<p>Incompatibilities that exist when source documents have no
schema, and when running with XPath 1.0 compatibility mode set to
true. This specification has been designed to reduce the number of
incompatibilities in this situation to an absolute
min<span>i</span>mum, but some differences remain and are listed
individually.</p>
</li>
<li>
<p>Incompatibilities that arise when XPath 1.0 compatibility mode
is set to false. In this case, the number of expressions where
compatibility is lost is rather greater.</p>
</li>
<li>
<p>Incompatibilities that arise when the source document is
processed using a schema (whether or not XPath 1.0 compatibility
mode is set to true). Processing the document with a schema changes
the way that the values of nodes are interpreted, and this can
cause an XPath expression to return different results.</p>
</li>
</ol>
<div class="div2">
<h3><a name="id-incompat-in-true-mode" id=
"id-incompat-in-true-mode"></a>I.1 Incompatibilities when
Compatibility Mode is true</h3>
<p>The list below contains all known areas, within the scope of
this specification, where an XPath 2.0 processor running with
compatibility mode set to true will produce different results from
an XPath 1.0 processor evaluating the same expression, assuming
that the expression was valid in XPath 1.0, and that the nodes in
the source document have no type annotations other than
<code>xs:untyped</code> and <code>xs:untypedAtomic</code>.</p>
<p>Incompatibilities in the behavior of individual functions are
not listed here, but are included in an appendix of <a href=
"#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and
Operators (Second Edition)]</a>.</p>
<p>Since both XPath 1.0 and XPath 2.0 leave some aspects of the
specification implementation-defined, there may be incompatiblities
in the behavior of a particular implementation that are outside the
scope of this specification. Equally, some aspects of the behavior
of XPath are defined by the host language.</p>
<ol class="enumar">
<li>
<p>Consecutive comparison operators such as <code>A &lt; B &lt;
C</code> were supported in XPath 1.0, but are not permitted by the
XPath 2.0 grammar. In most cases such comparisons in XPath 1.0 did
not have the intuitive meaning, so it is unlikely that they have
been widely used in practice. If such a construct is found, an
XPath 2.0 processor will report a syntax error, and the construct
can be rewritten as <code>(A &lt; B) &lt; C</code></p>
</li>
<li>
<p>When converting strings to numbers (either explicitly when using
the <code>number</code> function, or implicitly say on a function
call), certain strings that converted to the special value
<code>NaN</code> under XPath 1.0 will convert to values other than
<code>NaN</code> under XPath 2.0. These include any number written
with a leading <code>+</code> sign, any number in exponential
floating point notation (for example <code>1.0e+9</code>), and the
strings <code>INF</code> and <code>-INF</code>.</p>
<p>Furthermore, the strings <code>Infinity</code> and
<code>-Infinity</code>, which were accepted by XPath 1.0 as
representations of the floating-point values positive and negative
infinity, are no longer recognized. They are converted to
<code>NaN</code> when running under XPath 2.0 with compatibility
mode set to true, and cause a dynamic error when compatibility mode
is set to false.</p>
</li>
<li>
<p>XPath 2.0 does not allow a token starting with a letter to
follow immediately after a numeric literal, without intervening
whitespace. For example, <code>10div 3</code> was permitted in
XPath 1.0, but in XPath 2.0 must be written as <code>10 div
3</code>.</p>
</li>
<li>
<p>The namespace axis is deprecated in XPath 2.0. Implementations
may support the namespace axis for backward compatibility with
XPath 1.0, but they are not required to do so. (XSLT 2.0 requires
that if XPath backwards compatibility mode is supported, then the
namespace axis must also be supported; but other host languages may
define the conformance rules differently.)</p>
</li>
<li>
<p>If one operand in a general comparison is a single atomic value
of type <code>xs:boolean</code>, the other operand is converted to
<code>xs:boolean</code> when XPath 1.0 compatibility mode is set to
true. In XPath 1.0, if neither operand of a comparison operation
using the &lt;, &lt;=, &gt; or &gt;= operator was a node set, both
operands were converted to numbers. The result of the expression
<code>true() &gt; number('0.5')</code> is therefore true in XPath
1.0, but is false in XPath 2.0 even when compatibility mode is set
to true.</p>
</li>
<li>
<p>In XPath 2.0, a type error is raised if, for a PITarget
specified in a SequenceType of form
<code>processing-instruction(N)</code>,
<em>fn:normalize-space(N)</em> is not in the lexical space of
NCName. In XPath 1.0, this condition was not treated as an
error.</p>
</li>
<li>
<p>In XPath 1.0, the expression <code>-x|y</code> parsed as
<code>-(x|y)</code>, and returned the negation of the numeric value
of the first node in the union of <code>x</code> and
<code>y</code>. In XPath 2.0, this expression parses as
<code>(-x)|y</code>. When XPath 1.0 Compatibility Mode is true,
this will always cause a type error.</p>
</li>
<li>
<p>The rules for converting numbers to strings have changed. These
may affect the way numbers are displayed in the output of a
stylesheet. For numbers whose absolute value is in the range
<code>1E-6</code> to <code>1E+6</code>, the result should be the
same, but outside this range, scientific format is used for
non-integral <code>xs:float</code> and <code>xs:double</code>
values.</p>
</li>
</ol>
</div>
<div class="div2">
<h3><a name="id-incompat-in-false-mode" id=
"id-incompat-in-false-mode"></a>I.2 Incompatibilities when
Compatibility Mode is false</h3>
<p>Even when the setting of the XPath 1.0 compatibility mode is
false, many XPath expressions will still produce the same results
under XPath 2.0 as under XPath 1.0. The exceptions are described in
this section.</p>
<p>In all cases it is assumed that the expression in question was
valid under XPath 1.0, that XPath 1.0 compatibility mode is false,
and that all elements and attributes are annotated with the types
<code>xs:untyped</code> and <code>xs:untypedAtomic</code>
respectively.</p>
<p>In the description below, the terms <em>node-set</em> and
<em>number</em> are used with their XPath 1.0 meanings, that is, to
describe expressions which according to the rules of XPath 1.0
would have generated a node-set or a number respectively.</p>
<ol class="enumar">
<li>
<p>When a node-set containing more than one node is supplied as an
argument to a function or operator that expects a single node or
value, the XPath 1.0 rule was that all nodes after the first were
discarded. Under XPath 2.0, a type error occurs if there is more
than one node. The XPath 1.0 behavior can always be restored by
using the predicate <code>[1]</code> to explicitly select the first
node in the node-set.</p>
</li>
<li>
<p>In XPath 1.0, the <code>&lt;</code> and <code>&gt;</code>
operators, when applied to two strings, attempted to convert both
the strings to numbers and then made a numeric comparison between
the results. In XPath 2.0, these operators perform a string
comparison using the default collating sequence. (If either value
is numeric, however, the results are compatible with XPath 1.0)</p>
</li>
<li>
<p>When an empty node-set is supplied as an argument to a function
or operator that expects a number, the value is no longer converted
implicitly to NaN. The XPath 1.0 behavior can always be restored by
using the <code>number</code> function to perform an explicit
conversion.</p>
</li>
<li>
<p>More generally, the supplied arguments to a function or operator
are no longer implicitly converted to the required type, except in
the case where the supplied argument is of type
<code>xs:untypedAtomic</code> (which will commonly be the case when
a node in a schemaless document is supplied as the argument). For
example, the function call <code>substring-before(10 div 3,
".")</code> raises a type error under XPath 2.0, because the
arguments to the <code>substring-before</code> function must be
strings rather than numbers. The XPath 1.0 behavior can be restored
by performing an explicit conversion to the required type using a
constructor function or cast.</p>
</li>
<li>
<p>The rules for comparing a node-set to a boolean have changed. In
XPath 1.0, an expression such as <code>$node-set = true()</code>
was evaluated by converting the node-set to a boolean and then
performing a boolean comparison: so this expression would return
<code>true</code> if <code>$node-set</code> was non-empty. In XPath
2.0, this expression is handled in the same way as other
comparisons between a sequence and a singleton: it is
<code>true</code> if <code>$node-set</code> contains at least one
node whose value, after atomization and conversion to a boolean
using the casting rules, is <code>true</code>.</p>
<p>This means that if <code>$node-set</code> is empty, the result
under XPath 2.0 will be <code>false</code> regardless of the value
of the boolean operand, and regardless of which operator is used.
If <code>$node-set</code> is non-empty, then in most cases the
comparison with a boolean is likely to fail, giving a dynamic
error. But if a node has the value "0", "1", "true", or "false",
evaluation of the expression may succeed.</p>
</li>
<li>
<p>Comparisons of a number to a boolean, a number to a string, or a
string to a boolean are not allowed in XPath 2.0: they result in a
type error. In XPath 1.0 such comparisons were allowed, and were
handled by converting one of the operands to the type of the other.
So for example in XPath 1.0 <code>4 = true()</code> was true;
<code>4 = "+4"</code> was false (because the string <code>+4</code>
converts to <code>NaN</code>), and <code>false = "false"</code> was
false (because the string <code>"false"</code> converts to the
boolean <code>true</code>). In XPath 2.0 all these comparisons are
type errors.</p>
</li>
<li>
<p>Additional numeric types have been introduced, with the effect
that arithmetic may now be done as an integer, decimal, or single-
or double-precision floating point calculation where previously it
was always performed as double-precision floating point. The result
of the <code>div</code> operator when dividing two integers is now
a value of type decimal rather than double. The expression <code>10
div 0</code> raises an error rather than returning positive
infinity.</p>
</li>
<li>
<p>The rules for converting strings to numbers have changed. The
implicit conversion that occurs when passing an
<code>xs:untypedAtomic</code> value as an argument to a function
that expects a number no longer converts unrecognized strings to
the value <code>NaN</code>; instead, it reports a dynamic error.
This is in addition to the differences that apply when backwards
compatibility mode is set to true.</p>
</li>
<li>
<p>Many operations in XPath 2.0 produce an empty sequence as their
result when one of the arguments or operands is an empty sequence.
Where the operation expects a string, an empty sequence is usually
considered equivalent to a zero-length string, which is compatible
with the XPath 1.0 behavior. Where the operation expects a number,
however, the result is not the same. For example, if
<code>@width</code> returns an empty sequence, then in XPath 1.0
the result of <code>@width+1</code> was <code>NaN</code>, while
with XPath 2.0 it is <code>()</code>. This has the effect that a
filter expression such as <code>item[@width+1 != 2]</code> will
select items having no <code>width</code> attribute under XPath
1.0, and will not select them under XPath 2.0.</p>
</li>
<li>
<p>The typed value of a comment node, processing instruction node,
or namespace node under XPath 2.0 is of type
<code>xs:string</code>, not <code>xs:untypedAtomic</code>. This
means that no implicit conversions are applied if the value is used
in a context where a number is expected. If a
processing-instruction node is used as an operand of an arithmetic
operator, for example, XPath 1.0 would attempt to convert the
string value of the node to a number (and deliver <code>NaN</code>
if unsuccessful), while XPath 2.0 will report a type error.</p>
</li>
<li>
<p>In XPath 1.0, it was defined that with an expression of the form
<code>A and B</code>, B would not be evaluated if A was false.
Similarly in the case of <code>A or B</code>, B would not be
evaluated if A was true. This is no longer guaranteed with XPath
2.0: the implementation is free to evaluate the two operands in
either order or in parallel. This change has been made to give more
scope for optimization in situations where XPath expressions are
evaluated against large data collections supported by indexes.
Implementations may choose to retain backwards compatibility in
this area, but they are not obliged to do so.</p>
</li>
<li>
<p>In XPath 1.0, the expression <code>-x|y</code> parsed as
<code>-(x|y)</code>, and returned the negation of the numeric value
of the first node in the union of <code>x</code> and
<code>y</code>. In XPath 2.0, this expression parses as
<code>(-x)|y</code>. When XPath 1.0 Compatibility Mode is false,
this will cause a type error, except in the situation where
<code>x</code> evaluates to an empty sequence. In that situation,
XPath 2.0 will return the value of <code>y</code>, whereas XPath
1.0 returned the negation of the numeric value of
<code>y</code>.</p>
</li>
</ol>
</div>
<div class="div2">
<h3><a name="id-incompat-when-using-schema" id=
"id-incompat-when-using-schema"></a>I.3 Incompatibilities when
using a Schema</h3>
<p>An XPath expression applied to a document that has been
processed against a schema will not always give the same results as
the same expression applied to the same document in the absence of
a schema. Since schema processing had no effect on the result of an
XPath 1.0 expression, this may give rise to further
incompatibilities. This section gives a few examples of the
differences that can arise.</p>
<p>Suppose that the context node is an element node derived from
the following markup: <code>&lt;background color="red green
blue"/&gt;</code>. In XPath 1.0, the predicate
<code>[@color="blue"]</code> would return <code>false</code>. In
XPath 2.0, if the <code>color</code> attribute is defined in a
schema to be of type <code>xs:NMTOKENS</code>, the same predicate
will return <code>true</code>.</p>
<p>Similarly, consider the expression <code>@birth &lt;
@death</code> applied to the element <code>&lt;person
birth="1901-06-06" death="1991-05-09"/&gt;</code>. With XPath 1.0,
this expression would return false, because both attributes are
converted to numbers, which returns <code>NaN</code> in each case.
With XPath 2.0, in the presence of a schema that annotates these
attributes as dates, the expression returns <code>true</code>.</p>
<p>Once schema validation is applied, elements and attributes
cannot be used as operands and arguments of expressions that expect
a different data type. For example, it is no longer possible to
apply the <code>substring</code> function to a date to extract the
year component, or to a number to extract the integer part.
Similarly, if an attribute is annotated as a boolean then it is not
possible to compare it with the strings <code>"true"</code> or
<code>"false"</code>. All such operations lead to type errors. The
remedy when such errors occur is to introduce an explicit
conversion, or to do the computation in a different way. For
example, <code>substring-after(@temperature, "-")</code> might be
rewritten as <code>abs(@temperature)</code>.</p>
<p>In the case of an XPath 2.0 implementation that provides the
static typing feature, many further type errors will be reported in
respect of expressions that worked under XPath 1.0. For example, an
expression such as <code>round(../@price)</code> might lead to a
static type error because the processor cannot infer statically
that <code>../@price</code> is guaranteed to be numeric.</p>
<p>Schema validation will in many cases perform whitespace
normalization on the contents of elements (depending on their
type). This will change the result of operations such as the
<code>string-length</code> function.</p>
<p>Schema validation augments the data model by adding default
values for omitted attributes and empty elements.</p>
</div>
</div>
</div>
<div class="div1">
<h2><a name="id-revisions-log" id="id-revisions-log"></a>J Changes
since the First Edition (Non-Normative)</h2>
<div class="xpath">
<p class="xpath">This version of the XPath specification was
created by applying the errata from <a href=
"http://www.w3.org/XML/2007/qt-errata/xpath20-errata.html">Errata
for XML Path Language (XPath) 2.0</a> to the <a href=
"http://www.w3.org/TR/2007/REC-xpath20-20070123/">XPath 2.0
Recommendation</a>. No other substantive changes have been
made.</p>
</div>
<div class="xpath">
<table border="1" cellpadding="5" width="100%" class="xpath">
<thead>
<tr>
<td>Erratum</td>
<td>Bugzilla</td>
<td>Category</td>
<td>Description</td>
</tr>
</thead>
<tbody>
<tr>
<td><a href=
"http://www.w3.org/XML/2007/qt-errata/xpath20-errata.html#E1">XP.E1</a></td>
<td><a href=
"http://www.w3.org/Bugs/Public/show_bug.cgi?id=4298">4298</a></td>
<td>editorial</td>
<td>Spelling mistake: minimum</td>
</tr>
<tr>
<td><a href=
"http://www.w3.org/XML/2007/qt-errata/xpath20-errata.html#E2">XP.E2</a></td>
<td><a href=
"http://www.w3.org/Bugs/Public/show_bug.cgi?id=4855">4855</a></td>
<td>editorial</td>
<td>Some incompatibilities from XPath 1.0 are undocumented; others
are wrongly classified as applying only when compatibility mode is
false.</td>
</tr>
<tr>
<td><a href=
"http://www.w3.org/XML/2007/qt-errata/xpath20-errata.html#E3">XP.E3</a></td>
<td><a href=
"http://www.w3.org/Bugs/Public/show_bug.cgi?id=4868">4868</a></td>
<td>editorial</td>
<td>For valid syntax, parentheses need to be added to the expansion
for leading "/" and leading "//" in a path expression.</td>
</tr>
<tr>
<td><a href=
"http://www.w3.org/XML/2007/qt-errata/xpath20-errata.html#E4">XP.E4</a></td>
<td><a href=
"http://www.w3.org/Bugs/Public/show_bug.cgi?id=4446">4446</a></td>
<td>substantive</td>
<td>This erratum adds more details to the rules defining
permissible expression rewrites for optimization and other
purposes.</td>
</tr>
<tr>
<td><a href=
"http://www.w3.org/XML/2007/qt-errata/xpath20-errata.html#E5">XP.E5</a></td>
<td><a href=
"http://www.w3.org/Bugs/Public/show_bug.cgi?id=4873">4873</a></td>
<td>substantive</td>
<td>This erratum clarifies the conditions under which a castable
expression may raise an error.</td>
</tr>
<tr>
<td><a href=
"http://www.w3.org/XML/2007/qt-errata/xpath20-errata.html#E6">XP.E6</a></td>
<td><a href=
"http://www.w3.org/Bugs/Public/show_bug.cgi?id=5445">5445</a></td>
<td>editorial</td>
<td>Undocumented incompatibility when the operators &lt;, &gt;,
&lt;=, or &gt;= are used to compare a number to a boolean.</td>
</tr>
<tr>
<td><a href=
"http://www.w3.org/XML/2007/qt-errata/xpath20-errata.html#E7">XP.E7</a></td>
<td><a href=
"http://www.w3.org/Bugs/Public/show_bug.cgi?id=5351">5351</a></td>
<td>substantive</td>
<td>Specifies that an error results if the PITarget specified in a
SequenceType of form processing-instruction(PITarget) is not a
syntactically valid NCName.</td>
</tr>
<tr>
<td><a href=
"http://www.w3.org/XML/2007/qt-errata/xpath20-errata.html#E8">XP.E8</a></td>
<td><a href=
"http://www.w3.org/Bugs/Public/show_bug.cgi?id=5261">5261</a></td>
<td>editorial</td>
<td>Removes references to error code FORG0001 from description of
cast expression. Replaces them with a reference to Functions and
Operators for normative description of error behavior.</td>
</tr>
<tr>
<td><a href=
"http://www.w3.org/XML/2007/qt-errata/xpath20-errata.html#E9">XP.E9</a></td>
<td><a href=
"http://www.w3.org/Bugs/Public/show_bug.cgi?id=5471">5471</a></td>
<td>editorial</td>
<td>Deletes unnecessary reference to RFC2396 from Normative
References. This item is never referenced in the normative
text.</td>
</tr>
<tr>
<td><a href=
"http://www.w3.org/XML/2007/qt-errata/xpath20-errata.html#E10">XP.E10</a></td>
<td><a href=
"http://www.w3.org/Bugs/Public/show_bug.cgi?id=5223">5223</a></td>
<td>substantive</td>
<td>Specifies that general comparisons cast an untyped operand to
the primitive base type of the other operand rather than to the
most specific type of the other operand.</td>
</tr>
<tr>
<td><a href=
"http://www.w3.org/XML/2007/qt-errata/xpath20-errata.html#E11">XP.E11</a></td>
<td><a href=
"http://www.w3.org/Bugs/Public/show_bug.cgi?id=5984">5984</a></td>
<td>editorial</td>
<td>Corrects a list of examples of primitive atomic types.</td>
</tr>
<tr>
<td><a href=
"http://www.w3.org/XML/2007/qt-errata/xpath20-errata.html#E13">XP.E13</a></td>
<td><a href=
"http://www.w3.org/Bugs/Public/show_bug.cgi?id=5347">5347</a></td>
<td>substantive</td>
<td>Allows (and encourages) the use of XML 1.0 editions newer than
the Third Edition.</td>
</tr>
<tr>
<td><a href=
"http://www.w3.org/XML/2007/qt-errata/xpath20-errata.html#E14">XP.E14</a></td>
<td><a href=
"http://www.w3.org/Bugs/Public/show_bug.cgi?id=6027">6027</a></td>
<td>substantive</td>
<td>Specifies conformance criteria for syntax extensions.</td>
</tr>
<tr>
<td><a href=
"http://www.w3.org/XML/2007/qt-errata/xpath20-errata.html#E15">XP.E15</a></td>
<td><a href=
"http://www.w3.org/Bugs/Public/show_bug.cgi?id=6287">6287</a></td>
<td>editorial</td>
<td>Defines the meaning of "undefined" for Data Model
properties.</td>
</tr>
<tr>
<td><a href=
"http://www.w3.org/XML/2007/qt-errata/xpath20-errata.html#E16">XP.E16</a></td>
<td><a href=
"http://www.w3.org/Bugs/Public/show_bug.cgi?id=5727">5727</a></td>
<td>substantive</td>
<td>Clarifications on parsing leading / in XPath expressions.</td>
</tr>
<tr>
<td><a href=
"http://www.w3.org/XML/2007/qt-errata/xpath20-errata.html#E18">XP.E18</a></td>
<td><a href=
"http://www.w3.org/Bugs/Public/show_bug.cgi?id=5876">5876</a></td>
<td>substantive</td>
<td>Corrects the description of precedence with respect to
parentheses and square brackets.</td>
</tr>
<tr>
<td><a href=
"http://www.w3.org/XML/2007/qt-errata/xpath20-errata.html#E19">XP.E19</a></td>
<td><a href=
"http://www.w3.org/Bugs/Public/show_bug.cgi?id=5351">5351</a></td>
<td>substantive</td>
<td>Specifies that leading and trailing whitespace are stripped
from a PITarget specified in a SequenceType of form
processing-instruction(PITarget) before it is tested to see if it
is a syntactically valid NCName. Also makes the description of the
error introduced in E12 more precise. If accepted, this supersedes
E12.</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</body>
</html>
